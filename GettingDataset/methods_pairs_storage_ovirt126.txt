1620
#method_before
private String composeExistingVmsWarningMessage(List<T> existingVms) {
    final StringBuffer s = new StringBuffer();
    for (T t : existingVms) {
        if (s.length() > 0) {
            // $NON-NLS-1$
            s.append(", ");
        }
        s.append(extractNameFromEntity(t));
    }
    return s.toString();
}
#method_after
private String composeExistingVmsWarningMessage(List<T> existingVms) {
    final List<String> list = new ArrayList<String>();
    for (T t : existingVms) {
        list.add(extractNameFromEntity(t));
    }
    // $NON-NLS-1$
    return StringUtils.join(list, ", ");
}
#end_block

#method_before
private void sendWarningForNonExportableDisks(List<Disk> nonExportableDisks) {
    if (!nonExportableDisks.isEmpty()) {
        final StringBuilder s = new StringBuilder();
        for (Disk disk : nonExportableDisks) {
            if (s.length() > 0) {
                // $NON-NLS-1$
                s.append(", ");
            }
            s.append(disk.getDiskAlias());
        }
        // append warning message
        getModel().setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMTemplate(s.toString()));
    }
}
#method_after
private void sendWarningForNonExportableDisks(List<Disk> nonExportableDisks) {
    if (!nonExportableDisks.isEmpty()) {
        final List<String> list = new ArrayList<String>();
        for (Disk disk : nonExportableDisks) {
            list.add(disk.getDiskAlias());
        }
        // $NON-NLS-1$
        final String s = StringUtils.join(list, ", ");
        // append warning message
        getModel().setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMTemplate(s));
    }
}
#end_block

#method_before
@Override
public void setMessage(String message) {
    messageHTML.appendText(message);
}
#method_after
@Override
public void setMessage(String message) {
    if (message == null) {
        return;
    }
    messagePanel.add(new Label(message));
}
#end_block

#method_before
@Override
public void edit(final UnitVmModel model) {
    Driver.driver.edit(model);
    model.getStorageDomain().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            addDiskAllocation(model);
        }
    });
    model.getStorageDomain().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isDisksAllocationEnabled = model.getDisks() != null && !model.getDisks().isEmpty();
            disksAllocationView.setEnabled(isDisksAllocationEnabled);
            // $NON-NLS-1$ //$NON-NLS-2$
            disksAllocationLabel.getElement().getStyle().setColor(isDisksAllocationEnabled ? "black" : "grey");
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                VmMakeTemplatePopupWidget.this.setMessage(model.getMessage());
            }
        }
    });
}
#method_after
@Override
public void edit(final UnitVmModel model) {
    Driver.driver.edit(model);
    model.getStorageDomain().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            addDiskAllocation(model);
        }
    });
    model.getStorageDomain().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isDisksAllocationEnabled = model.getDisks() != null && !model.getDisks().isEmpty();
            disksAllocationView.setEnabled(isDisksAllocationEnabled);
            // $NON-NLS-1$ //$NON-NLS-2$
            disksAllocationLabel.getElement().getStyle().setColor(isDisksAllocationEnabled ? "black" : "grey");
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            }
        }
    });
}
#end_block

#method_before
void sendWarningForNonExportableDisks(ArrayList<Disk> disks) {
    // filter non-exportable disks
    final List<Disk> nonExportableDisks = new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!disk.isAllowSnapshot()) {
            nonExportableDisks.add(disk);
        }
    }
    if (!nonExportableDisks.isEmpty()) {
        final StringBuilder s = new StringBuilder();
        for (Disk disk : nonExportableDisks) {
            if (s.length() > 0) {
                // $NON-NLS-1$
                s.append(", ");
            }
            s.append(disk.getDiskAlias());
        }
        // append warning message
        setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMSnapshot(s.toString()));
    }
}
#method_after
void sendWarningForNonExportableDisks(ArrayList<Disk> disks) {
    // filter non-exportable disks
    final List<String> list = new ArrayList<String>();
    for (Disk disk : disks) {
        if (!disk.isAllowSnapshot()) {
            list.add(disk.getDiskAlias());
        }
    }
    if (!list.isEmpty()) {
        // $NON-NLS-1$
        final String s = StringUtils.join(list, ", ");
        // append warning message
        setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMSnapshot(s));
    }
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.GetVmDiskList(new AsyncQuery((ExportVmModel) getWindow(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> diskList = (ArrayList<Disk>) returnValue;
            final List<Disk> nonExportableDisks = new ArrayList<Disk>();
            for (Disk disk : diskList) {
                if (!disk.isAllowSnapshot()) {
                    nonExportableDisks.add(disk);
                }
            }
            if (!nonExportableDisks.isEmpty()) {
                final StringBuilder s = new StringBuilder();
                for (Disk disk : nonExportableDisks) {
                    if (s.length() > 0) {
                        // $NON-NLS-1$
                        s.append(", ");
                    }
                    s.append(disk.getDiskAlias());
                }
                // append warning message
                model.setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVM(s.toString()));
            }
        }
    }), entity.getId());
}
#method_after
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.GetVmDiskList(new AsyncQuery((ExportVmModel) getWindow(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> diskList = (ArrayList<Disk>) returnValue;
            // filter non-exportable disks
            final List<String> list = new ArrayList<String>();
            for (Disk disk : diskList) {
                if (!disk.isAllowSnapshot()) {
                    list.add(disk.getDiskAlias());
                }
            }
            if (!list.isEmpty()) {
                // $NON-NLS-1$
                final String s = StringUtils.join(list, ", ");
                // append warning message
                model.setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVM(s));
            }
        }
    }), entity.getId());
}
#end_block

#method_before
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    RunOnceLoadHosts(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsAutoAssign().setEntity(true);
}
#end_block

#method_before
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#method_after
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    // set destination host if specified
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        tempVar.setDestinationVdsId(null);
    } else {
        tempVar.setDestinationVdsId(defaultHost != null ? defaultHost.getId() : null);
    }
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    } else if (ev.equals(ConsoleModel.ErrorEventDefinition) && sender instanceof SpiceConsoleModel) {
        SpiceConsoleModel_Error(sender, (ErrorCodeEventArgs) args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public void edit(final SnapshotModel model) {
    Driver.driver.edit(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                VmSnapshotCreatePopupWidget.this.setMessage(model.getMessage());
            }
        }
    });
}
#method_after
@Override
public void edit(final SnapshotModel model) {
    Driver.driver.edit(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            }
        }
    });
}
#end_block

#method_before
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleUserId() == null || vm.getConsoleUserId().equals(Frontend.getLoggedInUser().getUserId())) {
        command.Execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    GetRoleActionGroupsByUserIdParameters params = new GetRoleActionGroupsByUserIdParameters(vm.getConsoleUserId());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            List<ActionGroup> resultList = ((List<ActionGroup>) returnValue.getReturnValue());
            if (resultList.contains(ActionGroup.RECONNECT_TO_VM)) {
                command.Execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetRoleActionGroupsByUserId, params, query);
}
#method_after
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getLoggedInUser().getUserId().equals(vm.getConsoleUserId())) {
        command.Execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    HasAdElementReconnectPermissionParameters params = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId().getValue(), vm.getId().getValue());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            boolean returnValue = ((Boolean) ((VdcQueryReturnValue) result).getReturnValue());
            if (returnValue) {
                command.Execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, params, query);
}
#end_block

#method_before
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setParentModel(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        } else if (selectionContextChanged(vm)) {
            // if new data comes which has changed the selection context, (e.g. the OS type changed)
            // recalculate the default selected protocol
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#method_after
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        } else if (selectionContextChanged(vm)) {
            // if new data comes which has changed the selection context, (e.g. the OS type changed)
            // recalculate the default selected protocol
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#end_block

#method_before
@Override
protected void Connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().Debug("Connecting to Spice console...");
        if (!getspice().getIsInstalled()) {
            // $NON-NLS-1$
            getLogger().Info("Spice client is not installed.");
            getspice().Install();
            return;
        }
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            getLogger().Info("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            getspice().Install();
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!getEntity().getVmOs().isWindows() || getEntity().getSpiceDriverVersion() == null) {
            getspice().setIsWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#method_after
@Override
protected void Connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().Debug("Connecting to Spice console...");
        if (!getspice().getIsInstalled()) {
            // $NON-NLS-1$
            getLogger().Info("Spice client is not installed.");
            getspice().Install();
            return;
        }
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            getLogger().Info("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            getspice().Install();
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!getEntity().getVmOs().isWindows() || !getEntity().getHasSpiceDriver()) {
            getspice().setIsWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#end_block

#method_before
private void Spice_Disconnected(Object sender, ErrorCodeEventArgs e) {
    getspice().getDisconnectedEvent().removeListener(this);
    getspice().getMenuItemSelectedEvent().removeListener(this);
    setIsConnected(false);
    UpdateActionAvailability();
    if (e.getErrorCode() > 100) {
        getErrorEvent().raise(this, e);
    }
    // save console flag
    Frontend.RunAction(VdcActionType.UpdateVmConsoleData, new UpdateVmConsoleDataParameters(getEntity().getId(), null), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        // Ignore result, this tries to update vm console data
        // nothing to do with result
        }
    });
}
#method_after
private void Spice_Disconnected(Object sender, ErrorCodeEventArgs e) {
    getspice().getDisconnectedEvent().removeListener(this);
    getspice().getMenuItemSelectedEvent().removeListener(this);
    setIsConnected(false);
    UpdateActionAvailability();
    if (e.getErrorCode() > 100) {
        getErrorEvent().raise(this, e);
    }
}
#end_block

#method_before
private void ExecuteQuery(final VM vm) {
    AsyncQuery _asyncQuery0 = new AsyncQuery();
    _asyncQuery0.setModel(this);
    _asyncQuery0.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model0, Object result0) {
            SpiceConsoleModel thisSpiceConsoleModel = (SpiceConsoleModel) model0;
            VM thisVm = thisSpiceConsoleModel.getEntity();
            storage_domains isoDomain = null;
            if (result0 != null) {
                isoDomain = (storage_domains) result0;
            }
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetVdsCertificateSubjectByVmId);
            queryTypeList.add(VdcQueryType.GetCACertificate);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SSLEnabled, Config.DefaultConfigurationVersion));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.CipherSuite, Config.DefaultConfigurationVersion));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceSecureChannels, thisVm.getVdsGroupCompatibilityVersion().toString()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.EnableSpiceRootCertificateValidation, Config.DefaultConfigurationVersion));
            parametersList.add(new GetVmByVmIdParameters(thisVm.getId()));
            parametersList.add(new VdcQueryParametersBase());
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceToggleFullScreenKeys, Config.DefaultConfigurationVersion));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceReleaseCursorKeys, Config.DefaultConfigurationVersion));
            if (isoDomain != null) {
                queryTypeList.add(VdcQueryType.GetAllIsoImagesListByStoragePoolId);
                GetAllImagesListByStoragePoolIdParameters getIsoPamams = new GetAllImagesListByStoragePoolIdParameters(vm.getStoragePoolId());
                parametersList.add(getIsoPamams);
            }
            Frontend.RunMultipleQueries(queryTypeList, parametersList, thisSpiceConsoleModel);
        }
    };
    AsyncDataProvider.GetIsoDomainByDataCenterId(_asyncQuery0, vm.getStoragePoolId());
}
#method_after
private void ExecuteQuery(final VM vm) {
    AsyncQuery _asyncQuery0 = new AsyncQuery();
    _asyncQuery0.setModel(this);
    _asyncQuery0.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model0, Object result0) {
            SpiceConsoleModel thisSpiceConsoleModel = (SpiceConsoleModel) model0;
            VM thisVm = thisSpiceConsoleModel.getEntity();
            storage_domains isoDomain = null;
            if (result0 != null) {
                isoDomain = (storage_domains) result0;
            }
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetVdsCertificateSubjectByVmId);
            queryTypeList.add(VdcQueryType.GetCACertificate);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SSLEnabled, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.CipherSuite, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceSecureChannels, thisVm.getVdsGroupCompatibilityVersion().toString()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.EnableSpiceRootCertificateValidation, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetVmByVmIdParameters(thisVm.getId()));
            parametersList.add(new VdcQueryParametersBase());
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceToggleFullScreenKeys, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceReleaseCursorKeys, AsyncDataProvider.getDefaultConfigurationVersion()));
            if (isoDomain != null) {
                queryTypeList.add(VdcQueryType.GetAllIsoImagesListByStoragePoolId);
                GetAllImagesListByStoragePoolIdParameters getIsoPamams = new GetAllImagesListByStoragePoolIdParameters(vm.getStoragePoolId());
                parametersList.add(getIsoPamams);
            }
            Frontend.RunMultipleQueries(queryTypeList, parametersList, thisSpiceConsoleModel);
        }
    };
    AsyncDataProvider.GetIsoDomainByDataCenterId(_asyncQuery0, vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : getEntity().getSpiceDriverVersion() != null ? false : true);
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#method_after
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : !getEntity().getHasSpiceDriver());
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#end_block

#method_before
public void PostSendVmTicket(VdcReturnValueBase returnValue) {
    if (returnValue == null || !returnValue.getSucceeded()) {
        return;
    }
    ticket = (String) returnValue.getActionReturnValue();
    // we attempt to perform SSO (otherwise an error will be thrown)
    if (!getConfigurator().getIsAdmin() && getEntity().getGuestAgentVersion() != null && getEntity().getStatus() == VMStatus.Up) {
        getLogger().Info(// $NON-NLS-1$
        "SpiceConsoleManager::Connect: Attempting to perform SSO on Desktop " + getEntity().getVmName());
        Frontend.RunAction(VdcActionType.VmLogon, new VmOperationParameterBase(getEntity().getId()), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                final SpiceConsoleModel spiceConsoleModel = (SpiceConsoleModel) result.getState();
                final VdcReturnValueBase logonCommandReturnValue = result.getReturnValue();
                boolean isLogonSucceeded = logonCommandReturnValue != null && logonCommandReturnValue.getSucceeded();
                if (isLogonSucceeded) {
                    spiceConsoleModel.ExecuteQuery(getEntity());
                } else {
                    if (logonCommandReturnValue != null && logonCommandReturnValue.getFault().getError() == VdcBllErrors.nonresp) {
                        UICommand okCommand = new UICommand("SpiceWithoutAgentOK", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                logSsoOnDesktopFailedAgentNonResp(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                                "");
                                spiceConsoleModel.ExecuteQuery(getEntity());
                                parentModel.setWindow(null);
                            }
                        });
                        UICommand cancelCommand = new UICommand("SpiceWithoutAgentCancel", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                parentModel.setWindow(null);
                            }
                        });
                        createConnectWithoutAgentConfirmationPopup(okCommand, cancelCommand);
                    } else {
                        logSsoOnDesktopFailed(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                        "");
                    }
                }
            }
        }, this);
    } else {
        ExecuteQuery(getEntity());
    }
}
#method_after
public void PostSendVmTicket(VdcReturnValueBase returnValue) {
    if (returnValue == null || !returnValue.getSucceeded()) {
        return;
    }
    ticket = (String) returnValue.getActionReturnValue();
    // we attempt to perform SSO (otherwise an error will be thrown)
    if (!getConfigurator().getIsAdmin() && getEntity().getHasAgent() && getEntity().getStatus() == VMStatus.Up) {
        getLogger().Info(// $NON-NLS-1$
        "SpiceConsoleManager::Connect: Attempting to perform SSO on Desktop " + getEntity().getVmName());
        Frontend.RunAction(VdcActionType.VmLogon, new VmOperationParameterBase(getEntity().getId()), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                final SpiceConsoleModel spiceConsoleModel = (SpiceConsoleModel) result.getState();
                final VdcReturnValueBase logonCommandReturnValue = result.getReturnValue();
                boolean isLogonSucceeded = logonCommandReturnValue != null && logonCommandReturnValue.getSucceeded();
                if (isLogonSucceeded) {
                    spiceConsoleModel.ExecuteQuery(getEntity());
                } else {
                    if (logonCommandReturnValue != null && logonCommandReturnValue.getFault().getError() == VdcBllErrors.nonresp) {
                        UICommand okCommand = new UICommand("SpiceWithoutAgentOK", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                logSsoOnDesktopFailedAgentNonResp(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                                "");
                                spiceConsoleModel.ExecuteQuery(getEntity());
                                parentModel.setWindow(null);
                            }
                        });
                        UICommand cancelCommand = new UICommand("SpiceWithoutAgentCancel", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                parentModel.setWindow(null);
                            }
                        });
                        createConnectWithoutAgentConfirmationPopup(okCommand, cancelCommand);
                    } else {
                        logSsoOnDesktopFailed(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                        "");
                    }
                }
            }
        }, this);
    } else {
        ExecuteQuery(getEntity());
    }
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    RunOnceLoadHosts(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsAutoAssign().setEntity(true);
}
#end_block

#method_before
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#method_after
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    // set destination host if specified
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        tempVar.setDestinationVdsId(null);
    } else {
        tempVar.setDestinationVdsId(defaultHost != null ? defaultHost.getId() : null);
    }
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#end_block

#method_before
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#method_after
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    } else if (ev.equals(ConsoleModel.ErrorEventDefinition) && sender instanceof SpiceConsoleModel) {
        SpiceConsoleModel_Error(sender, (ErrorCodeEventArgs) args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public void triggerPoolMonitoringJob() {
    SchedulerUtilQuartzImpl.getInstance().triggerJob(poolMonitoringJobId);
}
#method_after
@Override
@ExcludeClassInterceptors
public void triggerPoolMonitoringJob() {
    SchedulerUtilQuartzImpl.getInstance().triggerJob(poolMonitoringJobId);
}
#end_block

#method_before
protected static int getNumOfPrestartedVmsInPool(NGuid poolId) {
    List<VM> vmsInPool = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    int numOfPrestartedVmsInPool = 0;
    if (vmsInPool != null) {
        for (VM vm : vmsInPool) {
            if (isPrestartedVm(vm))
                ++numOfPrestartedVmsInPool;
        }
    }
    return numOfPrestartedVmsInPool;
}
#method_after
protected static int getNumOfPrestartedVmsInPool(NGuid poolId) {
    List<VM> vmsInPool = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    int numOfPrestartedVmsInPool = 0;
    if (vmsInPool != null) {
        for (VM vm : vmsInPool) {
            if (vm.isStartingOrUp() && canAttachPrestartedVmToUser(vm.getId()))
                ++numOfPrestartedVmsInPool;
        }
    }
    return numOfPrestartedVmsInPool;
}
#end_block

#method_before
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new java.util.ArrayList<String>());
}
#method_after
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new ArrayList<String>());
}
#end_block

#method_before
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // check that there isn't another user already attached to this VM:
    boolean returnValue = !vmAssignedToUser(vmId, new java.util.ArrayList<String>());
    // Make sure the Vm is running stateless
    returnValue = returnValue && vmIsRunningStateless(vmId);
    return returnValue;
}
#method_after
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // and make sure the Vm is running stateless
    return !vmAssignedToUser(vmId, new ArrayList<String>()) && vmIsRunningStateless(vmId);
}
#end_block

#method_before
protected static boolean isVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#method_after
protected static boolean isVmFree(Guid vmId, ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected static boolean canRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#method_after
protected static boolean canRunPoolVm(Guid vmId, ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // If the quota is in use by ether VM or image - return false
    if (getQuotaDAO().isQuotaInUse(quota) && !quota.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IN_USE_BY_VM_OR_DISK);
        return false;
    }
    // Otherwise
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // If the quota is in use by ether VM or image - return false
    if (!QuotaEnforcementTypeEnum.DISABLED.equals(quota.getQuotaEnforcementType()) && getQuotaDAO().isQuotaInUse(quota)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IN_USE_BY_VM_OR_DISK);
        return false;
    }
    // Otherwise
    return true;
}
#end_block

#method_before
private boolean refreshIsoDomain(Guid storageDomainId, List<RepoFileMetaData> problematicRepoFileList, FileTypeExtension fileTypeExt) {
    boolean refreshSucceeded = false;
    List<RepoFileMetaData> tempProblematicRepoFileList = new ArrayList<RepoFileMetaData>();
    // Fetch all the Storage pools for this Iso domain Id.
    List<StoragePoolIsoMap> isoMapList = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStorage(storageDomainId);
    log.debugFormat("Fetched {0} storage pools for {1} file type, in Iso domain {2}.", isoMapList.size(), fileTypeExt, storageDomainId);
    Iterator<StoragePoolIsoMap> iter = isoMapList.iterator();
    while (iter.hasNext() && !refreshSucceeded) {
        StoragePoolIsoMap storagePoolIsoMap = iter.next();
        Guid storagePoolId = storagePoolIsoMap.getstorage_pool_id().getValue();
        if ((storagePoolIsoMap.getstatus() != null) && (storagePoolIsoMap.getstatus() == StorageDomainStatus.Active)) {
            // Try to refresh the domain of the storage pool id.
            refreshSucceeded = refreshIsoDomainFileForStoragePool(storageDomainId, storagePoolId, fileTypeExt);
        } else {
            log.debugFormat("Storage domain id {0}, is not active, and there for could not be refreshed for {1} file type (Iso domain status is {2}).", storageDomainId, fileTypeExt, storagePoolIsoMap.getstatus());
        }
        if (!refreshSucceeded) {
            log.debugFormat("Failed refreshing Storage domain id {0}, for {1} file type in storage pool id {2}.", storageDomainId, fileTypeExt, storagePoolId);
            if (storagePoolIsoMap.getstatus() != StorageDomainStatus.Maintenance) {
                // set a mock repository file meta data with storage domain id and storage pool id.
                RepoFileMetaData repoFileMetaData = new RepoFileMetaData();
                repoFileMetaData.setStoragePoolId(storagePoolId);
                repoFileMetaData.setRepoDomainId(storageDomainId);
                repoFileMetaData.setFileType(fileTypeExt);
                // Add the repository file to the list of problematic Iso domains.
                tempProblematicRepoFileList.add(repoFileMetaData);
            }
        }
    }
    // If refreshed was not succeeded add the problematic storage Iso domain to the list.
    if (!refreshSucceeded) {
        problematicRepoFileList.addAll(tempProblematicRepoFileList);
    }
    return refreshSucceeded;
}
#method_after
private boolean refreshIsoDomain(Guid storageDomainId, List<RepoFileMetaData> problematicRepoFileList, FileTypeExtension fileTypeExt) {
    boolean refreshSucceeded = false;
    List<RepoFileMetaData> tempProblematicRepoFileList = new ArrayList<RepoFileMetaData>();
    // Fetch all the Storage pools for this Iso domain Id.
    List<StoragePoolIsoMap> isoMapList = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStorage(storageDomainId);
    log.debugFormat("Fetched {0} storage pools for {1} file type, in Iso domain {2}.", isoMapList.size(), fileTypeExt, storageDomainId);
    Iterator<StoragePoolIsoMap> iter = isoMapList.iterator();
    while (iter.hasNext() && !refreshSucceeded) {
        StoragePoolIsoMap storagePoolIsoMap = iter.next();
        Guid storagePoolId = storagePoolIsoMap.getstorage_pool_id().getValue();
        StorageDomainStatus status = storagePoolIsoMap.getstatus();
        if (status != StorageDomainStatus.Active) {
            log.debugFormat("Storage domain id {0}, is not active, and therefore could not be refreshed for {1} file type (Iso domain status is {2}).", storageDomainId, fileTypeExt, status);
        } else {
            // Try to refresh the domain of the storage pool id because its status is active.
            refreshSucceeded = refreshIsoDomainFileForStoragePool(storageDomainId, storagePoolId, fileTypeExt);
            if (!refreshSucceeded) {
                log.debugFormat("Failed refreshing Storage domain id {0}, for {1} file type in storage pool id {2}.", storageDomainId, fileTypeExt, storagePoolId);
                // set a mock repository file meta data with storage domain id and storage pool id.
                RepoFileMetaData repoFileMetaData = new RepoFileMetaData();
                repoFileMetaData.setStoragePoolId(storagePoolId);
                repoFileMetaData.setRepoDomainId(storageDomainId);
                repoFileMetaData.setFileType(fileTypeExt);
                // Add the repository file to the list of problematic Iso domains.
                tempProblematicRepoFileList.add(repoFileMetaData);
            }
        }
    }
    // If refreshed was not succeeded add the problematic storage Iso domain to the list.
    if (!refreshSucceeded) {
        problematicRepoFileList.addAll(tempProblematicRepoFileList);
    }
    return refreshSucceeded;
}
#end_block

#method_before
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new java.util.ArrayList<String>());
}
#method_after
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new ArrayList<String>());
}
#end_block

#method_before
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // check that there isn't another user already attached to this VM:
    boolean returnValue = !vmAssignedToUser(vmId, new java.util.ArrayList<String>());
    // Make sure the Vm is running stateless
    returnValue = returnValue && vmIsRunningStateless(vmId);
    return returnValue;
}
#method_after
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // and make sure the Vm is running stateless
    return !vmAssignedToUser(vmId, new ArrayList<String>()) && vmIsRunningStateless(vmId);
}
#end_block

#method_before
protected static boolean isVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#method_after
protected static boolean isVmFree(Guid vmId, ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected static boolean canRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#method_after
protected static boolean canRunPoolVm(Guid vmId, ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#end_block

#method_before
@Test
public void testkDuplicateKeys() {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.checkDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testkDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@Test
public void testkDuplicateKeys() {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    String fileName = "AppErrors.properties";
    File file = new File(baseDir + "/src/main/resources/bundles/" + fileName);
    DuplicateKeysCheck.checkDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testkDuplicateKeys() throws FileNotFoundException {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    String fileName = "AppErrors.properties";
    File file = new File(baseDir + "/src/main/resources/bundles/" + fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@Test
public void testkDuplicateKeys() {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.checkDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testkDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
public void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    logAuditMessage(volume.getClusterId(), volume, null, logType, new HashMap<String, String>());
}
#method_after
public void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    logAuditMessage(volume.getClusterId(), volume, null, logType, Collections.<String, String>emptyMap());
}
#end_block

#method_before
public void logServerMessage(final VDS server, final AuditLogType logType) {
    logAuditMessage(null, null, server, logType, new HashMap<String, String>());
}
#method_after
public void logServerMessage(final VDS server, final AuditLogType logType) {
    logAuditMessage(null, null, server, logType, Collections.<String, String>emptyMap());
}
#end_block

#method_before
public Map<String, Class<?>> getTypeDictionary() {
    return mTypeDict;
}
#method_after
public Map<String, Class<?>> getTypeDictionary() {
    return typeDict;
}
#end_block

#method_before
protected void buildBasicValidationTable() {
    for (String key : mVerbs.keySet()) {
        final List<ValueValidationFunction> curList = new ArrayList<ValueValidationFunction>();
        final Class<?> curType = mTypeDict.get(key);
        if (curType == java.math.BigDecimal.class) {
            curList.add(validDecimal);
        } else if (curType == Integer.class) {
            curList.add(validInteger);
        } else if (curType == Date.class) {
            curList.add(validDateTime);
        } else if (curType == TimeSpan.class) {
            curList.add(validTimeSpan);
        } else {
            curList.add(validCharacters);
        }
        final IConditionValueAutoCompleter tmp = getFieldValueAutoCompleter(key);
        if (tmp != null) {
            if (tmp.getClass() == DateEnumValueAutoCompleter.class) {
                curList.add(validateDateEnumValueByValueAC);
            } else {
                curList.add(validateFieldValueByValueAC);
            }
        }
        mValidationDict.put(key, curList);
    }
}
#method_after
protected void buildBasicValidationTable() {
    for (String key : mVerbs.keySet()) {
        final List<ValueValidationFunction> curList = new ArrayList<ValueValidationFunction>();
        final Class<?> curType = typeDict.get(key);
        if (curType == java.math.BigDecimal.class) {
            curList.add(validDecimal);
        } else if (curType == Integer.class) {
            curList.add(validInteger);
        } else if (curType == Date.class) {
            curList.add(validDateTime);
        } else if (curType == TimeSpan.class) {
            curList.add(validTimeSpan);
        } else {
            curList.add(validCharacters);
        }
        final IConditionValueAutoCompleter tmp = getFieldValueAutoCompleter(key);
        if (tmp != null) {
            if (tmp.getClass() == DateEnumValueAutoCompleter.class) {
                curList.add(validateDateEnumValueByValueAC);
            } else {
                curList.add(validateFieldValueByValueAC);
            }
        }
        validationDict.put(key, curList);
    }
}
#end_block

#method_before
public boolean validateFieldValue(String fieldName, String fieldValue) {
    if (mValidationDict.containsKey(fieldName)) {
        final List<ValueValidationFunction> validationList = mValidationDict.get(fieldName);
        for (ValueValidationFunction curValidationFunc : validationList) {
            if (!curValidationFunc.isValid(fieldName, fieldValue)) {
                return false;
            }
        }
    }
    return true;
}
#method_after
public boolean validateFieldValue(String fieldName, String fieldValue) {
    if (validationDict.containsKey(fieldName)) {
        final List<ValueValidationFunction> validationList = validationDict.get(fieldName);
        for (ValueValidationFunction curValidationFunc : validationList) {
            if (!curValidationFunc.isValid(fieldName, fieldValue)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public String getDbFieldName(String fieldName) {
    String retval = null;
    if (mColumnNameDict.containsKey(fieldName)) {
        retval = mColumnNameDict.get(fieldName);
    }
    return retval;
}
#method_after
public String getDbFieldName(String fieldName) {
    String retval = null;
    if (columnNameDict.containsKey(fieldName)) {
        retval = columnNameDict.get(fieldName);
    }
    return retval;
}
#end_block

#method_before
public String getSortableDbField(String fieldName) {
    if (mSortableFieldDict.containsKey(fieldName)) {
        return mSortableFieldDict.get(fieldName);
    } else {
        return getDbFieldName(fieldName);
    }
}
#method_after
public String getSortableDbField(String fieldName) {
    if (sortableFieldDict.containsKey(fieldName)) {
        return sortableFieldDict.get(fieldName);
    } else {
        return getDbFieldName(fieldName);
    }
}
#end_block

#method_before
public Class<?> getDbFieldType(String fieldName) {
    Class<?> retval = null;
    if (mTypeDict.containsKey(fieldName)) {
        retval = mTypeDict.get(fieldName);
    }
    return retval;
}
#method_after
public Class<?> getDbFieldType(String fieldName) {
    Class<?> retval = null;
    if (typeDict.containsKey(fieldName)) {
        retval = typeDict.get(fieldName);
    }
    return retval;
}
#end_block

#method_before
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (String field : mColumnNameDict.keySet()) {
        if (mTypeDict.get(field) == String.class && !mNotFreeTextSearchableFieldsList.contains(field)) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, mColumnNameDict.get(field), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#method_after
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (String field : columnNameDict.keySet()) {
        if (typeDict.get(field) == String.class && !notFreeTextSearchableFieldsList.contains(field)) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, columnNameDict.get(field), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#end_block

#method_before
@Test
public void testEncryptThreads() throws Exception {
    List<Thread> l = new LinkedList<Thread>();
    final String plain = "Test123!32@";
    final boolean[] failed = new boolean[] { false };
    for (int i = 0; i < 100; i++) {
        l.add(new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    String encrypted = EncryptionUtils.encrypt(plain, keyStoreURL, keyStorePass, certAlias);
                    String plain2 = EncryptionUtils.decrypt(encrypted, keyStoreURL, keyStorePass, certAlias);
                    if (!plain.equals(plain2)) {
                        failed[0] = true;
                        System.out.println("BAD");
                        System.out.println("plain2: " + plain2);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }));
    }
    for (Thread t : l) {
        t.start();
    }
    for (Thread t : l) {
        t.join();
    }
    assertFalse(failed[0]);
}
#method_after
@Test
public void testEncryptThreads() throws Exception {
    List<Thread> l = new LinkedList<Thread>();
    final String plain = "Test123!32@";
    final AtomicBoolean failed = new AtomicBoolean();
    for (int i = 0; i < 100; i++) {
        l.add(new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    String encrypted = EncryptionUtils.encrypt(plain, keyStoreURL, keyStorePass, certAlias);
                    String plain2 = EncryptionUtils.decrypt(encrypted, keyStoreURL, keyStorePass, certAlias);
                    if (!plain.equals(plain2)) {
                        failed.set(true);
                        System.out.println("BAD");
                        System.out.println("plain2: " + plain2);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }));
    }
    for (Thread t : l) {
        t.start();
    }
    for (Thread t : l) {
        t.join();
    }
    assertFalse(failed.get());
}
#end_block

#method_before
public final static String encrypt(String source, String certificateFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (!StringHelper.isNullOrEmpty(source.trim())) {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            result = encrypt(source, store.getCertificate(alias));
        }
        return result;
    } catch (Exception e) {
        log.error("Error doing the encryption", e);
        throw e;
    }
}
#method_after
public final static String encrypt(String source, String certificateFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (source.trim().length() > 0) {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            result = encrypt(source, store.getCertificate(alias));
        }
        return result;
    } catch (Exception e) {
        log.error("Error doing the encryption", e);
        throw e;
    }
}
#end_block

#method_before
public static String decrypt(String source, String keyFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (!StringHelper.isNullOrEmpty(source.trim())) {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            result = decrypt(source, store.getKey(alias, passwd.toCharArray()));
        }
        return result;
    } catch (Exception e) {
        log.error("Failed to decrypt " + e.getMessage());
        log.debug("Failed to decrypt", e);
        throw e;
    }
}
#method_after
public static String decrypt(String source, String keyFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (source.trim().length() > 0) {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            result = decrypt(source, store.getKey(alias, passwd.toCharArray()));
        }
        return result;
    } catch (Exception e) {
        log.error("Failed to decrypt " + e.getMessage());
        log.debug("Failed to decrypt", e);
        throw e;
    }
}
#end_block

#method_before
@Override
public void edit(ImportCloneModel object) {
    if (object.getEntity() instanceof VM) {
        dialogLabelEditor.setText(constants.sameVmNameExists().replaceFirst("\\$\\{VmName\\}", // $NON-NLS-1$
        ((VM) object.getEntity()).getVmName()));
        cloneEditor.setLabel(constants.cloneImportVm());
        suffixEditor.setLabel(constants.cloneImportSuffixVm());
    } else {
        dialogLabelEditor.setText(constants.sameTemplateNameExists() + " (" + ((VmTemplate) object.getEntity()).getname() + // $NON-NLS-1$ //$NON-NLS-2$
        ")");
        cloneEditor.setLabel(constants.cloneImportTemplate());
        suffixEditor.setLabel(constants.cloneImportSuffixTemplate());
    }
    Driver.driver.edit(object);
}
#method_after
@Override
public void edit(ImportCloneModel object) {
    if (object.getEntity() instanceof VM) {
        dialogLabelEditor.setText(messages.sameVmNameExists(((VM) object.getEntity()).getVmName()));
        cloneEditor.asRadioButton().setHTML(templates.twoLinesRadioButtonLabel(constants.cloneImportVm(), constants.cloneImportVmDetails()).asString());
        suffixEditor.setLabel(constants.cloneImportSuffixVm());
    } else {
        dialogLabelEditor.setText(constants.sameTemplateNameExists() + " (" + ((VmTemplate) object.getEntity()).getname() + // $NON-NLS-1$ //$NON-NLS-2$
        ")");
        cloneEditor.setLabel(constants.cloneImportTemplate());
        suffixEditor.setLabel(constants.cloneImportSuffixTemplate());
    }
    Driver.driver.edit(object);
}
#end_block

#method_before
@Override
public String getLabel() {
    if (useRadioButtonWidgetLabel) {
        return asRadioButton().getHTML();
    } else {
        return super.getLabel();
    }
}
#method_after
@Override
public String getLabel() {
    if (useRadioButtonWidgetLabel) {
        return asRadioButton().getText();
    } else {
        return super.getLabel();
    }
}
#end_block

#method_before
@Override
public void setLabel(String label) {
    if (useRadioButtonWidgetLabel) {
        asRadioButton().setHTML(label);
    } else {
        super.setLabel(label);
    }
}
#method_after
@Override
public void setLabel(String label) {
    if (useRadioButtonWidgetLabel) {
        asRadioButton().setText(label);
    } else {
        super.setLabel(label);
    }
}
#end_block

#method_before
private boolean isQuotaValidationNeeded() {
    return DiskStorageType.IMAGE == oldDisk.getDiskStorageType();
}
#method_after
private boolean isQuotaValidationNeeded() {
    return oldDisk != null && newDisk != null && oldDisk instanceof DiskImage && newDisk instanceof DiskImage && DiskStorageType.IMAGE == oldDisk.getDiskStorageType();
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        DiskImage newDiskImage = (DiskImage) newDisk;
        QuotaStorageConsumptionParameter consumptionRequest = new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
        newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes());
        QuotaStorageConsumptionParameter releaseRequest = new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
        oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes());
        if (oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId())) {
            // empty old quota
            list.add(consumptionRequest);
        } else {
            // non-empty old quota
            if (!oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
                // different new quota
                list.add(consumptionRequest);
                list.add(releaseRequest);
            }
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        DiskImage newDiskImage = (DiskImage) newDisk;
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        if (emptyOldQuota || differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Check whether the given server is already part of the cluster
    if (getVdsStaticDao().getAllForHost(getParameters().getServerName()).size() > 0 || getVdsStaticDao().getAllWithIpAddress(getParameters().getServerName()).size() > 0) {
        setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
    }
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        Map<String, String> serverFingerPrint = extractServers(serversXml);
        // Check if any of the server in the map is already part of some other cluster.
        if (!validateServers(serverFingerPrint.keySet())) {
            setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
        }
        getQueryReturnValue().setReturnValue(serverFingerPrint);
    } catch (AuthenticationException ae) {
        setReturnMessage(VdcBllMessages.SSH_AUTHENTICATION_FAILED.toString());
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    // Check whether the given server is already part of the cluster
    if (getVdsStaticDao().getAllForHost(getParameters().getServerName()).size() > 0 || getVdsStaticDao().getAllWithIpAddress(getParameters().getServerName()).size() > 0) {
        setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
        return;
    }
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        Map<String, String> serverFingerPrint = extractServers(serversXml);
        // Check if any of the server in the map is already part of some other cluster.
        if (!validateServers(serverFingerPrint.keySet())) {
            setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
        }
        getQueryReturnValue().setReturnValue(serverFingerPrint);
    } catch (AuthenticationException ae) {
        setReturnMessage(VdcBllMessages.SSH_AUTHENTICATION_FAILED.toString());
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
private void setReturnMessage(String errorMessage) {
    getQueryReturnValue().setSucceeded(false);
    getQueryReturnValue().setExceptionString(errorMessage);
    return;
}
#method_after
private void setReturnMessage(String errorMessage) {
    getQueryReturnValue().setSucceeded(false);
    getQueryReturnValue().setExceptionString(errorMessage);
}
#end_block

#method_before
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
        log.errorFormat("Reverting task {0}, handler: {1}", type, getCurrentTaskHandler().getClass().getName());
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#method_after
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#end_block

#method_before
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#method_after
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    if (parametersForTask.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parametersForTask.setParametersCurrentUser(getCurrentUser());
    }
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#end_block

#method_before
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#method_after
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.error("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
public void setContext(CommandContext context) {
    if (context == null) {
        return;
    }
    CompensationContext compensationContext = context.getCompensationContext();
    if (compensationContext != null) {
        setCompensationContext(compensationContext);
    }
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext != null) {
        setExecutionContext(executionContext);
        if (executionContext.getJob() != null) {
            if (executionContext.getJob().getOwnerId() != null) {
                DbUser user = DbFacade.getInstance().getDbUserDao().get(executionContext.getJob().getOwnerId().getValue());
                if (user != null) {
                    setUserName(user.getusername());
                }
            }
            setJobId(executionContext.getJob().getId());
        } else if (executionContext.getStep() != null) {
            setJobId(executionContext.getStep().getJobId());
        }
    }
    if (commandLock == null) {
        commandLock = context.getLock();
    }
}
#method_after
public void setContext(CommandContext context) {
    if (context == null) {
        return;
    }
    CompensationContext compensationContext = context.getCompensationContext();
    if (compensationContext != null) {
        setCompensationContext(compensationContext);
    }
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext != null) {
        setExecutionContext(executionContext);
        if (executionContext.getJob() != null) {
            setJobId(executionContext.getJob().getId());
        } else if (executionContext.getStep() != null) {
            setJobId(executionContext.getStep().getJobId());
        }
    }
    if (commandLock == null) {
        commandLock = context.getLock();
    }
}
#end_block

#method_before
public void setValues(double limit, double consumedByOthers, double consumedByUser) {
    int othersConsumptionPercent = (int) Math.round(consumedByOthers * 100 / limit);
    int userConsumptionPercent = (int) Math.round(consumedByUser * 100 / limit);
    double free = limit - consumedByOthers - consumedByUser;
    switch(getType()) {
        case STORAGE:
            // $NON-NLS-1$
            String freeStorage = free == 0 ? "0" : diskSizeRenderer.render(free);
            setTitle(constants.freeStorage() + freeStorage);
            break;
        case CPU:
            setTitle(messages.quotaFreeCpus((int) free));
            break;
        case MEM:
            // $NON-NLS-1$
            String freeMem = free > 4096 ? diskSizeRenderer.render(free / 1024) : (int) free + "MB";
            setTitle(constants.freeMemory() + freeMem);
            break;
    }
    if (limit == UNLIMITED) {
        // unlimited
        setUnlimited();
    } else if (consumedByOthers + consumedByUser == 0) {
        // empty
        setZeroValue();
    } else if (consumedByOthers + consumedByUser > limit) {
        // exceeded
        switch(getType()) {
            case STORAGE:
                setExceeded(messages.exceedingStorage(othersConsumptionPercent + userConsumptionPercent - 100, -free));
                break;
            case CPU:
                setExceeded(messages.exceedingCpus(othersConsumptionPercent + userConsumptionPercent - 100, (int) -free));
                break;
            case MEM:
                // $NON-NLS-1$
                String freeMem = free < -4096 ? diskSizeRenderer.render(-free / 1024) : (int) -free + "MB";
                setExceeded(messages.exceedingMem(othersConsumptionPercent + userConsumptionPercent - 100, freeMem));
                break;
        }
    } else {
        percentageBarA.setStyleName(style.percentageBarA());
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarB.setVisible(true);
        setValueA(othersConsumptionPercent);
        setValueB(userConsumptionPercent);
        setBars();
    }
}
#method_after
public void setValues(double limit, double consumedByOthers, double consumedByUser) {
    int othersConsumptionPercent = (int) Math.round(consumedByOthers * 100 / limit);
    int userConsumptionPercent = (int) Math.round(consumedByUser * 100 / limit);
    double free = limit - consumedByOthers - consumedByUser;
    setTitleInternal(free);
    if (limit == UNLIMITED) {
        // unlimited
        setUnlimited();
    } else if (consumedByOthers + consumedByUser == 0) {
        // empty
        setZeroValue();
    } else if (consumedByOthers + consumedByUser > limit) {
        // exceeded
        switch(getType()) {
            case STORAGE:
                setExceeded(messages.exceedingStorage(othersConsumptionPercent + userConsumptionPercent - 100, -free));
                break;
            case CPU:
                setExceeded(messages.exceedingCpus(othersConsumptionPercent + userConsumptionPercent - 100, (int) -free));
                break;
            case MEM:
                // $NON-NLS-1$
                String freeMem = free < (-MB_GB_THRESHOLD * GIGA) ? diskSizeRenderer.render(-free / GIGA) : (int) -free + "MB";
                setExceeded(messages.exceedingMem(othersConsumptionPercent + userConsumptionPercent - 100, freeMem));
                break;
        }
    } else {
        percentageBarA.setStyleName(style.percentageBarA());
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarB.setVisible(true);
        setValueA(othersConsumptionPercent);
        setValueB(userConsumptionPercent);
        setBars();
    }
}
#end_block

#method_before
public void setZeroValue() {
    percentageBarA.setVisible(true);
    percentageBarA.setTitle(title);
    percentageBarA.setStyleName(style.empty());
    // $NON-NLS-1$
    percentageBarA.setWidth("99%");
    percentageLabelA.setText(ZERO);
    percentageLabelA.setStyleName(style.percentageLabelBlack());
}
#method_after
public void setZeroValue() {
    percentageBarA.setVisible(true);
    percentageBarA.setTitle(title);
    percentageBarA.setStyleName(style.empty());
    // $NON-NLS-1$
    percentageBarA.setWidth(FULL_WIDTH + "%");
    percentageLabelA.setText(ZERO);
    percentageLabelA.setStyleName(style.percentageLabelBlack());
}
#end_block

#method_before
public void setBars() {
    int fakeA = valueA;
    int fakeB = valueB;
    if (valueA != null && valueB != null && valueA + valueB >= 99) {
        double factor = (double) 98 / (valueA + valueB);
        fakeA = (int) Math.round(factor * valueA);
        fakeB = (int) Math.round(factor * valueB);
        fakeA = (fakeB == 0 ? 99 : fakeA);
        fakeB = (fakeA == 0 ? 99 : fakeB);
    }
    if (valueB != null) {
        // $NON-NLS-1$
        String percentageB = valueB + "%";
        // $NON-NLS-1$
        String fakePercentageB = fakeB + "%";
        // $NON-NLS-1$
        percentageLabelB.setText(valueB < 10 ? "" : percentageB);
        percentageLabelB.setStyleName(style.percentageLabel());
        percentageBarB.setWidth(fakePercentageB);
        percentageBarB.setVisible(valueB != 0);
        percentageBarB.setTitle(percentageB);
    }
    if (valueA != null) {
        // $NON-NLS-1$
        String percentageA = valueA + "%";
        // $NON-NLS-1$
        String fakePercentageA = fakeA + "%";
        // $NON-NLS-1$
        percentageLabelA.setText(valueA < 10 ? "" : percentageA);
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarA.setWidth(fakePercentageA);
        percentageBarA.setVisible(valueA != 0);
        percentageBarA.setTitle(percentageA);
    }
}
#method_after
public void setBars() {
    int fakeA = valueA;
    int fakeB = valueB;
    if (valueA != null && valueB != null && valueA + valueB >= FULL_WIDTH) {
        double factor = (double) (FULL_WIDTH - 1) / (valueA + valueB);
        fakeA = (int) Math.round(factor * valueA);
        fakeB = (int) Math.round(factor * valueB);
        fakeA = (fakeB == 0 ? FULL_WIDTH : fakeA);
        fakeB = (fakeA == 0 ? FULL_WIDTH : fakeB);
    }
    setBar(percentageBarA, percentageLabelA, valueA, fakeA, style.percentageLabelBlack());
    setBar(percentageBarB, percentageLabelB, valueB, fakeB, style.percentageLabel());
}
#end_block

#method_before
protected boolean MigrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || (HAOnly && vm.isAutoStartup()))) {
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType()), new CommandContext(createMigrateVmContext(parentContext, vm)));
            if (!result.getCanDoAction() || !(((Boolean) result.getActionReturnValue()).booleanValue())) {
                succeeded = false;
                AppendCustomValue("failedVms", vm.getVmName(), ",");
                log.errorFormat("ResourceManager::vdsMaintenance - Failed migrating desktop '{0}'", vm.getVmName());
            }
        }
    }
    return succeeded;
}
#method_after
protected boolean MigrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || (HAOnly && vm.isAutoStartup()))) {
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType()), createMigrateVmContext(parentContext, vm));
            if (!result.getCanDoAction() || !(((Boolean) result.getActionReturnValue()).booleanValue())) {
                succeeded = false;
                AppendCustomValue("failedVms", vm.getVmName(), ",");
                log.errorFormat("ResourceManager::vdsMaintenance - Failed migrating desktop '{0}'", vm.getVmName());
            }
        }
    }
    return succeeded;
}
#end_block

#method_before
protected ExecutionContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), vm.getVmName());
        values.put(VdcObjectType.VDS.name().toLowerCase(), vm.getRunOnVdsName());
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), parentContext.getJob().getStep(StepEnum.EXECUTING), StepEnum.MIGRATE_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.MIGRATE_VM, values));
        ctx.setStep(step);
        ctx.setMonitored(true);
    } catch (RuntimeException e) {
        log.error("Failed to create ExecutionContext for MigrateVmCommand", e);
    }
    return ctx;
}
#method_after
protected CommandContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), vm.getVmName());
        values.put(VdcObjectType.VDS.name().toLowerCase(), vm.getRunOnVdsName());
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), parentContext.getJob().getStep(StepEnum.EXECUTING), StepEnum.MIGRATE_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.MIGRATE_VM, values));
        ctx.setStep(step);
        ctx.setMonitored(true);
    } catch (RuntimeException e) {
        log.error("Failed to create ExecutionContext for MigrateVmCommand", e);
    }
    return new CommandContext(ctx);
}
#end_block

#method_before
@Override
protected ExecutionContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    return new ExecutionContext();
}
#method_after
@Override
protected CommandContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    return ExecutionHandler.createInternalJobContext();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getvds_name());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setCorrelationId(getCorrelationId());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getvds_type()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case PowerClient:
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getvds_type()));
            }
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getvds_name(), getVds().getvds_type().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            upgrade.setCorrelationId(getCorrelationId());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getvds_name());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setCorrelationId(getCorrelationId());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getvds_type()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case PowerClient:
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getvds_type()));
            }
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getvds_name(), getVds().getvds_type().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getmem_available() < minAvailableThreshold || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("AvailableMemory", stat.getmem_available().toString());
        logable.AddCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.AddCustomValue("Threshold", stat.getmem_available() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, stat.getmem_available() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getmem_available() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getmem_available() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if (stat.getmem_available() < minAvailableThreshold || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("AvailableMemory", stat.getmem_available().toString());
        logable.AddCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.AddCustomValue("Threshold", stat.getmem_available() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.AddCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.AddCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.AddCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.AddCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    if (oldVmStatus == VMStatus.MigratingFrom && VM.isGuestUp(runningVm.getstatus())) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getstatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("vds::Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#end_block

#method_before
private void allQueriesForVms() {
    when(vmDao.getAllForVdsGroup(any(Guid.class))).thenReturn(new ArrayList<VM>());
}
#method_after
private void allQueriesForVms() {
    when(vmDao.getAllForVdsGroup(any(Guid.class))).thenReturn(Collections.<VM>emptyList());
}
#end_block

#method_before
@Override
public List<VM> getAllForVdsGroup(Guid vdsGroupId) {
    return getCallsHandler().executeReadList("GetVmsByVdsGroupId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vdsGroupId", vdsGroupId));
}
#method_after
@Override
public List<VM> getAllForVdsGroup(Guid vds_group_id) {
    return getCallsHandler().executeReadList("GetVmsByVdsGroupId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_id", vds_group_id));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        VdsActionParameters parameters = new VdsActionParameters();
        for (VDS vds : allForVdsGroup) {
            parameters.setVdsId(vds.getId());
            if (getVdsGroup().getStoragePoolId() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId().getValue());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId().getValue());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getstatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            List<VM> vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
            boolean notDownVms = false;
            boolean suspendedVms = false;
            for (VM vm : vmList) {
                // the vm cluster id is the same as the cluster.id
                if (!vm.getVdsGroupId().equals(oldGroup.getId())) {
                    continue;
                } else {
                    hasVms = true;
                }
                if (vm.getStatus() == VMStatus.Suspended) {
                    suspendedVms = true;
                } else if (vm.getStatus() != VMStatus.Down) {
                    notDownVms = true;
                }
            }
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId().getValue());
        if (oldGroup.getStoragePoolId() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getstatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            List<VM> vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId().getValue());
        if (oldGroup.getStoragePoolId() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
public void activate() {
    VDS vds = null;
    try {
        // refresh vds from db in case changed while was down
        if (log.isDebugEnabled()) {
            log.debugFormat("Trying to activate host {0} , meanwhile setting status to Unassigned meanwhile", getVdsId());
        }
        vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        /**
         * refresh capabilities
         */
        VDSStatus newStatus = refreshCapabilities(new AtomicBoolean(), vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("Succeeded to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
    } catch (java.lang.Exception e) {
        log.infoFormat("Failed to get VDS = {0} capabilities with error: {1}.", getVdsId(), e.getMessage());
        log.infoFormat("Failed to activate VDS = {0}", getVdsId());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void activate() {
    VDS vds = null;
    try {
        // refresh vds from db in case changed while was down
        log.debugFormat("Trying to activate host {0} , meanwhile setting status to Unassigned.", getVdsId());
        vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        /**
         * refresh capabilities
         */
        VDSStatus newStatus = refreshCapabilities(new AtomicBoolean(), vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("Succeeded to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
    } catch (java.lang.Exception e) {
        log.infoFormat("Failed to activate VDS = {0} with error: {1}.", getVdsId(), e.getMessage());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getvds_group_compatibility_version();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getvds_group_compatibility_version();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getstatus() != VDSStatus.Down) {
        if (mUnrespondedAttempts.get() < Config.<Integer>GetValue(ConfigValues.VDSAttemptsToResetCount) || lastUpdate + (TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.TimeoutToResetVdsInSeconds))) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getstatus() != VDSStatus.Connecting && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getstatus() == VDSStatus.NonResponsive || vds.getstatus() == VDSStatus.Maintenance) {
            // clearNotRespondingVds();
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.errorFormat("VDS::handleNetworkException Server failed to respond, vds_id = {0}, vds_name = {1}, error = {2}", vds.getId(), vds.getvds_name(), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getstatus() != VDSStatus.Down) {
        if (mUnrespondedAttempts.get() < Config.<Integer>GetValue(ConfigValues.VDSAttemptsToResetCount) || lastUpdate + (TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.TimeoutToResetVdsInSeconds))) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getstatus() != VDSStatus.Connecting && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getstatus() == VDSStatus.NonResponsive || vds.getstatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.errorFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, error = {2}", vds.getId(), vds.getvds_name(), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds);
    }
    return true;
}
#end_block

#method_before
private void addModelListeners(SystemTreeModelProvider modelProvider) {
    modelProvider.getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Collapse tree on refresh
            collapseTree(display.getRootTreeNode());
            // will collapse as it should do.
            if (initialized) {
                display.getRootTreeNode().setChildOpen(0, true);
            }
            initialized = true;
        }
    });
}
#method_after
private void addModelListeners(final SystemTreeModelProvider modelProvider) {
    modelProvider.getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Reset selection in the model
            SystemTreeItemModel lastSelectedItem = modelProvider.getSelectionModel().getSelectedObject();
            modelProvider.getSelectionModel().setSelected(lastSelectedItem, false);
            expandTree(display.getRootTreeNode(), ITEM_LEVEL);
        }
    });
}
#end_block

#method_before
@Override
protected CellTree createDataDisplayWidget(SystemTreeModelProvider modelProvider) {
    SystemTreeResources res = GWT.create(SystemTreeResources.class);
    display = new CellTree(modelProvider, null, res);
    display.setAnimationEnabled(true);
    display.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.BOUND_TO_SELECTION);
    return display;
}
#method_after
@Override
protected CellTree createDataDisplayWidget(SystemTreeModelProvider modelProvider) {
    SystemTreeResources res = GWT.create(SystemTreeResources.class);
    display = new CellTree(modelProvider, null, res) {

        @Override
        protected void onLoad() {
            expandTree(display.getRootTreeNode(), ITEM_LEVEL);
        }
    };
    display.setAnimationEnabled(true);
    display.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.BOUND_TO_SELECTION);
    return display;
}
#end_block

#method_before
private void expandTree(TreeNode node) {
    if (node == null) {
        return;
    }
    for (int i = 0; i < node.getChildCount(); i++) {
        expandTree(node.setChildOpen(i, true));
    }
}
#method_after
private void expandTree(TreeNode node) {
    expandTree(node, ALL_LEVELS);
}
#end_block

#method_before
private void expandTree(TreeNode node) {
    if (node == null) {
        return;
    }
    for (int i = 0; i < node.getChildCount(); i++) {
        expandTree(node.setChildOpen(i, true));
    }
}
#method_after
private void expandTree(TreeNode node, int expandUpToLevel) {
    if (node == null) {
        return;
    }
    for (int i = 0; i < node.getChildCount(); i++) {
        boolean expandNode = 0 < expandUpToLevel ? true : false;
        expandTree(node.setChildOpen(i, expandNode), expandUpToLevel - 1);
    }
}
#end_block

#method_before
private TreeNode findNode(TreeNode node, SystemTreeItemModel model) {
    TreeNode result = null;
    if (node == null) {
        return null;
    }
    int i = 0;
    while (result == null && i < node.getChildCount()) {
        if (null != model && model.equals(node.getChildValue(i))) {
            result = node.setChildOpen(i, true);
            break;
        }
        // Only check open nodes, otherwise they couldn't have been selected.
        if (node.isChildOpen(i)) {
            result = findNode(node.setChildOpen(i, true), model);
        }
        i++;
    }
    return result;
}
#method_after
private TreeNode findNode(TreeNode node, SystemTreeItemModel model) {
    TreeNode result = null;
    if (node == null) {
        return null;
    }
    int i = 0;
    while (result == null && i < node.getChildCount()) {
        if (model != null && model.equals(node.getChildValue(i))) {
            result = node.setChildOpen(i, true);
            break;
        }
        // Only check open nodes, otherwise they couldn't have been selected.
        if (node.isChildOpen(i)) {
            result = findNode(node.setChildOpen(i, true), model);
        }
        i++;
    }
    return result;
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                for (Object object : list) {
                    if (object instanceof VM) {
                        vms.add((VM) object);
                    } else if (object instanceof vm_pools) {
                        pools.add((vm_pools) object);
                    }
                }
            }
            userPortalListModel.setvms(vms);
            userPortalListModel.setpools(pools);
            userPortalListModel.OnVmAndPoolLoad();
        }
    }));
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                if (list != null) {
                    for (Object object : list) {
                        if (object instanceof VM) {
                            vms.add((VM) object);
                        } else if (object instanceof vm_pools) {
                            pools.add((vm_pools) object);
                        }
                    }
                }
            }
            userPortalListModel.setvms(vms);
            userPortalListModel.setpools(pools);
            userPortalListModel.OnVmAndPoolLoad();
        }
    }));
}
#end_block

#method_before
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new GetVmByVmIdParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#method_after
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // disable Host tab
    model.setIsHostTabVisible(false);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#end_block

#method_before
public void PostVmNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    gettempVm().setVmType(model.getVmType());
    gettempVm().setVmtGuid(template.getId());
    gettempVm().setVmName(name);
    gettempVm().setVmOs((VmOsType) model.getOSType().getSelectedItem());
    gettempVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    gettempVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    gettempVm().setVmDescription((String) model.getDescription().getEntity());
    gettempVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    gettempVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    gettempVm().setVdsGroupId(newClusterID);
    gettempVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    gettempVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    gettempVm().setAutoSuspend(false);
    gettempVm().setStateless((Boolean) model.getIsStateless().getEntity());
    gettempVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    gettempVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    gettempVm().setDefaultBootSequence(model.getBootSequence());
    gettempVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    gettempVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    gettempVm().setKernelUrl((String) model.getKernel_path().getEntity());
    gettempVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    gettempVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    gettempVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    gettempVm().setPriority((Integer) prioritySelectedItem.getEntity());
    if (model.getQuota().getSelectedItem() != null) {
        gettempVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    gettempVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        gettempVm().setDedicatedVmForVds(null);
    } else {
        gettempVm().setDedicatedVmForVds(defaultHost.getId());
    }
    gettempVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
        gettempVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    }
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(NGuid.Empty)) {
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(gettempVm(), new ArrayList<DiskImage>(), NGuid.Empty);
            parameters.setMakeCreatorExplicitOwner(true);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    stopProgress(result.getState());
                    cancel();
                }
            }, this);
        } else {
            setstorageDomain((storage_domains) model.getStorageDomain().getSelectedItem());
            if ((Boolean) model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        ArrayList<DiskImage> templateDisks = (ArrayList<DiskImage>) result;
                        for (DiskImage templateDisk : templateDisks) {
                            DiskModel disk = null;
                            for (DiskModel a : ((UnitVmModel) userPortalListModel1.getWindow()).getDisks()) {
                                if (templateDisk.getId().equals(a.getDisk().getId())) {
                                    disk = a;
                                    break;
                                }
                            }
                            if (disk != null) {
                                templateDisk.setvolume_type((VolumeType) disk.getVolumeType().getSelectedItem());
                                templateDisk.setvolume_format(AsyncDataProvider.GetDiskVolumeFormat((VolumeType) disk.getVolumeType().getSelectedItem(), getstorageDomain().getstorage_type()));
                            }
                        }
                        HashMap<Guid, DiskImage> dict = new HashMap<Guid, DiskImage>();
                        for (DiskImage a : templateDisks) {
                            dict.put(a.getId(), a);
                        }
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(gettempVm(), dict, getstorageDomain().getId());
                        param.setMakeCreatorExplicitOwner(true);
                        ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                        parameters.add(param);
                        Frontend.RunMultipleAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendMultipleActionAsyncResult a) {
                                stopProgress(a.getState());
                                cancel();
                            }
                        }, this);
                    }
                };
                AsyncDataProvider.GetTemplateDiskList(_asyncQuery, template.getId());
            } else {
                VmManagementParametersBase param = new VmManagementParametersBase(gettempVm());
                param.setStorageDomainId(getstorageDomain().getId());
                param.setMakeCreatorExplicitOwner(true);
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(param);
                Frontend.RunMultipleAction(VdcActionType.AddVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendMultipleActionAsyncResult a) {
                        stopProgress(a.getState());
                        cancel();
                    }
                }, this);
            }
        }
    } else {
        Guid oldClusterID = ((VM) selectedItem.getEntity()).getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            Frontend.RunAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                        @Override
                        public void Executed(FrontendActionAsyncResult a) {
                            stopProgress(a.getState());
                            cancel();
                        }
                    }, this);
                }
            }, this);
        } else {
            Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult a) {
                    stopProgress(a.getState());
                    cancel();
                }
            }, this);
        }
    }
}
#method_after
public void PostVmNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    gettempVm().setVmType(model.getVmType());
    gettempVm().setVmtGuid(template.getId());
    gettempVm().setVmName(name);
    gettempVm().setVmOs((VmOsType) model.getOSType().getSelectedItem());
    gettempVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    gettempVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    gettempVm().setVmDescription((String) model.getDescription().getEntity());
    gettempVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    gettempVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    gettempVm().setVdsGroupId(newClusterID);
    gettempVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    gettempVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    gettempVm().setAutoSuspend(false);
    gettempVm().setStateless((Boolean) model.getIsStateless().getEntity());
    gettempVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    gettempVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    gettempVm().setDefaultBootSequence(model.getBootSequence());
    gettempVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    gettempVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    gettempVm().setKernelUrl((String) model.getKernel_path().getEntity());
    gettempVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    gettempVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    gettempVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    gettempVm().setPriority((Integer) prioritySelectedItem.getEntity());
    if (model.getQuota().getSelectedItem() != null) {
        gettempVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    gettempVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        gettempVm().setDedicatedVmForVds(null);
    } else {
        gettempVm().setDedicatedVmForVds(defaultHost.getId());
    }
    gettempVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
        gettempVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
        gettempVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    }
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(NGuid.Empty)) {
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(gettempVm(), new ArrayList<DiskImage>(), NGuid.Empty);
            parameters.setMakeCreatorExplicitOwner(true);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    stopProgress(result.getState());
                    cancel();
                }
            }, this);
        } else {
            setstorageDomain((storage_domains) model.getStorageDomain().getSelectedItem());
            if ((Boolean) model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        ArrayList<DiskImage> templateDisks = (ArrayList<DiskImage>) result;
                        for (DiskImage templateDisk : templateDisks) {
                            DiskModel disk = null;
                            for (DiskModel a : ((UnitVmModel) userPortalListModel1.getWindow()).getDisks()) {
                                if (templateDisk.getId().equals(a.getDisk().getId())) {
                                    disk = a;
                                    break;
                                }
                            }
                            if (disk != null) {
                                templateDisk.setvolume_type((VolumeType) disk.getVolumeType().getSelectedItem());
                                templateDisk.setvolume_format(AsyncDataProvider.GetDiskVolumeFormat((VolumeType) disk.getVolumeType().getSelectedItem(), getstorageDomain().getstorage_type()));
                            }
                        }
                        HashMap<Guid, DiskImage> dict = new HashMap<Guid, DiskImage>();
                        for (DiskImage a : templateDisks) {
                            dict.put(a.getId(), a);
                        }
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(gettempVm(), dict, getstorageDomain().getId());
                        param.setMakeCreatorExplicitOwner(true);
                        ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                        parameters.add(param);
                        Frontend.RunMultipleAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendMultipleActionAsyncResult a) {
                                stopProgress(a.getState());
                                cancel();
                            }
                        }, this);
                    }
                };
                AsyncDataProvider.GetTemplateDiskList(_asyncQuery, template.getId());
            } else {
                VmManagementParametersBase param = new VmManagementParametersBase(gettempVm());
                param.setStorageDomainId(getstorageDomain().getId());
                param.setMakeCreatorExplicitOwner(true);
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(param);
                Frontend.RunMultipleAction(VdcActionType.AddVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendMultipleActionAsyncResult a) {
                        stopProgress(a.getState());
                        cancel();
                    }
                }, this);
            }
        }
    } else {
        Guid oldClusterID = ((VM) selectedItem.getEntity()).getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            Frontend.RunAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                        @Override
                        public void Executed(FrontendActionAsyncResult a) {
                            stopProgress(a.getState());
                            cancel();
                        }
                    }, this);
                }
            }, this);
        } else {
            Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult a) {
                    stopProgress(a.getState());
                    cancel();
                }
            }, this);
        }
    }
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalBasicListModel userPortalBasicListModel = (UserPortalBasicListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                for (Object object : list) {
                    if (object instanceof VM) {
                        vms.add((VM) object);
                    } else if (object instanceof vm_pools) {
                        pools.add((vm_pools) object);
                    }
                }
            }
            userPortalBasicListModel.setvms(vms);
            userPortalBasicListModel.setpools(pools);
            userPortalBasicListModel.OnVmAndPoolLoad();
        }
    }));
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalBasicListModel userPortalBasicListModel = (UserPortalBasicListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                if (list != null) {
                    for (Object object : list) {
                        if (object instanceof VM) {
                            vms.add((VM) object);
                        } else if (object instanceof vm_pools) {
                            pools.add((vm_pools) object);
                        }
                    }
                }
            }
            userPortalBasicListModel.setvms(vms);
            userPortalBasicListModel.setpools(pools);
            userPortalBasicListModel.OnVmAndPoolLoad();
        }
    }));
}
#end_block

#method_before
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    if (getStorageDomainStatus() != null) {
        valid = Arrays.asList(statuses).contains(getStorageDomainStatus());
    }
    if (!valid) {
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#method_after
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    StorageDomainStatus status = getStorageDomainStatus();
    if (status != null) {
        valid = Arrays.asList(statuses).contains(status);
    }
    if (!valid) {
        if (status == StorageDomainStatus.Locked) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
        }
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setvds_name(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.sethost_name(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setport(model.getPort());
    } else {
        entity.setport(DEFAULT_VDSM_PORT);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplayAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplayAddress()) ? null : model.getDisplayAddress());
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setvds_name(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.sethost_name(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setport(model.getPort());
    } else {
        entity.setport(DEFAULT_VDSM_PORT);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getcpu_cores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getlibvirt_version() != null) {
        Version version = new Version();
        version.setMajor(entity.getlibvirt_version().getMajor());
        version.setMinor(entity.getlibvirt_version().getMinor());
        version.setRevision(entity.getlibvirt_version().getRevision());
        version.setBuild(entity.getlibvirt_version().getBuild());
        version.setFullVersion(entity.getlibvirt_version().getRpmName());
        model.setLibvirtVersion(version);
    }
    model.setDisplayAddress(entity.getConsoleAddress());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getcpu_cores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getlibvirt_version() != null) {
        Version version = new Version();
        version.setMajor(entity.getlibvirt_version().getMajor());
        version.setMinor(entity.getlibvirt_version().getMinor());
        version.setRevision(entity.getlibvirt_version().getRevision());
        version.setBuild(entity.getlibvirt_version().getBuild());
        version.setFullVersion(entity.getlibvirt_version().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    return model;
}
#end_block

#method_before
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplayAddress(), transform.getDisplayAddress());
}
#method_after
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplay().getAddress(), transform.getDisplay().getAddress());
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    try {
        log.info("Init VM Custom Properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization failed", e);
        throw new RuntimeException(e);
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public static void EnableLoadBalancer() {
    log.info("Start scheduling to enable load balancer");
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "PerformLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), TimeUnit.MINUTES);
    log.info("Finished scheduling to enable load balancer");
}
#method_after
public static void EnableLoadBalancer() {
    log.info("Start scheduling to enable vds load balancer");
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "PerformLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), TimeUnit.MINUTES);
    log.info("Finished scheduling to enable vds load balancer");
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        log.info("AuditLogCleanupManager::deleteAgedOutAuditLogs - entered");
        DateTime latestTimeToKeep = DateTime.getNow().AddDays(Config.<Integer>GetValue(ConfigValues.AuditLogAgingThreashold) * -1);
        DbFacade.getInstance().getAuditLogDao().removeAllBeforeDate(latestTimeToKeep);
    } catch (RuntimeException e) {
        log.error("AuditLogCleanupManager::deleteAgedOutAuditLogs() - failed with exception", e);
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        log.info("Start deleteAgedOutAuditLogs");
        DateTime latestTimeToKeep = DateTime.getNow().AddDays(Config.<Integer>GetValue(ConfigValues.AuditLogAgingThreashold) * -1);
        DbFacade.getInstance().getAuditLogDao().removeAllBeforeDate(latestTimeToKeep);
        log.info("Finished deleteAgedOutAuditLogs");
    } catch (RuntimeException e) {
        log.error("deleteAgedOutAuditLog failed with exception", e);
    }
}
#end_block

#method_before
public static void InitDictionaries() {
    log.info("Start initializing " + CpuFlagsManagerHandler.class.getSimpleName());
    _managersDictionary.clear();
    for (Version ver : Config.<HashSet<Version>>GetValue(ConfigValues.SupportedClusterLevels)) {
        _managersDictionary.put(ver, new CpuFlagsManager(ver));
    }
    log.info("Finished initializing " + CpuFlagsManagerHandler.class.getSimpleName());
}
#method_after
public static void InitDictionaries() {
    log.info("Start initializing dictionaries");
    _managersDictionary.clear();
    for (Version ver : Config.<HashSet<Version>>GetValue(ConfigValues.SupportedClusterLevels)) {
        _managersDictionary.put(ver, new CpuFlagsManager(ver));
    }
    log.info("Finished initializing dictionaries");
}
#end_block

#method_before
public void init() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!VM.isStatusDown(vm.getStatus())) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    vm.setStatus(status);
    boolean isVmStatusDown = VM.isStatusDown(status);
    if (isVmStatusDown || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmStatusDown) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    InternalSetVmStatus(vm, status, VmExitStatus.Normal, StringUtils.EMPTY);
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    vm.setStatus(status);
    boolean isVmStatusDown = VM.isStatusDown(status);
    if (isVmStatusDown || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmStatusDown) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#end_block

#method_before
@OnTimerMethodAnnotation("fetchIsoDomains")
public void fetchIsoDomains() {
    // Gets all the active Iso storage domains.
    List<RepoFileMetaData> repofileList = DbFacade.getInstance().getRepoFileMetaDataDao().getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    // Set count down latch to size of map for multiple threaded.
    final CountDownLatch latch = new CountDownLatch(repofileList.size());
    resetProblematicList();
    // Iterate for each storage domain.
    for (final RepoFileMetaData repoFileMetaData : repofileList) {
        // from the DB.
        if (shouldRefreshIsoDomain(repoFileMetaData.getLastRefreshed())) {
            ThreadPoolUtil.execute(new Runnable() {

                @Override
                public void run() {
                    updateCachedIsoFileListFromVdsm(repoFileMetaData, latch);
                }
            });
        } else {
            latch.countDown();
            log.debugFormat("Automatic refresh process for {0} file type in storage domain id {1} was not performed since refresh time out did not passed yet.", repoFileMetaData.getFileType(), repoFileMetaData.getRepoDomainId());
        }
    }
    try {
        latch.await();
    } catch (InterruptedException e) {
        log.error("Automatic refresh process encounter a problem.", e);
    }
    // After refresh for all Iso domains finished, handle the log.
    handleErrorLog(problematicRepoFileList);
}
#method_after
@OnTimerMethodAnnotation("fetchIsoDomains")
public void fetchIsoDomains() {
    // Gets all the active Iso storage domains.
    List<RepoFileMetaData> repofileList = DbFacade.getInstance().getRepoFileMetaDataDao().getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    resetProblematicList();
    // Iterate for each storage domain.
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final RepoFileMetaData repoFileMetaData : repofileList) {
        // from the DB.
        if (shouldRefreshIsoDomain(repoFileMetaData.getLastRefreshed())) {
            tasks.add(new Callable<Void>() {

                @Override
                public Void call() {
                    updateCachedIsoFileListFromVdsm(repoFileMetaData);
                    return null;
                }
            });
        } else {
            log.debugFormat("Automatic refresh process for {0} file type in storage domain id {1} was not performed since refresh time out did not passed yet.", repoFileMetaData.getFileType(), repoFileMetaData.getRepoDomainId());
        }
    }
    ThreadPoolUtil.invokeAll(tasks);
    // After refresh for all Iso domains finished, handle the log.
    handleErrorLog(problematicRepoFileList);
}
#end_block

#method_before
private void updateCachedIsoFileListFromVdsm(RepoFileMetaData repoFileMetaData, final CountDownLatch latch) {
    boolean isRefreshed = false;
    try {
        List<RepoFileMetaData> problematicRepoFileList = new ArrayList<RepoFileMetaData>();
        isRefreshed = refreshIsoDomain(repoFileMetaData.getRepoDomainId(), problematicRepoFileList, repoFileMetaData.getFileType());
        addRepoFileToProblematicList(problematicRepoFileList);
    } finally {
        // At any case count down the latch, and print log message.
        latch.countDown();
        log.infoFormat("Finished automatic refresh process for {0} file type with {1}, for storage domain id {2}.", repoFileMetaData.getFileType(), isRefreshed ? "success" : "failure", repoFileMetaData.getRepoDomainId());
    }
}
#method_after
private void updateCachedIsoFileListFromVdsm(RepoFileMetaData repoFileMetaData) {
    boolean isRefreshed = false;
    try {
        List<RepoFileMetaData> problematicRepoFileList = new ArrayList<RepoFileMetaData>();
        isRefreshed = refreshIsoDomain(repoFileMetaData.getRepoDomainId(), problematicRepoFileList, repoFileMetaData.getFileType());
        addRepoFileToProblematicList(problematicRepoFileList);
    } finally {
        log.infoFormat("Finished automatic refresh process for {0} file type with {1}, for storage domain id {2}.", repoFileMetaData.getFileType(), isRefreshed ? "success" : "failure", repoFileMetaData.getRepoDomainId());
    }
}
#end_block

#method_before
void initialize() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    SchedulerUtilQuartzImpl.getInstance().scheduleACronJob(this, "onTimer", new Class<?>[] {}, new Object[] {}, Config.<String>GetValue(ConfigValues.AutoRecoverySchedule));
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    SchedulerUtilQuartzImpl.getInstance().scheduleACronJob(this, "onTimer", new Class<?>[] {}, new Object[] {}, Config.<String>GetValue(ConfigValues.AutoRecoverySchedule));
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.info("Checking autorecoverable " + logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + ": " + fail.getId());
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.info("Checking autorecoverable " + logMsg + " done");
}
#method_after
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.debugFormat("Checking autorecoverable {0}", logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + " id: " + fail.getId() + getHostName(fail));
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.debugFormat("Checking autorecoverable {0} done", logMsg);
}
#end_block

#method_before
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.info("Start initializing " + this.getClass().getSimpleName());
        String ranges = Config.<String>GetValue(ConfigValues.MacPoolRanges);
        if (!"".equals(ranges)) {
            try {
                initRanges(ranges);
            } catch (MacPoolExceededMaxException e) {
                log.error("MAC Pool range exceeded maximum number of mac pool addressed. Please check Mac Pool configuration.");
            }
        }
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAll();
        for (VmNetworkInterface iface : interfaces) {
            addMac(iface.getMacAddress());
        }
        initialized = true;
        log.info("Finished initializing " + this.getClass().getSimpleName());
    } catch (Exception ex) {
        log.error(INIT_ERROR_MSG, ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.info("Start initializing " + getClass().getSimpleName());
        String ranges = Config.<String>GetValue(ConfigValues.MacPoolRanges);
        if (!"".equals(ranges)) {
            try {
                initRanges(ranges);
            } catch (MacPoolExceededMaxException e) {
                log.error("MAC Pool range exceeded maximum number of mac pool addressed. Please check Mac Pool configuration.");
            }
        }
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAll();
        for (VmNetworkInterface iface : interfaces) {
            forceAddMac(iface.getMacAddress());
        }
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    } catch (Exception ex) {
        log.error(INIT_ERROR_MSG, ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
public String allocateNewMac() {
    String mac = null;
    log.info("MacPoolManager::allocateNewMac entered");
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to allocate new Mac address.");
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NOT_INITIALIZED);
        }
        if (availableMacs.isEmpty()) {
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NO_MACS_LEFT);
        }
        Iterator<String> my = availableMacs.iterator();
        mac = my.next();
        commitNewMac(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
    log.infoFormat("MacPoolManager::allocateNewMac allocated mac = '{0}", mac);
    return mac;
}
#method_after
public String allocateNewMac() {
    String mac = null;
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to allocate new Mac address.");
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NOT_INITIALIZED);
        }
        if (availableMacs.isEmpty()) {
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NO_MACS_LEFT);
        }
        Iterator<String> my = availableMacs.iterator();
        mac = my.next();
        commitNewMac(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
    return mac;
}
#end_block

#method_before
private boolean commitNewMac(String mac) {
    availableMacs.remove(mac);
    allocatedMacs.add(mac);
    if (availableMacs.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        AuditLogDirector.log(logable, AuditLogType.MAC_POOL_EMPTY);
        return false;
    }
    return true;
}
#method_after
private boolean commitNewMac(String mac) {
    availableMacs.remove(mac);
    allocatedMacs.put(mac, 1);
    if (availableMacs.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        AuditLogDirector.log(logable, AuditLogType.MAC_POOL_EMPTY);
        return false;
    }
    return true;
}
#end_block

#method_before
public void freeMac(String mac) {
    log.infoFormat("MacPoolManager::freeMac(mac = '{0}') - entered", mac);
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free mac address " + mac + " .");
        } else {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void freeMac(String mac) {
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free mac address " + mac + " .");
        } else {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
private void internalFreeMac(String mac) {
    if (allocatedCustomMacs.contains(mac)) {
        allocatedCustomMacs.remove(mac);
    } else if (allocatedMacs.contains(mac)) {
        allocatedMacs.remove(mac);
        availableMacs.add(mac);
    }
}
#method_after
private void internalFreeMac(String mac) {
    if (allocatedMacs.containsKey(mac)) {
        removeMacFromMap(allocatedMacs, mac);
        if (!allocatedMacs.containsKey(mac)) {
            availableMacs.add(mac);
        }
    } else if (allocatedCustomMacs.containsKey(mac)) {
        removeMacFromMap(allocatedCustomMacs, mac);
    }
}
#end_block

#method_before
public boolean addMac(String mac) {
    boolean retVal = true;
    lockObj.writeLock().lock();
    try {
        if (allocatedMacs.contains(mac)) {
            retVal = false;
        } else {
            if (availableMacs.contains(mac)) {
                retVal = commitNewMac(mac);
            } else if (allocatedCustomMacs.contains(mac)) {
                retVal = false;
            } else {
                allocatedCustomMacs.add(mac);
            }
        }
    } finally {
        lockObj.writeLock().unlock();
    }
    return retVal;
}
#method_after
public boolean addMac(String mac) {
    boolean retVal = false;
    lockObj.writeLock().lock();
    try {
        if (availableMacs.contains(mac)) {
            retVal = commitNewMac(mac);
        } else if (allocatedMacs.containsKey(mac)) {
            retVal = addMacToMap(allocatedMacs, mac);
        } else {
            retVal = addMacToMap(allocatedCustomMacs, mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
    return retVal;
}
#end_block

#method_before
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return allocatedMacs.contains(mac) || allocatedCustomMacs.contains(mac);
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return allocatedMacs.containsKey(mac) || allocatedCustomMacs.containsKey(mac);
    } finally {
        lockObj.readLock().unlock();
    }
}
#end_block

#method_before
public void freeMacs(List<String> macs) {
    log.info("MacPoolManager::freeMacs - entered");
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free MAC addresses.");
        }
        for (String mac : macs) {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void freeMacs(List<String> macs) {
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free MAC addresses.");
        }
        for (String mac : macs) {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public void Initialize() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.info("Initialized VDSBrokerFrontend");
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    InitHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incompleted jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    InitHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), Config.DefaultConfigurationVersion)).getoption_value();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#method_after
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), Config.DefaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
/**
 * In memory tree initialized during initialization
 */
protected void init() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    tagsMapByID.clear();
    tagsMapByName.clear();
    tags root = new tags("root", null, true, ROOT_TAG_ID, "root");
    AddTagToHash(root);
    AddChildren(root);
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
/**
 * In memory tree initialized during initialization
 */
protected void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    tagsMapByID.clear();
    tagsMapByName.clear();
    tags root = new tags("root", null, true, ROOT_TAG_ID, "root");
    AddTagToHash(root);
    AddChildren(root);
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void initialize() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    succeededJobTime = Config.<Integer>GetValue(ConfigValues.SucceededJobCleanupTimeInMinutes).intValue();
    failedJobTime = Config.<Integer>GetValue(ConfigValues.FailedJobCleanupTimeInMinutes).intValue();
    Integer cleanupFrequency = Config.<Integer>GetValue(ConfigValues.JobCleanupRateInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "completed_jobs_cleanup", new Class[] {}, new Object[] {}, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    succeededJobTime = Config.<Integer>GetValue(ConfigValues.SucceededJobCleanupTimeInMinutes).intValue();
    failedJobTime = Config.<Integer>GetValue(ConfigValues.FailedJobCleanupTimeInMinutes).intValue();
    Integer cleanupFrequency = Config.<Integer>GetValue(ConfigValues.JobCleanupRateInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "completed_jobs_cleanup", new Class[] {}, new Object[] {}, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void initialize(String bundleBaseName) {
    log.info("Start initializing " + this.getClass().getSimpleName());
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
        }
    }
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
public void initialize(String bundleBaseName) {
    log.info("Start initializing " + getClass().getSimpleName());
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
        }
    }
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String volumeName = getParameters().getVolumeName();
    /*
         * To get the service info, the UI will not pass the volume name, in that case
         * engine will fetch the volume name in the database.
         *
         * NFS volume name should be passed to get nfs service details, similarly
         * REPLICATE/DISTRIBUTED_REPLICATE volume name should be passed as an
         * argument to get the SHD details.
         *
         * So to get volume name from database engine will do the following steps.
         * 1. First fetch NFS + REPLICATE/DISTRIBUTED_REPLICATE volume name
         * 2. If not found then fetch the nfs volume name and then fetch
         *    REPLICATE/DISTRIBUTED_REPLICATE volume name
         * 3. The VDS query will be called twice, one with nfs volume name
         *    and another with replicate volume name, finally combine the service details.
         */
    if (!getParameters().isDetailRequired() && StringUtils.isEmpty(volumeName)) {
        VDSReturnValue nfsReturnValue = null;
        String nfsVolumeName = "";
        String replicateVolumeName = "";
        // Get Nfs + Replicated/Distributed Replicate volume name.
        volumeName = getNfsReplicateVolumeName(getParameters().getClusterId());
        if (StringUtils.isEmpty(volumeName)) {
            // Get Nfs enabled volume name
            nfsVolumeName = getNfsVolumeName(getParameters().getClusterId());
            // Get Replicated volume name
            replicateVolumeName = getReplicateVolumeName(getParameters().getClusterId());
            // If there is no volume present in the cluster, then return empty Volume Advanced Details
            if (StringUtils.isEmpty(nfsVolumeName) && StringUtils.isEmpty(replicateVolumeName)) {
                log.error("To get service details, no Nfs or Replicated volumes found in the cluster.");
                getQueryReturnValue().setReturnValue(new GlusterVolumeAdvancedDetails());
                return;
            }
            if (StringUtils.isNotEmpty(nfsVolumeName)) {
                nfsReturnValue = executeCommand(nfsVolumeName);
            }
            if (nfsReturnValue != null && StringUtils.isNotEmpty(replicateVolumeName)) {
                // Get shd status value
                VDSReturnValue shdStatusReturnValue = executeCommand(replicateVolumeName);
                GlusterVolumeAdvancedDetails volumeAdvancedDetailsForNfs = (GlusterVolumeAdvancedDetails) nfsReturnValue.getReturnValue();
                GlusterVolumeAdvancedDetails volumeAdvancedDetailsForShd = (GlusterVolumeAdvancedDetails) shdStatusReturnValue.getReturnValue();
                // combine the Nfs + Shd status
                volumeAdvancedDetailsForNfs.getServiceInfo().addAll(volumeAdvancedDetailsForShd.getServiceInfo());
                getQueryReturnValue().setReturnValue(volumeAdvancedDetailsForNfs);
            } else if (nfsReturnValue == null && StringUtils.isNotEmpty(replicateVolumeName)) {
                VDSReturnValue shdReturnValue = executeCommand(replicateVolumeName);
                getQueryReturnValue().setReturnValue(shdReturnValue.getReturnValue());
            } else if (nfsReturnValue != null && StringUtils.isEmpty(replicateVolumeName)) {
                getQueryReturnValue().setReturnValue(nfsReturnValue.getReturnValue());
            }
        }
    } else {
        VDSReturnValue returnValue = executeCommand(volumeName);
        getQueryReturnValue().setReturnValue(returnValue.getReturnValue());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    String volumeName = getParameters().getVolumeName();
    if (StringUtils.isNotEmpty(volumeName)) {
        getQueryReturnValue().setReturnValue(fetchAdvancedDetails(volumeName));
    } else {
        getQueryReturnValue().setReturnValue(getServiceInfo());
    }
}
#end_block

#method_before
private List<GlusterVolumeEntity> getReplicateAndNfsVolumes(Guid clusterId, GlusterVolumeType volumeType) {
    return getGlusterVolumeDao().getVolumesByOptionAndVolumeType(clusterId, GlusterStatus.UP, OPTION_KEY, OPTION_VALUE, volumeType);
}
#method_after
private List<GlusterVolumeEntity> getReplicateAndNfsVolumes(Guid clusterId, List<GlusterVolumeType> volumeTypes) {
    return getGlusterVolumeDao().getVolumesByStatusTypesAndOption(clusterId, GlusterStatus.UP, volumeTypes, OPTION_KEY_NFS_DISABLE, OPTION_VALUE_OFF);
}
#end_block

#method_before
private List<GlusterVolumeEntity> getNfsVolumes(Guid clusterId) {
    return getGlusterVolumeDao().getVolumesByOption(clusterId, GlusterStatus.UP, OPTION_KEY, OPTION_VALUE);
}
#method_after
private List<GlusterVolumeEntity> getNfsVolumes(Guid clusterId) {
    return getGlusterVolumeDao().getVolumesByOption(clusterId, GlusterStatus.UP, OPTION_KEY_NFS_DISABLE, OPTION_VALUE_OFF);
}
#end_block

#method_before
private List<GlusterVolumeEntity> getReplicateVolumes(Guid clusterId, GlusterVolumeType volumeType) {
    return getGlusterVolumeDao().getVolumesByVolumeType(clusterId, GlusterStatus.UP, volumeType);
}
#method_after
private List<GlusterVolumeEntity> getReplicateVolumes(Guid clusterId, List<GlusterVolumeType> volumeTypes) {
    return getGlusterVolumeDao().getVolumesByStatusAndTypes(clusterId, GlusterStatus.UP, volumeTypes);
}
#end_block

#method_before
@Test
public void testGetVolumesByOption() {
    List<GlusterVolumeEntity> volumes = dao.getVolumesByOption(CLUSTER_ID, GlusterStatus.UP, NFS_OPTION_KEY, NFS_OPTION_VALUE);
    assertTrue(volumes != null);
    assertTrue(volumes.contains(existingReplVol));
    assertTrue(volumes.get(0).isNfsEnabled());
}
#method_after
@Test
public void testGetVolumesByOption() {
    List<GlusterVolumeEntity> volumes = dao.getVolumesByOption(CLUSTER_ID, GlusterStatus.UP, OPTION_KEY_NFS_DISABLE, OPTION_VALUE_OFF);
    assertTrue(volumes != null);
    assertTrue(volumes.contains(existingReplVol));
    assertTrue(volumes.get(0).isNfsEnabled());
}
#end_block

#method_before
@Override
public void edit(final RunOnceModel object) {
    Driver.driver.edit(object);
    object.getCustomPropertySheet().getKeyValueLines().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
        }
    });
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean toShow = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(toShow);
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabValid());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
}
#method_after
@Override
public void edit(final RunOnceModel object) {
    Driver.driver.edit(object);
    object.getCustomPropertySheet().getKeyValueLines().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
        }
    });
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean toShow = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(toShow);
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
}
#end_block

#method_before
public boolean Validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    // getCustomProperties().ValidateEntity(new IValidation[] { new CustomPropertyValidation(this.getCustomPropertiesKeysList()) });
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinux_Unassign_UnknownOS() && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation;
}
#method_after
public boolean Validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    // getCustomProperties().ValidateEntity(new IValidation[] { new CustomPropertyValidation(this.getCustomPropertiesKeysList()) });
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinux_Unassign_UnknownOS() && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    if (getIsAutoAssign().getEntity() != null && (Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation;
}
#end_block

#method_before
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // disable Host tab
    model.setIsHostTabValid(false);
    model.getIsAutoAssign().setEntity(true);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new GetVmByVmIdParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#method_after
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // disable Host tab
    model.setIsHostTabVisible(false);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
private void RunOnceUpdateBootSequence(VM vm) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            VmListModel vmListModel = (VmListModel) model;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel.getWindow();
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = runOnceModel.getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new GetVmByVmIdParameters(vm.getId()), _asyncQuery);
}
#method_after
private void RunOnceUpdateBootSequence(VM vm) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            VmListModel vmListModel = (VmListModel) model;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel.getWindow();
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = runOnceModel.getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), _asyncQuery);
}
#end_block

#method_before
private void RunOnceLoadHosts(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    // append just active hosts
    AsyncDataProvider.GetHostListByCluster(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final RunOnceModel model = (RunOnceModel) target;
            final List<VDS> hosts = (ArrayList<VDS>) returnValue;
            final List<VDS> activeHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (VDSStatus.Up.equals(host.getstatus())) {
                    activeHosts.add(host);
                }
            }
            model.getDefaultHost().setItems(activeHosts);
        }
    }), vm.getVdsGroupName());
    // disable host tab when no active host is available
    model.setIsHostTabValid(!model.getDefaultHost().getIsEmpty());
}
#method_after
private void RunOnceLoadHosts(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    // append just active hosts
    AsyncDataProvider.GetHostListByCluster(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final RunOnceModel model = (RunOnceModel) target;
            final List<VDS> hosts = (ArrayList<VDS>) returnValue;
            final List<VDS> activeHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (VDSStatus.Up.equals(host.getstatus())) {
                    activeHosts.add(host);
                }
            }
            model.getDefaultHost().setItems(activeHosts);
            // hide host tab when no active host is available
            if (activeHosts.isEmpty()) {
                model.setIsHostTabVisible(false);
            }
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#method_after
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    } else if (ev.equals(ConsoleModel.ErrorEventDefinition) && sender instanceof SpiceConsoleModel) {
        SpiceConsoleModel_Error(sender, (ErrorCodeEventArgs) args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public NGuid getStoragePoolId() {
    return storagePool;
}
#method_after
@Override
public NGuid getStoragePoolId() {
    return storagePoolId;
}
#end_block

#method_before
@Override
public void setStoragePoolId(NGuid storagePool) {
    this.storagePool = storagePool;
}
#method_after
@Override
public void setStoragePoolId(NGuid storagePool) {
    this.storagePoolId = storagePool;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((compatVersion == null) ? 0 : compatVersion.hashCode());
    result = prime * result + ((compatibility_version == null) ? 0 : compatibility_version.hashCode());
    result = prime * result + ((cpu_name == null) ? 0 : cpu_name.hashCode());
    result = prime * result + cpu_over_commit_duration_minutes;
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + high_utilization;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + low_utilization;
    result = prime * result + max_vds_memory_over_commit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + ((migrateOnError == null) ? 0 : migrateOnError.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((selection_algorithm == null) ? 0 : selection_algorithm.hashCode());
    result = prime * result + ((storagePool == null) ? 0 : storagePool.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((compatVersion == null) ? 0 : compatVersion.hashCode());
    result = prime * result + ((compatibility_version == null) ? 0 : compatibility_version.hashCode());
    result = prime * result + ((cpu_name == null) ? 0 : cpu_name.hashCode());
    result = prime * result + cpu_over_commit_duration_minutes;
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + high_utilization;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + low_utilization;
    result = prime * result + max_vds_memory_over_commit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + ((migrateOnError == null) ? 0 : migrateOnError.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((selection_algorithm == null) ? 0 : selection_algorithm.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VDSGroup other = (VDSGroup) obj;
    if (compatVersion == null) {
        if (other.compatVersion != null)
            return false;
    } else if (!compatVersion.equals(other.compatVersion))
        return false;
    if (compatibility_version == null) {
        if (other.compatibility_version != null)
            return false;
    } else if (!compatibility_version.equals(other.compatibility_version))
        return false;
    if (cpu_name == null) {
        if (other.cpu_name != null)
            return false;
    } else if (!cpu_name.equals(other.cpu_name))
        return false;
    if (cpu_over_commit_duration_minutes != other.cpu_over_commit_duration_minutes)
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        if (high_utilization != other.high_utilization)
            return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (low_utilization != other.low_utilization)
        return false;
    if (max_vds_memory_over_commit != other.max_vds_memory_over_commit)
        return false;
    if (countThreadsAsCores != other.countThreadsAsCores)
        return false;
    if (migrateOnError != other.migrateOnError)
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (selection_algorithm == null) {
        if (other.selection_algorithm != null)
            return false;
    } else if (!selection_algorithm.equals(other.selection_algorithm))
        return false;
    if (storagePool == null) {
        if (other.storagePool != null)
            return false;
    } else if (!storagePool.equals(other.storagePool))
        return false;
    if (storagePoolName == null) {
        if (other.storagePoolName != null)
            return false;
    } else if (!storagePoolName.equals(other.storagePoolName))
        return false;
    if (transparentHugepages != other.transparentHugepages)
        return false;
    if (virtService != other.virtService) {
        return false;
    }
    if (glusterService != other.glusterService) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VDSGroup other = (VDSGroup) obj;
    if (compatVersion == null) {
        if (other.compatVersion != null)
            return false;
    } else if (!compatVersion.equals(other.compatVersion))
        return false;
    if (compatibility_version == null) {
        if (other.compatibility_version != null)
            return false;
    } else if (!compatibility_version.equals(other.compatibility_version))
        return false;
    if (cpu_name == null) {
        if (other.cpu_name != null)
            return false;
    } else if (!cpu_name.equals(other.cpu_name))
        return false;
    if (cpu_over_commit_duration_minutes != other.cpu_over_commit_duration_minutes)
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        if (high_utilization != other.high_utilization)
            return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (low_utilization != other.low_utilization)
        return false;
    if (max_vds_memory_over_commit != other.max_vds_memory_over_commit)
        return false;
    if (countThreadsAsCores != other.countThreadsAsCores)
        return false;
    if (migrateOnError != other.migrateOnError)
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (selection_algorithm == null) {
        if (other.selection_algorithm != null)
            return false;
    } else if (!selection_algorithm.equals(other.selection_algorithm))
        return false;
    if (storagePoolId == null) {
        if (other.storagePoolId != null)
            return false;
    } else if (!storagePoolId.equals(other.storagePoolId))
        return false;
    if (storagePoolName == null) {
        if (other.storagePoolName != null)
            return false;
    } else if (!storagePoolName.equals(other.storagePoolName))
        return false;
    if (transparentHugepages != other.transparentHugepages)
        return false;
    if (virtService != other.virtService) {
        return false;
    }
    if (glusterService != other.glusterService) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds().getstatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        setSucceeded(MigrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getstatus() == VDSStatus.NonResponsive || getVds().getstatus() == VDSStatus.Connecting || getVds().getstatus() == VDSStatus.Down) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isMigrationOnProgress()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds().getstatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        setSucceeded(MigrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getstatus() == VDSStatus.NonResponsive || getVds().getstatus() == VDSStatus.Connecting || getVds().getstatus() == VDSStatus.Down) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        MigrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        MigrateAllVms(getExecutionContext(), true);
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getvds_name(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isMigrationOnProgress()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        MigrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        MigrateAllVms(getExecutionContext(), true);
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getvds_name(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        if (Config.<Boolean>GetValue(ConfigValues.HardwareInfoEnabled, vds.getvds_group_compatibility_version().getValue()) && Config.<Boolean>GetValue(ConfigValues.HardwareInfoEnabled, vds.getsupported_cluster_levels())) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getvds_group_compatibility_version();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    this.vmManagedDeviceMap = map;
}
#method_after
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    this.managedDeviceMap = map;
}
#end_block

#method_before
public List<VmDevice> getUnmanagedDeviceList() {
    return vmUnManagedDeviceList;
}
#method_after
public List<VmDevice> getUnmanagedDeviceList() {
    return unmanagedDeviceList;
}
#end_block

#method_before
public void setUnmanagedDeviceList(List<VmDevice> list) {
    this.vmUnManagedDeviceList = list;
}
#method_after
public void setUnmanagedDeviceList(List<VmDevice> list) {
    this.unmanagedDeviceList = list;
}
#end_block

#method_before
@Deprecated
public VmOsType getOsType() {
    return getos();
}
#method_after
@Deprecated
public VmOsType getOsType() {
    return getOs();
}
#end_block

#method_before
@Deprecated
public void setOsType(VmOsType value) {
    setos(value);
}
#method_after
@Deprecated
public void setOsType(VmOsType value) {
    setOs(value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + (autosuspend ? 1231 : 1237);
    result = prime * result + cpusPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (fail_back ? 1231 : 1237);
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + ((mOs == null) ? 0 : mOs.hashCode());
    result = prime * result + memSizeMB;
    result = prime * result + niceLevel;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timezone == null) ? 0 : timezone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vds_group_id == null) ? 0 : vds_group_id.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((dedicated_vm_for_vds == null) ? 0 : dedicated_vm_for_vds.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + (autosuspend ? 1231 : 1237);
    result = prime * result + cpusPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + ((mOs == null) ? 0 : mOs.hashCode());
    result = prime * result + memSizeMB;
    result = prime * result + niceLevel;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timezone == null) ? 0 : timezone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (failBack != other.failBack) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (deleteProtected != other.deleteProtected) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vdsGroupId == null) {
        if (other.vdsGroupId != null) {
            return false;
        }
    } else if (!vdsGroupId.equals(other.vdsGroupId)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicatedVmForVds == null) {
        if (other.dedicatedVmForVds != null) {
            return false;
        }
    } else {
        if (!dedicatedVmForVds.equals(other.dedicatedVmForVds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void setDataCenter(ListModel value) {
    privateDataCenter = value;
}
#method_after
private void setDataCenter(NotChangableForVmInPoolListModel value) {
    privateDataCenter = value;
}
#end_block

#method_before
private void setStorageDomain(ListModel value) {
    privateStorageDomain = value;
}
#method_after
private void setStorageDomain(NotChangableForVmInPoolListModel value) {
    privateStorageDomain = value;
}
#end_block

#method_before
private void setTemplate(ListModel value) {
    privateTemplate = value;
}
#method_after
private void setTemplate(NotChangableForVmInPoolListModel value) {
    privateTemplate = value;
}
#end_block

#method_before
private void setOSType(ListModel value) {
    privateOSType = value;
}
#method_after
private void setOSType(NotChangableForVmInPoolListModel value) {
    privateOSType = value;
}
#end_block

#method_before
private void setNumOfMonitors(ListModel value) {
    privateNumOfMonitors = value;
}
#method_after
private void setNumOfMonitors(NotChangableForVmInPoolListModel value) {
    privateNumOfMonitors = value;
}
#end_block

#method_before
private void setAllowConsoleReconnect(EntityModel value) {
    privateAllowConsoleReconnect = value;
}
#method_after
private void setAllowConsoleReconnect(NotChangableForVmInPoolEntityModel value) {
    privateAllowConsoleReconnect = value;
}
#end_block

#method_before
private void setDescription(EntityModel value) {
    privateDescription = value;
}
#method_after
private void setDescription(NotChangableForVmInPoolEntityModel value) {
    privateDescription = value;
}
#end_block

#method_before
private void setDomain(ListModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(NotChangableForVmInPoolListModel value) {
    privateDomain = value;
}
#end_block

#method_before
private void setMemSize(EntityModel value) {
    privateMemSize = value;
}
#method_after
private void setMemSize(NotChangableForVmInPoolEntityModel value) {
    privateMemSize = value;
}
#end_block

#method_before
private void setMinAllocatedMemory(EntityModel value) {
    privateMinAllocatedMemory = value;
}
#method_after
private void setMinAllocatedMemory(NotChangableForVmInPoolEntityModel value) {
    privateMinAllocatedMemory = value;
}
#end_block

#method_before
private void setQuota(ListModel value) {
    privateQuota = value;
}
#method_after
private void setQuota(NotChangableForVmInPoolListModel value) {
    privateQuota = value;
}
#end_block

#method_before
private void setCluster(ListModel value) {
    privateCluster = value;
}
#method_after
private void setCluster(NotChangableForVmInPoolListModel value) {
    privateCluster = value;
}
#end_block

#method_before
private void setUsbPolicy(ListModel value) {
    privateUsbPolicy = value;
}
#method_after
private void setUsbPolicy(NotChangableForVmInPoolListModel value) {
    privateUsbPolicy = value;
}
#end_block

#method_before
private void setTimeZone(ListModel value) {
    privateTimeZone = value;
}
#method_after
private void setTimeZone(NotChangableForVmInPoolListModel value) {
    privateTimeZone = value;
}
#end_block

#method_before
private void setNumOfSockets(ListModel value) {
    privateNumOfSockets = value;
}
#method_after
private void setNumOfSockets(NotChangableForVmInPoolListModel value) {
    privateNumOfSockets = value;
}
#end_block

#method_before
private void setTotalCPUCores(EntityModel value) {
    privateTotalCPUCores = value;
}
#method_after
private void setTotalCPUCores(NotChangableForVmInPoolEntityModel value) {
    privateTotalCPUCores = value;
}
#end_block

#method_before
private void setCoresPerSocket(ListModel value) {
    privateCoresPerSocket = value;
}
#method_after
private void setCoresPerSocket(NotChangableForVmInPoolListModel value) {
    privateCoresPerSocket = value;
}
#end_block

#method_before
private void setDefaultHost(ListModel value) {
    privateDefaultHost = value;
}
#method_after
private void setDefaultHost(NotChangableForVmInPoolListModel value) {
    privateDefaultHost = value;
}
#end_block

#method_before
private void setIsSmartcardEnabled(EntityModel value) {
    privateisSmartcardEnabled = value;
}
#method_after
private void setIsSmartcardEnabled(NotChangableForVmInPoolEntityModel value) {
    privateisSmartcardEnabled = value;
}
#end_block

#method_before
private void setIsStateless(EntityModel value) {
    privateIsStateless = value;
}
#method_after
private void setIsStateless(NotChangableForVmInPoolEntityModel value) {
    privateIsStateless = value;
}
#end_block

#method_before
private void setDisplayProtocol(ListModel value) {
    privateDisplayProtocol = value;
}
#method_after
private void setDisplayProtocol(NotChangableForVmInPoolListModel value) {
    privateDisplayProtocol = value;
}
#end_block

#method_before
private void setProvisioning(EntityModel value) {
    privateProvisioning = value;
}
#method_after
private void setProvisioning(NotChangableForVmInPoolEntityModel value) {
    privateProvisioning = value;
}
#end_block

#method_before
public void setProvisioningThin_IsSelected(EntityModel value) {
    privateProvisioningThin_IsSelected = value;
}
#method_after
public void setProvisioningThin_IsSelected(NotChangableForVmInPoolEntityModel value) {
    privateProvisioningThin_IsSelected = value;
}
#end_block

#method_before
public void setProvisioningClone_IsSelected(EntityModel value) {
    privateProvisioningClone_IsSelected = value;
}
#method_after
public void setProvisioningClone_IsSelected(NotChangableForVmInPoolEntityModel value) {
    privateProvisioningClone_IsSelected = value;
}
#end_block

#method_before
private void setPriority(ListModel value) {
    privatePriority = value;
}
#method_after
private void setPriority(NotChangableForVmInPoolListModel value) {
    privatePriority = value;
}
#end_block

#method_before
private void setIsHighlyAvailable(EntityModel value) {
    privateIsHighlyAvailable = value;
}
#method_after
private void setIsHighlyAvailable(NotChangableForVmInPoolEntityModel value) {
    privateIsHighlyAvailable = value;
}
#end_block

#method_before
private void setFirstBootDevice(ListModel value) {
    privateFirstBootDevice = value;
}
#method_after
private void setFirstBootDevice(NotChangableForVmInPoolListModel value) {
    privateFirstBootDevice = value;
}
#end_block

#method_before
private void setSecondBootDevice(ListModel value) {
    privateSecondBootDevice = value;
}
#method_after
private void setSecondBootDevice(NotChangableForVmInPoolListModel value) {
    privateSecondBootDevice = value;
}
#end_block

#method_before
private void setCdImage(ListModel value) {
    privateCdImage = value;
}
#method_after
private void setCdImage(NotChangableForVmInPoolListModel value) {
    privateCdImage = value;
}
#end_block

#method_before
public void setCdAttached(EntityModel value) {
    cdAttached = value;
}
#method_after
public void setCdAttached(NotChangableForVmInPoolEntityModel value) {
    cdAttached = value;
}
#end_block

#method_before
private void setInitrd_path(EntityModel value) {
    privateInitrd_path = value;
}
#method_after
private void setInitrd_path(NotChangableForVmInPoolEntityModel value) {
    privateInitrd_path = value;
}
#end_block

#method_before
private void setKernel_path(EntityModel value) {
    privateKernel_path = value;
}
#method_after
private void setKernel_path(NotChangableForVmInPoolEntityModel value) {
    privateKernel_path = value;
}
#end_block

#method_before
private void setKernel_parameters(EntityModel value) {
    privateKernel_parameters = value;
}
#method_after
private void setKernel_parameters(NotChangableForVmInPoolEntityModel value) {
    privateKernel_parameters = value;
}
#end_block

#method_before
private void setCustomProperties(EntityModel value) {
    privateCustomProperties = value;
}
#method_after
private void setCustomProperties(NotChangableForVmInPoolEntityModel value) {
    privateCustomProperties = value;
}
#end_block

#method_before
public void setCustomPropertySheet(KeyValueModel customPropertySheet) {
    this.customPropertySheet = customPropertySheet;
}
#method_after
public void setCustomPropertySheet(NotChangableForVmInPoolKeyValueModel customPropertySheet) {
    this.customPropertySheet = customPropertySheet;
}
#end_block

#method_before
public void setIsAutoAssign(EntityModel value) {
    privateIsAutoAssign = value;
}
#method_after
public void setIsAutoAssign(NotChangableForVmInPoolEntityModel value) {
    privateIsAutoAssign = value;
}
#end_block

#method_before
public void setRunVMOnSpecificHost(EntityModel value) {
    privateRunVMOnSpecificHost = value;
}
#method_after
public void setRunVMOnSpecificHost(NotChangableForVmInPoolEntityModel value) {
    privateRunVMOnSpecificHost = value;
}
#end_block

#method_before
public void setDontMigrateVM(EntityModel value) {
    privateDontMigrateVM = value;
}
#method_after
public void setDontMigrateVM(NotChangableForVmInPoolEntityModel value) {
    privateDontMigrateVM = value;
}
#end_block

#method_before
private void setIsTemplatePublic(EntityModel value) {
    privateIsTemplatePublic = value;
}
#method_after
private void setIsTemplatePublic(NotChangableForVmInPoolEntityModel value) {
    privateIsTemplatePublic = value;
}
#end_block

#method_before
public void setCpuPinning(EntityModel cpuPinning) {
    this.cpuPinning = cpuPinning;
}
#method_after
public void setCpuPinning(NotChangableForVmInPoolEntityModel cpuPinning) {
    this.cpuPinning = cpuPinning;
}
#end_block

#method_before
public void Initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.Initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getDontMigrateVM().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getRunVMOnSpecificHost().setEntity(false);
    getRunVMOnSpecificHost().setIsChangable(false);
    getCdImage().setIsChangable(false);
    InitOSType();
    InitDisplayProtocol();
    InitFirstBootDevice();
    InitNumOfMonitors();
    InitAllowConsoleReconnect();
    InitMinimalVmMemSize();
    InitMaximalVmMemSize32OS();
    behavior.Initialize(SystemTreeSelectedItem);
}
#method_after
public void Initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.Initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getDontMigrateVM().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getRunVMOnSpecificHost().setEntity(false);
    getRunVMOnSpecificHost().setIsChangable(false);
    getHostCpu().setEntity(false);
    getRunVMOnSpecificHost().setIsChangable(false);
    getCdImage().setIsChangable(false);
    InitOSType();
    InitDisplayProtocol();
    InitFirstBootDevice();
    InitNumOfMonitors();
    InitAllowConsoleReconnect();
    InitMinimalVmMemSize();
    InitMaximalVmMemSize32OS();
    behavior.Initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getDontMigrateVM()) {
            DontMigrateVM_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#end_block

#method_before
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(DataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#method_after
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#end_block

#method_before
private void RunVMOnSpecificHost_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getRunVMOnSpecificHost().getEntity() == true) {
        getDontMigrateVM().setEntity(false);
        getDontMigrateVM().setIsChangable(false);
    } else {
        getDontMigrateVM().setIsChangable(true);
    }
}
#method_after
private void RunVMOnSpecificHost_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getRunVMOnSpecificHost().getEntity() == true) {
        clearAndDisable(getDontMigrateVM());
        getHostCpu().setIsChangable(true);
    } else {
        clearAndDisable(getHostCpu());
        getDontMigrateVM().setIsChangable(true);
    }
    behavior.updateCpuPinningVisibility();
}
#end_block

#method_before
private void IsAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == true) {
        getRunVMOnSpecificHost().setEntity(false);
        getRunVMOnSpecificHost().setIsChangable(false);
    } else {
        getRunVMOnSpecificHost().setIsChangable(true);
    }
}
#method_after
private void IsAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == true) {
        clearAndDisable(getRunVMOnSpecificHost());
        clearAndDisable(getHostCpu());
    } else {
        getRunVMOnSpecificHost().setIsChangable(true);
    }
    behavior.updateCpuPinningVisibility();
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(DataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#method_after
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#end_block

#method_before
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (DataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || DataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS) {
        String kernelPath = (String) getKernel_path().getEntity();
        String initrdPath = (String) getInitrd_path().getEntity();
        String kernelParams = (String) getKernel_parameters().getEntity();
        String cannotStartOrEndWithWhitespaceMsg = ConstantsManager.getInstance().getConstants().trimmingSpacesInField();
        if (hasTrimmingWhitespaces(kernelPath)) {
            getKernel_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(cannotStartOrEndWithWhitespaceMsg);
        }
        if (hasTrimmingWhitespaces(kernelParams)) {
            getKernel_parameters().setIsValid(false);
            getKernel_parameters().getInvalidityReasons().add(cannotStartOrEndWithWhitespaceMsg);
        }
        if (hasTrimmingWhitespaces(initrdPath)) {
            getInitrd_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(cannotStartOrEndWithWhitespaceMsg);
        }
        if ((kernelParams.length() > 0 || initrdPath.length() > 0) && kernelPath.length() == 0) {
            boolean kernelParamInvalid = false;
            boolean inetdPathInvalid = false;
            if (kernelParams.length() > 0) {
                getKernel_parameters().setIsValid(false);
                kernelParamInvalid = true;
            }
            if (initrdPath.length() > 0) {
                getInitrd_path().setIsValid(false);
                inetdPathInvalid = true;
            }
            String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
            "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
            "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
            "");
            getKernel_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(msg);
            getKernel_parameters().getInvalidityReasons().add(msg);
            getKernel_path().getInvalidityReasons().add(msg);
        }
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getKernel_parameters().getIsValid() && getInitrd_path().getIsValid() && behavior.Validate() && customPropertySheetValid;
}
#method_after
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT), new I18NNameValidation() });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255), new SpecialAsciiI18NOrNoneValidation() });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || AsyncDataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS) {
        getKernel_path().ValidateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().ValidateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().ValidateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        String kernelPath = (String) getKernel_path().getEntity();
        String initrdPath = (String) getInitrd_path().getEntity();
        String kernelParams = (String) getKernel_parameters().getEntity();
        if ((kernelParams.length() > 0 || initrdPath.length() > 0) && kernelPath.length() == 0) {
            boolean kernelParamInvalid = false;
            boolean inetdPathInvalid = false;
            if (kernelParams.length() > 0) {
                getKernel_parameters().setIsValid(false);
                kernelParamInvalid = true;
            }
            if (initrdPath.length() > 0) {
                getInitrd_path().setIsValid(false);
                inetdPathInvalid = true;
            }
            String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
            "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
            "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
            "");
            getKernel_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(msg);
            getKernel_parameters().getInvalidityReasons().add(msg);
            getKernel_path().getInvalidityReasons().add(msg);
        }
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getKernel_parameters().getIsValid() && getInitrd_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
protected void setPoolType(ListModel value) {
    poolType = value;
}
#method_after
protected void setPoolType(NotChangableForVmInPoolListModel value) {
    poolType = value;
}
#end_block

#method_before
protected void setNumOfDesktops(EntityModel value) {
    numOfDesktops = value;
}
#method_after
protected void setNumOfDesktops(NotChangableForVmInPoolEntityModel value) {
    numOfDesktops = value;
}
#end_block

#method_before
public void setAssignedVms(EntityModel value) {
    assignedVms = value;
}
#method_after
public void setAssignedVms(NotChangableForVmInPoolEntityModel value) {
    assignedVms = value;
}
#end_block

#method_before
protected void setPrestartedVms(EntityModel value) {
    prestartedVms = value;
}
#method_after
protected void setPrestartedVms(NotChangableForVmInPoolEntityModel value) {
    prestartedVms = value;
}
#end_block

#method_before
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#method_after
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setClusterPolicyModel(new ClusterPolicyModel());
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#end_block

#method_before
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#method_after
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            if (getGlusterHostAddress().getEntity() == null || ((String) getGlusterHostAddress().getEntity()).trim().length() == 0) {
                // $NON-NLS-1$
                getGlusterHostFingerprint().setEntity("");
                return;
            }
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#end_block

#method_before
public boolean Validate(boolean validateStoragePool, boolean validateCpu) {
    getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().ValidateSelectedItem(new IValidation[] {});
    }
    getVersion().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = ((Boolean) getEnableOvirtService().getEntity()) || ((Boolean) getEnableGlusterService().getEntity());
    }
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (((Boolean) getIsImportGlusterConfiguration().getEntity()) && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    getGlusterHostAddress().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? isFingerprintVerified() : true));
    return super.Validate() && getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? isFingerprintVerified() : true);
}
#method_after
public boolean Validate(boolean validateStoragePool, boolean validateCpu) {
    getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().ValidateSelectedItem(new IValidation[] {});
    }
    getVersion().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = ((Boolean) getEnableOvirtService().getEntity()) || ((Boolean) getEnableGlusterService().getEntity());
    }
    getGlusterHostAddress().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (((Boolean) getIsImportGlusterConfiguration().getEntity()) && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getClusterPolicyModel().Validate() && getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true);
}
#end_block

#method_before
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(true);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#method_after
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    object.getOverCommitTime().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setClusterPolicyModel(object);
            if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.PowerSave)) {
                policyRadioButton_powerSave.setValue(true);
            } else if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.EvenlyDistribute)) {
                policyRadioButton_evenDist.setValue(true);
            } else {
                policyRadioButton_none.setValue(true);
            }
            setSelectionAlgorithm();
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    if (object.getClusterPolicyModel().isEditClusterPolicyFirst()) {
        tabsPanel.switchTab(clusterPolicyTab);
    }
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    object.getClusterPolicyModel().getOverCommitTime().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setClusterPolicyModel(object.getClusterPolicyModel());
            if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.PowerSave)) {
                policyRadioButton_powerSave.setValue(true);
            } else if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.EvenlyDistribute)) {
                policyRadioButton_evenDist.setValue(true);
            } else {
                policyRadioButton_none.setValue(true);
            }
            setSelectionAlgorithm();
        }
    });
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    setClusterServiceModel(new ClusterServiceModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(getClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    setClusterServiceModel(new ClusterServiceModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    clusterGeneralModel = new ClusterGeneralModel();
    list.add(clusterGeneralModel);
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(getClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.Init(true);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getname());
    clusterModel.getName().setEntity(cluster.getname());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.setSelectionAlgorithm(cluster.getselection_algorithm());
    clusterModel.getOverCommitTime().setEntity(cluster.getcpu_over_commit_duration_minutes());
    clusterModel.setOverCommitLowLevel(cluster.getlow_utilization());
    clusterModel.setOverCommitHighLevel(cluster.gethigh_utilization());
    clusterModel.SaveDefaultValues();
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.Init(true);
    clusterModel.getClusterPolicyModel().setEditClusterPolicyFirst(clusterPolicyFirst);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getname());
    clusterModel.getName().setEntity(cluster.getname());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getClusterPolicyModel().setSelectionAlgorithm(cluster.getselection_algorithm());
    clusterModel.getClusterPolicyModel().getOverCommitTime().setEntity(cluster.getcpu_over_commit_duration_minutes());
    clusterModel.getClusterPolicyModel().setOverCommitLowLevel(cluster.getlow_utilization());
    clusterModel.getClusterPolicyModel().setOverCommitHighLevel(cluster.gethigh_utilization());
    clusterModel.getClusterPolicyModel().SaveDefaultValues();
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals((Boolean) model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getSelectionAlgorithm());
    if (model.getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getOverCommitHighLevel());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals((Boolean) model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getClusterPolicyModel().getSelectionAlgorithm());
    if (model.getClusterPolicyModel().getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getClusterPolicyModel().getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getClusterPolicyModel().getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getClusterPolicyModel().getOverCommitHighLevel());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        OnSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command, Object... parameters) {
    if (command == getEditCommand() && parameters.length > 0 && Boolean.TRUE.equals(parameters[0])) {
        this.clusterPolicyFirst = true;
        super.ExecuteCommand(command, parameters);
        this.clusterPolicyFirst = false;
    }
}
#end_block

#method_before
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = commonModel.getSearchString().trim();
    String inputSearchStringPrefix = commonModel.getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(":");
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchStringPrefixRaw.equals(disksSearchPrefix) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchStringPrefix.equals(disksSearchPrefix + space) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    commonModel.setSearchStringPrefix(searchStringPrefix);
    commonModel.setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(commonModel.getEffectiveSearchString());
    getMainModel().Search();
}
#method_after
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDisksSearchPrefix = "^\\s*(disk(s)?\\s*(:)+)+\\s*";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    // $NON-NLS-1$
    final String colon = ":";
    RegExp searchPatternDisksSearchPrefix = RegExp.compile(searchRegexDisksSearchPrefix, searchRegexFlags);
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = commonModel.getSearchString().trim();
    String inputSearchStringPrefix = commonModel.getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(colon);
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchPatternDisksSearchPrefix.test(searchStringPrefixRaw) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchPatternDisksSearchPrefix.test(searchStringPrefix) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    commonModel.setSearchStringPrefix(searchStringPrefix);
    commonModel.setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(commonModel.getEffectiveSearchString());
    getMainModel().Search();
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getstatus();
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getstatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("vds::Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#end_block

#method_before
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.debug("Checking autorecoverable " + logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + ": " + fail.getId());
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.debug("Checking autorecoverable " + logMsg + " done");
}
#method_after
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.debugFormat("Checking autorecoverable {0}", logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + " id: " + fail.getId() + getHostName(fail));
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.debugFormat("Checking autorecoverable {0} done", logMsg);
}
#end_block

#method_before
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        log.errorFormat("Reverting task handler: {0}", getCurrentTaskHandler().getClass().getName());
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#method_after
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#end_block

#method_before
@Override
public String getValue(String value) throws GeneralSecurityException {
    /*
         * The idea of this method would normally be to decrypt and return
         * the decrypted value. Due to security reasons, we do not wish to return
         * the real value. Just an indication if we have a value in the DB or not.
         * So if there's no value we return "Empty".
         * If there's a value we try to decrypt. On success we return "Set",
         * On failure we return an error.
         */
    String returnedValue = "Empty";
    if (value != null && !value.equals("")) {
        try {
            decrypt(value);
            returnedValue = "Set";
        } catch (Exception e) {
            String msg = "Failed to decrypt the current value";
            Logger.getLogger(EngineConfig.class).debug(msg, e);
            throw new GeneralSecurityException(msg);
        }
    }
    return returnedValue;
}
#method_after
@Override
public String getValue(String value) throws GeneralSecurityException {
    /*
         * The idea of this method would normally be to decrypt and return
         * the decrypted value. Due to security reasons, we do not wish to return
         * the real value. Just an indication if we have a value in the DB or not.
         * So if there's no value we return "Empty".
         * If there's a value we try to decrypt. On success we return "Set",
         * On failure we return an error.
         */
    String returnedValue = "Empty";
    if (value != null && !value.equals("")) {
        try {
            decrypt(value);
            returnedValue = "Set";
        } catch (Exception e) {
            String msg = "Failed to decrypt the current value";
            log.error(msg, e);
            throw new GeneralSecurityException(msg);
        }
    }
    return returnedValue;
}
#end_block

#method_before
@Override
public String setValue(String value) throws GeneralSecurityException {
    String returnedValue = null;
    String password = null;
    try {
        password = extractPasswordValue(value);
        if (StringUtils.isBlank(password)) {
            return StringUtils.EMPTY;
        }
        returnedValue = encrypt(password);
    } catch (Throwable e) {
        String msg = "Failed to encrypt the current value";
        Logger.getLogger(EngineConfig.class).debug(msg, e);
        throw new GeneralSecurityException(msg);
    }
    return returnedValue;
}
#method_after
@Override
public String setValue(String value) throws GeneralSecurityException {
    String returnedValue = null;
    String password = null;
    try {
        password = extractPasswordValue(value);
        if (StringUtils.isBlank(password)) {
            return StringUtils.EMPTY;
        }
        returnedValue = encrypt(password);
    } catch (Throwable e) {
        String msg = "Failed to encrypt the current value";
        log.error(msg, e);
        throw new GeneralSecurityException(msg);
    }
    return returnedValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (!getVm().getStatus().isStatusOfRunningOrPausedVM()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'mCdImagePath' means eject CD
        if (!StringUtils.isEmpty(mCdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if ((VmRunHandler.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(mCdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (!getVm().isRunningOrPaused()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'mCdImagePath' means eject CD
        if (!StringUtils.isEmpty(mCdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if ((VmRunHandler.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(mCdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
protected boolean GetRunningOnVds() {
    // We will need the virtual machine and the status, so it is worth saving references:
    final VM vm = getVm();
    final VMStatus status = vm.getStatus();
    // there is no need to find the id of the host:
    if (!status.isStatusOfRunningOrPausedVM() && status != VMStatus.NotResponding) {
        return false;
    }
    // Find the id of the host where the machine is running:
    NGuid hostId = vm.getRunOnVds();
    if (hostId == null) {
        log.warnFormat("Strange, according to the status \"{0}\" virtual machine \"{1}\" should be running in a host but it isn't.", status, vm.getId());
        return false;
    }
    // Find the reference to the host using the id that we got before (setting
    // the host to null is required in order to make sure that the host is
    // reloaded from the database):
    setVdsId(new Guid(hostId.toString()));
    setVds(null);
    if (getVds() == null) {
        log.warnFormat("Strange, virtual machine \"{0}\" is is running in host \"{1}\" but that host can't be found.", vm.getId(), hostId);
        return false;
    }
    // a host:
    return true;
}
#method_after
protected boolean GetRunningOnVds() {
    // We will need the virtual machine and the status, so it is worth saving references:
    final VM vm = getVm();
    final VMStatus status = vm.getStatus();
    // there is no need to find the id of the host:
    if (!status.isRunningOrPaused() && status != VMStatus.NotResponding) {
        return false;
    }
    // Find the id of the host where the machine is running:
    NGuid hostId = vm.getRunOnVds();
    if (hostId == null) {
        log.warnFormat("Strange, according to the status \"{0}\" virtual machine \"{1}\" should be running in a host but it isn't.", status, vm.getId());
        return false;
    }
    // Find the reference to the host using the id that we got before (setting
    // the host to null is required in order to make sure that the host is
    // reloaded from the database):
    setVdsId(new Guid(hostId.toString()));
    setVds(null);
    if (getVds() == null) {
        log.warnFormat("Strange, virtual machine \"{0}\" is is running in host \"{1}\" but that host can't be found.", vm.getId(), hostId);
        return false;
    }
    // a host:
    return true;
}
#end_block

#method_before
@Override
protected void Perform() {
    if (getVm().getStatus().isStatusOfRunningVM()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.Pause, new PauseVDSCommandParameters(getVdsId(), getVmId())).getReturnValue());
        // Vds.pause(VmId);
        setSucceeded(true);
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#method_after
@Override
protected void Perform() {
    if (getVm().isRunning()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.Pause, new PauseVDSCommandParameters(getVdsId(), getVmId())).getReturnValue());
        // Vds.pause(VmId);
        setSucceeded(true);
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
public static boolean CanPauseVm(Guid vmId, java.util.ArrayList<String> message) {
    boolean retValue = true;
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else {
        if (vm.getStatus() == VMStatus.WaitForLaunch || vm.getStatus() == VMStatus.MigratingFrom || vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
        } else if (!vm.getStatus().isStatusOfRunningVM()) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.toString());
        }
    }
    if (!retValue) {
        message.add(VdcBllMessages.VAR__ACTION__PAUSE.toString());
        message.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#method_after
public static boolean CanPauseVm(Guid vmId, java.util.ArrayList<String> message) {
    boolean retValue = true;
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else {
        if (vm.getStatus() == VMStatus.WaitForLaunch || vm.getStatus() == VMStatus.MigratingFrom || vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
        } else if (!vm.isRunning()) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.toString());
        }
    }
    if (!retValue) {
        message.add(VdcBllMessages.VAR__ACTION__PAUSE.toString());
        message.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else if (!getVm().getStatus().isStatusOfRunningVM() && getVm().getStatus() != VMStatus.Paused && getVm().getStatus() != VMStatus.NotResponding && getVm().getStatus() != VMStatus.Suspended) {
        if (getVm().getStatus() == VMStatus.SavingState || getVm().getStatus() == VMStatus.RestoringState) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_SAVING_RESTORING);
        } else {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else if (!getVm().isRunning() && getVm().getStatus() != VMStatus.Paused && getVm().getStatus() != VMStatus.NotResponding && getVm().getStatus() != VMStatus.Suspended) {
        if (getVm().getStatus() == VMStatus.SavingState || getVm().getStatus() == VMStatus.RestoringState) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_SAVING_RESTORING);
        } else {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
        }
    }
    return retValue;
}
#end_block

#method_before
public static boolean IsVmRunning(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm != null) {
        return vm.getStatus().isStatusOfRunningOrPausedVM() || vm.getStatus() == VMStatus.Unknown;
    }
    return false;
}
#method_after
public static boolean IsVmRunning(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm != null) {
        return vm.isRunningOrPaused() || vm.getStatus() == VMStatus.Unknown;
    }
    return false;
}
#end_block

#method_before
@Override
protected void ExecuteVDSCommand() {
    SetVmStatusVDSCommandParameters parameters = getParameters();
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(parameters.getVmId());
    vmDynamic.setstatus(parameters.getStatus());
    if (parameters.getStatus().isStatusOfNotRunningVM()) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        VmStatistics vmStatistics = DbFacade.getInstance().getVmStatisticsDao().get(parameters.getVmId());
        VM vm = new VM(null, vmDynamic, vmStatistics);
        ResourceManager.getInstance().InternalSetVmStatus(vm, parameters.getStatus());
        DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
        List<VmNetworkInterface> interfaces = vm.getInterfaces();
        if (interfaces != null && interfaces.size() > 0) {
            for (VmNetworkInterface ifc : interfaces) {
                VmNetworkStatistics stats = ifc.getStatistics();
                DbFacade.getInstance().getVmNetworkStatisticsDao().update(stats);
            }
        }
    } else if (parameters.getStatus() == VMStatus.Unknown) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
    }
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#method_after
@Override
protected void ExecuteVDSCommand() {
    SetVmStatusVDSCommandParameters parameters = getParameters();
    final VMStatus status = parameters.getStatus();
    if (status == null) {
        log.warnFormat("got request to change the status of VM whose id is {0} to null,  ignoring", parameters.getVmId());
        return;
    }
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(parameters.getVmId());
    vmDynamic.setstatus(status);
    if (status.isNotRunning()) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        VmStatistics vmStatistics = DbFacade.getInstance().getVmStatisticsDao().get(parameters.getVmId());
        VM vm = new VM(null, vmDynamic, vmStatistics);
        ResourceManager.getInstance().InternalSetVmStatus(vm, status);
        DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
        List<VmNetworkInterface> interfaces = vm.getInterfaces();
        if (interfaces != null && interfaces.size() > 0) {
            for (VmNetworkInterface ifc : interfaces) {
                VmNetworkStatistics stats = ifc.getStatistics();
                DbFacade.getInstance().getVmNetworkStatisticsDao().update(stats);
            }
        }
    } else if (status == VMStatus.Unknown) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
    }
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#end_block

#method_before
@Override
protected void Perform() {
    if (getVm().getStatus().isStatusOfRunningOrPausedVM()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeFloppy, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), mCdImagePath)).getReturnValue());
        setSucceeded(true);
    }
}
#method_after
@Override
protected void Perform() {
    if (getVm().isRunningOrPaused()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeFloppy, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), mCdImagePath)).getReturnValue());
        setSucceeded(true);
    }
}
#end_block

#method_before
public boolean isDown() {
    return getStatus() == VMStatus.Down;
}
#method_after
// /////////////////////////////////////////////
// / Utility methods that check the VM state ///
// /////////////////////////////////////////////
public boolean isDown() {
    return getStatus() == VMStatus.Down;
}
#end_block

#method_before
public boolean isRunning() {
    return getStatus().isStatusOfRunningVM();
}
#method_after
public boolean isRunning() {
    return getStatus().isRunning();
}
#end_block

#method_before
public void init() {
    log.info("ResourceManager::ResourceManager::Entered");
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.getStatus().isStatusOfNotRunningVM()) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
}
#method_after
public void init() {
    log.info("ResourceManager::ResourceManager::Entered");
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    boolean isVmNotRunning = status.isStatusOfNotRunningVM();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    if (oldVmStatus == VMStatus.MigratingFrom && runningVm.getstatus().isStatusOfGuestUp()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    if (oldVmStatus == VMStatus.MigratingFrom && runningVm.getstatus().isGuestUp()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid newActiveSnapshotId = Guid.NewGuid();
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getParameters().setInitialVmStatus(getVm().getStatus());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), getParameters().getSnapshotType(), getVm(), getCompensationContext());
    freeLock();
    setActionReturnValue(createdSnapshotId);
    if (getDisksList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        endSuccessfully();
    } else {
        for (DiskImage image : getDisksList()) {
            ImagesActionsParametersBase tempVar = new ImagesActionsParametersBase(image.getImageId());
            tempVar.setDescription(getParameters().getDescription());
            tempVar.setSessionId(getParameters().getSessionId());
            tempVar.setQuotaId(image.getQuotaId());
            tempVar.setVmSnapshotId(newActiveSnapshotId);
            tempVar.setEntityId(getParameters().getEntityId());
            VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
            tempVar.setParentCommand(parentCommand);
            ImagesActionsParametersBase p = tempVar;
            VdcActionParametersBase parrentParamsForTask = getParametersForTask(parentCommand, getParameters());
            p.setParentParameters(parrentParamsForTask);
            getParameters().getImagesParameters().add(p);
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            } else {
                throw new VdcBLLException(vdcReturnValue.getFault().getError(), "CreateAllSnapshotsFromVmCommand::executeVmCommand: Failed to create snapshot!");
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    Guid newActiveSnapshotId = Guid.NewGuid();
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getParameters().setInitialVmStatus(getVm().getStatus());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    if (getDisksList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, getCompensationContext());
        // at the moment there's no need to execute vdsm Snapshot command for diskless snapshots,
        // when support for ram snapshot will be introduced, this vdsm command should be executed
        // for diskless snapshots as well (currently executed within endSuccesfully() method.
        incrementVmGeneration();
    } else {
        new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), getParameters().getSnapshotType(), getVm(), getCompensationContext());
        freeLock();
        for (DiskImage image : getDisksList()) {
            ImagesActionsParametersBase tempVar = new ImagesActionsParametersBase(image.getImageId());
            tempVar.setDescription(getParameters().getDescription());
            tempVar.setSessionId(getParameters().getSessionId());
            tempVar.setQuotaId(image.getQuotaId());
            tempVar.setVmSnapshotId(newActiveSnapshotId);
            tempVar.setEntityId(getParameters().getEntityId());
            VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
            tempVar.setParentCommand(parentCommand);
            ImagesActionsParametersBase p = tempVar;
            VdcActionParametersBase parrentParamsForTask = getParametersForTask(parentCommand, getParameters());
            p.setParentParameters(parrentParamsForTask);
            getParameters().getImagesParameters().add(p);
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            } else {
                throw new VdcBLLException(vdcReturnValue.getFault().getError(), "CreateAllSnapshotsFromVmCommand::executeVmCommand: Failed to create snapshot!");
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isRunning() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isRunning() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
@Override
protected void Perform() {
    // Set the VM to null, to fetch it again from the DB ,instead from the cache.
    // We want to get the VM state from the DB, to avoid multi requests for VM hibernation.
    setVm(null);
    if (getVm().getStatus().isStatusOfRunningVM()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getVm().getDynamicData(), getVm().getStatus());
                // Set the VM to SavingState to lock the VM,to avoid situation of multi VM hibernation.
                getVm().setStatus(VMStatus.SavingState);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
                getCompensationContext().stateChanged();
                return null;
            }
        });
        Guid image1GroupId = Guid.NewGuid();
        // this is temp code until SPM will implement the new verb that does
        // it for us:
        Guid hiberVol1 = Guid.NewGuid();
        VDSReturnValue ret1 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image1GroupId, getImageSizeInBytes(), getVolumeType(), VolumeFormat.RAW, hiberVol1, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret1.getSucceeded()) {
            return;
        }
        Guid guid1 = createTask(ret1.getCreationInfo(), VdcActionType.HibernateVm, VdcObjectType.Storage, getStorageDomainId().getValue());
        getReturnValue().getTaskIdList().add(guid1);
        // second vol should be 10kb
        Guid image2GroupId = Guid.NewGuid();
        Guid hiberVol2 = Guid.NewGuid();
        VDSReturnValue ret2 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image2GroupId, getMetaDataSizeInBytes(), VolumeType.Sparse, VolumeFormat.COW, hiberVol2, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret2.getSucceeded()) {
            return;
        }
        Guid guid2 = createTask(ret2.getCreationInfo(), VdcActionType.HibernateVm);
        getReturnValue().getTaskIdList().add(guid2);
        // this is the new param that should be passed to the hibernate
        // command
        getVm().setHibernationVolHandle(String.format("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s", getStorageDomainId().toString(), getVm().getStoragePoolId().toString(), image1GroupId.toString(), hiberVol1.toString(), image2GroupId.toString(), hiberVol2.toString()));
        // end of temp code
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
        getParameters().setTaskIds(new java.util.ArrayList<Guid>());
        getParameters().getTaskIds().add(guid1);
        getParameters().getTaskIds().add(guid2);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void Perform() {
    // Set the VM to null, to fetch it again from the DB ,instead from the cache.
    // We want to get the VM state from the DB, to avoid multi requests for VM hibernation.
    setVm(null);
    if (getVm().isRunning()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getVm().getDynamicData(), getVm().getStatus());
                // Set the VM to SavingState to lock the VM,to avoid situation of multi VM hibernation.
                getVm().setStatus(VMStatus.SavingState);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
                getCompensationContext().stateChanged();
                return null;
            }
        });
        Guid image1GroupId = Guid.NewGuid();
        // this is temp code until SPM will implement the new verb that does
        // it for us:
        Guid hiberVol1 = Guid.NewGuid();
        VDSReturnValue ret1 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image1GroupId, getImageSizeInBytes(), getVolumeType(), VolumeFormat.RAW, hiberVol1, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret1.getSucceeded()) {
            return;
        }
        Guid guid1 = createTask(ret1.getCreationInfo(), VdcActionType.HibernateVm, VdcObjectType.Storage, getStorageDomainId().getValue());
        getReturnValue().getTaskIdList().add(guid1);
        // second vol should be 10kb
        Guid image2GroupId = Guid.NewGuid();
        Guid hiberVol2 = Guid.NewGuid();
        VDSReturnValue ret2 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image2GroupId, getMetaDataSizeInBytes(), VolumeType.Sparse, VolumeFormat.COW, hiberVol2, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret2.getSucceeded()) {
            return;
        }
        Guid guid2 = createTask(ret2.getCreationInfo(), VdcActionType.HibernateVm);
        getReturnValue().getTaskIdList().add(guid2);
        // this is the new param that should be passed to the hibernate
        // command
        getVm().setHibernationVolHandle(String.format("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s", getStorageDomainId().toString(), getVm().getStoragePoolId().toString(), image1GroupId.toString(), hiberVol1.toString(), image2GroupId.toString(), hiberVol2.toString()));
        // end of temp code
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
        getParameters().setTaskIds(new java.util.ArrayList<Guid>());
        getParameters().getTaskIds().add(guid1);
        getParameters().getTaskIds().add(guid2);
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                case // probably wrong xml format sent.
                PROTOCOL_ERROR:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status.isStatusOfRunningVM() || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getVmName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                case // probably wrong xml format sent.
                PROTOCOL_ERROR:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getVmName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
protected boolean canMigrateVm(@SuppressWarnings("unused") Guid vmGuid, ArrayList<String> reasons) {
    boolean retValue = true;
    VM vm = getVm();
    if (vm == null) {
        retValue = false;
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
    } else {
        // If VM is pinned to host, no migration can occur
        if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.name());
        } else if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE.toString());
        } else if (vm.getStatus() == VMStatus.MigratingFrom) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS.name());
        } else if (vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.name());
        } else if (vm.getStatus() == VMStatus.Paused) {
            retValue = false;
            reasons.add(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED.name());
        } else if (!vm.getStatus().isStatusOfQualifyToMigrateVM()) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.name());
        } else if (getDestinationVds() != null && getDestinationVds().getstatus() != VDSStatus.Up) {
            retValue = false;
            reasons.add(VdcBllMessages.VAR__HOST_STATUS__UP.name());
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.name());
        }
        retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && getVdsSelector().canFindVdsToRunOn(reasons, true);
    }
    if (!retValue) {
        reasons.add(VdcBllMessages.VAR__ACTION__MIGRATE.toString());
        reasons.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#method_after
protected boolean canMigrateVm(@SuppressWarnings("unused") Guid vmGuid, ArrayList<String> reasons) {
    boolean retValue = true;
    VM vm = getVm();
    if (vm == null) {
        retValue = false;
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
    } else {
        // If VM is pinned to host, no migration can occur
        if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.name());
        } else if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE.toString());
        } else if (vm.getStatus() == VMStatus.MigratingFrom) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS.name());
        } else if (vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.name());
        } else if (vm.getStatus() == VMStatus.Paused) {
            retValue = false;
            reasons.add(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED.name());
        } else if (!vm.isQualifyToMigrate()) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.name());
        } else if (getDestinationVds() != null && getDestinationVds().getstatus() != VDSStatus.Up) {
            retValue = false;
            reasons.add(VdcBllMessages.VAR__HOST_STATUS__UP.name());
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.name());
        }
        retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && getVdsSelector().canFindVdsToRunOn(reasons, true);
    }
    if (!retValue) {
        reasons.add(VdcBllMessages.VAR__ACTION__MIGRATE.toString());
        reasons.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots();
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    // The snapshot being restored to
    Snapshot targetSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    if (targetSnapshot == null) {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Can't find target snapshot by id: " + getParameters().getDstSnapshotId());
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(targetSnapshot);
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    List<Guid> deletedDisksIds = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDao().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#method_after
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    Set<Guid> deletedDisksIds = new HashSet<Guid>();
    for (DiskImage image : getDiskImageDao().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#end_block

#method_before
protected void restoreSnapshotAndRemoveObsoleteSnapshots() {
    targetSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    if (targetSnapshot == null) {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Can't find target snapshot by id: " + getParameters().getDstSnapshotId());
    }
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
        case STATELESS:
            restoreConfiguration(targetSnapshot);
            break;
        // Currently UI sends the "in preview" snapshot to restore when "Commit" is pressed.
        case REGULAR:
            if (SnapshotStatus.IN_PREVIEW == targetSnapshot.getStatus()) {
                prepareToDeletePreviewBranch();
                // Set the active snapshot's images as target images for restore, because they are what we keep.
                getParameters().setImagesList(getDiskImageDao().getAllSnapshotsForVmSnapshot(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE)));
                break;
            }
        default:
            throw new VdcBLLException(VdcBllErrors.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#method_after
protected void restoreSnapshotAndRemoveObsoleteSnapshots(Snapshot targetSnapshot) {
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
        case STATELESS:
            restoreConfiguration(targetSnapshot);
            break;
        // Currently UI sends the "in preview" snapshot to restore when "Commit" is pressed.
        case REGULAR:
            if (SnapshotStatus.IN_PREVIEW == targetSnapshot.getStatus()) {
                prepareToDeletePreviewBranch();
                // Set the active snapshot's images as target images for restore, because they are what we keep.
                getParameters().setImagesList(getDiskImageDao().getAllSnapshotsForVmSnapshot(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE)));
                break;
            }
        default:
            throw new VdcBLLException(VdcBllErrors.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#end_block

#method_before
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDao().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDao().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            if (!snapshotsToRemove.contains(snapshotToRemove.getValue())) {
                snapshotsToRemove.add(snapshotToRemove.getValue());
            }
            parentImage = getDiskImageDao().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#method_after
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDao().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDao().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            snapshotsToRemove.add(snapshotToRemove.getValue());
            parentImage = getDiskImageDao().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    super.endVmCommand();
    // if we got here, the target snapshot exists for sure
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
}
#method_after
@Override
protected void endVmCommand() {
    // if we got here, the target snapshot exists for sure
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
    super.endVmCommand();
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> vmCountColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return String.valueOf(object.getvm_count());
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.runningVms(), "110px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> vmCountColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return String.valueOf(object.getvm_count());
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#end_block

#method_before
@Override
public void debug(Object arg0) {
    log.debug(addPrefixToLogMessage(arg0));
}
#method_after
@Override
public void debug(Object arg0) {
    if (isDebugEnabled()) {
        log.debug(addPrefixToLogMessage(arg0));
    }
}
#end_block

#method_before
@Override
public void debug(Object arg0, Throwable arg1) {
    log.debug(addPrefixToLogMessage(arg0), arg1);
}
#method_after
@Override
public void debug(Object arg0, Throwable arg1) {
    if (isDebugEnabled()) {
        log.debug(addPrefixToLogMessage(arg0), arg1);
    }
}
#end_block

#method_before
@Override
public void trace(Object arg0) {
    if (log.isTraceEnabled()) {
        log.trace(arg0);
    }
}
#method_after
@Override
public void trace(Object arg0) {
    if (log.isTraceEnabled()) {
        log.trace(addPrefixToLogMessage(arg0));
    }
}
#end_block

#method_before
@Override
public Permissions list() {
    return mapCollection(getBackendCollection(queryType, queryParams));
}
#method_after
@Override
public Permissions list() {
    Set<permissions> permissions = new TreeSet<permissions>(new PermissionsComparator());
    List<permissions> directPermissions = getBackendCollection(queryType, queryParams);
    permissions.addAll(directPermissions);
    if (queryType.equals(VdcQueryType.GetPermissionsForObject)) {
        permissions.addAll(getInheritedPermissions());
    }
    return mapCollection(permissions);
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreation(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
protected Permissions mapCollection(List<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        if (entity.getObjectType() != VdcObjectType.System) {
            castEveryonePermissionsToUser(entity);
            Permission permission = map(entity, getUserById(entity.getad_element_id()));
            collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
        }
    }
    return collection;
}
#method_after
protected Permissions mapCollection(Set<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        castEveryonePermissionsToUser(entity);
        Permission permission = map(entity, getUserById(entity.getad_element_id()));
        collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
    }
    return collection;
}
#end_block

#method_before
private void castEveryonePermissionsToUser(permissions entity) {
    if (entity.getad_element_id() != null && entity.getad_element_id().equals(Guid.EVERYONE) && queryType.equals(VdcQueryType.GetPermissionsByAdElementId)) {
        entity.setad_element_id(((MultilevelAdministrationByAdElementIdParameters) queryParams).getAdElementId());
    }
}
#method_after
private void castEveryonePermissionsToUser(permissions entity) {
    if (entity.getad_element_id() != null && entity.getad_element_id().equals(Guid.EVERYONE) && queryType.equals(VdcQueryType.GetPermissionsByAdElementId)) {
        entity.setad_element_id(this.targetId);
    }
}
#end_block

#method_before
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance().init();
    log.infoFormat("TagsDirector: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    log.infoFormat("JobRepositoryCleanupManager: {0}", new Date());
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    log.infoFormat("AutoRecoveryManager: {0}", new Date());
    AutoRecoveryManager.getInstance().initialize();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance().init();
    log.infoFormat("TagsDirector: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    log.infoFormat("JobRepositoryCleanupManager: {0}", new Date());
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    log.infoFormat("AutoRecoveryManager: {0}", new Date());
    AutoRecoveryManager.getInstance().initialize();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
            boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
            returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
            if (returnValue != null) {
                return returnValue;
            }
            CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
            command.setInternalExecution(runAsInternal);
            command.setContext(context);
            ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
            returnValue = command.executeAction();
            returnValue.setCorrelationId(parameters.getCorrelationId());
            returnValue.setJobId(command.getJobId());
            return returnValue;
    }
}
#method_after
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
            boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
            returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
            if (returnValue != null) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons: {1}", actionType, StringUtils.join(returnValue.getCanDoActionMessages(), ','));
                return returnValue;
            }
            CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
            command.setInternalExecution(runAsInternal);
            command.setContext(context);
            ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
            returnValue = command.executeAction();
            returnValue.setCorrelationId(parameters.getCorrelationId());
            returnValue.setJobId(command.getJobId());
            return returnValue;
    }
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        ProgressBarColumn<VDS> loadColumn = new ProgressBarColumn<VDS>() {

            @Override
            protected String getProgressText(VDS object) {
                int numOfActiveVMs = object.getvm_active() != null ? object.getvm_active() : 0;
                return ConstantsManager.getInstance().getMessages().numberOfVmsForHostsLoad(numOfActiveVMs);
            }

            @Override
            protected Integer getProgressValue(VDS object) {
                return object.getvm_active() != null ? Math.min(object.getvm_active(), 100) : 0;
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(loadColumn, constants.loadHost(), "80px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noHostsToDisplay());
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> vmCountColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                // $NON-NLS-1$
                return object.getvm_active() != null ? object.getvm_active().toString() : "0";
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.runningVms(), "80px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#end_block

#method_before
public OrderedMultiSelectionModel<T> getSelectionModel() {
    return selectionModel;
}
#method_after
@Override
public OrderedMultiSelectionModel<T> getSelectionModel() {
    return selectionModel;
}
#end_block

#method_before
@Override
protected List<T> getSelectedItems() {
    return new ArrayList<T>(selectionModel.getSelectedList());
}
#method_after
@Override
public List<T> getSelectedItems() {
    return selectionModel.getSelectedList();
}
#end_block

#method_before
public void setLoadingState(LoadingState state) {
    table.setLoadingState(state);
}
#method_after
@Override
public void setLoadingState(LoadingState state) {
    table.setLoadingState(state);
}
#end_block

#method_before
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "100px");
}
#method_after
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
void initTableColumns() {
    getTable().enableColumnResizing();
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noDisksToDisplay());
}
#method_after
void initTableColumns() {
    getTable().enableColumnResizing();
}
#end_block

#method_before
@UiHandler({ "basicViewButton", "advancedViewButton" })
void handleViewButtonClick(ClickEvent event) {
    boolean advancedViewEnabled = advancedViewButton.getValue();
    getTable().ensureColumnPresent(AdvancedViewColumns.logTypeColumn, constants.eventIdEvent(), advancedViewEnabled, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(AdvancedViewColumns.userColumn, constants.userEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.hostColumn, constants.hostEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.virtualMachineColumn, constants.vmEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.templateColumn, constants.templateEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.dataCenterColumn, constants.dcEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.storageColumn, constants.storageEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.clusterColumn, constants.clusterEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.volumeColumn, constants.volumeEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.corrIdColumn, constants.eventCorrelationId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
}
#method_after
@UiHandler({ "basicViewButton", "advancedViewButton" })
void handleViewButtonClick(ClickEvent event) {
    boolean advancedViewEnabled = advancedViewButton.getValue();
    getTable().ensureColumnPresent(AdvancedViewColumns.logTypeColumn, constants.eventIdEvent(), advancedViewEnabled, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(AdvancedViewColumns.userColumn, constants.userEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.hostColumn, constants.hostEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.virtualMachineColumn, constants.vmEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.templateColumn, constants.templateEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.dataCenterColumn, constants.dcEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.storageColumn, constants.storageEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.clusterColumn, constants.clusterEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.volumeColumn, constants.volumeEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.corrIdColumn, constants.eventCorrelationId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.originColumn, constants.eventOrigin(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.customEventIdColumn, constants.eventCustomEventId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new AuditLogSeverityColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<AuditLog> logTimeColumn = new FullDateTimeColumn<AuditLog>() {

        @Override
        protected Date getRawValue(AuditLog object) {
            return object.getlog_time();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(logTimeColumn, constants.timeEvent(), "150px");
    TextColumnWithTooltip<AuditLog> messageColumn = new TextColumnWithTooltip<AuditLog>() {

        @Override
        public String getValue(AuditLog object) {
            return object.getmessage();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(messageColumn, constants.messageEvent(), "150px");
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noEventsToDisplay());
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new AuditLogSeverityColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<AuditLog> logTimeColumn = new FullDateTimeColumn<AuditLog>() {

        @Override
        protected Date getRawValue(AuditLog object) {
            return object.getlog_time();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(logTimeColumn, constants.timeEvent(), "150px");
    TextColumnWithTooltip<AuditLog> messageColumn = new TextColumnWithTooltip<AuditLog>() {

        @Override
        public String getValue(AuditLog object) {
            return object.getmessage();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(messageColumn, constants.messageEvent(), "150px");
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "80px");
    TextColumnWithTooltip<VM> loggedInUserColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            if (object.getGuestCurUserName() == null) {
                // $NON-NLS-1$
                return "";
            }
            return String.valueOf(object.getGuestCurUserName());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(loggedInUserColumn, constants.loggedInUserVm(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newServerVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewServerCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newDesktopVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDesktopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.pauseVmImage(), resources.pauseVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            ConsoleModel defaultConsoleModel = getMainModel().getDefaultConsoleModel();
            return defaultConsoleModel != null ? defaultConsoleModel.getConnectCommand() : null;
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noVMsToDisplay());
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newServerVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewServerCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newDesktopVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDesktopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.pauseVmImage(), resources.pauseVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            ConsoleModel defaultConsoleModel = getMainModel().getDefaultConsoleModel();
            return defaultConsoleModel != null ? defaultConsoleModel.getConnectCommand() : null;
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    MoveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void refreshVdsStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.Execute();
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    /**
     * TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
     */
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
private void refreshVdsStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.Execute();
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Recieved a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = null;
            vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getstatus() && !(vmToUpdate.getStatus() == VMStatus.SavingState && runningVm.getstatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.Execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getstatus() && !(vmToUpdate.getStatus() == VMStatus.SavingState && runningVm.getstatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.Execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#end_block

#method_before
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = null;
        // _vdsManager.getVm(vm.getvm_guid());
        vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitMessage());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitStatus(), vmInternalData.getVmDynamic().getExitMessage());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down);
                    AddVmDynamicToList(curVm.getDynamicData());
                    AddVmStatisticsToList(curVm.getStatisticsData());
                    AddVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = null;
        vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else /**
                 * check if vm is suspended and remove it from async list
                 */
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            AddVmDynamicToList(vmToRemove.getDynamicData());
            AddVmStatisticsToList(vmToRemove.getStatisticsData());
            AddVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getVmName()));
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#method_after
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            addVmDynamicToList(vmToRemove.getDynamicData());
            addVmStatisticsToList(vmToRemove.getStatisticsData());
            addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getVmName()));
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        /**
         * inMigration
         */
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void clearVm(VM vm, String exitMessage) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        if (vm.getStatus() != VMStatus.Suspended) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down);
            vm.setExitStatus(VmExitStatus.Error);
            vm.setExitMessage(exitMessage);
        }
        AddVmDynamicToList(vm.getDynamicData());
        AddVmStatisticsToList(vm.getStatisticsData());
        AddVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#method_after
private void clearVm(VM vm, VmExitStatus exitStatus, String exitMessage) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to _vmDynamicToSave though because it might been removed from it in #updateRepository
        if (vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.Down) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down, exitStatus, exitMessage);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be execute in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    if (isVmDownUnexpectedly() && getVm().isAutoStartup() && wasVmUpInitially()) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#method_after
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreate(VdcActionType.AddDisk, params, new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#end_block

#method_before
@Override
public Disks list() {
    return mapCollection(getBackendCollection(SearchType.Disk));
}
#method_after
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisks, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new EntityIdResolver() {

        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
@Override
public Permissions list() {
    return mapCollection(getBackendCollection(queryType, queryParams));
}
#method_after
@Override
public Permissions list() {
    Set<permissions> permissions = new TreeSet<permissions>(new PermissionsComparator());
    List<permissions> directPermissions = getBackendCollection(queryType, queryParams);
    permissions.addAll(directPermissions);
    if (queryType.equals(VdcQueryType.GetPermissionsForObject)) {
        permissions.addAll(getInheritedPermissions());
    }
    return mapCollection(permissions);
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreation(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
protected Permissions mapCollection(List<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        if (entity.getObjectType() != VdcObjectType.System) {
            Permission permission = map(entity, getUserById(entity.getad_element_id()));
            collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
        }
    }
    return collection;
}
#method_after
protected Permissions mapCollection(Set<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        Permission permission = map(entity, getUserById(entity.getad_element_id()));
        collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
    }
    return collection;
}
#end_block

#method_before
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        ad_groups group = new ad_groups();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        LdapGroup group = new LdapGroup();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver resolver = new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    MoveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Recieved a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        // _vdsManager.getVm(vm.getvm_guid());
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down);
                    AddVmDynamicToList(curVm.getDynamicData());
                    AddVmStatisticsToList(curVm.getStatisticsData());
                    AddVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down);
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            AddVmDynamicToList(vmToRemove.getDynamicData());
            AddVmStatisticsToList(vmToRemove.getStatisticsData());
            AddVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove);
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#method_after
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            addVmDynamicToList(vmToRemove.getDynamicData());
            addVmStatisticsToList(vmToRemove.getStatisticsData());
            addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove);
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#end_block

#method_before
private void clearVm(VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        if (vm.getStatus() != VMStatus.Suspended) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down);
        }
        AddVmDynamicToList(vm.getDynamicData());
        AddVmStatisticsToList(vm.getStatisticsData());
        AddVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#method_after
private void clearVm(VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        if (vm.getStatus() != VMStatus.Suspended) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!getParameters().isNested()) {
        return Collections.singletonMap(getVdsGroupId().toString(), LockingGroup.GLUSTER.name());
    }
    return super.getExclusiveLocks();
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!isInternalExecution()) {
        return Collections.singletonMap(getVdsGroupId().toString(), LockingGroup.GLUSTER.name());
    }
    return super.getExclusiveLocks();
}
#end_block

#method_before
protected VdcReturnValueBase runBllAction(VdcActionType actionType, GlusterParametersBase params) {
    params.setNested(true);
    VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(actionType, params);
    setSucceeded(returnValue.getSucceeded());
    return returnValue;
}
#method_after
protected VdcReturnValueBase runBllAction(VdcActionType actionType, VdcActionParametersBase params) {
    VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(actionType, params);
    setSucceeded(returnValue.getSucceeded());
    return returnValue;
}
#end_block

#method_before
private Response addNfsOrLocalOrPosix(VdcActionType action, StorageDomain model, storage_domain_static entity, Guid hostId) {
    storage_server_connections cnx = mapToCnx(model);
    entity.setstorage(addStorageServerConnection(cnx, hostId));
    if (action == VdcActionType.AddNFSStorageDomain) {
        storage_domains existing = getExistingStorageDomain(hostId, entity.getstorage_type(), entity.getstorage_domain_type(), cnx);
        if (existing != null) {
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingNFSStorageDomain;
        }
    }
    if (action != VdcActionType.AddExistingNFSStorageDomain) {
        validateParameters(model, 2, "name");
    }
    return performCreation(action, getAddParams(entity, hostId), ID_RESOLVER);
}
#method_after
private Response addNfsOrLocalOrPosix(VdcActionType action, StorageDomain model, StorageDomainStatic entity, Guid hostId) {
    StorageServerConnections cnx = mapToCnx(model);
    entity.setstorage(addStorageServerConnection(cnx, hostId));
    if (action == VdcActionType.AddNFSStorageDomain) {
        storage_domains existing = getExistingStorageDomain(hostId, entity.getstorage_type(), entity.getstorage_domain_type(), cnx);
        if (existing != null) {
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingNFSStorageDomain;
        }
    }
    if (action != VdcActionType.AddExistingNFSStorageDomain) {
        validateParameters(model, 2, "name");
    }
    return performCreate(action, getAddParams(entity, hostId), ID_RESOLVER);
}
#end_block

#method_before
private Response addSAN(StorageDomain model, StorageType storageType, storage_domain_static entity, Guid hostId) {
    boolean overrideLuns = model.getStorage().isSetOverrideLuns() ? model.getStorage().isOverrideLuns() : false;
    return performCreation(VdcActionType.AddSANStorageDomain, getSanAddParams(entity, hostId, getLunIds(model.getStorage(), storageType, hostId), overrideLuns), ID_RESOLVER);
}
#method_after
private Response addSAN(StorageDomain model, StorageType storageType, StorageDomainStatic entity, Guid hostId) {
    boolean overrideLuns = model.getStorage().isSetOverrideLuns() ? model.getStorage().isOverrideLuns() : false;
    return performCreate(VdcActionType.AddSANStorageDomain, getSanAddParams(entity, hostId, getLunIds(model.getStorage(), storageType, hostId), overrideLuns), ID_RESOLVER);
}
#end_block

#method_before
private void connectStorageToHost(Guid hostId, StorageType storageType, LogicalUnit unit) {
    storage_server_connections cnx = StorageDomainHelper.getConnection(storageType, unit.getAddress(), unit.getTarget(), unit.getUsername(), unit.getPassword(), unit.getPort());
    performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(cnx, hostId));
}
#method_after
private void connectStorageToHost(Guid hostId, StorageType storageType, LogicalUnit unit) {
    StorageServerConnections cnx = StorageDomainHelper.getConnection(storageType, unit.getAddress(), unit.getTarget(), unit.getUsername(), unit.getPassword(), unit.getPort());
    performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(cnx, hostId));
}
#end_block

#method_before
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage.type");
    validateEnums(StorageDomain.class, storageDomain);
    storage_domain_static entity = mapToStatic(storageDomain);
    Guid hostId = getHostId(storageDomain);
    Response resp = null;
    switch(entity.getstorage_type()) {
        case ISCSI:
        case FCP:
            resp = addSAN(storageDomain, entity.getstorage_type(), entity, hostId);
            break;
        case NFS:
            validateParameters(storageDomain.getStorage(), "address", "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddNFSStorageDomain, storageDomain, entity, hostId);
            break;
        case LOCALFS:
            validateParameters(storageDomain.getStorage(), "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddLocalStorageDomain, storageDomain, entity, hostId);
            break;
        case POSIXFS:
            validateParameters(storageDomain.getStorage(), "path", "vfsType");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId);
            break;
        default:
            break;
    }
    addLinks(((StorageDomain) resp.getEntity()), getLinksToExclude(storageDomain));
    return resp;
}
#method_after
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage.type");
    validateEnums(StorageDomain.class, storageDomain);
    StorageDomainStatic entity = mapToStatic(storageDomain);
    Guid hostId = getHostId(storageDomain);
    Response resp = null;
    switch(entity.getstorage_type()) {
        case ISCSI:
        case FCP:
            resp = addSAN(storageDomain, entity.getstorage_type(), entity, hostId);
            break;
        case NFS:
            validateParameters(storageDomain.getStorage(), "address", "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddNFSStorageDomain, storageDomain, entity, hostId);
            break;
        case LOCALFS:
            validateParameters(storageDomain.getStorage(), "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddLocalStorageDomain, storageDomain, entity, hostId);
            break;
        case POSIXFS:
            validateParameters(storageDomain.getStorage(), "path", "vfsType");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId);
            break;
        default:
            break;
    }
    addLinks(((StorageDomain) resp.getEntity()), getLinksToExclude(storageDomain));
    return resp;
}
#end_block

#method_before
protected storage_domain_static mapToStatic(StorageDomain model) {
    return getMapper(modelType, storage_domain_static.class).map(model, null);
}
#method_after
protected StorageDomainStatic mapToStatic(StorageDomain model) {
    return getMapper(modelType, StorageDomainStatic.class).map(model, null);
}
#end_block

#method_before
protected void mapNfsOrLocalOrPosix(StorageDomain model, storage_domains entity) {
    final Storage storage = model.getStorage();
    storage_server_connections cnx = getStorageServerConnection(entity.getstorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    if (cnx.getNfsRetrans() != null) {
        storage.setNfsRetrans(cnx.getNfsRetrans().intValue());
    }
    if (cnx.getNfsTimeo() != null) {
        storage.setNfsTimeo(cnx.getNfsTimeo().intValue());
    }
    if (cnx.getNfsVersion() != null) {
        storage.setNfsVersion(StorageDomainMapper.map(cnx.getNfsVersion(), null));
    }
}
#method_after
protected void mapNfsOrLocalOrPosix(StorageDomain model, storage_domains entity) {
    final Storage storage = model.getStorage();
    StorageServerConnections cnx = getStorageServerConnection(entity.getstorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    if (cnx.getNfsRetrans() != null) {
        storage.setNfsRetrans(cnx.getNfsRetrans().intValue());
    }
    if (cnx.getNfsTimeo() != null) {
        storage.setNfsTimeo(cnx.getNfsTimeo().intValue());
    }
    if (cnx.getNfsVersion() != null) {
        storage.setNfsVersion(StorageDomainMapper.map(cnx.getNfsVersion(), null));
    }
}
#end_block

#method_before
protected void mapVolumeGroupIscsi(StorageDomain model, storage_domains entity) {
    VolumeGroup vg = model.getStorage().getVolumeGroup();
    for (LUNs lun : getLunsByVgId(vg.getId())) {
        List<storage_server_connections> lunConnections = lun.getLunConnections();
        if (lunConnections != null) {
            for (storage_server_connections cnx : lunConnections) {
                LogicalUnit unit = map(lun);
                unit = map(cnx, unit);
                vg.getLogicalUnits().add(unit);
            }
        }
    }
}
#method_after
protected void mapVolumeGroupIscsi(StorageDomain model, storage_domains entity) {
    VolumeGroup vg = model.getStorage().getVolumeGroup();
    for (LUNs lun : getLunsByVgId(vg.getId())) {
        List<StorageServerConnections> lunConnections = lun.getLunConnections();
        if (lunConnections != null) {
            for (StorageServerConnections cnx : lunConnections) {
                LogicalUnit unit = map(lun);
                unit = map(cnx, unit);
                vg.getLogicalUnits().add(unit);
            }
        }
    }
}
#end_block

#method_before
protected org.ovirt.engine.api.model.StorageType map(StorageType type) {
    return getMapper(StorageType.class, org.ovirt.engine.api.model.StorageType.class).map(type, null);
}
#method_after
protected LogicalUnit map(StorageServerConnections cnx, LogicalUnit template) {
    return getMapper(StorageServerConnections.class, LogicalUnit.class).map(cnx, template);
}
#end_block

#method_before
protected storage_server_connections mapToCnx(StorageDomain model) {
    return getMapper(StorageDomain.class, storage_server_connections.class).map(model, null);
}
#method_after
protected StorageServerConnections mapToCnx(StorageDomain model) {
    return getMapper(StorageDomain.class, StorageServerConnections.class).map(model, null);
}
#end_block

#method_before
private String addStorageServerConnection(storage_server_connections cnx, Guid hostId) {
    return performAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(cnx, hostId), String.class);
}
#method_after
private String addStorageServerConnection(StorageServerConnections cnx, Guid hostId) {
    return performAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(cnx, hostId), String.class);
}
#end_block

#method_before
private storage_server_connections getStorageServerConnection(String id) {
    return getEntity(storage_server_connections.class, VdcQueryType.GetStorageServerConnectionById, new StorageServerConnectionQueryParametersBase(id), "Storage server connection: id=" + id);
}
#method_after
private StorageServerConnections getStorageServerConnection(String id) {
    return getEntity(StorageServerConnections.class, VdcQueryType.GetStorageServerConnectionById, new StorageServerConnectionQueryParametersBase(id), "Storage server connection: id=" + id);
}
#end_block

#method_before
private storage_domains getExistingStorageDomain(Guid hostId, StorageType storageType, StorageDomainType domainType, storage_server_connections cnx) {
    List<storage_domains> existing = asCollection(storage_domains.class, getEntity(ArrayList.class, VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, cnx.getconnection()), "Existing storage domains: path=" + cnx.getconnection()));
    return existing.size() != 0 ? existing.get(0) : null;
}
#method_after
private storage_domains getExistingStorageDomain(Guid hostId, StorageType storageType, StorageDomainType domainType, StorageServerConnections cnx) {
    List<storage_domains> existing = asCollection(storage_domains.class, getEntity(ArrayList.class, VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, cnx.getconnection()), "Existing storage domains: path=" + cnx.getconnection()));
    return existing.size() != 0 ? existing.get(0) : null;
}
#end_block

#method_before
private StorageDomainManagementParameter getAddParams(storage_domain_static entity, Guid hostId) {
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(entity);
    params.setVdsId(hostId);
    return params;
}
#method_after
private StorageDomainManagementParameter getAddParams(StorageDomainStatic entity, Guid hostId) {
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(entity);
    params.setVdsId(hostId);
    return params;
}
#end_block

#method_before
private AddSANStorageDomainParameters getSanAddParams(storage_domain_static entity, Guid hostId, ArrayList<String> lunIds, boolean force) {
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(entity);
    params.setVdsId(hostId);
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#method_after
private AddSANStorageDomainParameters getSanAddParams(StorageDomainStatic entity, Guid hostId, ArrayList<String> lunIds, boolean force) {
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(entity);
    params.setVdsId(hostId);
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#end_block

#method_before
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "id|name");
    Guid storageDomainId;
    if (storageDomain.isSetId()) {
        storageDomainId = asGuid(storageDomain.getId());
    } else {
        storageDomainId = lookupStorageDomainIdByName(storageDomain.getName());
    }
    return performCreation(VdcActionType.AttachStorageDomainToPool, new DetachStorageDomainFromPoolParameters(storageDomainId, dataCenterId), new StorageDomainIdResolver(storageDomainId));
}
#method_after
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "id|name");
    Guid storageDomainId;
    if (storageDomain.isSetId()) {
        storageDomainId = asGuid(storageDomain.getId());
    } else {
        storageDomainId = lookupStorageDomainIdByName(storageDomain.getName());
    }
    return performCreate(VdcActionType.AttachStorageDomainToPool, new DetachStorageDomainFromPoolParameters(storageDomainId, dataCenterId), new StorageDomainIdResolver(storageDomainId));
}
#end_block

#method_before
protected Groups mapDomainGroupsCollection(List<ad_groups> entities) {
    Groups collection = new Groups();
    for (ad_groups entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#method_after
protected Groups mapDomainGroupsCollection(List<LdapGroup> entities) {
    Groups collection = new Groups();
    for (LdapGroup entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#end_block

#method_before
protected Group mapAdGroup(ad_groups entity) {
    return getMapper(ad_groups.class, Group.class).map(entity, null);
}
#method_after
protected Group mapAdGroup(LdapGroup entity) {
    return getMapper(LdapGroup.class, Group.class).map(entity, null);
}
#end_block

#method_before
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), ad_groups.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#method_after
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), LdapGroup.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#end_block

#method_before
protected ad_groups getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<ad_groups> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (ad_groups adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#method_after
protected LdapGroup getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<LdapGroup> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (LdapGroup adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#end_block

#method_before
protected List<ad_groups> getGroupsFromDomain() {
    return asCollection(ad_groups.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#method_after
protected List<LdapGroup> getGroupsFromDomain() {
    return asCollection(LdapGroup.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#end_block

#method_before
public ad_groups lookupGroupById(Guid id) {
    return getEntity(ad_groups.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#method_after
public LdapGroup lookupGroupById(Guid id) {
    return getEntity(LdapGroup.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#end_block

#method_before
@Override
public ad_groups lookupEntity(Guid nullId) {
    return lookupGroupById(id);
}
#method_after
@Override
public LdapGroup lookupEntity(Guid nullId) throws BackendFailureException {
    return lookupGroupById(this.id);
}
#end_block

#method_before
@Override
protected Group doPopulate(Group model, ad_groups entity) {
    return model;
}
#method_after
@Override
protected Group doPopulate(Group model, LdapGroup entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(vm.getUsb(), lookupCluster(staticVm.getvds_group_id()));
        if (usbPolicy != null) {
            staticVm.setusb_policy(usbPolicy);
        }
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        staticVm.setusb_policy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), lookupCluster(staticVm.getvds_group_id())));
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
private Response cloneVmFromSnapshot(VmStatic staticVm, String snapshotId, HashMap<Guid, DiskImage> images) {
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreation(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
private Response cloneVmFromSnapshot(VmStatic staticVm, String snapshotId, HashMap<Guid, DiskImage> images) {
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreate(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreation(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreation(VdcActionType.AddVm, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    return performCreation(VdcActionType.AddVmFromScratch, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
private void addInlineStatistics(VM vm) {
    EntityIdResolver resolver = new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(vm.getId()));
    BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM> statisticsResource = inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, Guid.createGuidFromString(vm.getId()), query));
    Statistics statistics = statisticsResource.list();
    vm.setStatistics(statistics);
}
#method_after
private void addInlineStatistics(VM vm) {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(vm.getId()));
    BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM> statisticsResource = inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, Guid.createGuidFromString(vm.getId()), query));
    Statistics statistics = statisticsResource.list();
    vm.setStatistics(statistics);
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    model = addInlineDetails(details, model);
    if (details.contains(Detail.STATISTICS)) {
        addInlineStatistics(model);
    }
    // setPayload(model); //TODO: removed due to (potential) performance issue, but we will need to find another way to get payload information for *all* VMs, such as a designated backend query.
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setCertificateInfo(model);
    return model;
}
#end_block

#method_before
@Override
public Template update(Template incoming) {
    validateEnums(Template.class, incoming);
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class), VdcActionType.UpdateVmTemplate, new UpdateParametersProvider());
}
#method_after
@Override
public Template update(Template incoming) {
    validateEnums(Template.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class), VdcActionType.UpdateVmTemplate, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(incoming.getUsb(), lookupCluster(updated.getvds_group_id()));
    if (usbPolicy != null) {
        updated.setusb_policy(usbPolicy);
    }
    return new UpdateVmTemplateParameters(updated);
}
#method_after
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setusb_policy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getusb_policy(), lookupCluster(updated.getvds_group_id())));
    return new UpdateVmTemplateParameters(updated);
}
#end_block

#method_before
@Override
public VmPool update(VmPool incoming) {
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class), VdcActionType.UpdateVmPoolWithVms, new UpdateParametersProvider());
}
#method_after
@Override
public VmPool update(VmPool incoming) {
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class), VdcActionType.UpdateVmPoolWithVms, new UpdateParametersProvider());
}
#end_block

#method_before
public org.ovirt.engine.api.model.VM lookupEntity(Guid id) throws BackendFailureException {
    VM vm = doGetEntity(VM.class, query, getQueryParams(queryParamsClass, id), id.toString());
    org.ovirt.engine.api.model.VM model = new org.ovirt.engine.api.model.VM();
    model.setId(vm.getId().toString());
    return LinkHelper.addLinks(getUriInfo(), model);
}
#method_after
@Override
public Object lookupEntity(Object id) throws BackendFailureException {
    VM vm = doGetEntity(VM.class, query, getQueryParams(queryParamsClass, id), id.toString());
    org.ovirt.engine.api.model.VM model = new org.ovirt.engine.api.model.VM();
    model.setId(vm.getId().toString());
    return LinkHelper.addLinks(getUriInfo(), model);
}
#end_block

#method_before
@Override
protected boolean matchEntity(Q entity, Guid id) {
    return id.equals(CDROM_ID) && parentId.equals(entity.getQueryableId());
}
#method_after
@Override
protected <T> boolean matchEntity(Q entity, T id) {
    return id.equals(CDROM_ID) && parentId.equals(entity.getQueryableId());
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(map(lookupEntity(asGuid(disk.getId())))).build();
    } else {
        validateDiskForCreation(disk);
        return performCreation(addAction, getAddParameters(map(disk), disk), getEntityIdResolver(disk.getName()));
    }
}
#method_after
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(map(lookupEntity(asGuid(disk.getId())))).build();
    } else {
        validateDiskForCreation(disk);
        return performCreate(addAction, getAddParameters(map(disk), disk), getEntityIdResolver(disk.getName()));
    }
}
#end_block

#method_before
@Override
protected boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, String name) {
    return false;
}
#method_after
@Override
protected <T> boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, T id) {
    return id != null && (id.equals(entity.getId()));
}
#end_block

#method_before
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return model;
}
#end_block

#method_before
@Override
protected Group doPopulate(Group model, ad_groups entity) {
    return model;
}
#method_after
@Override
protected Group doPopulate(Group model, LdapGroup entity) {
    return model;
}
#end_block

#method_before
@Override
public Tag update(Tag incoming) {
    if (parent.isSetParentName(incoming)) {
        incoming.getParent().getTag().setId(parent.getParentId(incoming));
    }
    Tag existingTag = get();
    String existingTagParentId = existingTag.isSetParent() && existingTag.getParent().isSetTag() && existingTag.getParent().getTag().isSetId() ? existingTag.getParent().getTag().getId() : null;
    if (isSetParent(incoming) && !incoming.getParent().getTag().getId().equals(existingTagParentId)) {
        moveTag(asGuid(incoming.getParent().getTag().getId()));
    }
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetTagByTagId, GetTagByTagIdParameters.class), VdcActionType.UpdateTag, new UpdateParametersProvider());
}
#method_after
@Override
public Tag update(Tag incoming) {
    if (parent.isSetParentName(incoming)) {
        incoming.getParent().getTag().setId(parent.getParentId(incoming));
    }
    Tag existingTag = get();
    String existingTagParentId = existingTag.isSetParent() && existingTag.getParent().isSetTag() && existingTag.getParent().getTag().isSetId() ? existingTag.getParent().getTag().getId() : null;
    if (isSetParent(incoming) && !incoming.getParent().getTag().getId().equals(existingTagParentId)) {
        moveTag(asGuid(incoming.getParent().getTag().getId()));
    }
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetTagByTagId, GetTagByTagIdParameters.class), VdcActionType.UpdateTag, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public Hosts list() {
    // Filtered users are not allowed to view hosts
    if (isFiltered()) {
        throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.GlusterOnly) {
        return listGlusterOnly();
    } else {
        return listAll();
    }
}
#method_after
@Override
public Hosts list() {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.GlusterOnly) {
        return listGlusterOnly();
    } else {
        return listAll();
    }
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreation(VdcActionType.AddVds, addParams, new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreate(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#end_block

#method_before
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = addStatistics(model, entity, uriInfo, httpHeaders);
    addCertificateInfo(host);
    return host;
}
#method_after
@Override
protected Host doPopulate(Host model, VDS entity) {
    return model;
}
#end_block

#method_before
public HostStorage list() {
    HostStorage ret = new HostStorage();
    for (LUNs lun : getLogicalUnits()) {
        Storage storage = map(lun);
        ArrayList<storage_server_connections> lunConnections = lun.getLunConnections();
        if (lunConnections != null && !lunConnections.isEmpty()) {
            getMapper(storage_server_connections.class, LogicalUnit.class).map(lunConnections.get(0), storage.getLogicalUnits().get(0));
        }
        ret.getStorage().add(addLinks(storage));
    }
    for (storage_domains vg : getVolumeGroups()) {
        ret.getStorage().add(addLinks(map(vg)));
    }
    return ret;
}
#method_after
public HostStorage list() {
    HostStorage ret = new HostStorage();
    for (LUNs lun : getLogicalUnits()) {
        Storage storage = map(lun);
        ArrayList<StorageServerConnections> lunConnections = lun.getLunConnections();
        if (lunConnections != null && !lunConnections.isEmpty()) {
            getMapper(StorageServerConnections.class, LogicalUnit.class).map(lunConnections.get(0), storage.getLogicalUnits().get(0));
        }
        ret.getStorage().add(addLinks(storage));
    }
    for (storage_domains vg : getVolumeGroups()) {
        ret.getStorage().add(addLinks(map(vg)));
    }
    return ret;
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#method_after
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreate(VdcActionType.AddDisk, params, new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#end_block

#method_before
@Override
public Disks list() {
    return mapCollection(getBackendCollection(SearchType.Disk));
}
#method_after
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisks, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#end_block

#method_before
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        Guid clusterId = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(parentId), "id").getvds_group_id();
        Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
        if (net != null) {
            ni.setNetworkName(net.getname());
        }
    }
    return ni;
}
#method_after
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        if (device.isSetId() || device.isSetName()) {
            Guid clusterId = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(parentId), "id").getvds_group_id();
            Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
            if (net != null) {
                ni.setNetworkName(net.getName());
            }
        } else {
            ni.setNetworkName(null);
        }
    }
    return ni;
}
#end_block

#method_before
@Override
public Response add(Permit permit) {
    validateParameters(permit, "name|id");
    validateEnums(Permit.class, permit);
    ArrayList<ActionGroup> actionGroups = new ArrayList<ActionGroup>();
    actionGroups.add(map(permit));
    return performCreation(VdcActionType.AttachActionGroupsToRole, new ActionGroupsToRoleParameter(roleId, actionGroups), new PermitIdResolver(actionGroups.get(0)));
}
#method_after
@Override
public Response add(Permit permit) {
    validateParameters(permit, "name|id");
    validateEnums(Permit.class, permit);
    ArrayList<ActionGroup> actionGroups = new ArrayList<ActionGroup>();
    actionGroups.add(map(permit));
    return performCreate(VdcActionType.AttachActionGroupsToRole, new ActionGroupsToRoleParameter(roleId, actionGroups), new PermitIdResolver(actionGroups.get(0)));
}
#end_block

#method_before
@Override
public ActionGroup lookupEntity(Guid guid) {
    return actionGroup;
}
#method_after
@Override
public ActionGroup lookupEntity(Guid id) {
    return actionGroup;
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreation(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        ad_groups group = new ad_groups();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        LdapGroup group = new LdapGroup();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#end_block

#method_before
@Override
public Response add(Role role) {
    validateParameters(role, "name", "permits.id");
    validateEnums(Role.class, role);
    return performCreation(VdcActionType.AddRoleWithActionGroups, new RoleWithActionGroupsParameters(map(role), mapPermits(role.getPermits().getPermits())), new QueryIdResolver(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class));
}
#method_after
@Override
public Response add(Role role) {
    validateParameters(role, "name", "permits.id");
    validateEnums(Role.class, role);
    return performCreate(VdcActionType.AddRoleWithActionGroups, new RoleWithActionGroupsParameters(map(role), mapPermits(role.getPermits().getPermits())), new QueryIdResolver<Guid>(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class));
}
#end_block

#method_before
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    BackendVmNicsResource parent = (BackendVmNicsResource) collection;
    Guid clusterId = parent.getClusterId();
    org.ovirt.engine.core.common.businessentities.Network network = parent.getClusterNetwork(clusterId, null, model.getNetwork().getName());
    String networkId = network == null ? null : network.getId().toString();
    model.getNetwork().setId(networkId);
    model.getNetwork().setName(null);
    if (entity.isPortMirroring()) {
        PortMirroring portMirroring = new PortMirroring();
        Networks networks = new Networks();
        Network net = new Network();
        net.setId(networkId);
        net.setName(network.getname());
        portMirroring.setNetworks(networks);
        portMirroring.getNetworks().getNetworks().add(net);
        model.setPortMirroring(portMirroring);
    }
    return parent.addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    BackendVmNicsResource parent = (BackendVmNicsResource) collection;
    parent.addReportedDevices(model, entity);
    return model;
}
#end_block

#method_before
@Override
public NIC update(NIC device) {
    // TODO: this is temporary mapping between engine boolean port mirroring parameter, and REST
    // port mirroring network collection, next engine version will support the network collection
    // in port mirroring
    validateEnums(NIC.class, device);
    boolean fault = false;
    String faultString = "The port mirroring network must match the Network set on the NIC";
    boolean isPortMirroring = device.isSetPortMirroring() && device.getPortMirroring().isSetNetworks();
    boolean isPortMirroringExceeded = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() > 1;
    isPortMirroring = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() == 1;
    if (isPortMirroringExceeded) {
        fault = true;
        faultString = "Cannot set more than one network in port mirroring mode";
    }
    String networkId = (device.isSetNetwork() && device.getNetwork().isSetId()) ? device.getNetwork().getId() : null;
    String networkName = (device.isSetNetwork() && device.getNetwork().isSetName()) ? device.getNetwork().getName() : null;
    if (!fault && isPortMirroring) {
        Network pmNetwork = device.getPortMirroring().getNetworks().getNetworks().get(0);
        String pmNetworkId = (pmNetwork.isSetId() ? pmNetwork.getId() : null);
        String pmNetworkName = (pmNetwork.isSetName() ? pmNetwork.getName() : null);
        if (pmNetworkId != null) {
            if (networkId == null) {
                networkId = (networkName != null) ? getNetworkId(networkName) : get().getNetwork().getId();
            }
            fault = (!pmNetworkId.equals(networkId));
        } else if (pmNetworkName != null) {
            if (networkName == null) {
                if (networkId == null) {
                    networkId = get().getNetwork().getId();
                }
                pmNetworkId = getNetworkId(pmNetworkName);
                fault = (!networkId.equals(pmNetworkId));
            }
            fault = fault || (!pmNetworkName.equals(networkName));
        } else {
            fault = true;
            faultString = "Network must have name or id property for port mirroring";
        }
    }
    if (fault) {
        Fault f = new Fault();
        f.setReason(faultString);
        Response response = Response.status(Response.Status.BAD_REQUEST).entity(f).build();
        throw new WebApplicationException(response);
    }
    return super.update(device);
}
#method_after
@Override
public NIC update(NIC device) {
    validateEnums(NIC.class, device);
    if (device.isSetPortMirroring() || device.isSetNetwork()) {
        validatePortMirroring(device);
    }
    return super.update(device);
}
#end_block

#method_before
private String getNetworkId(String networkName) {
    BackendVmNicsResource parent = (BackendVmNicsResource) collection;
    Guid clusterId = parent.getClusterId();
    org.ovirt.engine.core.common.businessentities.Network n = parent.getClusterNetwork(clusterId, null, networkName);
    if (n != null) {
        return n.getId().toString();
    }
    return null;
}
#method_after
private String getNetworkId(String networkName) {
    if (networkName != null) {
        BackendVmNicsResource parent = (BackendVmNicsResource) collection;
        Guid clusterId = parent.getClusterId();
        org.ovirt.engine.core.common.businessentities.network.Network n = parent.getClusterNetwork(clusterId, null, networkName);
        if (n != null) {
            return n.getId().toString();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public Response activate(Action action) {
    ActivateDeactivateVmNicParameters params = new ActivateDeactivateVmNicParameters(guid, PlugAction.PLUG);
    BackendNicsResource parent = (BackendNicsResource) collection;
    params.setVmId(parent.parentId);
    return doAction(VdcActionType.ActivateDeactivateVmNic, params, action);
}
#method_after
@Override
public Response activate(Action action) {
    NIC nic = get();
    nic.setPlugged(true);
    update(nic);
    return actionSuccess(action);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    ActivateDeactivateVmNicParameters params = new ActivateDeactivateVmNicParameters(guid, PlugAction.UNPLUG);
    params.setVmId(((BackendNicsResource) collection).parentId);
    return doAction(VdcActionType.ActivateDeactivateVmNic, params, action);
}
#method_after
@Override
public Response deactivate(Action action) {
    NIC nic = get();
    nic.setPlugged(false);
    update(nic);
    return actionSuccess(action);
}
#end_block

#method_before
@Override
public Role update(Role role) {
    validateEnums(Role.class, role);
    return performUpdate(role, new QueryIdResolver(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class), VdcActionType.UpdateRole, new UpdateParametersProvider());
}
#method_after
@Override
public Role update(Role role) {
    validateEnums(Role.class, role);
    return performUpdate(role, new QueryIdResolver<Guid>(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class), VdcActionType.UpdateRole, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected Action doPopulate(Action model, List entity) {
    model.setId(asString(ids));
    if (model.isSetFault()) {
        setReason(model.getFault());
    }
    return model;
}
#method_after
@Override
protected Action doPopulate(Action model, List entity) {
    return model;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Collection<VmTemplate> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    params.setGetAll(true);
    Map<VmTemplate, DiskImageList> ret = getEntity(HashMap.class, VdcQueryType.GetTemplatesFromExportDomain, params, "Templates under storage domain id : " + storageDomainId.toString());
    return ret.keySet();
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Collection<VmTemplate> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    Map<VmTemplate, DiskImageList> ret = getEntity(HashMap.class, VdcQueryType.GetTemplatesFromExportDomain, params, "Templates under storage domain id : " + storageDomainId.toString());
    return ret.keySet();
}
#end_block

#method_before
@Override
public Events list() {
    return mapCollection(getBackendCollection());
}
#method_after
@Override
public Events list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllEventMessages, new GetEventMessagesParameters()));
    } else {
        return mapCollection(getBackendCollection());
    }
}
#end_block

#method_before
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return new BackendEventResource(id, this);
}
#method_after
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return inject(new BackendEventResource(id, this));
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveExternalEvent, new RemoveExternalEventParameters(asLong(id)));
}
#end_block

#method_before
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    if (namedCluster(pool)) {
        pool.getCluster().setId(getClusterId(pool));
    }
    vm_pools entity = map(pool);
    entity.setvm_pool_type(VmPoolType.Automatic);
    VM vm = mapToVM(pool, template);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    return performCreation(VdcActionType.AddVmPoolWithVms, new AddVmPoolWithVmsParameters(entity, vm, size, -1), new QueryIdResolver(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class));
}
#method_after
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    if (namedCluster(pool)) {
        pool.getCluster().setId(getClusterId(pool));
    }
    vm_pools entity = map(pool);
    entity.setvm_pool_type(VmPoolType.Automatic);
    VM vm = mapToVM(pool, template);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    return performCreate(VdcActionType.AddVmPoolWithVms, new AddVmPoolWithVmsParameters(entity, vm, size, -1), new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class));
}
#end_block

#method_before
@Override
public VmPool doPopulate(VmPool pool, vm_pools entity) {
    if (pool.isSetSize() && pool.getSize() > 0) {
        VM vm = getEntity(VM.class, SearchType.VM, "Vms: pool=" + pool.getName());
        pool.setTemplate(new Template());
        pool.getTemplate().setId(vm.getVmtGuid().toString());
    }
    return pool;
}
#method_after
@Override
public VmPool doPopulate(VmPool pool, vm_pools entity) {
    return pool;
}
#end_block

#method_before
@Override
protected Collection<org.ovirt.engine.core.common.businessentities.VM> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    params.setGetAll(true);
    return getBackendCollection(VdcQueryType.GetVmsFromExportDomain, params);
}
#method_after
@Override
protected Collection<org.ovirt.engine.core.common.businessentities.VM> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    return getBackendCollection(VdcQueryType.GetVmsFromExportDomain, params);
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    QueryIdResolver hostResolver = new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && incoming.getCluster().isSetId() && !asGuid(incoming.getCluster().getId()).equals(entity.getvds_group_id())) {
        performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(asGuid(incoming.getCluster().getId()), guid));
    }
    return performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
}
#method_after
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && incoming.getCluster().isSetId() && !asGuid(incoming.getCluster().getId()).equals(entity.getvds_group_id())) {
        performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(asGuid(incoming.getCluster().getId()), guid));
    }
    return performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    storage_server_connections cnx = new storage_server_connections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    // TODO: when VSDM and Backend will support this, we will need to externalize this parameter to the user
    cnx.setportal("0");
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#method_after
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    // TODO: when VSDM and Backend will support this, we will need to externalize this parameter to the user
    cnx.setportal("0");
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#end_block

#method_before
public Response iscsiDiscover(Action action) {
    validateParameters(action, "iscsi.address");
    List<storage_server_connections> result = getBackendCollection(storage_server_connections.class, VdcQueryType.DiscoverSendTargets, createDiscoveryQueryParams(action));
    return actionSuccess(mapTargets(action, result));
}
#method_after
public Response iscsiDiscover(Action action) {
    validateParameters(action, "iscsi.address");
    List<StorageServerConnections> result = getBackendCollection(StorageServerConnections.class, VdcQueryType.DiscoverSendTargets, createDiscoveryQueryParams(action));
    return actionSuccess(mapTargets(action, result));
}
#end_block

#method_before
private Action mapTargets(Action action, List<storage_server_connections> targets) {
    if (targets != null) {
        for (storage_server_connections cnx : targets) {
            action.getIscsiTargets().add(map(cnx).getTarget());
        }
    }
    return action;
}
#method_after
private Action mapTargets(Action action, List<StorageServerConnections> targets) {
    if (targets != null) {
        for (StorageServerConnections cnx : targets) {
            action.getIscsiTargets().add(map(cnx).getTarget());
        }
    }
    return action;
}
#end_block

#method_before
protected LogicalUnit map(storage_server_connections cnx) {
    return getMapper(storage_server_connections.class, LogicalUnit.class).map(cnx, null);
}
#method_after
protected LogicalUnit map(StorageServerConnections cnx) {
    return getMapper(StorageServerConnections.class, LogicalUnit.class).map(cnx, null);
}
#end_block

#method_before
private DiscoverSendTargetsQueryParameters createDiscoveryQueryParams(Action action) {
    storage_server_connections connectionDetails = new storage_server_connections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setconnection(iscsiDetails.getAddress());
    connectionDetails.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setport(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setpassword(iscsiDetails.getPassword());
    }
    return new DiscoverSendTargetsQueryParameters(guid, connectionDetails);
}
#method_after
private DiscoverSendTargetsQueryParameters createDiscoveryQueryParams(Action action) {
    StorageServerConnections connectionDetails = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setconnection(iscsiDetails.getAddress());
    connectionDetails.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setport(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setpassword(iscsiDetails.getPassword());
    }
    return new DiscoverSendTargetsQueryParameters(guid, connectionDetails);
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    HostStatisticalQuery query = new HostStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Host, VDS>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    HostStatisticalQuery query = new HostStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Host, VDS>(entityType, guid, query));
}
#end_block

#method_before
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = parent.addStatistics(model, entity, uriInfo, httpHeaders);
    parent.addCertificateInfo(host);
    return host;
}
#method_after
@Override
protected Host doPopulate(Host model, VDS entity) {
    return model;
}
#end_block

#method_before
@Override
protected boolean matchEntity(VmNetworkInterface entity, Guid id) {
    return id.equals(entity.getId());
}
#method_after
@Override
protected <T> boolean matchEntity(VmNetworkInterface entity, T id) {
    return id.equals(entity.getId());
}
#end_block

#method_before
@Override
public Response add(Role role) {
    validateParameters(role, "id|name");
    validateEnums(Role.class, role);
    if (!role.isSetId()) {
        org.ovirt.engine.core.common.businessentities.Role entity = getEntity(org.ovirt.engine.core.common.businessentities.Role.class, VdcQueryType.GetRoleByName, new MultilevelAdministrationByRoleNameParameters(role.getName()), role.getName());
        role.setId(entity.getId().toString());
    }
    return performCreation(VdcActionType.AddSystemPermission, new PermissionsOperationsParametes(newPermission(role.getId())), new QueryIdResolver(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Role role) {
    validateParameters(role, "id|name");
    validateEnums(Role.class, role);
    if (!role.isSetId()) {
        org.ovirt.engine.core.common.businessentities.Role entity = getEntity(org.ovirt.engine.core.common.businessentities.Role.class, VdcQueryType.GetRoleByName, new MultilevelAdministrationByRoleNameParameters(role.getName()), role.getName());
        role.setId(entity.getId().toString());
    }
    return performCreate(VdcActionType.AddSystemPermission, new PermissionsOperationsParametes(newPermission(role.getId())), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
@Override
public Response add(NIC device) {
    // TODO: this is temporary mapping between engine boolean port mirroring parameter, and REST
    // port mirroring network collection, next engine version will support the network collection
    // in port mirroring
    validateEnums(NIC.class, device);
    boolean fault = false;
    String faultString = "The port mirroring network must match the Network set on the NIC";
    boolean isPortMirroring = device.isSetPortMirroring() && device.getPortMirroring().isSetNetworks();
    boolean isPortMirroringExceeded = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() > 1;
    if (!fault && isPortMirroringExceeded) {
        fault = true;
        faultString = "Cannot set more than one network in port mirroring mode";
    }
    isPortMirroring = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() == 1;
    if (!fault && isPortMirroring) {
        org.ovirt.engine.api.model.Network pmNetwork = device.getPortMirroring().getNetworks().getNetworks().get(0);
        String pmNetworkId = (pmNetwork.isSetId() ? pmNetwork.getId() : null);
        String pmNetworkName = (pmNetwork.isSetName() ? pmNetwork.getName() : null);
        String networkId = (device.isSetNetwork() && device.getNetwork().isSetId()) ? device.getNetwork().getId() : null;
        String networkName = (device.isSetNetwork() && device.getNetwork().isSetName()) ? device.getNetwork().getName() : null;
        if (pmNetworkId != null) {
            networkId = (networkId == null) ? getNetworkId(networkName) : networkId;
            fault = (!pmNetworkId.equals(networkId));
        } else if (pmNetworkName != null) {
            if (networkName == null && networkId != null) {
                pmNetworkId = getNetworkId(pmNetworkName);
                fault = (!pmNetworkId.equals(networkId));
            }
            fault = fault || (!pmNetworkName.equals(networkName));
        } else {
            fault = true;
            faultString = "Network must have name or id property for port mirroring";
        }
    }
    if (fault) {
        Fault f = new Fault();
        f.setReason(faultString);
        Response response = Response.status(Response.Status.BAD_REQUEST).entity(f).build();
        throw new WebApplicationException(response);
    }
    return super.add(device);
}
#method_after
@Override
public Response add(NIC device) {
    // TODO: this is temporary mapping between engine boolean port mirroring parameter, and REST
    // port mirroring network collection, next engine version will support the network collection
    // in port mirroring
    validateEnums(NIC.class, device);
    boolean fault = false;
    String faultString = "The port mirroring network must match the Network set on the NIC";
    boolean isPortMirroring = device.isSetPortMirroring() && device.getPortMirroring().isSetNetworks();
    boolean isPortMirroringExceeded = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() > 1;
    if (!fault && isPortMirroringExceeded) {
        fault = true;
        faultString = "Cannot set more than one network in port mirroring mode";
    }
    isPortMirroring = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() == 1;
    if (!fault && isPortMirroring) {
        org.ovirt.engine.api.model.Network pmNetwork = device.getPortMirroring().getNetworks().getNetworks().get(0);
        String pmNetworkId = (pmNetwork.isSetId() ? pmNetwork.getId() : null);
        String pmNetworkName = (pmNetwork.isSetName() ? pmNetwork.getName() : null);
        String networkId = (device.isSetNetwork() && device.getNetwork().isSetId()) ? device.getNetwork().getId() : null;
        String networkName = (device.isSetNetwork() && device.getNetwork().isSetName()) ? device.getNetwork().getName() : null;
        if (networkName != null || networkId != null) {
            if (pmNetworkId != null) {
                networkId = (networkId == null) ? getNetworkId(networkName) : networkId;
                fault = (!networkId.equals(pmNetworkId));
            } else if (pmNetworkName != null) {
                if (networkName == null && networkId != null) {
                    pmNetworkId = getNetworkId(pmNetworkName);
                    fault = (!networkId.equals(pmNetworkId));
                }
                fault = fault || (!pmNetworkName.equals(networkName));
            } else {
                fault = true;
                faultString = "Network must have name or id property for port mirroring";
            }
        }
    }
    if (fault) {
        Fault f = new Fault();
        f.setReason(faultString);
        Response response = Response.status(Response.Status.BAD_REQUEST).entity(f).build();
        throw new WebApplicationException(response);
    }
    return super.add(device);
}
#end_block

#method_before
private String getNetworkId(String networkName) {
    Guid clusterId = getClusterId();
    org.ovirt.engine.core.common.businessentities.Network n = getClusterNetwork(clusterId, null, networkName);
    if (n != null) {
        return n.getId().toString();
    }
    return null;
}
#method_after
private String getNetworkId(String networkName) {
    if (networkName != null) {
        Guid clusterId = getClusterId();
        org.ovirt.engine.core.common.businessentities.network.Network n = getClusterNetwork(clusterId, null, networkName);
        if (n != null) {
            return n.getId().toString();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    return addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    return model;
}
#end_block

#method_before
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        Guid clusterId = getClusterId();
        Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
        if (net != null) {
            ni.setNetworkName(net.getname());
        }
    }
    return ni;
}
#method_after
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        if (device.getNetwork().isSetId() || device.getNetwork().isSetName()) {
            Guid clusterId = getClusterId();
            Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
            if (net != null) {
                ni.setNetworkName(net.getName());
            }
        } else {
            ni.setNetworkName(null);
        }
    }
    return ni;
}
#end_block

#method_before
@Override
protected Creation doPopulate(Creation model, List entity) {
    model.setId(asString(ids));
    if (model.isSetFault()) {
        setReason(model.getFault());
    }
    return model;
}
#method_after
@Override
protected Creation doPopulate(Creation model, List entity) {
    return model;
}
#end_block

#method_before
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver storageDomainResolver = new QueryIdResolver(VdcQueryType.GetStorageDomainById, StorageDomainQueryParametersBase.class);
    storage_domains entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getstorage_type();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#method_after
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver<Guid> storageDomainResolver = new QueryIdResolver<Guid>(VdcQueryType.GetStorageDomainById, StorageDomainQueryParametersBase.class);
    storage_domains entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getstorage_type();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#end_block

#method_before
private void addLunsToStorageDomain(StorageDomain incoming, StorageType storageType, List<LogicalUnit> newLuns, boolean overrideLuns) {
    for (LogicalUnit lun : newLuns) {
        if (lun.isSetAddress() && lun.isSetTarget()) {
            storage_server_connections connection = StorageDomainHelper.getConnection(storageType, lun.getAddress(), lun.getTarget(), lun.getUsername(), lun.getPassword(), lun.getPort());
            performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(connection, getHostId(incoming)));
        }
    }
    refreshVDSM(incoming);
    ExtendSANStorageDomainParameters params = createParameters(guid, newLuns, overrideLuns);
    performAction(VdcActionType.ExtendSANStorageDomain, params);
}
#method_after
private void addLunsToStorageDomain(StorageDomain incoming, StorageType storageType, List<LogicalUnit> newLuns, boolean overrideLuns) {
    for (LogicalUnit lun : newLuns) {
        if (lun.isSetAddress() && lun.isSetTarget()) {
            StorageServerConnections connection = StorageDomainHelper.getConnection(storageType, lun.getAddress(), lun.getTarget(), lun.getUsername(), lun.getPassword(), lun.getPort());
            performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(connection, getHostId(incoming)));
        }
    }
    refreshVDSM(incoming);
    ExtendSANStorageDomainParameters params = createParameters(guid, newLuns, overrideLuns);
    performAction(VdcActionType.ExtendSANStorageDomain, params);
}
#end_block

#method_before
@Override
protected StorageDomain doPopulate(StorageDomain model, storage_domains entity) {
    if (StorageDomainSharedStatus.Unattached.equals(entity.getstorage_domain_shared_status())) {
        model.setStatus(StatusUtils.create(StorageDomainStatus.UNATTACHED));
    } else {
        model.setStatus(null);
    }
    return model;
}
#method_after
@Override
protected StorageDomain doPopulate(StorageDomain model, storage_domains entity) {
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(StorageDomain incoming, storage_domains entity) {
    // save SD type before mapping
    org.ovirt.engine.core.common.businessentities.StorageDomainType currentType = entity.getStorageStaticData() == null ? null : entity.getStorageStaticData().getstorage_domain_type();
    storage_domain_static updated = getMapper(modelType, storage_domain_static.class).map(incoming, entity.getStorageStaticData());
    // if SD type was 'Master', and user gave 'Data', they are the same, this is not a real update, so exchange data back to master.
    if (currentType == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master && updated.getstorage_domain_type() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Data) {
        updated.setstorage_domain_type(org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    }
    return new StorageDomainManagementParameter(updated);
}
#method_after
@Override
public VdcActionParametersBase getParameters(StorageDomain incoming, storage_domains entity) {
    // save SD type before mapping
    org.ovirt.engine.core.common.businessentities.StorageDomainType currentType = entity.getStorageStaticData() == null ? null : entity.getStorageStaticData().getstorage_domain_type();
    StorageDomainStatic updated = getMapper(modelType, StorageDomainStatic.class).map(incoming, entity.getStorageStaticData());
    // if SD type was 'Master', and user gave 'Data', they are the same, this is not a real update, so exchange data back to master.
    if (currentType == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master && updated.getstorage_domain_type() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Data) {
        updated.setstorage_domain_type(org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    }
    return new StorageDomainManagementParameter(updated);
}
#end_block

#method_before
@Override
public Response add(Tag tag) {
    validateParameters(tag, "name");
    if (isSetParentName(tag)) {
        tag.getParent().getTag().setId(getParentId(tag));
    }
    return performCreation(VdcActionType.AddTag, new TagsOperationParameters(map(tag)), new TagNameResolver(tag.getName()));
}
#method_after
@Override
public Response add(Tag tag) {
    validateParameters(tag, "name");
    if (isSetParentName(tag)) {
        tag.getParent().getTag().setId(getParentId(tag));
    }
    return performCreate(VdcActionType.AddTag, new TagsOperationParameters(map(tag)), new TagNameResolver(tag.getName()));
}
#end_block

#method_before
@Override
public tags lookupEntity(Guid id) {
    // AddTag returns nothing, lookup name instead
    assert (id == null);
    return lookupTagByName(name);
}
#method_after
@Override
public tags lookupEntity(Guid id) throws BackendFailureException {
    // AddTag returns nothing, lookup name instead
    assert (id == null);
    return lookupTagByName(name);
}
#end_block

#method_before
protected Q getEntity(EntityIdResolver entityResolver, boolean notFoundAs404) {
    try {
        return entityResolver.resolve(guid);
    } catch (Exception e) {
        return handleError(entityType, e, notFoundAs404);
    }
}
#method_after
protected <T> Q getEntity(EntityIdResolver<T> entityResolver, boolean notFoundAs404) {
    try {
        return entityResolver.resolve((T) guid);
    } catch (Exception e) {
        return handleError(entityType, e, notFoundAs404);
    }
}
#end_block

#method_before
protected R performUpdate(R incoming, EntityIdResolver entityResolver, VdcActionType update, ParametersProvider<R, Q> updateProvider) {
    // REVISIT maintain isolation across retrievals and update
    Q entity = getEntity(entityResolver, true);
    validateUpdate(incoming, map(entity));
    performAction(update, updateProvider.getParameters(incoming, entity));
    return addLinks(doPopulate(map(getEntity(entityResolver, false)), entity));
}
#method_after
protected final R performUpdate(R incoming, Q entity, R model, EntityIdResolver<Guid> entityResolver, VdcActionType update, ParametersProvider<R, Q> updateProvider) {
    entity = doUpdate(incoming, entity, model, entityResolver, update, updateProvider);
    R model2 = map(entity);
    deprecatedPopulate(model2, entity);
    return addLinks(doPopulate(model2, entity));
}
#end_block

#method_before
public Network get() {
    org.ovirt.engine.core.common.businessentities.Network entity = parent.lookupNetwork(guid);
    if (entity == null) {
        return notFound();
    }
    return addLinks(map(entity));
}
#method_after
public Network get() {
    org.ovirt.engine.core.common.businessentities.network.Network entity = parent.lookupNetwork(guid);
    if (entity == null) {
        return notFound();
    }
    return addLinks(map(entity));
}
#end_block

#method_before
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.Network entity) {
    return model;
}
#method_after
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return model;
}
#end_block

#method_before
@Override
public HostNics list() {
    HostNics ret = new HostNics();
    List<VdsNetworkInterface> ifaces = getCollection();
    List<org.ovirt.engine.core.common.businessentities.Network> clusterNetworks = getClusterNetworks();
    Map<String, String> networkIds = new HashMap<String, String>();
    for (org.ovirt.engine.core.common.businessentities.Network nwk : clusterNetworks) {
        networkIds.put(nwk.getname(), nwk.getId().toString());
    }
    for (VdsNetworkInterface iface : ifaces) {
        HostNIC hostNic = populate(map(iface, ifaces), iface);
        if (networkIds.containsKey(iface.getNetworkName())) {
            hostNic.getNetwork().setId(networkIds.get(iface.getNetworkName()));
            hostNic.getNetwork().setName(null);
        }
        ret.getHostNics().add(addLinks(hostNic));
    }
    return addActions(ret);
}
#method_after
@Override
public HostNics list() {
    HostNics ret = new HostNics();
    List<VdsNetworkInterface> ifaces = getCollection();
    List<org.ovirt.engine.core.common.businessentities.network.Network> clusterNetworks = getClusterNetworks();
    Map<String, String> networkIds = new HashMap<String, String>();
    for (org.ovirt.engine.core.common.businessentities.network.Network nwk : clusterNetworks) {
        networkIds.put(nwk.getName(), nwk.getId().toString());
    }
    for (VdsNetworkInterface iface : ifaces) {
        HostNIC hostNic = populate(map(iface, ifaces), iface);
        if (networkIds.containsKey(iface.getNetworkName())) {
            hostNic.getNetwork().setId(networkIds.get(iface.getNetworkName()));
            hostNic.getNetwork().setName(null);
        }
        ret.getHostNics().add(addLinks(hostNic));
    }
    return addActions(ret);
}
#end_block

#method_before
@SuppressWarnings("serial")
@Override
public Response add(final HostNIC nic) {
    validateParameters(nic, "name", "network.id|name", "bonding.slaves.id|name");
    validateEnums(HostNIC.class, nic);
    return performCreation(VdcActionType.AddBond, new AddBondParameters(asGuid(hostId), nic.getName(), lookupNetwork(nic.getNetwork()), lookupSlaves(nic)) {

        {
            setBondingOptions(map(nic, null).getBondOptions());
        }
    }, new HostNicResolver(nic.getName()));
}
#method_after
@SuppressWarnings("serial")
@Override
public Response add(final HostNIC nic) {
    validateParameters(nic, "name", "network.id|name", "bonding.slaves.id|name");
    validateEnums(HostNIC.class, nic);
    return performCreate(VdcActionType.AddBond, new AddBondParameters(asGuid(hostId), nic.getName(), lookupNetwork(nic.getNetwork()), lookupSlaves(nic)) {

        {
            setBondingOptions(map(nic, null).getBondOptions());
        }
    }, new HostNicResolver(nic.getName()));
}
#end_block

#method_before
public HostNIC lookupNic(String id, boolean forcePopulate) {
    List<VdsNetworkInterface> ifaces = getCollection();
    for (VdsNetworkInterface iface : ifaces) {
        if (iface.getId().toString().equals(id)) {
            HostNIC hostNic = map(iface, ifaces);
            if (forcePopulate) {
                doPopulate(hostNic, iface);
            } else {
                populate(hostNic, iface);
            }
            for (org.ovirt.engine.core.common.businessentities.Network nwk : getClusterNetworks()) {
                if (nwk.getname().equals(iface.getNetworkName())) {
                    hostNic.getNetwork().setId(nwk.getId().toString());
                    hostNic.getNetwork().setName(null);
                    break;
                }
            }
            return addLinks(hostNic);
        }
    }
    return notFound();
}
#method_after
public HostNIC lookupNic(String id, boolean forcePopulate) {
    List<VdsNetworkInterface> ifaces = getCollection();
    for (VdsNetworkInterface iface : ifaces) {
        if (iface.getId().toString().equals(id)) {
            HostNIC hostNic = map(iface, ifaces);
            if (forcePopulate) {
                deprecatedPopulate(hostNic, iface);
                doPopulate(hostNic, iface);
            } else {
                populate(hostNic, iface);
            }
            for (org.ovirt.engine.core.common.businessentities.network.Network nwk : getClusterNetworks()) {
                if (nwk.getName().equals(iface.getNetworkName())) {
                    hostNic.getNetwork().setId(nwk.getId().toString());
                    hostNic.getNetwork().setName(null);
                    break;
                }
            }
            return addLinks(hostNic);
        }
    }
    return notFound();
}
#end_block

#method_before
protected List<VdsNetworkInterface> getCollection() {
    return getBackendCollection(VdcQueryType.GetVdsInterfacesByVdsId, new GetVdsByVdsIdParameters(asGuid(hostId)));
}
#method_after
protected List<VdsNetworkInterface> getCollection() {
    return getBackendCollection(VdcQueryType.GetVdsInterfacesByVdsId, new IdQueryParameters(asGuid(hostId)));
}
#end_block

#method_before
@Override
protected VdsNetworkInterface map(HostNIC entity, VdsNetworkInterface template) {
    VdsNetworkInterface iface = super.map(entity, template);
    if (entity.isSetNetwork()) {
        org.ovirt.engine.core.common.businessentities.Network net = lookupNetwork(entity.getNetwork());
        iface.setNetworkName(net.getname());
    }
    return iface;
}
#method_after
@Override
protected VdsNetworkInterface map(HostNIC entity, VdsNetworkInterface template) {
    VdsNetworkInterface iface = super.map(entity, template);
    if (entity.isSetNetwork()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = lookupNetwork(entity.getNetwork());
        iface.setNetworkName(net.getName());
    }
    return iface;
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.Network lookupNetwork(Network network) {
    String id = network.getId();
    String name = network.getName();
    for (org.ovirt.engine.core.common.businessentities.Network entity : getBackendCollection(org.ovirt.engine.core.common.businessentities.Network.class, VdcQueryType.GetAllNetworks, new GetAllNetworkQueryParamenters(Guid.Empty))) {
        if ((id != null && id.equals(entity.getId().toString())) || (name != null && name.equals(entity.getname()))) {
            return entity;
        }
    }
    return handleError(new EntityNotFoundException(id != null ? id : name), false);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.network.Network lookupNetwork(Network network) {
    String id = network.getId();
    String name = network.getName();
    for (org.ovirt.engine.core.common.businessentities.network.Network entity : getBackendCollection(org.ovirt.engine.core.common.businessentities.network.Network.class, VdcQueryType.GetAllNetworks, new IdQueryParameters(Guid.Empty))) {
        if ((id != null && id.equals(entity.getId().toString())) || (name != null && name.equals(entity.getName()))) {
            return entity;
        }
    }
    return handleError(new EntityNotFoundException(id != null ? id : name), false);
}
#end_block

#method_before
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return model;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<org.ovirt.engine.core.common.businessentities.Network> getClusterNetworks() {
    VDS vds = getEntity(VDS.class, VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(Guid.createGuidFromString(getHostId())), "Host");
    return getEntity(List.class, VdcQueryType.GetAllNetworksByClusterId, new VdsGroupQueryParamenters(vds.getvds_group_id()), "Networks");
}
#method_after
@SuppressWarnings("unchecked")
protected List<org.ovirt.engine.core.common.businessentities.network.Network> getClusterNetworks() {
    VDS vds = getEntity(VDS.class, VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(Guid.createGuidFromString(getHostId())), "Host");
    return getEntity(List.class, VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(vds.getvds_group_id()), "Networks");
}
#end_block

#method_before
public org.ovirt.engine.core.common.businessentities.Network lookupClusterNetwork(Network net) {
    List<org.ovirt.engine.core.common.businessentities.Network> networks = getClusterNetworks();
    if (net.isSetId()) {
        for (org.ovirt.engine.core.common.businessentities.Network nwk : networks) {
            if (nwk.getId().toString().equals(net.getId()))
                return nwk;
        }
    } else {
        String networkName = net.getName();
        for (org.ovirt.engine.core.common.businessentities.Network nwk : networks) {
            if (nwk.getname().equals(networkName))
                return nwk;
        }
    }
    return notFound(org.ovirt.engine.core.common.businessentities.Network.class);
}
#method_after
public org.ovirt.engine.core.common.businessentities.network.Network lookupClusterNetwork(Network net) {
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getClusterNetworks();
    if (net.isSetId()) {
        for (org.ovirt.engine.core.common.businessentities.network.Network nwk : networks) {
            if (nwk.getId().toString().equals(net.getId()))
                return nwk;
        }
    } else {
        String networkName = net.getName();
        for (org.ovirt.engine.core.common.businessentities.network.Network nwk : networks) {
            if (nwk.getName().equals(networkName))
                return nwk;
        }
    }
    return notFound(org.ovirt.engine.core.common.businessentities.network.Network.class);
}
#end_block

#method_before
private List<String> nicsToNetworksToSync(List<HostNIC> hostNics) {
    List<String> networks = new ArrayList<String>();
    for (HostNIC nic : hostNics) {
        if (nic.isSetOverrideConfiguration() && nic.isOverrideConfiguration() && nic.isSetNetwork()) {
            org.ovirt.engine.core.common.businessentities.Network net = lookupNetwork(nic.getNetwork());
            networks.add(net.getname());
        }
    }
    return networks;
}
#method_after
private List<String> nicsToNetworksToSync(List<HostNIC> hostNics) {
    List<String> networks = new ArrayList<String>();
    for (HostNIC nic : hostNics) {
        if (nic.isSetOverrideConfiguration() && nic.isOverrideConfiguration() && nic.isSetNetwork()) {
            org.ovirt.engine.core.common.businessentities.network.Network net = lookupNetwork(nic.getNetwork());
            networks.add(net.getName());
        }
    }
    return networks;
}
#end_block

#method_before
protected boolean isPopulate() {
    List<String> populates = httpHeaders.getRequestHeader(POPULATE);
    if (populates != null && populates.size() > 0) {
        return Boolean.valueOf(populates.get(0));
    } else {
        return false;
    }
}
#method_after
protected boolean isPopulate() {
    List<String> populates = httpHeaders.getRequestHeader(POPULATE);
    if (populates != null && populates.size() > 0) {
        return Boolean.valueOf(populates.get(0)).booleanValue();
    } else {
        return false;
    }
}
#end_block

#method_before
protected Response doAdd(Snapshot snapshot, boolean block) {
    validateParameters(snapshot, "description");
    CreateAllSnapshotsFromVmParameters snapshotParams = new CreateAllSnapshotsFromVmParameters(parentId, snapshot.getDescription());
    return performCreation(VdcActionType.CreateAllSnapshotsFromVm, snapshotParams, new SnapshotIdResolver(), block);
}
#method_after
protected Response doAdd(Snapshot snapshot, boolean block) {
    validateParameters(snapshot, "description");
    CreateAllSnapshotsFromVmParameters snapshotParams = new CreateAllSnapshotsFromVmParameters(parentId, snapshot.getDescription());
    return performCreate(VdcActionType.CreateAllSnapshotsFromVm, snapshotParams, new SnapshotIdResolver(), block);
}
#end_block

#method_before
@Override
public org.ovirt.engine.core.common.businessentities.Snapshot lookupEntity(Guid id) {
    return getSnapshotById(id);
}
#method_after
@Override
public org.ovirt.engine.core.common.businessentities.Snapshot lookupEntity(Guid id) throws BackendFailureException {
    return getSnapshotById(id);
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getActionParameters(network, entity);
    return performCreation(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getActionParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
@Override
public Networks list() {
    Networks networks = mapCollection(getBackendCollection(queryType, getQueryParameters()));
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#method_after
@Override
public Networks list() {
    Networks networks;
    if (isFiltered()) {
        networks = mapCollection(getBackendCollection(queryType, getQueryParameters()));
    } else {
        networks = mapCollection(getBackendCollection(SearchType.Network));
    }
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#end_block

#method_before
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new GetAllNetworkQueryParamenters(Guid.Empty);
}
#method_after
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new IdQueryParameters(Guid.Empty);
}
#end_block

#method_before
@Override
protected AddNetworkStoragePoolParameters getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.Network entity) {
    if (namedDataCenter(network)) {
        entity.setstorage_pool_id(getDataCenterId(network));
    }
    return new AddNetworkStoragePoolParameters(entity.getstorage_pool_id().getValue(), entity);
}
#method_after
@Override
protected AddNetworkStoragePoolParameters getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    if (namedDataCenter(network)) {
        entity.setDataCenterId(getDataCenterId(network));
    }
    return new AddNetworkStoragePoolParameters(entity.getDataCenterId().getValue(), entity);
}
#end_block

#method_before
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.Network entity) {
    return model;
}
#method_after
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return model;
}
#end_block

#method_before
@Override
protected Group doPopulate(Group model, ad_groups entity) {
    return model;
}
#method_after
@Override
protected Group doPopulate(Group model, LdapGroup entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    validateEnumParameters(volume);
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreation(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class), true);
}
#method_after
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    validateEnumParameters(volume);
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreate(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver<Guid>(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class), true);
}
#end_block

#method_before
private Collection<DetailedLink> getLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks"));
    links.add(createLink("roles"));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE));
    links.add(createLink("tags"));
    links.add(createLink("templates", LinkFlags.SEARCHABLE));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE));
    links.add(createLink("vms", LinkFlags.SEARCHABLE));
    links.add(createLink("disks", LinkFlags.SEARCHABLE));
    return links;
}
#method_after
private Collection<DetailedLink> getLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks", LinkFlags.SEARCHABLE));
    links.add(createLink("roles"));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE));
    links.add(createLink("tags"));
    links.add(createLink("templates", LinkFlags.SEARCHABLE));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE));
    links.add(createLink("vms", LinkFlags.SEARCHABLE));
    links.add(createLink("disks", LinkFlags.SEARCHABLE));
    return links;
}
#end_block

#method_before
private Collection<DetailedLink> getGlusterLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks"));
    links.add(createLink("roles"));
    links.add(createLink("tags"));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    return links;
}
#method_after
private Collection<DetailedLink> getGlusterLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks", LinkFlags.SEARCHABLE));
    links.add(createLink("roles"));
    links.add(createLink("tags"));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    return links;
}
#end_block

#method_before
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, "name", "dataCenter.name|id");
    validateEnums(Cluster.class, cluster);
    storage_pool pool = getStoragePool(cluster, this);
    VDSGroup entity = map(cluster, map(pool));
    return performCreation(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(entity), new QueryIdResolver(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class));
}
#method_after
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, "name", "dataCenter.name|id");
    validateEnums(Cluster.class, cluster);
    storage_pool pool = getStoragePool(cluster, this);
    VDSGroup entity = map(cluster, map(pool));
    return performCreate(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class));
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#method_after
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, guid, query));
}
#end_block

#method_before
protected Guid getStorageDomainId(Action action) {
    if (action.getStorageDomain().isSetId()) {
        return asGuid(action.getStorageDomain().getId());
    } else {
        return lookupStorageDomainIdByName(action.getStorageDomain().getName());
    }
}
#method_after
@Override
protected Guid getStorageDomainId(Action action) {
    if (action.getStorageDomain().isSetId()) {
        return asGuid(action.getStorageDomain().getId());
    } else {
        return lookupStorageDomainIdByName(action.getStorageDomain().getName());
    }
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(storage_domains.class, SearchType.StorageDomain, "Storage: name=" + name).getId();
}
#method_after
@Override
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(storage_domains.class, SearchType.StorageDomain, "Storage: name=" + name).getId();
}
#end_block

#method_before
@Override
public Response ticket(Action action) {
    return doAction(VdcActionType.SetVmTicket, new SetVmTicketParameters(guid, getTicketValue(action), getTicketExpiry(action)), action);
}
#method_after
@Override
public Response ticket(Action action) {
    final Response response = doAction(VdcActionType.SetVmTicket, new SetVmTicketParameters(guid, getTicketValue(action), getTicketExpiry(action)), action);
    final Action actionResponse = (Action) response.getEntity();
    if (CreationStatus.FAILED.value().equals(actionResponse.getStatus().getState())) {
        actionResponse.getTicket().setValue(null);
        actionResponse.getTicket().setExpiry(null);
    }
    return response;
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    parent.addInlineDetails(details, model);
    addStatistics(model, entity, uriInfo, httpHeaders);
    parent.setPayload(model);
    setBallooning(model);
    setCertificateInfo(model);
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(incoming.getUsb(), lookupCluster(updated.getvds_group_id()));
    if (usbPolicy != null) {
        updated.setusb_policy(usbPolicy);
    }
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        params.setVmPayload(parent.getPayload(incoming));
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setusb_policy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getvds_group_id())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#end_block

#method_before
@Override
public Response add(Network network) {
    // right now, name is mandatory (future - id alone will be enough)
    validateParameters(network, "name");
    if (!network.isSetId()) {
        network.setId(getNetworkId(network.getName(), clusterId));
    }
    org.ovirt.engine.core.common.businessentities.Network entity = map(network);
    return performCreation(addAction, getActionParameters(network, entity), new NetworkIdResolver(network.getName()));
}
#method_after
@Override
public Response add(Network network) {
    // right now, name is mandatory (future - id alone will be enough)
    validateParameters(network, "name");
    if (!network.isSetId()) {
        network.setId(getNetworkId(network.getName(), clusterId));
    }
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    return performCreate(addAction, getActionParameters(network, entity), new NetworkIdResolver(network.getName()));
}
#end_block

#method_before
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new VdsGroupQueryParamenters(asGuid(clusterId));
}
#method_after
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new IdQueryParameters(asGuid(clusterId));
}
#end_block

#method_before
@Override
protected VdcActionParametersBase getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.Network entity) {
    return new AttachNetworkToVdsGroupParameter(getVDSGroup(), entity);
}
#method_after
@Override
protected VdcActionParametersBase getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return new AttachNetworkToVdsGroupParameter(getVDSGroup(), entity);
}
#end_block

#method_before
private String getNetworkId(String networkName, String clusterId) {
    NGuid dataCenterId = getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupById, new GetVdsGroupByIdParameters(asGuid(clusterId)), null).getStoragePoolId();
    GetAllNetworkQueryParamenters params = new GetAllNetworkQueryParamenters(asGuid(dataCenterId));
    List<org.ovirt.engine.core.common.businessentities.Network> networks = getBackendCollection(VdcQueryType.GetAllNetworks, params);
    for (org.ovirt.engine.core.common.businessentities.Network nw : networks) {
        if (nw.getname().equals(networkName)) {
            return nw.getId().toString();
        }
    }
    return null;
}
#method_after
private String getNetworkId(String networkName, String clusterId) {
    NGuid dataCenterId = getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupById, new GetVdsGroupByIdParameters(asGuid(clusterId)), null).getStoragePoolId();
    IdQueryParameters params = new IdQueryParameters(asGuid(dataCenterId));
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getBackendCollection(VdcQueryType.GetAllNetworks, params);
    for (org.ovirt.engine.core.common.businessentities.network.Network nw : networks) {
        if (nw.getName().equals(networkName)) {
            return nw.getId().toString();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.Network entity) {
    return model;
}
#method_after
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(Quota quota) {
    validateParameters(quota, "name");
    org.ovirt.engine.core.common.businessentities.Quota entity = map(quota);
    entity.setStoragePoolId(dataCenterId);
    return performCreation(VdcActionType.AddQuota, new QuotaCRUDParameters(entity), new QueryIdResolver(VdcQueryType.GetQuotaByQuotaId, GetQuotaByQuotaIdQueryParameters.class));
}
#method_after
@Override
public Response add(Quota quota) {
    validateParameters(quota, "name");
    org.ovirt.engine.core.common.businessentities.Quota entity = map(quota);
    entity.setStoragePoolId(dataCenterId);
    return performCreate(VdcActionType.AddQuota, new QuotaCRUDParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetQuotaByQuotaId, GetQuotaByQuotaIdQueryParameters.class));
}
#end_block

#method_before
@Override
public DataCenter update(DataCenter incoming) {
    validateEnums(DataCenter.class, incoming);
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class), VdcActionType.UpdateStoragePool, new UpdateParametersProvider());
}
#method_after
@Override
public DataCenter update(DataCenter incoming) {
    validateEnums(DataCenter.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class), VdcActionType.UpdateStoragePool, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    Network network = findNetwork(model);
    model.getNetwork().setId(network.getId().toString());
    model.getNetwork().setName(null);
    return model;
}
#method_after
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(template));
    if (namedCluster(template)) {
        staticVm.setvds_group_id(getClusterId(template));
    }
    UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(template.getUsb(), lookupCluster(staticVm.getvds_group_id()));
    if (usbPolicy != null) {
        staticVm.setusb_policy(usbPolicy);
    }
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    return performCreation(VdcActionType.AddVmTemplate, params, new QueryIdResolver(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(template));
    if (namedCluster(template)) {
        staticVm.setvds_group_id(getClusterId(template));
    }
    staticVm.setusb_policy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), lookupCluster(staticVm.getvds_group_id())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
protected List<AdUser> getUsersFromDomain() {
    return asCollection(AdUser.class, getEntity(ArrayList.class, SearchType.AdUser, getSearchPattern("*", getCurrentDomain())));
}
#method_after
protected List<LdapUser> getUsersFromDomain() {
    return asCollection(LdapUser.class, getEntity(ArrayList.class, SearchType.AdUser, getSearchPattern("*", getCurrentDomain())));
}
#end_block

#method_before
protected Users mapDomainUserCollection(List<AdUser> entities) {
    Users collection = new Users();
    for (AdUser entity : entities) {
        collection.getUsers().add(addLinks(modifyDomain(mapAdUser(entity)), true));
    }
    return collection;
}
#method_after
protected Users mapDomainUserCollection(List<LdapUser> entities) {
    Users collection = new Users();
    for (LdapUser entity : entities) {
        collection.getUsers().add(addLinks(modifyDomain(mapAdUser(entity)), true));
    }
    return collection;
}
#end_block

#method_before
protected VdcUser map(AdUser adUser) {
    return getMapper(AdUser.class, VdcUser.class).map(adUser, null);
}
#method_after
protected VdcUser map(LdapUser adUser) {
    return getMapper(LdapUser.class, VdcUser.class).map(adUser, null);
}
#end_block

#method_before
protected User mapAdUser(AdUser adUser) {
    return getMapper(AdUser.class, User.class).map(adUser, null);
}
#method_after
protected User mapAdUser(LdapUser adUser) {
    return getMapper(LdapUser.class, User.class).map(adUser, null);
}
#end_block

#method_before
@Override
public DbUser lookupEntity(Guid nullId) {
    return lookupUserById(id);
}
#method_after
@Override
public DbUser lookupEntity(Guid id) throws BackendFailureException {
    return lookupUserById(this.id);
}
#end_block

#method_before
@Override
public Response add(DataCenter dataCenter) {
    validateParameters(dataCenter, "name", "storageType");
    validateEnums(DataCenter.class, dataCenter);
    validateEnum(StorageType.class, dataCenter.getStorageType().toUpperCase());
    storage_pool entity = map(dataCenter);
    return performCreation(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(entity), new QueryIdResolver(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class));
}
#method_after
@Override
public Response add(DataCenter dataCenter) {
    validateParameters(dataCenter, "name", "storageType");
    validateEnums(DataCenter.class, dataCenter);
    validateEnum(StorageType.class, dataCenter.getStorageType().toUpperCase());
    storage_pool entity = map(dataCenter);
    return performCreate(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(entity), new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class));
}
#end_block

#method_before
@Override
protected DataCenter doPopulate(DataCenter model, storage_pool entity) {
    GetAvailableStoragePoolVersionsParameters parameters = new GetAvailableStoragePoolVersionsParameters();
    parameters.setStoragePoolId(new Guid(model.getId()));
    model.setSupportedVersions(getMapper(List.class, SupportedVersions.class).map(getEntity(ArrayList.class, VdcQueryType.GetAvailableStoragePoolVersions, parameters, model.getId()), null));
    return model;
}
#method_after
@Override
protected DataCenter doPopulate(DataCenter model, storage_pool entity) {
    return model;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver resolver = new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
protected final R populate(R model, Q entity) {
    return (isPopulate() ? doPopulate(model, entity) : model);
}
#method_after
protected final R populate(R model, Q entity) {
    model = deprecatedPopulate(model, entity);
    return (isPopulate() ? doPopulate(model, entity) : model);
}
#end_block

#method_before
protected VdcQueryParametersBase getQueryParams(Class<? extends VdcQueryParametersBase> queryParamsClass, Guid id) {
    VdcQueryParametersBase params = null;
    try {
        params = queryParamsClass.getConstructor(Guid.class).newInstance(id);
    } catch (Exception e) {
    // trivial class construction
    }
    return params;
}
#method_after
protected <T> VdcQueryParametersBase getQueryParams(Class<? extends VdcQueryParametersBase> queryParamsClass, T id) {
    VdcQueryParametersBase params = null;
    try {
        params = queryParamsClass.getConstructor(id.getClass()).newInstance(id);
    } catch (Exception e) {
    // trivial class construction
    }
    return params;
}
#end_block

#method_before
public Q resolve(Guid id) throws BackendFailureException {
    Q entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#method_after
@Override
public Q resolve(T id) throws BackendFailureException {
    Q entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#end_block

#method_before
public Object resolve(Guid id) throws BackendFailureException {
    Object entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#method_after
public Q resolve(T id) throws BackendFailureException {
    Q entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#end_block

#method_before
public Q lookupEntity(Guid id) throws BackendFailureException {
    return doGetEntity(entityType, query, getQueryParams(queryParamsClass, id), id.toString());
}
#method_after
@Override
public Q lookupEntity(T id) throws BackendFailureException {
    return doGetEntity(entityType, query, getQueryParams(queryParamsClass, id), id.toString());
}
#end_block

#method_before
@Override
public Response add(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "serverId", "brickDir");
    }
    List<GlusterBrickEntity> brickEntities = mapBricks(asGuid(getVolumeId()), bricks);
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    int stripeCount = bricks.isSetStripeCount() ? bricks.getStripeCount() : 0;
    return performCreationMultiple(VdcActionType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionParameters(asGuid(getVolumeId()), brickEntities, replicaCount, stripeCount), new QueryIdResolver(VdcQueryType.GetGlusterBrickById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "serverId", "brickDir");
    }
    List<GlusterBrickEntity> brickEntities = mapBricks(asGuid(getVolumeId()), bricks);
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    int stripeCount = bricks.isSetStripeCount() ? bricks.getStripeCount() : 0;
    return performCreationMultiple(VdcActionType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionParameters(asGuid(getVolumeId()), brickEntities, replicaCount, stripeCount), new QueryIdResolver<Guid>(VdcQueryType.GetGlusterBrickById, IdQueryParameters.class));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected GlusterBricks resolveCreatedList(VdcReturnValueBase result, EntityIdResolver entityResolver) {
    try {
        GlusterBricks bricks = new GlusterBricks();
        for (Guid id : (List<Guid>) result.getActionReturnValue()) {
            GlusterBrickEntity created = entityResolver.resolve(id);
            bricks.getGlusterBricks().add(addLinks(doPopulate(map(created), created)));
        }
        return bricks;
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
protected GlusterBricks resolveCreatedList(VdcReturnValueBase result, EntityIdResolver<Guid> entityResolver) {
    try {
        GlusterBricks bricks = new GlusterBricks();
        for (Guid id : (List<Guid>) result.getActionReturnValue()) {
            GlusterBrickEntity created = entityResolver.resolve(id);
            bricks.getGlusterBricks().add(addLinks(doPopulate(map(created), created)));
        }
        return bricks;
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#end_block

#method_before
protected Response performCreationMultiple(VdcActionType task, VdcActionParametersBase taskParams, EntityIdResolver entityResolver) {
    VdcReturnValueBase createResult;
    try {
        createResult = doAction(task, taskParams);
    } catch (Exception e) {
        return handleError(e, false);
    }
    GlusterBricks model = resolveCreatedList(createResult, entityResolver);
    Response response = null;
    if (model == null) {
        response = Response.status(ACCEPTED_STATUS).build();
    } else {
        response = Response.created(URI.create(getUriInfo().getPath())).entity(model).build();
    }
    return response;
}
#method_after
protected Response performCreationMultiple(VdcActionType task, VdcActionParametersBase taskParams, EntityIdResolver<Guid> entityResolver) {
    VdcReturnValueBase createResult;
    try {
        createResult = doAction(task, taskParams);
    } catch (Exception e) {
        return handleError(e, false);
    }
    GlusterBricks model = resolveCreatedList(createResult, entityResolver);
    Response response = null;
    if (model == null) {
        response = Response.status(ACCEPTED_STATUS).build();
    } else {
        response = Response.created(URI.create(getUriInfo().getPath())).entity(model).build();
    }
    return response;
}
#end_block

#method_before
protected R resolveCreated(VdcReturnValueBase result, EntityIdResolver entityResolver, Class<? extends BaseResource> suggestedParentType) {
    try {
        Q created = entityResolver.resolve((Guid) result.getActionReturnValue());
        return addLinks(doPopulate(map(created), created), suggestedParentType);
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
protected <T> Q resolveCreated(VdcReturnValueBase result, IResolver<T, Q> entityResolver) {
    try {
        return entityResolver.resolve((T) result.getActionReturnValue());
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#end_block

#method_before
@Override
public Cluster update(Cluster incoming) {
    validateEnums(Cluster.class, incoming);
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class), VdcActionType.UpdateVdsGroup, new UpdateParametersProvider());
}
#method_after
@Override
public Cluster update(Cluster incoming) {
    validateEnums(Cluster.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class), VdcActionType.UpdateVdsGroup, new UpdateParametersProvider());
}
#end_block

#method_before
protected boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, Guid id) {
    return id != null && id.equals(entity.getId());
}
#method_after
protected <T> boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, T id) {
    return id != null && id.equals(entity.getId());
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new EntityIdResolver() {

        @Override
        public VdsNetworkInterface lookupEntity(Guid guid) throws BackendFailureException {
            return parent.lookupInterface(id);
        }
    };
    HostNicStatisticalQuery query = new HostNicStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<HostNIC, VdsNetworkInterface>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public VdsNetworkInterface lookupEntity(Guid guid) throws BackendFailureException {
            return parent.lookupInterface(id);
        }
    };
    HostNicStatisticalQuery query = new HostNicStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<HostNIC, VdsNetworkInterface>(entityType, guid, query));
}
#end_block

#method_before
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return parent.addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return parent.doPopulate(model, entity);
}
#end_block

#method_before
@SuppressWarnings("serial")
@Override
public HostNIC update(HostNIC nic) {
    validateEnums(HostNIC.class, nic);
    VdsNetworkInterface originalInter = parent.lookupInterface(id);
    final VdsNetworkInterface inter = map(nic, originalInter);
    org.ovirt.engine.core.common.businessentities.Network oldNetwork = getOldNetwork(originalInter);
    org.ovirt.engine.core.common.businessentities.Network newNetwork = getNewNetwork(nic);
    UpdateNetworkToVdsParameters params = new UpdateNetworkToVdsParameters(Guid.createGuidFromString(parent.getHostId()), newNetwork != null ? newNetwork : oldNetwork, new ArrayList<VdsNetworkInterface>() {

        {
            add(inter);
        }
    });
    params.setOldNetworkName(oldNetwork != null ? oldNetwork.getname() : null);
    if (nic.isSetName() && inter.getBonded() != null && inter.getBonded()) {
        params.setBondName(nic.getName());
    }
    if (nic.isSetIp()) {
        if (nic.getIp().isSetAddress()) {
            params.setAddress(nic.getIp().getAddress());
        }
        if (nic.getIp().isSetNetmask()) {
            params.setSubnet(nic.getIp().getNetmask());
        }
        if (nic.getIp().isSetGateway()) {
            params.setGateway(nic.getIp().getGateway());
        }
    }
    if (nic.isSetBootProtocol()) {
        BootProtocol bootProtocol = BootProtocol.fromValue(nic.getBootProtocol());
        if (bootProtocol != null) {
            params.setBootProtocol(map(bootProtocol, null));
        }
    } else if (nic.isSetIp() && nic.getIp().isSetAddress() && !nic.getIp().getAddress().isEmpty()) {
        params.setBootProtocol(NetworkBootProtocol.StaticIp);
    }
    if (nic.isSetBonding() && nic.getBonding().isSetOptions()) {
        params.setBondingOptions(getBondingOptions(nic.getBonding().getOptions().getOptions()));
    }
    if (nic.isSetCheckConnectivity()) {
        params.setCheckConnectivity(nic.isCheckConnectivity());
    }
    performAction(VdcActionType.UpdateNetworkToVdsInterface, params);
    return parent.lookupNic(id, true);
}
#method_after
@SuppressWarnings("serial")
@Override
public HostNIC update(HostNIC nic) {
    validateEnums(HostNIC.class, nic);
    VdsNetworkInterface originalInter = parent.lookupInterface(id);
    final VdsNetworkInterface inter = map(nic, originalInter);
    org.ovirt.engine.core.common.businessentities.network.Network oldNetwork = getOldNetwork(originalInter);
    org.ovirt.engine.core.common.businessentities.network.Network newNetwork = getNewNetwork(nic);
    UpdateNetworkToVdsParameters params = new UpdateNetworkToVdsParameters(Guid.createGuidFromString(parent.getHostId()), newNetwork != null ? newNetwork : oldNetwork, new ArrayList<VdsNetworkInterface>() {

        {
            add(inter);
        }
    });
    params.setOldNetworkName(oldNetwork != null ? oldNetwork.getName() : null);
    if (nic.isSetName() && inter.getBonded() != null && inter.getBonded()) {
        params.setBondName(nic.getName());
    }
    if (nic.isSetIp()) {
        if (nic.getIp().isSetAddress()) {
            params.setAddress(nic.getIp().getAddress());
        }
        if (nic.getIp().isSetNetmask()) {
            params.setSubnet(nic.getIp().getNetmask());
        }
        if (nic.getIp().isSetGateway()) {
            params.setGateway(nic.getIp().getGateway());
        }
    }
    if (nic.isSetBootProtocol()) {
        BootProtocol bootProtocol = BootProtocol.fromValue(nic.getBootProtocol());
        if (bootProtocol != null) {
            params.setBootProtocol(map(bootProtocol, null));
        }
    } else if (nic.isSetIp() && nic.getIp().isSetAddress() && !nic.getIp().getAddress().isEmpty()) {
        params.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    }
    if (nic.isSetBonding() && nic.getBonding().isSetOptions()) {
        params.setBondingOptions(getBondingOptions(nic.getBonding().getOptions().getOptions()));
    }
    if (nic.isSetCheckConnectivity()) {
        params.setCheckConnectivity(nic.isCheckConnectivity());
    }
    performAction(VdcActionType.UpdateNetworkToVdsInterface, params);
    return parent.lookupNic(id, true);
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network getNewNetwork(HostNIC nic) {
    org.ovirt.engine.core.common.businessentities.Network newNetwork = null;
    if (nic.isSetNetwork()) {
        newNetwork = map(nic.getNetwork(), parent.lookupClusterNetwork(nic.getNetwork()));
    }
    return newNetwork;
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network getNewNetwork(HostNIC nic) {
    org.ovirt.engine.core.common.businessentities.network.Network newNetwork = null;
    if (nic.isSetNetwork()) {
        newNetwork = map(nic.getNetwork(), parent.lookupClusterNetwork(nic.getNetwork()));
    }
    return newNetwork;
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network getOldNetwork(VdsNetworkInterface originalInter) {
    String oldNetworkName = originalInter.getNetworkName();
    if (!StringHelper.isNullOrEmpty(oldNetworkName)) {
        return lookupAtachedNetwork(originalInter.getNetworkName());
    } else {
        GetAllChildVlanInterfacesQueryParameters params = new GetAllChildVlanInterfacesQueryParameters(asGuid(originalInter.getVdsId()), originalInter);
        List<VdsNetworkInterface> vlans = getBackendCollection(VdsNetworkInterface.class, VdcQueryType.GetAllChildVlanInterfaces, params);
        if (vlans != null && !vlans.isEmpty()) {
            return lookupAtachedNetwork(vlans.get(0).getNetworkName());
        } else {
            return null;
        }
    }
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network getOldNetwork(VdsNetworkInterface originalInter) {
    String oldNetworkName = originalInter.getNetworkName();
    if (!StringHelper.isNullOrEmpty(oldNetworkName)) {
        return lookupAtachedNetwork(originalInter.getNetworkName());
    } else {
        InterfaceAndIdQueryParameters params = new InterfaceAndIdQueryParameters(asGuid(originalInter.getVdsId()), originalInter);
        List<VdsNetworkInterface> vlans = getBackendCollection(VdsNetworkInterface.class, VdcQueryType.GetAllChildVlanInterfaces, params);
        if (vlans != null && !vlans.isEmpty()) {
            return lookupAtachedNetwork(vlans.get(0).getNetworkName());
        } else {
            return null;
        }
    }
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network lookupAtachedNetwork(String networkName) {
    if (!StringHelper.isNullOrEmpty(networkName)) {
        for (org.ovirt.engine.core.common.businessentities.Network nwk : parent.getClusterNetworks()) {
            if (nwk.getname().equals(networkName))
                return nwk;
        }
    }
    return null;
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network lookupAtachedNetwork(String networkName) {
    if (!StringHelper.isNullOrEmpty(networkName)) {
        for (org.ovirt.engine.core.common.businessentities.network.Network nwk : parent.getClusterNetworks()) {
            if (nwk.getName().equals(networkName))
                return nwk;
        }
    }
    return null;
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network map(Network network, org.ovirt.engine.core.common.businessentities.Network template) {
    return getMapper(Network.class, org.ovirt.engine.core.common.businessentities.Network.class).map(network, template);
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network map(Network network, org.ovirt.engine.core.common.businessentities.network.Network template) {
    return getMapper(Network.class, org.ovirt.engine.core.common.businessentities.network.Network.class).map(network, template);
}
#end_block

#method_before
@Override
protected boolean matchEntity(VM entity, String name) {
    return false;
}
#method_after
@Override
protected <T> boolean matchEntity(VM entity, T id) {
    return (id == null || id.equals(CDROM_ID)) && parentId.equals(entity.getQueryableId());
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new EntityIdResolver() {

        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return ((BackendVmDisksResource) collection).addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return ((BackendVmDisksResource) collection).doPopulate(model, entity);
}
#end_block

#method_before
@Override
public Groups list() {
    if (isFiltered()) {
        return mapDbGroupsCollection(getBackendCollection(DbUser.class, VdcQueryType.GetDbUserByUserId, new GetDbUserByUserIdParameters(getCurrent().get(VdcUser.class).getUserId())));
    } else {
        return mapDbGroupsCollection(getGroupsCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#method_after
@Override
public Groups list() {
    if (isFiltered()) {
        return mapDbGroupsCollection(getBackendCollection(DbUser.class, VdcQueryType.GetAllDbUsers, new VdcQueryParametersBase()));
    } else {
        return mapDbGroupsCollection(getGroupsCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#end_block

#method_before
@Override
public List<AuditLog> getAll() {
    return recoreds;
}
#method_after
@Override
public List<AuditLog> getAll(Guid userID, boolean isFiltered) {
    return recoreds;
}
#end_block

#method_before
@Override
public Events list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetEventMessages, new GetEventMessagesParameters()));
    } else {
        return mapCollection(getBackendCollection());
    }
}
#method_after
@Override
public Events list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllEventMessages, new GetEventMessagesParameters()));
    } else {
        return mapCollection(getBackendCollection());
    }
}
#end_block

#method_before
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return new BackendEventResource(id, this);
}
#method_after
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return inject(new BackendEventResource(id, this));
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveExternalEvent, new RemoveExternalEventParameters(asLong(id)));
}
#end_block

#method_before
@Override
public List<AuditLog> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetAllFromAuditLog", auditLogRowMapper, parameterSource);
}
#method_after
@Override
public List<AuditLog> getAll(Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeReadList("GetAllFromAuditLog", auditLogRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public void save(AuditLog event) {
    getCallsHandler().executeModification("InsertAuditLog", getSqlMapper(event).addValue("log_type_name", event.getlog_type_name()));
}
#method_after
@Override
public void save(AuditLog event) {
    if (event.isExternal()) {
        getCallsHandler().executeModification("InsertExternalAuditLog", getExternalEventSqlMapper(event));
    } else {
        getCallsHandler().executeModification("InsertAuditLog", getSqlMapper(event));
    }
}
#end_block

#method_before
@Override
public void update(AuditLog event) {
    getCallsHandler().executeModification("UpdateAuditLog", getSqlMapper(event));
}
#method_after
@Override
public void update(AuditLog event) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
private MapSqlParameterSource getSqlMapper(AuditLog event) {
    return getCustomMapSqlParameterSource().addValue("audit_log_id", event.getaudit_log_id()).addValue("log_time", event.getlog_time()).addValue("log_type", event.getlog_type()).addValue("severity", event.getseverity()).addValue("message", event.getmessage()).addValue("user_id", event.getuser_id()).addValue("user_name", event.getuser_name()).addValue("vds_id", event.getvds_id()).addValue("vds_name", event.getvds_name()).addValue("vm_id", event.getvm_id()).addValue("vm_name", event.getvm_name()).addValue("vm_template_id", event.getvm_template_id()).addValue("vm_template_name", event.getvm_template_name()).addValue("storage_pool_id", event.getstorage_pool_id()).addValue("storage_pool_name", event.getstorage_pool_name()).addValue("storage_domain_id", event.getstorage_domain_id()).addValue("storage_domain_name", event.getstorage_domain_name()).addValue("vds_group_id", event.getvds_group_id()).addValue("vds_group_name", event.getvds_group_name()).addValue("correlation_id", event.getCorrelationId()).addValue("job_id", event.getJobId()).addValue("quota_id", event.getQuotaId()).addValue("quota_name", event.getQuotaName()).addValue("gluster_volume_id", event.getGlusterVolumeId()).addValue("gluster_volume_name", event.getGlusterVolumeName());
}
#method_after
private MapSqlParameterSource getSqlMapper(AuditLog event) {
    return getCustomMapSqlParameterSource().addValue("audit_log_id", event.getaudit_log_id()).addValue("log_time", event.getlog_time()).addValue("log_type", event.getlog_type()).addValue("log_type_name", event.getlog_type_name()).addValue("severity", event.getseverity()).addValue("message", event.getmessage()).addValue("user_id", event.getuser_id()).addValue("user_name", event.getuser_name()).addValue("vds_id", event.getvds_id()).addValue("vds_name", event.getvds_name()).addValue("vm_id", event.getvm_id()).addValue("vm_name", event.getvm_name()).addValue("vm_template_id", event.getvm_template_id()).addValue("vm_template_name", event.getvm_template_name()).addValue("storage_pool_id", event.getstorage_pool_id()).addValue("storage_pool_name", event.getstorage_pool_name()).addValue("storage_domain_id", event.getstorage_domain_id()).addValue("storage_domain_name", event.getstorage_domain_name()).addValue("vds_group_id", event.getvds_group_id()).addValue("vds_group_name", event.getvds_group_name()).addValue("correlation_id", event.getCorrelationId()).addValue("job_id", event.getJobId()).addValue("quota_id", event.getQuotaId()).addValue("quota_name", event.getQuotaName()).addValue("gluster_volume_id", event.getGlusterVolumeId()).addValue("gluster_volume_name", event.getGlusterVolumeName());
}
#end_block

#method_before
@Override
public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
    AuditLog entity = new AuditLog();
    entity.setaudit_log_id(rs.getLong("audit_log_id"));
    entity.setlog_time(DbFacadeUtils.fromDate(rs.getTimestamp("log_time")));
    entity.setlog_type(AuditLogType.forValue(rs.getInt("log_type")));
    entity.setseverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    entity.setmessage(rs.getString("message"));
    entity.setuser_id(NGuid.createGuidFromString(rs.getString("user_id")));
    entity.setuser_name(rs.getString("user_name"));
    entity.setvds_id(NGuid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setvm_id(NGuid.createGuidFromString(rs.getString("vm_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvm_template_id(NGuid.createGuidFromString(rs.getString("vm_template_id")));
    entity.setvm_template_name(rs.getString("vm_template_name"));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setstorage_domain_id(NGuid.createGuidFromString(rs.getString("storage_domain_id")));
    entity.setstorage_domain_name(rs.getString("storage_domain_name"));
    entity.setvds_group_id(NGuid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setCorrelationId(rs.getString("correlation_id"));
    entity.setJobId(NGuid.createGuidFromString(rs.getString("job_id")));
    entity.setQuotaId(NGuid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setGlusterVolumeId(NGuid.createGuidFromString(rs.getString("gluster_volume_id")));
    entity.setGlusterVolumeName(rs.getString("gluster_volume_name"));
    return entity;
}
#method_after
@Override
public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
    AuditLog entity = new AuditLog();
    entity.setaudit_log_id(rs.getLong("audit_log_id"));
    entity.setlog_time(DbFacadeUtils.fromDate(rs.getTimestamp("log_time")));
    entity.setlog_type(AuditLogType.forValue(rs.getInt("log_type")));
    entity.setseverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    entity.setmessage(rs.getString("message"));
    entity.setuser_id(NGuid.createGuidFromString(rs.getString("user_id")));
    entity.setuser_name(rs.getString("user_name"));
    entity.setvds_id(NGuid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setvm_id(NGuid.createGuidFromString(rs.getString("vm_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvm_template_id(NGuid.createGuidFromString(rs.getString("vm_template_id")));
    entity.setvm_template_name(rs.getString("vm_template_name"));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setstorage_domain_id(NGuid.createGuidFromString(rs.getString("storage_domain_id")));
    entity.setstorage_domain_name(rs.getString("storage_domain_name"));
    entity.setvds_group_id(NGuid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setCorrelationId(rs.getString("correlation_id"));
    entity.setJobId(NGuid.createGuidFromString(rs.getString("job_id")));
    entity.setQuotaId(NGuid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setGlusterVolumeId(NGuid.createGuidFromString(rs.getString("gluster_volume_id")));
    entity.setGlusterVolumeName(rs.getString("gluster_volume_name"));
    entity.setOrigin(rs.getString("origin"));
    entity.setCustomEventId(rs.getInt("custom_event_id"));
    entity.setEventFloodInSec(rs.getInt("event_flood_in_sec"));
    entity.setCustomData(rs.getString("custom_data"));
    entity.setDeleted(rs.getBoolean("deleted"));
    return entity;
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreation(VdcActionType.AddVds, addParams, new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreation(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#end_block

#method_before
@Override
public Response performRemove(String id) {
    return performAction(VdcActionType.RemoveVds, new VdsActionParameters(asGuid(id)));
}
#method_after
@Override
public Response performRemove(String id) {
    return performAction(VdcActionType.RemoveVds, new RemoveVdsParameters(asGuid(id)));
}
#end_block

#method_before
@Override
public Users list() {
    if (isFiltered()) {
        return mapDbUserCollection(getBackendCollection(VdcQueryType.GetDbUserByUserId, new GetDbUserByUserIdParameters(getCurrent().get(VdcUser.class).getUserId())));
    } else {
        return mapDbUserCollection(getBackendCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#method_after
@Override
public Users list() {
    if (isFiltered()) {
        return mapDbUserCollection(getBackendCollection(VdcQueryType.GetAllDbUsers, new VdcQueryParametersBase()));
    } else {
        return mapDbUserCollection(getBackendCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#end_block

#method_before
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (!isNameConatinsDomain(user)) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    AdUser adUser = getEntity(AdUser.class, SearchType.AdUser, getSearchPattern(user.getUserName(), domain));
    if (adUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters newUser = new AddUserParameters();
    newUser.setVdcUser(map(adUser));
    return performCreation(VdcActionType.AddUser, newUser, new UserIdResolver(adUser.getUserId()), BaseResource.class);
}
#method_after
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (!isNameConatinsDomain(user)) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    LdapUser adUser = getEntity(LdapUser.class, SearchType.AdUser, getSearchPattern(user.getUserName(), domain));
    if (adUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters newUser = new AddUserParameters();
    newUser.setVdcUser(map(adUser));
    return performCreation(VdcActionType.AddUser, newUser, new UserIdResolver(adUser.getUserId()), BaseResource.class);
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#method_after
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#end_block

#method_before
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, "format", "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), "address", "target", "port");
        }
    } else {
        // Non lun disks require size
        validateParameters(disk, "provisionedSize|size");
    }
    validateEnums(Disk.class, disk);
}
#method_after
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, 3, "format", "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), 3, "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), 3, "address", "target", "port", "id");
        }
    } else if (disk.isSetLunStorage() && disk.getLunStorage().getLogicalUnits().isEmpty()) {
        // TODO: Implement nested entity existence validation infra for validateParameters()
        throw new WebFaultException(null, localize(Messages.INCOMPLETE_PARAMS_REASON), localize(Messages.INCOMPLETE_PARAMS_DETAIL_TEMPLATE, "LogicalUnit", "", "add"), Response.Status.BAD_REQUEST);
    } else {
        // Non lun disks require size
        validateParameters(disk, 3, "provisionedSize|size");
    }
    validateEnums(Disk.class, disk);
}
#end_block

#method_before
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisksByUserId, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#method_after
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisks, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetworkDAO().update(getNetwork());
    for (VDSGroup cluster : clusters) {
        NetworkClusterHelper.setStatus(cluster.getId(), getNetwork());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetworkDAO().update(getNetwork());
    for (NetworkCluster clusterAttachment : getClusterAttachments()) {
        NetworkClusterHelper.setStatus(clusterAttachment.getClusterId(), getNetwork());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<Network> networks = getNetworkDAO().getAll();
    Network oldNetwork = getNetworkById(networks);
    return validate(storagePoolExists()) && validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(vlanIsFree(networks)) && validate(networkExists(oldNetwork)) && validate(notChangingManagementNetworkName(oldNetwork)) && validate(networkNameNotUsed(networks)) && validate(networkNotUsedByRunningVm()) && validate(networkNotAttachedToCluster(oldNetwork));
}
#method_after
@Override
protected boolean canDoAction() {
    return validate(storagePoolExists()) && validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(vlanIsFree()) && validate(networkExists()) && validate(notChangingManagementNetworkName()) && validate(networkNameNotUsed()) && validate(networkNotUsedByRunningVm()) && validate(networkNotAttachedToCluster(getOldNetwork()));
}
#end_block

#method_before
private ValidationResult networkExists(Network oldNetwork) {
    return oldNetwork == null ? new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS) : ValidationResult.VALID;
}
#method_after
private ValidationResult networkExists() {
    return getOldNetwork() == null ? new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS) : ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult networkNameNotUsed(List<Network> networks) {
    Network networkWithSameName = getOtherNetworkWithSameName(networks);
    return networkWithSameName != null ? new ValidationResult(VdcBllMessages.NETWORK_IN_USE) : ValidationResult.VALID;
}
#method_after
private ValidationResult networkNameNotUsed() {
    Network networkWithSameName = getOtherNetworkWithSameName(getNetworks());
    return networkWithSameName != null ? new ValidationResult(VdcBllMessages.NETWORK_IN_USE) : ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult networkNotUsedByRunningVm() {
    String networkName = getNetworkName();
    for (VDSGroup cluster : getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId())) {
        List<VmStatic> vms = getVmStaticDAO().getAllByGroupAndNetworkName(cluster.getId(), networkName);
        if (vms.size() > 0) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult networkNotUsedByRunningVm() {
    String networkName = getNetworkName();
    for (NetworkCluster clusterAttachment : getClusterAttachments()) {
        List<VmStatic> vms = getVmStaticDAO().getAllByGroupAndNetworkName(clusterAttachment.getClusterId(), networkName);
        if (vms.size() > 0) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult notChangingManagementNetworkName(Network oldNetwork) {
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    return oldNetwork.getName().equals(managementNetwork) && !getNetworkName().equals(managementNetwork) ? new ValidationResult(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK) : ValidationResult.VALID;
}
#method_after
private ValidationResult notChangingManagementNetworkName() {
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    return getOldNetwork().getName().equals(managementNetwork) && !getNetworkName().equals(managementNetwork) ? new ValidationResult(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK) : ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<Network> all = getNetworks();
    return validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(networkDoesNotExist(all)) && validate(vlanIsFree(all));
}
#method_after
@Override
protected boolean canDoAction() {
    return validate(storagePoolExists()) && validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(networkDoesNotExist()) && validate(vlanIsFree());
}
#end_block

#method_before
private ValidationResult networkDoesNotExist(List<Network> networks) {
    return getNetworkByName(networks) == null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.NETWORK_NAME_ALREADY_EXISTS);
}
#method_after
private ValidationResult networkDoesNotExist() {
    return getNetworkByName(getNetworks()) == null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.NETWORK_NAME_ALREADY_EXISTS);
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (getIsVmRunning(entity) && entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (getIsVmRunning(entity) && entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setAddress(entity.getdisplay_ip());
            Integer displayPort = entity.getdisplay();
            model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
            Integer displaySecurePort = entity.getdisplay_secure_port();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        }
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (getIsVmRunning(entity) && entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (getIsVmRunning(entity) && entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
            model.setGuestInfo(new GuestInfo());
            model.getGuestInfo().setIps(new IPs());
            for (String item : entity.getVmIp().split(" ")) {
                if (!item.equals("")) {
                    IP ip = new IP();
                    ip.setAddress(item.trim());
                    model.getGuestInfo().getIps().getIPs().add(ip);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        case WINDOWS_2012X64:
            return VmOsType.Windows2012x64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    Payload model = template != null ? template : new Payload();
    if (entity.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
        if (deviceType != null) {
            model.setType(deviceType.value());
        }
    }
    PayloadFile file = new PayloadFile();
    file.setName(entity.getFileName());
    file.setContent(entity.getContent());
    model.setFile(file);
    return model;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFileName() != null) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        if (entity.getFileName() != null) {
            PayloadFile file = new PayloadFile();
            file.setName(entity.getFileName());
            file.setContent(entity.getContent());
            model.setFile(file);
        }
        return model;
    }
    return null;
}
#end_block

#method_before
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getstatus() == VMStatus.Up || entity.getstatus() == VMStatus.PoweringUp || entity.getstatus() == VMStatus.WaitForLaunch || entity.getstatus() == VMStatus.PoweredDown || entity.getstatus() == VMStatus.RebootInProgress || entity.getstatus() == VMStatus.RestoringState;
}
#method_after
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getStatus() == VMStatus.Up || entity.getStatus() == VMStatus.PoweringUp || entity.getStatus() == VMStatus.WaitForLaunch || entity.getStatus() == VMStatus.PoweredDown || entity.getStatus() == VMStatus.RebootInProgress || entity.getStatus() == VMStatus.RestoringState;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getInverse(VmStatic to) {
    VmStatistics statistics = new VmStatistics();
    statistics.setcpu_user(new Double(10L));
    statistics.setcpu_sys(new Double(20L));
    VmDynamic dynamic = new VmDynamic();
    dynamic.setstatus(VMStatus.Up);
    dynamic.setdisplay_type(to.getdefault_display_type());
    org.ovirt.engine.core.common.businessentities.VM ret = new org.ovirt.engine.core.common.businessentities.VM(to, dynamic, statistics);
    ret.setusage_mem_percent(Integer.valueOf(50));
    return ret;
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getInverse(VmStatic to) {
    VmStatistics statistics = new VmStatistics();
    statistics.setcpu_user(new Double(10L));
    statistics.setcpu_sys(new Double(20L));
    VmDynamic dynamic = new VmDynamic();
    dynamic.setstatus(VMStatus.Up);
    dynamic.setboot_sequence(to.getdefault_boot_sequence());
    dynamic.setdisplay_type(to.getdefault_display_type());
    org.ovirt.engine.core.common.businessentities.VM ret = new org.ovirt.engine.core.common.businessentities.VM(to, dynamic, statistics);
    ret.setUsageMemPercent(Integer.valueOf(50));
    return ret;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
}
#end_block

#method_before
@Test
public void testDisplayPort() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setstatus(VMStatus.Up);
    entity.setdisplay(5900);
    entity.setdisplay_secure_port(9999);
    VM model = VmMapper.map(entity, null);
    assertTrue(model.getDisplay().getPort() == 5900);
    assertTrue(model.getDisplay().getSecurePort() == 9999);
    entity.setdisplay(-1);
    entity.setdisplay_secure_port(-1);
    model = VmMapper.map(entity, null);
    assertNull(model.getDisplay().getPort());
    assertNull(model.getDisplay().getSecurePort());
}
#method_after
@Test
public void testDisplayPort() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setStatus(VMStatus.Up);
    entity.setDisplay(5900);
    entity.setDisplaySecurePort(9999);
    VM model = VmMapper.map(entity, null);
    assertTrue(model.getDisplay().getPort() == 5900);
    assertTrue(model.getDisplay().getSecurePort() == 9999);
    entity.setDisplay(-1);
    entity.setDisplaySecurePort(-1);
    model = VmMapper.map(entity, null);
    assertNull(model.getDisplay().getPort());
    assertNull(model.getDisplay().getSecurePort());
}
#end_block

#method_before
@Test
public void testMapHostId() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setstatus(VMStatus.Up);
    Guid guid = NGuid.NewGuid();
    entity.setrun_on_vds(guid);
    VM model = VmMapper.map(entity, null);
    assertEquals(guid.toString(), model.getHost().getId());
}
#method_after
@Test
public void testMapHostId() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setStatus(VMStatus.Up);
    Guid guid = NGuid.NewGuid();
    entity.setRunOnVds(guid);
    VM model = VmMapper.map(entity, null);
    assertEquals(guid.toString(), model.getHost().getId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getVmName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue) {
        VDS dedicatedVds;
        VM vmFromParams = getParameters().getVm();
        if (vmFromParams.getDedicatedVmForVds() != null && (dedicatedVds = DbFacade.getInstance().getVdsDao().get(vmFromParams.getDedicatedVmForVds())) != null) {
            VdcBllMessages returnMsg = isCpuPinningValid(vmFromParams.getCpuPinning(), getParameters().getVm().getNumOfCpus(), dedicatedVds.getcpu_cores() * dedicatedVds.getcpu_sockets() * dedicatedVds.getcpu_sockets());
            if (returnMsg != VdcBllMessages.Unassigned) {
                returnValue = false;
                addCanDoActionMessage(returnMsg);
            }
        } else {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VM_PINNING_WITHOUT_DEDICATED_VDS);
        }
    }
    if (getParameters().getVm().isUseHostCpuFlags() && getParameters().getVm().getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getVmName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning if the check haven't failed yet
    if (returnValue) {
        VM vmFromParams = getParameters().getVm();
        returnValue = isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData());
    }
    if (getParameters().getVm().isUseHostCpuFlags() && getParameters().getVm().getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (addVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (addVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            // add or remove the smartcard according to user request
            if (getVm().isSmartcardEnabled() != getVmTemplate().isSmartcardEnabled()) {
                VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
            }
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    if (getVm() != null) {
        removeVmInSpm(getVm().getStoragePoolId(), getVmId());
    }
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#end_block

#method_before
protected VmDynamicDAO getVmDynamicDao() {
    return DbFacade.getInstance().getVmDynamicDao();
}
#method_after
@Override
protected VmDynamicDAO getVmDynamicDao() {
    return DbFacade.getInstance().getVmDynamicDao();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    // Set the VM to null, to fetch it again from the DB ,instead from the cache.
    // We want to get the VM current data that was updated to the DB.
    setVm(null);
    try {
        updateVmInSpm(getVm().getStoragePoolId(), Arrays.asList(getVm()));
    } catch (Exception e) {
    // DO nothing
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getVmName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getVmName(), vmFromParams.getVmName())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getVmName())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    VDS dedicatedVds;
    if (vmFromParams.getDedicatedVmForVds() != null && (dedicatedVds = DbFacade.getInstance().getVdsDao().get(vmFromParams.getDedicatedVmForVds())) != null) {
        VdcBllMessages returnMsg = isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getNumOfCpus(), dedicatedVds.getcpu_cores() * dedicatedVds.getcpu_sockets());
        if (returnMsg != VdcBllMessages.Unassigned) {
            addCanDoActionMessage(returnMsg);
            return false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_WITHOUT_DEDICATED_VDS);
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getVmName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getVmName(), vmFromParams.getVmName())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getVmName())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return true;
}
#end_block

#method_before
@Test
public void isCpuPinningValid() {
    Assert.assertTrue("null value must be accepted", VmManagementCommandBase.isCpuPinningValid(null, 0, 0) == VdcBllMessages.Unassigned);
    Assert.assertTrue("empty string must be accepted", VmManagementCommandBase.isCpuPinningValid("", 0, 0) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("intentionally invalid", 0, 0) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0", 1, 1) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3,^2", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^5,^6,^7", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^1,^2,^3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8,9-12", 10, 13) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,^3,9-12,^10", 10, 13) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0_1#1", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-2_1#1-2", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#2,3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#1-4,^3", 10, 10) == VdcBllMessages.Unassigned);
    // validate vcpus over 9
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3", 12, 12) == VdcBllMessages.Unassigned);
    // negative tests
    Assert.assertTrue("random wrong text", VmManagementCommandBase.isCpuPinningValid("lorem ipsum", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("no cpu id specified, should not pass", VmManagementCommandBase.isCpuPinningValid("0", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("letter instead of vcpu ID", VmManagementCommandBase.isCpuPinningValid("A#1", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("letter instead of cpu ID", VmManagementCommandBase.isCpuPinningValid("0#B", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("A separating _ while only one vcpu pinning", VmManagementCommandBase.isCpuPinningValid("0#1_", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("Trailing _", VmManagementCommandBase.isCpuPinningValid("0#1_1#2_", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("Too many separators", VmManagementCommandBase.isCpuPinningValid("0#1__1#2", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("trailing junk", VmManagementCommandBase.isCpuPinningValid("0#1_1#2...", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    // negative logical validation
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3", 4, 12) == VdcBllMessages.VM_PINNING_VCPU_DOESNT_EXIST);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3", 12, 4) == VdcBllMessages.VM_PINNING_PCPU_DOESNT_EXIST);
}
#method_after
@Test
public void isCpuPinningValid() {
    VmManagementCommandBase<VmManagementParametersBase> test = spy(new VmManagementCommandBase<VmManagementParametersBase>(Guid.Empty));
    VmStatic vmStatic = new VmStatic();
    vmStatic.setnum_of_sockets(6);
    vmStatic.setcpu_per_socket(2);
    vmStatic.setdedicated_vm_for_vds(Guid.Empty);
    final VDS dedicatedVds = new VDS();
    dedicatedVds.setCpuThreads(16);
    dedicatedVds.setvds_group_compatibility_version(Version.v3_2);
    doReturn(dedicatedVds).when(test).getVds(Guid.Empty);
    Assert.assertTrue("null value must be accepted", test.isCpuPinningValid(null, vmStatic));
    Assert.assertTrue("empty string must be accepted", test.isCpuPinningValid("", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("intentionally invalid", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#0", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("0#^3", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("0#^3,^2", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^6", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^6,^7", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^6,^7", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^5,^6,^7", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1,2,3", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("0#^1,^2,^3", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4,6-8", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4,6-8,9-12", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4,^3,9-12,^10", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#0_1#1", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-2_1#1-2", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1,2,3_1#2,3", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1,2,3_1#1-4,^3", vmStatic));
    // validate vcpus over 9
    Assert.assertTrue(test.isCpuPinningValid("10#1,2,3_11#1-4,^3", vmStatic));
    // negative tests
    Assert.assertFalse("random wrong text", test.isCpuPinningValid("lorem ipsum", vmStatic));
    Assert.assertFalse("no cpu id specified, should not pass", test.isCpuPinningValid("0", vmStatic));
    Assert.assertFalse("letter instead of vcpu ID", test.isCpuPinningValid("A#1", vmStatic));
    Assert.assertFalse("letter instead of cpu ID", test.isCpuPinningValid("0#B", vmStatic));
    Assert.assertFalse("A separating _ while only one vcpu pinning", test.isCpuPinningValid("0#1_", vmStatic));
    Assert.assertFalse("Trailing _", test.isCpuPinningValid("0#1_1#2_", vmStatic));
    Assert.assertFalse("Too many separators", test.isCpuPinningValid("0#1__1#2", vmStatic));
    Assert.assertFalse("trailing junk", test.isCpuPinningValid("0#1_1#2...", vmStatic));
    // negative logical validation
    ArrayList<String> canDoActionMessages = test.getReturnValue().getCanDoActionMessages();
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,3_10#1-4,^3", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION.toString(), canDoActionMessages.get(0));
    }
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,^1,^2", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU.toString(), canDoActionMessages.get(0));
    }
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,3_20#1-4,^3", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_VCPU_DOES_NOT_EXIST.toString(), canDoActionMessages.get(0));
    }
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,3_11#1-20,^3", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_PCPU_DOES_NOT_EXIST.toString(), canDoActionMessages.get(0));
    }
    // making sure cluster < 3.2 does not get validated on pCPU as we cant tell the number for sure
    dedicatedVds.setvds_group_compatibility_version(Version.v3_1);
    Assert.assertTrue(test.isCpuPinningValid("10#1,2,3_11#1-20,^3", vmStatic));
}
#end_block

#method_before
static VdcBllMessages isCpuPinningValid(final String cpuPinning, int maxVcpus, int maxPcpus) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return VdcBllMessages.Unassigned;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        return VdcBllMessages.VM_PINNING_FORMAT_INVALID;
    }
    HashSet<Integer> vcpus = new HashSet<Integer>();
    String[] rules = cpuPinning.split("_");
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxVcpus) {
            // ERROR maps to a non existent vcpu
            return VdcBllMessages.VM_PINNING_VCPU_DOESNT_EXIST;
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more then one definition for the same vcpu
            return VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION;
        }
        TreeSet<Integer> currPcpus = parseCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return VdcBllMessages.VM_PINNING_FORMAT_INVALID;
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU;
        }
        if (currPcpus.last() >= maxPcpus * 2) {
            // ERROR maps to a non existent pcpu
            return VdcBllMessages.VM_PINNING_PCPU_DOESNT_EXIST;
        }
    }
    return VdcBllMessages.Unassigned;
}
#method_after
public boolean isCpuPinningValid(final String cpuPinning, VmStatic vmStatic) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return true;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    HashSet<Integer> vcpus = new HashSet<Integer>();
    String[] rules = cpuPinning.split("_");
    int maxvCPU = vmStatic.getnum_of_cpus();
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxvCPU) {
            // ERROR maps to a non existent vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_VCPU_DOES_NOT_EXIST);
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more then one definition for the same vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION);
        }
        Collection<Integer> currPcpus = parsePCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return failCanDoAction(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return failCanDoAction(VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU);
        }
        // can not check if no dedicated vds was configured
        if (vmStatic.getdedicated_vm_for_vds() != null) {
            VDS dedicatedVds = getVds(vmStatic.getdedicated_vm_for_vds().getValue());
            // check only from cluster version 3.2
            if (dedicatedVds != null && dedicatedVds.getvds_group_compatibility_version() != null && dedicatedVds.getvds_group_compatibility_version().compareTo(Version.v3_2) >= 0 && dedicatedVds.getCpuThreads() != null) {
                if (Collections.max(currPcpus) >= dedicatedVds.getCpuThreads()) {
                    // ERROR maps to a non existent pcpu
                    return failCanDoAction(VdcBllMessages.VM_PINNING_PCPU_DOES_NOT_EXIST);
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // the VM in Run Once scenario, in that case we need to add proper video device
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        addVideoCardAccordingToTheRequestedDisplayType(vm.getDisplayType());
    } else {
        addVideoCardsDefinedForTheVmFromDB();
    }
}
#method_after
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // the VM in Run Once scenario, in that case we need to add proper video device
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        addVideoCardByDisplayType(vm.getDisplayType());
    } else {
        addVideoCardsDefinedForVmInDB(vm.getId());
    }
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.InnerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.InnerText));
            vmBase.setdefault_display_type(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if ("ovf:OperatingSystemSection_Type".equals(value)) {
            ReadOsSection(section);
        } else if ("ovf:VirtualHardwareSection_Type".equals(value)) {
            ReadHardwareSection(section);
        } else if ("ovf:SnapshotsSection_Type".equals(value)) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.InnerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.InnerText));
            vmBase.setdefault_display_type(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if ("ovf:OperatingSystemSection_Type".equals(value)) {
            ReadOsSection(section);
        } else if ("ovf:VirtualHardwareSection_Type".equals(value)) {
            ReadHardwareSection(section);
        } else if ("ovf:SnapshotsSection_Type".equals(value)) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#end_block

#method_before
public static void RunQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback) {
    initQueryParamsFilter(parameters);
    dumpQueryDetails(queryType, parameters);
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async runQuery.");
    raiseQueryStartedEvent(queryType, callback.getContext());
    GenericApiGWTServiceAsync service = GenericApiGWTServiceAsync.Util.getInstance();
    service.RunQuery(queryType, parameters, new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onFailure(Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                callback.asyncCallback.OnSuccess(callback.getModel(), null);
            }
            raiseQueryCompleteEvent(queryType, callback.getContext());
        }

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from RunQuery.");
            if (!result.getSucceeded()) {
                logger.log(Level.WARNING, // $NON-NLS-1$
                "Failure while invoking ReturnQuery [" + result.getExceptionString() + // $NON-NLS-1$
                "]");
                if (getEventsHandler() != null) {
                    ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                    failedResult.add(result);
                    // getEventsHandler().runQueryFailed(failedResult);
                    String errorMessage = result.getExceptionString();
                    handleNotLoggedInEvent(errorMessage);
                }
                if (callback.isHandleFailure()) {
                    callback.getDel().OnSuccess(callback.getModel(), result);
                }
            } else {
                callback.setOriginalReturnValue(result);
                if (callback.getConverter() != null) {
                    callback.getDel().OnSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                } else {
                    callback.getDel().OnSuccess(callback.getModel(), result);
                }
            }
            raiseQueryCompleteEvent(queryType, callback.getContext());
        }
    });
}
#method_after
public static void RunQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback) {
    final QueryWrapper queryWrapper = new QueryWrapper(queryType, parameters, callback);
    final boolean isHandleSequentialQueries = isHandleSequentialQueries(queryWrapper);
    if (isHandleSequentialQueries) {
        if (currentRequests.get(queryWrapper.getKey()) == null) {
            currentRequests.put(queryWrapper.getKey(), queryWrapper);
        } else {
            pendingRequests.put(queryWrapper.getKey(), queryWrapper);
            return;
        }
    }
    initQueryParamsFilter(parameters);
    dumpQueryDetails(queryType, parameters);
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async runQuery.");
    raiseQueryStartedEvent(queryType, callback.getContext());
    GenericApiGWTServiceAsync service = GenericApiGWTServiceAsync.Util.getInstance();
    service.RunQuery(queryType, parameters, new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onFailure(Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.asyncCallback.OnSuccess(callback.getModel(), null);
                }
                raiseQueryCompleteEvent(queryType, callback.getContext());
            } finally {
                if (isHandleSequentialQueries) {
                    handleSequentialQueries(queryWrapper.getKey());
                }
            }
        }

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            try {
                // $NON-NLS-1$
                logger.finer("Succesful returned result from RunQuery.");
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking ReturnQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().OnSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().OnSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().OnSuccess(callback.getModel(), result);
                    }
                }
                raiseQueryCompleteEvent(queryType, callback.getContext());
            } finally {
                if (isHandleSequentialQueries) {
                    handleSequentialQueries(queryWrapper.getKey());
                }
            }
        }

        private void handleSequentialQueries(String key) {
            currentRequests.remove(queryWrapper.getKey());
            QueryWrapper wrapper = pendingRequests.get(key);
            if (wrapper != null) {
                pendingRequests.remove(queryWrapper.getKey());
                RunQuery(wrapper.getQueryType(), wrapper.getParameters(), wrapper.getCallback());
            }
        }
    });
}
#end_block

#method_before
@Override
public void addActionVersionMap(ActionVersionMap action_version_map) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("action_type", action_version_map.getaction_type()).addValue("cluster_minimal_version", action_version_map.getcluster_minimal_version()).addValue("storage_pool_minimal_version", action_version_map.getstorage_pool_minimal_version());
    getCallsHandler().executeModification("Insertaction_version_map", parameterSource);
}
#method_after
@Override
public void addActionVersionMap(ActionVersionMap actionVersionMap) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("action_type", actionVersionMap.getaction_type()).addValue("cluster_minimal_version", actionVersionMap.getcluster_minimal_version()).addValue("storage_pool_minimal_version", actionVersionMap.getstorage_pool_minimal_version());
    getCallsHandler().executeModification("Insertaction_version_map", parameterSource);
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(ActionVersionMap.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(async_tasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(LdapGroup.class).addAnnotatedClass(ActionVersionMap.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
private List<QuotaConsumptionParameter> getQuotaConsumptionParameters() {
    List<QuotaConsumptionParameter> consumptionParameters;
    // The enum markings prevent Quota dependencies unintentional inheritance.
    switch(getActionType().getQuotaDependency()) {
        case NONE:
            return null;
        case STORAGE:
            consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
            break;
        case VDS_GROUP:
            consumptionParameters = getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters();
            break;
        default:
            consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
            consumptionParameters.addAll(getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters());
            break;
    }
    return consumptionParameters;
}
#method_after
private List<QuotaConsumptionParameter> getQuotaConsumptionParameters() {
    // The enum markings prevent Quota dependencies unintentional inheritance.
    if (consumptionParameters == null) {
        switch(getActionType().getQuotaDependency()) {
            case NONE:
                return null;
            case STORAGE:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                break;
            case VDS_GROUP:
                consumptionParameters = getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters();
                break;
            default:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                consumptionParameters.addAll(getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters());
                break;
        }
    }
    return consumptionParameters;
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                if (parameter.getQuotaGuid() != null && parameter.getQuotaGuid() != Guid.Empty) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
                }
            }
        }
    }
}
#end_block

#method_before
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#method_after
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
public void OnSave() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    if (!model.getIsNew() && !((Version) model.getVersion().getSelectedItem()).equals(((storage_pool) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (((storage_pool) getSelectedItem()).getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED && model.getQuotaEnforceTypeListModel().getSelectedItem() != QuotaEnforcementTypeEnum.DISABLED) {
        promptNoQuotaAvailable(model.getEntity(), this);
    } else {
        OnSaveInternal();
    }
}
#method_after
public void OnSave() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    if ((model.getIsNew() || model.getEntity() == null) && model.getQuotaEnforceTypeListModel().getSelectedItem() != QuotaEnforcementTypeEnum.DISABLED) {
        promptNoQuotaInDCMessage();
    } else if (!((Version) model.getVersion().getSelectedItem()).equals(((storage_pool) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (((storage_pool) getSelectedItem()).getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED && model.getQuotaEnforceTypeListModel().getSelectedItem() != QuotaEnforcementTypeEnum.DISABLED) {
        checkForQuotaInDC(model.getEntity(), this);
    } else {
        OnSaveInternal();
    }
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(LdapGroup.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
protected boolean ValidateNotificationMethod(java.util.List<EventNotificationMethod> event_notification_methods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethods notificationMethod = event_notification_methods.get(0).getmethod_type();
    switch(notificationMethod) {
        case EMAIL:
            String mailAdress = (StringUtils.isEmpty(event_subscriber.getmethod_address())) ? user.getemail() : event_subscriber.getmethod_address();
            if (StringUtils.isEmpty(mailAdress) || !ValidatMailAddress(mailAdress)) {
                addCanDoActionMessage(VdcBllMessages.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
protected boolean ValidateNotificationMethod(java.util.List<EventNotificationMethod> eventNotificationMethods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethods notificationMethod = eventNotificationMethods.get(0).getmethod_type();
    switch(notificationMethod) {
        case EMAIL:
            String mailAdress = (StringUtils.isEmpty(event_subscriber.getmethod_address())) ? user.getemail() : event_subscriber.getmethod_address();
            if (StringUtils.isEmpty(mailAdress) || !ValidatMailAddress(mailAdress)) {
                addCanDoActionMessage(VdcBllMessages.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
protected boolean ValidateAdd(List<EventNotificationMethod> event_notification_methods, event_subscriber event_subscriber, DbUser user) {
    String tagName = event_subscriber.gettag_name();
    // validate notification method
    boolean retValue = ValidateNotificationMethod(event_notification_methods, event_subscriber, user);
    // validate tag name if exists
    if (retValue && StringUtils.isNotEmpty(tagName)) {
        retValue = ValidateTag(tagName);
    }
    return retValue;
}
#method_after
protected boolean ValidateAdd(List<EventNotificationMethod> eventNotificationMethods, event_subscriber event_subscriber, DbUser user) {
    String tagName = event_subscriber.gettag_name();
    // validate notification method
    boolean retValue = ValidateNotificationMethod(eventNotificationMethods, event_subscriber, user);
    // validate tag name if exists
    if (retValue && StringUtils.isNotEmpty(tagName)) {
        retValue = ValidateTag(tagName);
    }
    return retValue;
}
#end_block

#method_before
protected boolean ValidateRemove(List<EventNotificationMethod> event_notification_methods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = false;
    // check if user is subscribed to the event
    List<event_subscriber> list = DbFacade.getInstance().getEventDao().getAllForSubscriber(event_subscriber.getsubscriber_id());
    if (list.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
    } else {
        if (!ValidateSubscription(list, event_subscriber)) {
            addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
        } else {
            String tagName = event_subscriber.gettag_name();
            // validate notification method
            retValue = ValidateNotificationMethod(event_notification_methods, event_subscriber, user);
            // validate tag name if exists
            if (retValue && StringUtils.isNotEmpty(tagName)) {
                retValue = ValidateTag(tagName);
            }
        }
    }
    return retValue;
}
#method_after
protected boolean ValidateRemove(List<EventNotificationMethod> eventNotificationMethods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = false;
    // check if user is subscribed to the event
    List<event_subscriber> list = DbFacade.getInstance().getEventDao().getAllForSubscriber(event_subscriber.getsubscriber_id());
    if (list.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
    } else {
        if (!ValidateSubscription(list, event_subscriber)) {
            addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
        } else {
            String tagName = event_subscriber.gettag_name();
            // validate notification method
            retValue = ValidateNotificationMethod(eventNotificationMethods, event_subscriber, user);
            // validate tag name if exists
            if (retValue && StringUtils.isNotEmpty(tagName)) {
                retValue = ValidateTag(tagName);
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean connectHostToPool() {
    setStoragePool(null);
    final Guid masterDomainIdFromDb = getMasterDomainIdFromDb();
    final VDS vds = getVds();
    final storage_pool storagePool = getStoragePool();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(storagePool.getId(), masterDomainIdFromDb, vds.getId(), EventType.VDSCONNECTTOPOOL), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(masterDomainIdFromDb, vds, storagePool);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#method_after
private boolean connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid masterDomainIdFromDb, final VDS vds, final storage_pool storagePool) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    try {
        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getvds_spm_id(), masterDomainIdFromDb, storagePool.getmaster_domain_version())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.StoragePoolWrongMaster || e.getErrorCode() == VdcBllErrors.StoragePoolMasterNotFound) {
            boolean returnValue = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, new ReconstructMasterParameters(vds.getStoragePoolId(), masterDomainIdFromDb, vds.getId(), false)).getSucceeded();
            result = new EventResult(returnValue, EventType.RECONSTRUCT);
        } else {
            log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
            result.setSuccess(false);
        }
    } catch (RuntimeException exp) {
        log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
        result.setSuccess(false);
    }
    if (result.isSuccess() && result.getEventType() != EventType.RECONSTRUCT) {
        result.setSuccess(proceedVdsStats());
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    storage_pool storagePool = getStoragePoolDAO().get(storagePoolId);
    Guid masterDomainIdFromDb = getStorageDomainDAO().getMasterStorageDomainIdForPool(storagePoolId);
    try {
        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getvds_spm_id(), masterDomainIdFromDb, storagePool.getmaster_domain_version())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.StoragePoolWrongMaster || e.getErrorCode() == VdcBllErrors.StoragePoolMasterNotFound) {
            boolean returnValue = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, new ReconstructMasterParameters(vds.getStoragePoolId(), masterDomainIdFromDb, vds.getId(), false)).getSucceeded();
            result = new EventResult(returnValue, EventType.RECONSTRUCT);
        } else {
            log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
            result.setSuccess(false);
        }
    } catch (RuntimeException exp) {
        log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
        result.setSuccess(false);
    }
    if (result.isSuccess() && result.getEventType() != EventType.RECONSTRUCT) {
        result.setSuccess(proceedVdsStats());
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        if (getVdsGroup().supportsGlusterService()) {
            if (!_glusterPeerListSucceeded) {
                type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
            } else if (!_glusterPeerProbeSucceeded) {
                type = AuditLogType.GLUSTER_HOST_ADD_FAILED;
            }
        }
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        if (getVdsGroup().supportsGlusterService()) {
            if (!_glusterPeerListSucceeded) {
                type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
            } else if (!_glusterPeerProbeSucceeded) {
                type = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
            }
        }
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#end_block

#method_before
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.GLUSTER_HOST_ADD_FAILED);
            _glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().gethost_name(), e.getMessage());
        _glusterPeerProbeSucceeded = false;
        return false;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            _glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().gethost_name(), e.getMessage());
        _glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Runnable> tasks = new LinkedList<Runnable>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Runnable() {

                @Override
                public void run() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            });
        }
        new LatchedRunnableExecutor(tasks).execute();
    }
}
#end_block

#method_before
public NGuid getUserId() {
    if (mUserId.equals(Guid.Empty) && getCurrentUser() != null) {
        mUserId = getCurrentUser().getUserId();
    }
    return mUserId;
}
#method_after
public NGuid getUserId() {
    if (mUserId != null && mUserId.equals(Guid.Empty) && getCurrentUser() != null) {
        mUserId = getCurrentUser().getUserId();
    }
    return mUserId;
}
#end_block

#method_before
protected VDSGroup getVdsGroup() {
    if (mVdsGroup == null) {
        if (mVdsGroupId != null) {
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVds() != null) {
            mVdsGroupId = getVds().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVm() != null) {
            mVdsGroupId = getVm().getVdsGroupId();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        }
    }
    return mVdsGroup;
}
#method_after
protected VDSGroup getVdsGroup() {
    if (mVdsGroup == null) {
        if (mVdsGroupId != null) {
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVds() != null) {
            mVdsGroupId = getVds().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVm() != null) {
            mVdsGroupId = getVm().getVdsGroupId();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVmTemplate() != null) {
            mVdsGroupId = getVmTemplate().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        }
    }
    return mVdsGroup;
}
#end_block

#method_before
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    storage_domain_static domainFromDb = null;
    storage_pool_iso_map domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && data.getstatus() == StorageDomainStatus.InActive && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && data.getstatus() == StorageDomainStatus.InActive && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId);
            return result;
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
public void Init(VDS vds) {
    mCurrentVdsId = vds.getId();
    setmIrsPort(vds.getport());
    setmCurrentIrsHost(vds.gethost_name());
}
#method_after
public void Init(VDS vds) {
    mCurrentVdsId = vds.getId();
    setmIrsPort(vds.getport());
    privatemCurrentIrsHost = vds.gethost_name();
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    mCurrentVdsId = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
public String getIsoDirectory() {
    String tempVar = getmCurrentIrsHost();
    return String.format("\\\\%1$s\\CD", ((tempVar != null) ? tempVar : gethostFromVds()));
}
#method_after
public String getIsoDirectory() {
    String tempVar = privatemCurrentIrsHost;
    return String.format("\\\\%1$s\\CD", ((tempVar != null) ? tempVar : gethostFromVds()));
}
#end_block

#method_before
private void nullifyInternalProxies() {
    if (privatemIrsProxy != null) {
        XmlRpcUtils.shutDownConnection(((IrsServerWrapper) privatemIrsProxy).getHttpClient());
    }
    setmCurrentIrsHost(null);
    privatemIrsProxy = null;
    mCurrentVdsId = null;
}
#method_after
private void nullifyInternalProxies() {
    if (privatemIrsProxy != null) {
        XmlRpcUtils.shutDownConnection(((IrsServerWrapper) privatemIrsProxy).getHttpClient());
    }
    privatemCurrentIrsHost = null;
    privatemIrsProxy = null;
    mCurrentVdsId = null;
}
#end_block

#method_before
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    storage_pool_iso_map map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#method_after
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                synchronized (_lockObject) {
                    updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                }
                return result;
            }
        });
    }
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            synchronized (_lockObject) {
                if (_domainsInProblem.containsKey(domainId)) {
                    log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                    result = ProcessDomainRecovery(domainId);
                }
                _timers.remove(domainId);
            }
            return result;
        }
    });
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#end_block

#method_before
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getstatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    clearVdsFromCache(vdsId, vds.getvds_name());
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
        }
    } else {
        // Domain.
        if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
            log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. Moving the Domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId);
        }
    }
    // clear from cache of _vdssInProblem and
    // _domainsInProblem
    clearDomainFromCache(domainId);
    ClearTimer(domainId);
    return result;
}
#method_after
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getstatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    clearVdsFromCache(vdsId, vds.getvds_name());
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId);
        }
    }
    // clear from cache of _vdssInProblem and
    // _domainsInProblem
    clearDomainFromCache(domainId);
    ClearTimer(domainId);
    return result;
}
#end_block

#method_before
public void clearCache() {
    synchronized (_lockObject) {
        log.info("clearing cache for problematic entities in pool " + _storagePoolId);
        // clear lists
        _timers.clear();
        _domainsInProblem.clear();
        _vdssInProblem.clear();
    }
}
#method_after
public void clearCache() {
    log.info("clearing cache for problematic entities in pool " + _storagePoolId);
    // clear lists
    _timers.clear();
    _domainsInProblem.clear();
    _vdssInProblem.clear();
}
#end_block

#method_before
public void clearPoolTimers() {
    synchronized (_lockObject) {
        log.info("clear domain error-timers for pool " + _storagePoolId);
        for (String jobId : _timers.values()) {
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("failed deleting job " + jobId);
            }
        }
    }
}
#method_after
public void clearPoolTimers() {
    log.info("clear domain error-timers for pool " + _storagePoolId);
    for (String jobId : _timers.values()) {
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("failed deleting job " + jobId);
        }
    }
}
#end_block

#method_before
public void clearVdsFromCache(Guid vdsId, String vdsName) {
    log.infoFormat("Clearing cache of pool: {0} for problematic entities of VDS: {1}.", _storagePoolId, vdsName);
    synchronized (_lockObject) {
        if (_vdssInProblem.containsKey(vdsId)) {
            for (Guid domainId : _vdssInProblem.get(vdsId)) {
                DomainRecoveredFromProblem(domainId, vdsId, vdsName);
            }
        }
    }
}
#method_after
public void clearVdsFromCache(Guid vdsId, String vdsName) {
    log.infoFormat("Clearing cache of pool: {0} for problematic entities of VDS: {1}.", _storagePoolId, vdsName);
    if (_vdssInProblem.containsKey(vdsId)) {
        for (Guid domainId : _vdssInProblem.get(vdsId)) {
            DomainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#end_block

#method_before
private static String getDomainIdTuple(Guid domainId) {
    storage_domain_static storage_domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#method_after
private static String getDomainIdTuple(Guid domainId) {
    StorageDomainStatic storage_domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#end_block

#method_before
private void startReconstruct() {
    storage_domain_static masterDomain = null;
    List<storage_domain_static> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (storage_domain_static storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId());
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId());
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
@Override
public void vdsMovedToMaintanance(Guid vdsId) {
    VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
    MaintananceVdsCommand.ProcessStorageOnVdsInactive(vds);
    ExecutionHandler.updateSpecificActionJobCompleted(vdsId, VdcActionType.MaintananceVds, true);
}
#method_after
@Override
public void vdsMovedToMaintanance(VDS vds) {
    try {
        MaintananceVdsCommand.ProcessStorageOnVdsInactive(vds);
    } finally {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintananceVds, true);
    }
}
#end_block

#method_before
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    // clients, so we won't need to handle migration errors
    if (StringUtils.isNotEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.doCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getId()), ExecutionHandler.createInternalJobContext());
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setguest_cur_user_id(null);
        vmDynamic.setguest_cur_user_name(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
    }
}
#method_after
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    // clients, so we won't need to handle migration errors
    if (StringUtils.isNotEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.doCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getId()), ExecutionHandler.createInternalJobContext());
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setConsole_current_user_name(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((domainId == null) ? 0 : domainId.hashCode());
    result = prime * result + ((eventType == null) ? 0 : eventType.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((domainId == null) ? 0 : domainId.hashCode());
    result = prime * result + ((eventType == null) ? 0 : eventType.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Event other = (Event) obj;
    if (domainId == null) {
        if (other.domainId != null)
            return false;
    } else if (!domainId.equals(other.domainId))
        return false;
    if (eventType != other.eventType)
        return false;
    if (storagePoolId == null) {
        if (other.storagePoolId != null)
            return false;
    } else if (!storagePoolId.equals(other.storagePoolId))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Event other = (Event) obj;
    if (domainId == null) {
        if (other.domainId != null)
            return false;
    } else if (!domainId.equals(other.domainId))
        return false;
    if (eventType != other.eventType)
        return false;
    if (storagePoolId == null) {
        if (other.storagePoolId != null)
            return false;
    } else if (!storagePoolId.equals(other.storagePoolId))
        return false;
    if (vdsId == null) {
        if (other.vdsId != null)
            return false;
    } else if (!vdsId.equals(other.vdsId))
        return false;
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return "Event [storagePoolId=" + storagePoolId + ", domainId=" + domainId + ", eventType=" + eventType + "]";
}
#method_after
@Override
public String toString() {
    return "Event [eventType=" + eventType + ", storagePoolId=" + storagePoolId + ", domainId=" + domainId + ", vdsId=" + vdsId + "]";
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <V> Future<V> execute(FutureTask<V> command) {
    try {
        return (Future<V>) es.submit(command);
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. A submitted task was rejected");
        throw e;
    }
}
#method_after
@SuppressWarnings("unchecked")
public static <V> Future<V> execute(FutureTask<V> command) {
    try {
        return (Future<V>) es.submit(command);
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. The submitted event was rejected");
        throw e;
    }
}
#end_block

#method_before
@Override
public void submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            task.get();
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e.getMessage());
        }
    }
}
#method_after
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e.getMessage());
        }
    }
    return null;
}
#end_block

#method_before
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECONSTRUCT:
                    log.debugFormat("Current event was skiped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    break;
                default:
                    task = new FutureTask<EventResult>(callable);
                    getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
                    break;
            }
        } else {
            task = new FutureTask<EventResult>(callable);
            getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueuRunnable(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#method_after
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECONSTRUCT:
                    log.debugFormat("Current event was skiped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    break;
                default:
                    task = new FutureTask<EventResult>(callable);
                    getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
                    break;
            }
        } else {
            task = new FutureTask<EventResult>(callable);
            getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueueThread(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private boolean connectVdsToNewMaster(VDS vds) {
    storage_domains masterDomain = getNewMaster(false);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getstorage_type()).ConnectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#method_after
private boolean connectVdsToNewMaster(VDS vds) {
    storage_domains masterDomain = getNewMaster(false);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getstorage_type()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Runnable> tasks = new LinkedList<Runnable>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Runnable() {

                @Override
                public void run() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in pool {1}. error {2}", vds.getId(), getStoragePool().getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in pool {1}. error {2}", vds.getId(), getStoragePool().getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            });
        }
        new LatchedRunnableExecuter(tasks).execute();
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Runnable> tasks = new LinkedList<Runnable>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Runnable() {

                @Override
                public void run() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            });
        }
        new LatchedRunnableExecutor(tasks).execute();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded && performConnectOperations(vds)) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded && connectVdsToNewMaster(vds)) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    StorageDomainStatic storage = DbFacade.getInstance().getStorageDomainStaticDao().get(getParameters().getStorageDomainId());
    if (storage.getstorage_domain_type() == StorageDomainType.ImportExport) {
        VDSReturnValue retVal = null;
        try {
            retVal = executeVerb();
        } catch (RuntimeException e) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.AddCustomValue("StorageDomainName", storage.getstorage_name());
            AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED);
            throw e;
        }
        buildOvfReturnValue(retVal.getReturnValue());
    } else {
        getQueryReturnValue().setReturnValue(new java.util.ArrayList<VM>());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    StorageDomainStatic storage = DbFacade.getInstance().getStorageDomainStaticDao().get(getParameters().getStorageDomainId());
    if (storage.getstorage_domain_type() == StorageDomainType.ImportExport) {
        VDSReturnValue retVal = null;
        retVal = executeVerb(storage);
        buildOvfReturnValue(retVal.getReturnValue());
    } else {
        getQueryReturnValue().setReturnValue(new java.util.ArrayList<VM>());
    }
}
#end_block

#method_before
protected VDSReturnValue executeVerb() {
    GetVmsInfoVDSCommandParameters tempVar = new GetVmsInfoVDSCommandParameters(getParameters().getStoragePoolId());
    tempVar.setStorageDomainId(getParameters().getStorageDomainId());
    tempVar.setVmIdList(getParameters().getIds());
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetVmsInfo, tempVar);
    return retVal;
}
#method_after
protected VDSReturnValue executeVerb(StorageDomainStatic storage) {
    try {
        GetVmsInfoVDSCommandParameters tempVar = new GetVmsInfoVDSCommandParameters(getParameters().getStoragePoolId());
        tempVar.setStorageDomainId(getParameters().getStorageDomainId());
        tempVar.setVmIdList(getParameters().getIds());
        VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetVmsInfo, tempVar);
        return retVal;
    } catch (RuntimeException e) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.AddCustomValue("StorageDomainName", storage.getstorage_name());
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED);
        throw e;
    }
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    // External Events/Alerts
    mSeverities.put(AuditLogType.EXTERNAL_EVENT_NORMAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.EXTERNAL_EVENT_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.EXTERNAL_EVENT_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.EXTERNAL_ALERT, AuditLogSeverity.ALERT);
}
#end_block

#method_before
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        if ((message = mMessages.get(logType)) != null) {
            String resolvedMessage = resolveMessage(message, auditLogable);
            AuditLogSeverity severity = AuditLogSeverity.forValue(0);
            if (!((severity = mSeverities.get(logType)) != null)) {
                severity = AuditLogSeverity.NORMAL;
                log.infoFormat("No severity for {0} type", logType);
            }
            AuditLog auditLog;
            if (auditLogable != null) {
                AuditLog tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                auditLog = tempVar;
            } else {
                auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
            }
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        } else if (auditLogable != null) {
            log.infoFormat("No string for {0} type. Use default Log", auditLogable.getAuditLogTypeValue());
            defaultLog(auditLogable);
        }
    }
}
#method_after
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        String resolvedMessage = null;
        AuditLogSeverity severity = AuditLogSeverity.forValue(0);
        if (!((severity = mSeverities.get(logType)) != null)) {
            severity = AuditLogSeverity.NORMAL;
            log.infoFormat("No severity for {0} type", logType);
        }
        AuditLog auditLog = null;
        if (auditLogable != null) {
            AuditLog tempVar = null;
            // handle external log messages invoked by plugins via the API
            if (auditLogable.isExternal()) {
                // message is sent as an argument, no need to resolve.
                resolvedMessage = message = loggerString;
                tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName(), auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
            } else if ((message = mMessages.get(logType)) != null) {
                // Application log message from AuditLogMessages
                resolvedMessage = resolveMessage(message, auditLogable);
                tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
            }
            if (tempVar != null) {
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                tempVar.setExternal(auditLogable.isExternal());
                auditLog = tempVar;
            }
        } else {
            auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
        }
        if (auditLog != null) {
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        }
    } else if (auditLogable != null) {
        log.infoFormat("No string for {0} type. Use default Log", auditLogable.getAuditLogTypeValue());
        defaultLog(auditLogable);
    }
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    if (logType.getDuplicateEventsIntervalValue() > 0) {
        auditLogable.setEndTime(DateTime.getNow().AddSeconds(logType.getDuplicateEventsIntervalValue()));
        auditLogable.setTimeoutObjectId(ComposeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getDuplicateEventsIntervalValue();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(DateTime.getNow().AddSeconds(logType.getDuplicateEventsIntervalValue()));
        auditLogable.setTimeoutObjectId(ComposeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getSnapshotDao().get(getParameters().getDstSnapshotId()), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getCompensationContext());
    getVmDAO().incrementVmDbGeneration(getVm().getId());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getSnapshotDao().get(getParameters().getDstSnapshotId()), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getCompensationContext());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // the update is being executed in the same transaction so we can restore the vm config and end the command.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // the update is being executed in the same transaction so we can restore the vm config and end the command.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                getVmStaticDAO().incrementDbGeneration(getVm().getId());
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmHandler.updateDisksFromDb(getVm());
    Collection<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, true);
    DiskImage vmDisk = LinqUtils.first(diskImages);
    boolean result = true;
    Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    result = result && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.snapshotExists(snapshot)) && validate(snapshotsValidator.snapshotNotBroken(snapshot));
    if (vmDisk != null) {
        result = result && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, false, false, true, true, true, true, getVm().getDiskMap().values());
    }
    if (result && LinqUtils.foreach(diskImages, new Function<DiskImage, Guid>() {

        @Override
        public Guid eval(DiskImage disk) {
            return disk.getvm_snapshot_id().getValue();
        }
    }).contains(getParameters().getDstSnapshotId())) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.CANNOT_PREIEW_CURRENT_IMAGE);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__PREVIEW);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    VmHandler.updateDisksFromDb(getVm());
    Collection<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, true);
    DiskImage vmDisk = LinqUtils.first(diskImages);
    boolean result = true;
    Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    result = result && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.snapshotExists(snapshot)) && validate(snapshotsValidator.snapshotNotBroken(snapshot));
    if (vmDisk != null) {
        result = result && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, false, false, true, true, true, true, getVm().getDiskMap().values());
    }
    if (result && LinqUtils.foreach(diskImages, new Function<DiskImage, Guid>() {

        @Override
        public Guid eval(DiskImage disk) {
            return disk.getvm_snapshot_id().getValue();
        }
    }).contains(getParameters().getDstSnapshotId())) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.CANNOT_PREIEW_CURRENT_IMAGE);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__PREVIEW);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    getVmDAO().incrementVmDbGeneration(getVm().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    setSucceeded(true);
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceType.DISK.getName());
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getVmId()), VmDeviceType.DISK, payload.getType(), payload.getSpecParams(), true, true);
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceType.DISK.getName());
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getVmId()), VmDeviceType.DISK, payload.getType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getvds_group_id().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return iface.getNetworkName().equals(n.getname());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getVdsGroupId().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return n.getName().equals(iface.getNetworkName());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getvm_name())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getvm_name(), vmFromParams.getvm_name())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getvm_name())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.getauto_startup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getos(), vmFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getvds_group_id().equals(vmFromParams.getvds_group_id())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getdefault_display_type(), vmFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getnum_of_monitors() < vmFromParams.getnum_of_monitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getnum_of_sockets(), vmFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getiso_path())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getusb_policy(), vmFromParams.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!isPinningAndMigrationValid(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getVmName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getVmName(), vmFromParams.getVmName())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getVmName())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return true;
}
#end_block

#method_before
protected boolean areUpdatedFieldsLegal() {
    return VmHandler.mUpdateVmsStatic.IsUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getstatus());
}
#method_after
protected boolean areUpdatedFieldsLegal() {
    return VmHandler.mUpdateVmsStatic.IsUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus());
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getvm_name())) {
        return Collections.singletonMap(getParameters().getVm().getvm_name(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getVmName())) {
        return Collections.singletonMap(getParameters().getVm().getVmName(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // The cases must be persistent with the create_functions_sp
    if (getVm().getstatus() == VMStatus.Down || getVm().getstatus() == VMStatus.Suspended || getVm().getstatus() == VMStatus.ImageIllegal || getVm().getstatus() == VMStatus.ImageLocked || getVm().getstatus() == VMStatus.PoweringDown) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
    } else {
        if (getParameters().getVmStaticData().getQuotaId() != null && !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getvmt_cpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), getParameters().getVmStaticData().getcpu_per_socket() * getParameters().getVmStaticData().getnum_of_sockets(), getParameters().getVmStaticData().getmem_size_mb()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // The cases must be persistent with the create_functions_sp
    if (getVm().getStatus() == VMStatus.Down || getVm().getStatus() == VMStatus.Suspended || getVm().getStatus() == VMStatus.ImageIllegal || getVm().getStatus() == VMStatus.ImageLocked || getVm().getStatus() == VMStatus.PoweringDown) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
    } else {
        if (getParameters().getVmStaticData().getQuotaId() == null || getParameters().getVmStaticData().getQuotaId().equals(NGuid.Empty) || !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getVmtCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), getParameters().getVmStaticData().getcpu_per_socket() * getParameters().getVmStaticData().getnum_of_sockets(), getParameters().getVmStaticData().getmem_size_mb()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getstorage_pool_id());
        }
    }
    return super.getStoragePoolId();
}
#method_after
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getStoragePoolId());
        }
    }
    return super.getStoragePoolId();
}
#end_block

#method_before
protected void removeVmUsers() {
    List<tags_vm_map> all = getTagDao().getTagVmMapByVmIdAndDefaultTag(getVmId());
    for (tags_vm_map tagVm : all) {
        getTagDao().detachVmFromTag(tagVm.gettag_id(), getVmId());
    }
}
#method_after
protected void removeVmUsers() {
    List<TagsVmMap> all = getTagDao().getTagVmMapByVmIdAndDefaultTag(getVmId());
    for (TagsVmMap tagVm : all) {
        getTagDao().detachVmFromTag(tagVm.gettag_id(), getVmId());
    }
}
#end_block

#method_before
protected void endVmCommand() {
    endActionOnDisks();
    endActionOnVmConfiguration();
    setSucceeded(true);
}
#method_after
protected void endVmCommand() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    unlockVm();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().getHibernationVolHandle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getvm_name();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getvm_os().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#method_after
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getVmName();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getVmOs().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#end_block

#method_before
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getos().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getOs().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!targetstorageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
            return false;
        }
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<Disk>(images.values()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : getDisksBasedOnImage()) {
            if (images.containsKey(img.getId())) {
                // mode)
                if (((DiskImage) images.get(img.getId())).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
        return false;
    }
    // check destination storage have free space
    int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
    if (!StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
        return false;
    }
    if (!(checkVmInStorageDomain() && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, true, true, getDisksBasedOnImage()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!targetstorageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!CheckTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getVmtName()));
            return false;
        }
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<Disk>(images.values()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : getDisksBasedOnImage()) {
            if (images.containsKey(img.getId())) {
                // mode)
                if (((DiskImage) images.get(img.getId())).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
        return false;
    }
    // check destination storage have free space
    int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
    if (!StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
        return false;
    }
    if (!(checkVmInStorageDomain() && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, false, true, false, false, true, true, true, true, getDisksBasedOnImage()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    VmHandler.updateDisksFromDb(vm);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    for (Disk disk : vm.getDiskMap().values()) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.setParentId(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
            DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
            diskImage.setvolume_format(diskForVolumeInfo.getvolume_format());
            diskImage.setvolume_type(diskForVolumeInfo.getvolume_type());
            VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
            if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
                DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
                diskImage.setactual_size(fromVdsm.getactual_size());
            }
            AllVmImages.add(diskImage);
        }
    }
    if (StringUtils.isEmpty(vm.getvmt_name())) {
        VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getvmt_guid());
        vm.setvmt_name(t.getname());
    }
    getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
    List<Guid> imageGroupIds = new ArrayList<Guid>();
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageGroupIds.add(disk.getId());
        }
    }
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
public boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    VmHandler.updateDisksFromDb(vm);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    for (Disk disk : vm.getDiskMap().values()) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.setParentId(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
            DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
            diskImage.setvolume_format(diskForVolumeInfo.getvolume_format());
            diskImage.setvolume_type(diskForVolumeInfo.getvolume_type());
            VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
            if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
                DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
                diskImage.setactual_size(fromVdsm.getactual_size());
            }
            AllVmImages.add(diskImage);
        }
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getname());
    }
    getVm().setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
    List<Guid> imageGroupIds = new ArrayList<Guid>();
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageGroupIds.add(disk.getId());
        }
    }
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getstorage_pool_id(), getParameters().getStorageDomainId());
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = (ArrayList<VM>) qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getvm_name().equals(getVm().getvm_name())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#method_after
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = (ArrayList<VM>) qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getVmName().equals(getVm().getVmName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean CheckTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BlankVmTemplateId.equals(tmplId)) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean CheckTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BlankVmTemplateId.equals(tmplId)) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#end_block

#method_before
protected boolean updateVmImSpm() {
    VmHandler.updateDisksFromDb(getVm());
    return OvfDataUpdater.executeUpdateVmInSpmCommand(getVm().getstorage_pool_id(), OvfDataUpdater.getVmsMetadataDictionary(getVm().getstorage_pool_id(), Arrays.asList(getVm())), getParameters().getStorageDomainId());
}
#method_after
protected boolean updateVmImSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfDataUpdater.getInstance().loadVmData(getVm());
    VmHandler.updateDisksFromDb(getVm());
    OvfDataUpdater.getInstance().buildMetadataDictionaryForVm(getVm(), metaDictionary);
    return OvfDataUpdater.getInstance().executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
private void endCopyCollapseOperations(VM vm) {
    vm.setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    vm.setvmt_name(null);
    Snapshot activeSnapshot = DbFacade.getInstance().getSnapshotDao().get(DbFacade.getInstance().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    updateCopyVmInSpm(getVm().getstorage_pool_id(), vm, getParameters().getStorageDomainId());
}
#method_after
private void endCopyCollapseOperations(VM vm) {
    vm.setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    vm.setVmtName(null);
    Snapshot activeSnapshot = DbFacade.getInstance().getSnapshotDao().get(DbFacade.getInstance().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    updateCopyVmInSpm(getVm().getStoragePoolId(), vm, getParameters().getStorageDomainId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = isVmExist();
    if (retValue) {
        if (!isDiskExist(_oldDisk)) {
            return false;
        }
        List<VM> listVms = getVmDAO().getForDisk(_oldDisk.getId()).get(Boolean.TRUE);
        buidSharedLockMap(listVms);
        buidExclusiveLockMap(listVms);
        acquireLockInternal();
        // Check if all VMs are in status down.
        if (listVms != null && !listVms.isEmpty()) {
            for (VM vm : listVms) {
                if (vm.getstatus() != VMStatus.Down) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
        retValue = checkCanPerformRegularUpdate();
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist()) {
        return false;
    }
    if (!isDiskExist(oldDisk)) {
        return false;
    }
    List<VM> vmsDiskPluggedTo = getVmDAO().getForDisk(oldDisk.getId()).get(Boolean.TRUE);
    if (vmsDiskPluggedTo != null && !vmsDiskPluggedTo.isEmpty()) {
        buildSharedLockMap(vmsDiskPluggedTo);
        buildExclusiveLockMap(vmsDiskPluggedTo);
        acquireLockInternal();
        // Check if all VMs are in status down.
        for (VM vm : vmsDiskPluggedTo) {
            if (vm.getStatus() != VMStatus.Down) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
            }
        }
    }
    return checkCanPerformRegularUpdate();
}
#end_block

#method_before
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(_oldDisk.getId());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!checkPciAndIdeLimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    // Validate update boot disk.
    if (retValue && getParameters().getDiskInfo().isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(_oldDisk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                break;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    return retValue && validateShareableDisk();
}
#method_after
private boolean checkCanPerformRegularUpdate() {
    if (oldDisk.getDiskInterface() != newDisk.getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(oldDisk.getId());
            }
        }));
        allVmDisks.add(newDisk);
        if (!checkPciAndIdeLimit(getVm().getNumOfMonitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // Validate update boot disk.
    if (newDisk.isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(oldDisk.getId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                return false;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(newDisk, getVm());
    return validateShareableDisk();
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
private boolean validateShareableDisk() {
    if (DiskStorageType.LUN == oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = newDisk.isShareable();
    boolean isOldDiskShareable = oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isOldDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(oldDisk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) newDisk;
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) oldDisk).setvm_snapshot_id(null);
    } else if (isOldDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (listPermissionSubjects == null) {
        listPermissionSubjects = new ArrayList<PermissionSubject>();
        Guid diskId = _oldDisk == null ? null : _oldDisk.getId();
        listPermissionSubjects.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.EDIT_DISK_PROPERTIES));
    }
    return listPermissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (listPermissionSubjects == null) {
        listPermissionSubjects = new ArrayList<PermissionSubject>();
        Guid diskId = oldDisk == null ? null : oldDisk.getId();
        listPermissionSubjects.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.EDIT_DISK_PROPERTIES));
    }
    return listPermissionSubjects;
}
#end_block

#method_before
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            clearAddressOnInterfaceChange();
            _oldDisk.setBoot(getParameters().getDiskInfo().isBoot());
            _oldDisk.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
            _oldDisk.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
            _oldDisk.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
            _oldDisk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
            _oldDisk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
            _oldDisk.setShareable(getParameters().getDiskInfo().isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(_oldDisk);
            if (_oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) _oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            getVmDAO().incrementVmDbGeneration(getVm().getId());
            setSucceeded(true);
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#method_after
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            clearAddressOnInterfaceChange();
            oldDisk.setBoot(newDisk.isBoot());
            oldDisk.setDiskInterface(newDisk.getDiskInterface());
            oldDisk.setPropagateErrors(newDisk.getPropagateErrors());
            oldDisk.setWipeAfterDelete(newDisk.isWipeAfterDelete());
            oldDisk.setDiskAlias(newDisk.getDiskAlias());
            oldDisk.setDiskDescription(newDisk.getDiskDescription());
            oldDisk.setShareable(newDisk.isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(oldDisk);
            if (oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            setSucceeded(true);
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (oldDisk.getDiskInterface() != newDisk.getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#end_block

#method_before
@Override
public String getDiskAlias() {
    return _oldDisk.getDiskAlias();
}
#method_after
@Override
public String getDiskAlias() {
    return oldDisk.getDiskAlias();
}
#end_block

#method_before
private boolean isQuotaValidationNeeded() {
    return DiskStorageType.IMAGE == _oldDisk.getDiskStorageType();
}
#method_after
private boolean isQuotaValidationNeeded() {
    return DiskStorageType.IMAGE == oldDisk.getDiskStorageType();
}
#end_block

#method_before
private Guid getQuotaId() {
    if (getParameters().getDiskInfo() != null && isQuotaValidationNeeded()) {
        return ((DiskImage) getParameters().getDiskInfo()).getQuotaId();
    }
    return null;
}
#method_after
private Guid getQuotaId() {
    if (newDisk != null && isQuotaValidationNeeded()) {
        return ((DiskImage) newDisk).getQuotaId();
    }
    return null;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) _oldDisk;
        DiskImage newDiskImage = (DiskImage) getParameters().getDiskInfo();
        if (oldDiskImage.getQuotaId() == null || !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
            if (oldDiskImage.getQuotaId() != null && !Guid.Empty.equals(oldDiskImage.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
                oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
            }
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        DiskImage newDiskImage = (DiskImage) newDisk;
        if (oldDiskImage.getQuotaId() == null || !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
            if (oldDiskImage.getQuotaId() != null && !Guid.Empty.equals(oldDiskImage.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
                oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
            }
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
protected boolean ConcreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (!tmpRetValue.getSucceeded()) {
                log.error("AddVmFromScratchCommand::ConcreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
            }
        }
        VmHandler.LockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmDAO().incrementVmDbGeneration(getParameters().getVmStaticData().getId());
    }
    return ret;
}
#method_after
protected boolean ConcreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (!tmpRetValue.getSucceeded()) {
                log.error("AddVmFromScratchCommand::ConcreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
            }
        }
        VmHandler.LockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    return ret;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = sourceDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    }
    if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            DiskImageList images = new DiskImageList();
            for (VmTemplate t : templates.keySet()) {
                if (t.getId().equals(getVmTemplate().getId())) {
                    images = templates.get(t);
                    getVmTemplate().setInterfaces(t.getInterfaces());
                    break;
                }
            }
            ArrayList<DiskImage> list = new ArrayList<DiskImage>(Arrays.asList(images.getDiskImages()));
            getParameters().setImages(list);
            getVmTemplate().setImages(list);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            Map<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : list) {
                storage_domains storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                }
                storage_domain_static targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getstorage_type(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getname()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getsize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(getVmTemplate().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = sourceDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    }
    if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            DiskImageList images = new DiskImageList();
            for (VmTemplate t : templates.keySet()) {
                if (t.getId().equals(getVmTemplate().getId())) {
                    images = templates.get(t);
                    getVmTemplate().setInterfaces(t.getInterfaces());
                    break;
                }
            }
            ArrayList<DiskImage> list = new ArrayList<DiskImage>(Arrays.asList(images.getDiskImages()));
            getParameters().setImages(list);
            getVmTemplate().setImages(list);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            Map<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : list) {
                storage_domains storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getstorage_type(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getname()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getsize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(getVmTemplate().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<VmNetworkInterface> interfaces = getVmTemplate().getInterfaces();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id()));
    String networkName;
    for (VmNetworkInterface iface : interfaces) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        networkName = iface.getNetworkName();
        iface.setVmId(getVmTemplateId());
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        iDynamic.setStatistics(iStat);
        iDynamic.setId(iface.getId());
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        if (vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            iDynamic.setNetworkName(networkName);
        } else {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iDynamic.setNetworkName(StringUtils.EMPTY);
        }
        iDynamic.setSpeed(iface.getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
        getCompensationContext().snapshotNewEntity(iDynamic);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<VmNetworkInterface> interfaces = getVmTemplate().getInterfaces();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id()));
    String networkName;
    for (VmNetworkInterface iface : interfaces) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        networkName = iface.getNetworkName();
        iface.setVmId(getVmTemplateId());
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        iDynamic.setStatistics(iStat);
        iDynamic.setId(iface.getId());
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        if (vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            iDynamic.setNetworkName(networkName);
        } else {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iDynamic.setNetworkName(null);
        }
        iDynamic.setLinked(iface.isLinked());
        iDynamic.setSpeed(iface.getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
        getCompensationContext().snapshotNewEntity(iDynamic);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
@Override
protected void endMoveOrCopyCommand() {
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
    endActionOnAllImageGroups();
    updateTemplateInSpm();
    setSucceeded(true);
}
#method_after
@Override
protected void endMoveOrCopyCommand() {
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
    endActionOnAllImageGroups();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    } else {
        return super.getVmId();
    }
}
#method_after
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    }
    return super.getVmId();
}
#end_block

#method_before
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    } else {
        return super.getVm();
    }
}
#method_after
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    }
    return super.getVm();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    Map<Guid, storage_domains> domainsMap = new HashMap<Guid, storage_domains>();
    retVal = canDoAction_beforeCloneVm(retVal, canDoActionMessages, domainsMap);
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
    }
    return retVal && canDoAction_afterCloneVm(retVal, canDoActionMessages, domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, storage_domains> domainsMap = new HashMap<Guid, storage_domains>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setvm_name(getParameters().getVm().getvm_name());
    getVm().setstorage_pool_id(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setVmName(getParameters().getVm().getVmName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#end_block

#method_before
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getvmt_guid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getvmt_guid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#method_after
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getVmtGuid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getVmtGuid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getstorage_pool_id() != null ? image.getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getParameters().getSourceDomainId();
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getstorage_pool_id() != null ? image.getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getParameters().getSourceDomainId();
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getvm_name())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#method_after
protected boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getVmName())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        VM vm = getVm();
        // vm related ops
        if (!hasSnappableDisks(vm)) {
            endVmRelatedOps();
        } else {
            processImages();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        VM vm = getVm();
        // vm related ops
        if (vm.getImages().isEmpty()) {
            endVmRelatedOps();
        } else {
            processImages();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < list.size() - 1; i++) {
                    list.get(i).setId(disk.getId());
                }
            }
            disk.setcreation_date(new Date());
            BaseImagesCommand.saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        }
        Snapshot snapshot = new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            BaseImagesCommand.saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
                getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getdescription(), disk.getlast_modified_date(), disk.getappList()));
            }
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        }
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            DbFacade.getInstance().getImageDao().update(disk.getImage());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = diskList.get(diskList.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < diskList.size() - 1; i++) {
                    diskList.get(i).setId(disk.getId());
                }
            }
            disk.setcreation_date(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = diskList.get(diskList.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    }
    getVmStaticDAO().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getmem_size_mb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(getVm().getvds_group_id());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroupDAO().get(getVm().getVdsGroupId());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#end_block

#method_before
private void logField(VmStatic vmStaticFromOvf, String fieldName, String fieldValue) {
    String vmName = vmStaticFromOvf.getvm_name();
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("FieldName", fieldName);
    logable.AddCustomValue("VmName", vmName);
    logable.AddCustomValue("FieldValue", fieldValue);
    AuditLogDirector.log(logable, AuditLogType.VM_IMPORT_INFO);
}
#method_after
private static void logField(VmStatic vmStaticFromOvf, String fieldName, String fieldValue) {
    String vmName = vmStaticFromOvf.getvm_name();
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("FieldName", fieldName);
    logable.AddCustomValue("VmName", vmName);
    logable.AddCustomValue("FieldValue", fieldValue);
    AuditLogDirector.log(logable, AuditLogType.VM_IMPORT_INFO);
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getVdsGroupId()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(null);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getvm_name());
}
#method_after
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getVmName());
}
#end_block

#method_before
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setstatus(VMStatus.ImageLocked);
    tempVar.setvm_host("");
    tempVar.setvm_ip("");
    tempVar.setapp_list(getParameters().getVm().getDynamicData().getapp_list());
    DbFacade.getInstance().getVmDynamicDao().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#method_after
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setstatus(VMStatus.ImageLocked);
    tempVar.setvm_host("");
    tempVar.setvm_ip("");
    tempVar.setapp_list(getParameters().getVm().getDynamicData().getapp_list());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#end_block

#method_before
private void addVmStatistics() {
    VmStatistics stats = new VmStatistics();
    stats.setId(getVmId());
    DbFacade.getInstance().getVmStatisticsDao().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
    getCompensationContext().stateChanged();
}
#method_after
private void addVmStatistics() {
    VmStatistics stats = new VmStatistics();
    stats.setId(getVmId());
    getVmStatisticsDAO().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
    getCompensationContext().stateChanged();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDao().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        removeVmNetworkInterfaces();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDao().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDao().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDao().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            getDiskImageDynamicDAO().remove(disk.getImageId());
            getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                getBaseDiskDao().remove(disk.getId());
            }
        }
        removeVmNetworkInterfaces();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        getVmDynamicDAO().remove(getVmId());
        getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#end_block

#method_before
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        getVmDAO().incrementVmDbGeneration(getVm().getId());
        ;
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#method_after
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getvds_group_id(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
        if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getrun_on_vds() != null) {
            performLiveSnapshot(createdSnapshotId);
        }
    } else {
        revertToActiveSnapshot(createdSnapshotId);
    }
    endActionOnDisks();
    getVmDAO().incrementVmDbGeneration(getVm().getId());
    setSucceeded(getParameters().getTaskGroupSuccess());
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
        if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
            performLiveSnapshot(createdSnapshotId);
        }
    } else {
        revertToActiveSnapshot(createdSnapshotId);
    }
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    setSucceeded(getParameters().getTaskGroupSuccess());
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected void performLiveSnapshot(Guid createdSnapshotId) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                List<Disk> pluggedDisks = VmRunHandler.getInstance().getPluggedDisks(getVm());
                runVdsCommand(VDSCommandType.Snapshot, new SnapshotVDSCommandParameters(getVm().getrun_on_vds().getValue(), getVm().getId(), ImagesHandler.filterImageDisks(pluggedDisks, false, true)));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.SNAPSHOT_FAILED) {
            getParameters().setTaskGroupSuccess(false);
            log.errorFormat("Wasn't able to live snpashot due to error: {0}, rolling back.", ExceptionUtils.getMessage(e));
            revertToActiveSnapshot(createdSnapshotId);
        } else {
            throw e;
        }
    }
}
#method_after
protected void performLiveSnapshot(Guid createdSnapshotId) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                List<Disk> pluggedDisks = VmRunHandler.getInstance().getPluggedDisks(getVm());
                runVdsCommand(VDSCommandType.Snapshot, new SnapshotVDSCommandParameters(getVm().getRunOnVds().getValue(), getVm().getId(), ImagesHandler.filterImageDisks(pluggedDisks, false, true)));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        if (e.getErrorCode() != VdcBllErrors.SNAPSHOT_FAILED) {
            throw e;
        }
        handleVdsLiveSnapshotFailure(e);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, checkVmIsDown(), true, true, disksList);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && canDoSnapshot(getVm()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, true, true, true, false, true, true, disksList);
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()));
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false);
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, true, true, true, true, false, true, diskImages);
    setStoragePoolId(getVm().getstorage_pool_id());
    ensureDomainMap(diskImages, getParameters().getStorageDomainId());
    for (DiskImage disk : diskImages) {
        imageFromSourceDomainMap.put(disk.getId(), disk);
    }
    retValue = retValue && checkTemplateInStorageDomain(diskImages);
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    return retValue && destinationHasSpace();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()));
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false);
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, false, true, true, true, true, true, false, true, diskImages);
    setStoragePoolId(getVm().getStoragePoolId());
    ensureDomainMap(diskImages, getParameters().getStorageDomainId());
    for (DiskImage disk : diskImages) {
        imageFromSourceDomainMap.put(disk.getId(), disk);
    }
    retValue = retValue && checkTemplateInStorageDomain(diskImages);
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    return retValue && destinationHasSpace();
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain(List<DiskImage> diskImages) {
    boolean retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(diskImages);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid())) {
        List<DiskImage> imageList = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVm().getvmt_guid()), false, false);
        Map<Guid, DiskImage> templateImagesMap = new HashMap<Guid, DiskImage>();
        for (DiskImage image : imageList) {
            templateImagesMap.put(image.getImageId(), image);
        }
        for (DiskImage image : diskImages) {
            if (templateImagesMap.containsKey(image.getit_guid())) {
                if (!templateImagesMap.get(image.getit_guid()).getstorage_ids().contains(getParameters().getStorageDomainId())) {
                    retValue = false;
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
                    break;
                }
            }
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain(List<DiskImage> diskImages) {
    boolean retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(diskImages);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid())) {
        List<DiskImage> imageList = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVm().getVmtGuid()), false, false);
        Map<Guid, DiskImage> templateImagesMap = new HashMap<Guid, DiskImage>();
        for (DiskImage image : imageList) {
            templateImagesMap.put(image.getImageId(), image);
        }
        for (DiskImage image : diskImages) {
            if (templateImagesMap.containsKey(image.getit_guid())) {
                if (!templateImagesMap.get(image.getit_guid()).getstorage_ids().contains(getParameters().getStorageDomainId())) {
                    retValue = false;
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
                    break;
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VM vm = getVm();
    if (vm.getstatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // Check if vm is initializing to run or already running - if it is in
    // such state,
    // we cannot move the vm
    boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
    if (isVmDuringInit) {
        log.errorFormat("VM {0} must be down for Move VM to be successfuly executed", vm.getvm_name());
        setActionReturnValue(vm.getstatus());
        setSucceeded(false);
        return;
    }
    VmHandler.LockVm(vm.getDynamicData(), getCompensationContext());
    moveOrCopyAllImageGroups();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VM vm = getVm();
    if (vm.getStatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // Check if vm is initializing to run or already running - if it is in
    // such state,
    // we cannot move the vm
    boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
    if (isVmDuringInit) {
        log.errorFormat("VM {0} must be down for Move VM to be successfuly executed", vm.getVmName());
        setActionReturnValue(vm.getStatus());
        setSucceeded(false);
        return;
    }
    VmHandler.LockVm(vm.getDynamicData(), getCompensationContext());
    moveOrCopyAllImageGroups();
    setSucceeded(true);
}
#end_block

#method_before
protected void endMoveVmCommand() {
    endActionOnAllImageGroups();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        VmHandler.updateDisksFromDb(getVm());
        getVmDAO().incrementVmDbGeneration(getVm().getId());
        ;
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveVmCommand::EndMoveVmCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#method_after
protected void endMoveVmCommand() {
    boolean vmExists = (getVm() != null);
    if (vmExists) {
        incrementDbGeneration();
    }
    endActionOnAllImageGroups();
    if (vmExists) {
        VmHandler.UnLockVm(getVm());
        VmHandler.updateDisksFromDb(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveVmCommand::EndMoveVmCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean canRemoveLunDisk() {
    if (disk.getVmEntityType() == VmEntityType.VM) {
        for (VM vm : getVmsForDiskId()) {
            if (vm.getstatus() != VMStatus.Down) {
                VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
                if (vmDevice.getIsPlugged()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
    }
    return true;
}
#method_after
private boolean canRemoveLunDisk() {
    if (disk.getVmEntityType() == VmEntityType.VM) {
        for (VM vm : getVmsForDiskId()) {
            if (vm.getStatus() != VMStatus.Down) {
                VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
                if (vmDevice.getIsPlugged()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean canRemoveTemplateDisk() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (retValue && diskImage.getstorage_ids().size() == 1) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_LAST_DOMAIN);
    }
    if (retValue) {
        List<String> problematicVmNames = new ArrayList<String>();
        List<VM> vms = DbFacade.getInstance().getVmDao().getAllWithTemplate(getVmTemplateId());
        for (VM vm : vms) {
            List<Disk> vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
            for (Disk vmDisk : vmDisks) {
                if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage vmDiskImage = (DiskImage) vmDisk;
                    if (vmDiskImage.getit_guid().equals(diskImage.getImageId())) {
                        if (vmDiskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
                            retValue = false;
                            problematicVmNames.add(vm.getvm_name());
                        }
                        break;
                    }
                }
            }
        }
        if (!retValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
            addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveTemplateDisk() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (retValue && diskImage.getstorage_ids().size() == 1) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_LAST_DOMAIN);
    }
    if (retValue) {
        List<String> problematicVmNames = new ArrayList<String>();
        List<VM> vms = DbFacade.getInstance().getVmDao().getAllWithTemplate(getVmTemplateId());
        for (VM vm : vms) {
            List<Disk> vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
            for (Disk vmDisk : vmDisks) {
                if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage vmDiskImage = (DiskImage) vmDisk;
                    if (vmDiskImage.getit_guid().equals(diskImage.getImageId())) {
                        if (vmDiskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
                            retValue = false;
                            problematicVmNames.add(vm.getVmName());
                        }
                        break;
                    }
                }
            }
        }
        if (!retValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
            addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    boolean firstTime = true;
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<Disk> diskList = Arrays.asList(disk);
    for (VM vm : listVms) {
        VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getParameters().getStorageDomainId(), false, firstTime, false, false, vmDevice.getIsPlugged() && disk.isAllowSnapshot(), vmDevice.getIsPlugged(), false, firstTime, diskList)) {
            return false;
        }
        firstTime = false;
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    boolean firstTime = true;
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<Disk> diskList = Arrays.asList(disk);
    for (VM vm : listVms) {
        VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getStoragePoolId(), getParameters().getStorageDomainId(), false, firstTime, false, false, vmDevice.getIsPlugged() && disk.isAllowSnapshot(), vmDevice.getIsPlugged(), false, firstTime, diskList)) {
            return false;
        }
        firstTime = false;
    }
    return true;
}
#end_block

#method_before
private void endCommand() {
    List<VM> listVms = getVmsForDiskId();
    Backend.getInstance().EndAction(VdcActionType.RemoveImage, getParameters().getImagesParameters().get(0));
    for (VM vm : listVms) {
        getVmDAO().incrementVmDbGeneration(vm.getId());
    }
    setSucceeded(true);
}
#method_after
private void endCommand() {
    List<VM> listVms = getVmsForDiskId();
    for (VM vm : listVms) {
        getVmStaticDAO().incrementDbGeneration(vm.getId());
    }
    Backend.getInstance().EndAction(VdcActionType.RemoveImage, getParameters().getImagesParameters().get(0));
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#method_after
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endDefaultOperations() {
    endTemplateRelatedOperations();
    endUnlockOps();
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getStoragePoolId() == null ? null : getVdsGroup().getStoragePoolId().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    }
    return permissionCheckSubject;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            final List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Void runInTransaction() {
                    for (VM vm : vmsInPool) {
                        getVmDAO().updateVmOvfGeneration(vm.getId(), 0);
                    }
                    return null;
                }
            });
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
        getVmTemplateDAO().incrementVmTemplateDbGeneration(getVmTemplateId());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#method_after
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        incrementDbGeneration();
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#end_block

#method_before
protected void RemoveNetwork() {
    List<VmNetworkInterface> list = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getVmTemplateId());
    for (VmNetworkInterface iface : list) {
        DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(iface.getId(), getVmTemplateId()));
        DbFacade.getInstance().getVmNetworkInterfaceDao().remove(iface.getId());
    // \\DbFacade.Instance.RemoveInterfaceStatistics(iface.id);
    }
}
#method_after
protected void RemoveNetwork() {
    List<VmNetworkInterface> list = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getVmTemplateId());
    for (VmNetworkInterface iface : list) {
        DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(iface.getId(), getVmTemplateId()));
        DbFacade.getInstance().getVmNetworkInterfaceDao().remove(iface.getId());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate() != null) {
        UpdateVmTemplate();
        if (getVmTemplate().getstorage_pool_id() != null && !VmTemplateHandler.BlankVmTemplateId.equals(getVmTemplate().getId())) {
            getVmTemplateDAO().incrementVmTemplateDbGeneration(getVmTemplate().getId());
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate() != null) {
        getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
        UpdateVmTemplate();
        setSucceeded(true);
    }
}
#end_block

#method_before
private void UpdateVmTemplate() {
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
}
#method_after
private void UpdateVmTemplate() {
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
}
#end_block

#method_before
@OnTimerMethodAnnotation("ovfUpdate_timer")
public void ovfUpdate_timer() {
    log.info("OvfDataUpdater: Attempting to update VMs/Templates Ovf.");
    List<storage_pool> storagePools = DbFacade.getInstance().getStoragePoolDao().getAll();
    for (storage_pool pool : storagePools) {
        try {
            if (StoragePoolStatus.Up == pool.getstatus()) {
                log.infoFormat("OvfDataUpdater: Attempting to update VMs/Templates Ovf in Data Center {0}", pool.getname());
                List<VM> vmsForUpdate = getVmsForUpdate(DbFacade.getInstance().getVmDao().getAllVmsForOvfUpdateForStoragePool(pool.getId()));
                VmCommand.updateVmInSpm(pool.getId(), vmsForUpdate);
                if (!vmsForUpdate.isEmpty()) {
                    for (VM vm : vmsForUpdate) {
                        DbFacade.getInstance().getVmDao().updateVmOvfGeneration(vm.getId(), vm.getStaticData().getDb_generation());
                    }
                }
                List<VmTemplate> templatesForUpdate = getTemplatesForUpdate(DbFacade.getInstance().getVmTemplateDao().getAllVmTemplatesForOvfUpdateForStoragePool(pool.getId()));
                if (!templatesForUpdate.isEmpty()) {
                    VmTemplateCommand.UpdateTemplateInSpm(pool.getId(), templatesForUpdate);
                    for (VmTemplate template : templatesForUpdate) {
                        DbFacade.getInstance().getVmDao().updateVmOvfGeneration(template.getId(), template.getDb_generation());
                    }
                }
            }
        } catch (Exception ex) {
            addAuditLogError(pool.getname());
            log.errorFormat("Exception while trying to update VMs/Templates ovf in Data Center {0}, the exception is {1}", pool.getname(), ex.getMessage());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("ovfUpdate_timer")
public void ovfUpdate_timer() {
    itemsCountPerUpdate = reloadConfigValue();
    log.info("OvfDataUpdater: Attempting to update VMs/Templates Ovf.");
    List<storage_pool> storagePools = getStoragePoolDao().getAllByStatus(StoragePoolStatus.Up);
    for (storage_pool pool : storagePools) {
        try {
            log.infoFormat("Attempting to update VM OVFs in Data Center {0}", pool.getname());
            initProccessedInfoLists();
            updateOvfForVmsOfStoragePool(pool.getId());
            log.infoFormat("Successfully updated VM OVFs in Data Center {0}", pool.getname());
            log.infoFormat("Attempting to update template OVFs in Data Center {0}", pool.getname());
            updateOvfForTemplatesOfStoragePool(pool.getId());
            log.infoFormat("Succesfully updated templates OVFs in Data Center {0}", pool.getname());
            log.infoFormat("Attempting to remove uneeded template/vm OVFs in Data Center {0}", pool.getname());
            removeOvfForTemplatesAndVmsOfStoragePool(pool.getId());
            log.infoFormat("Succesfully removed unneeded template/vm OVFs in Data Center {0}", pool.getname());
        } catch (Exception ex) {
            addAuditLogError(pool.getname());
            log.errorFormat("Exception while trying to update or remove VMs/Templates ovf in Data Center {0}, the exception is {1}", pool.getname(), ex.getMessage());
            log.debug(ex.getStackTrace());
        }
    }
    proccessedIdsInfo = null;
    proccessedOvfGenerationsInfo = null;
}
#end_block

#method_before
private boolean verifyDisksNotLocked(List<DiskImage> disks) {
    for (DiskImage disk : disks) {
        if (disk.getimageStatus() == ImageStatus.LOCKED) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean verifyDisksNotLocked(List<DiskImage> disks) {
    for (DiskImage disk : disks) {
        if (disk.getimageStatus() == ImageStatus.LOCKED) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void addAuditLogError(String storagePoolName) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("StoragePoolName", storagePoolName);
    AuditLogDirector.log(logable, AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED);
}
#method_after
protected void addAuditLogError(String storagePoolName) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("StoragePoolName", storagePoolName);
    AuditLogDirector.log(logable, AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED);
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setOvf_generation(rs.getLong("ovf_generation"));
    entity.setDb_generation(rs.getLong("db_generation"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    OvfDataUpdater.getInstance().InitOvfDataUpdater();
    log.infoFormat("OvfDataUpdater: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    log.infoFormat("OvfDataUpdater: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    try {
        log.infoFormat("Init VM Custom Properties utilities: {0}", new Date());
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.errorFormat("Initialization failed. Exception message is {0} ", e.getMessage());
        log.debug("Initialization failed ", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (deleteProtected != other.deleteProtected) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()));
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getDescription()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOs()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getVmName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.isInitialized()).addValue("is_auto_suspend", vm.isAutoSuspend()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setVmName(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setVmOs(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOs(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setAutoSuspend(rs.getBoolean("is_auto_suspend"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setSelectionAlgorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    return entity;
}
#end_block

#method_before
@Override
public List<VmTemplate> getAllTemplatesRelatedToQuotaId(Guid quotaId) {
    return getCallsHandler().executeReadList("GetAllVmTemplatesRelatedToQuotaId", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource());
}
#method_after
@Override
public List<VmTemplate> getAllTemplatesRelatedToQuotaId(Guid quotaId) {
    return getCallsHandler().executeReadList("GetAllVmTemplatesRelatedToQuotaId", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource().addValue("quota_id", quotaId));
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private Guid[] getUserAndGroupIdsForUser(Guid userId) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", userId);
    DbUser user = (DbUser) query.uniqueResult();
    if (user == null) {
        return new Guid[0];
    }
    query = getSession().createQuery("from ad_groups where name in (:names)");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<AdGroups> groups = query.list();
    Guid[] result = new Guid[groups.size() + 1];
    result[0] = userId;
    for (int index = 0; index < groups.size(); index++) {
        result[index + 1] = groups.get(index).getid();
    }
    return result;
}
#method_after
private Guid[] getUserAndGroupIdsForUser(Guid userId) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", userId);
    DbUser user = (DbUser) query.uniqueResult();
    if (user == null) {
        return new Guid[0];
    }
    query = getSession().createQuery("from ad_groups where name in (:names)");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<LdapGroup> groups = query.list();
    Guid[] result = new Guid[groups.size() + 1];
    result[0] = userId;
    for (int index = 0; index < groups.size(); index++) {
        result[index + 1] = groups.get(index).getid();
    }
    return result;
}
#end_block

#method_before
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null && !model.getIsEveryoneSelected()) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    model.StartProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    PermissionsOperationsParametes permissionParams;
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(ApplicationGuids.quotaConsumer.asGuid());
        permissions perm = tempVar2;
        perm.setObjectId(((Quota) getEntity()).getId());
        perm.setObjectType(VdcObjectType.Quota);
        permissionParams = new PermissionsOperationsParametes();
        if (user.getIsGroup()) {
            permissionParams.setAdGroup(new AdGroups(user.getuser_id(), user.getname(), user.getdomain()));
        } else {
            permissionParams.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
        }
        permissionParams.setPermission(perm);
        list.add(permissionParams);
    }
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            QuotaUserListModel localModel = (QuotaUserListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
    Cancel();
}
#method_after
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null && !model.getIsEveryoneSelected()) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    model.StartProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    PermissionsOperationsParametes permissionParams;
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(ApplicationGuids.quotaConsumer.asGuid());
        permissions perm = tempVar2;
        perm.setObjectId(((Quota) getEntity()).getId());
        perm.setObjectType(VdcObjectType.Quota);
        permissionParams = new PermissionsOperationsParametes();
        if (user.getIsGroup()) {
            permissionParams.setAdGroup(new LdapGroup(user.getuser_id(), user.getname(), user.getdomain()));
        } else {
            permissionParams.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
        }
        permissionParams.setPermission(perm);
        list.add(permissionParams);
    }
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            QuotaUserListModel localModel = (QuotaUserListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
    Cancel();
}
#end_block

#method_before
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<AdUser> results = new ArrayList<AdUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<AdUser> tempUsers = (java.util.ArrayList<AdUser>) LdapFactory.getInstance(getDomain()).RunAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#method_after
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<LdapUser> tempUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).RunAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#end_block

#method_before
private void PopulateGroups() {
    try {
        boolean performPopulate = true;
        List<AdUser> users = (List<AdUser>) getReturnValue();
        if (getParameters() instanceof LdapSearchByUserIdListParameters) {
            LdapSearchByUserIdListParameters params = (LdapSearchByUserIdListParameters) getParameters();
            performPopulate = params.getPerformGroupsQueryInsideCmd();
        }
        if (performPopulate) {
            LdapBrokerUtils.performGroupPopulationForUsers(users, getLoginName(), getPassword(), getDomain(), new ArrayList<AdGroups>());
        }
    } catch (RuntimeException ex) {
        log.infoFormat("GetAdUserByUserIdListCommand failed. Exception: {0}", ex);
    }
}
#method_after
private void PopulateGroups() {
    try {
        boolean performPopulate = true;
        List<LdapUser> users = (List<LdapUser>) getReturnValue();
        if (getParameters() instanceof LdapSearchByUserIdListParameters) {
            LdapSearchByUserIdListParameters params = (LdapSearchByUserIdListParameters) getParameters();
            performPopulate = params.getPerformGroupsQueryInsideCmd();
        }
        if (performPopulate) {
            LdapBrokerUtils.performGroupPopulationForUsers(users, getLoginName(), getPassword(), getDomain(), new ArrayList<LdapGroup>());
        }
    } catch (RuntimeException ex) {
        log.infoFormat("GetAdUserByUserIdListCommand failed. Exception: {0}", ex);
    }
}
#end_block

#method_before
@Override
protected AdGroups getEntity(int index) {
    AdGroups entity = new AdGroups();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#method_after
@Override
protected LdapGroup getEntity(int index) {
    LdapGroup entity = new LdapGroup();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#end_block

#method_before
protected List<AdGroups> setUpGroups() {
    List<AdGroups> groups = new ArrayList<AdGroups>();
    for (int i = 0; i < NAMES.length; i++) {
        groups.add(getEntity(i));
    }
    return groups;
}
#method_after
protected List<LdapGroup> setUpGroups() {
    List<LdapGroup> groups = new ArrayList<LdapGroup>();
    for (int i = 0; i < NAMES.length; i++) {
        groups.add(getEntity(i));
    }
    return groups;
}
#end_block

#method_before
protected AdGroups getAdGroup(int index) {
    AdGroups adGroup = new AdGroups();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#method_after
protected LdapGroup getAdGroup(int index) {
    LdapGroup adGroup = new LdapGroup();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#end_block

#method_before
protected AdGroups getAdGroupWithDomain(int index) {
    AdGroups adGroup = new AdGroups();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(DOMAIN + "/" + NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#method_after
protected LdapGroup getAdGroupWithDomain(int index) {
    LdapGroup adGroup = new LdapGroup();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(DOMAIN + "/" + NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#end_block

#method_before
public static AdGroups setUpEntityExpectations(AdGroups entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getdomain()).andReturn(DOMAIN).anyTimes();
    expect(entity.getstatus()).andReturn(AdRefStatus.Active).anyTimes();
    return entity;
}
#method_after
public static LdapGroup setUpEntityExpectations(LdapGroup entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getdomain()).andReturn(DOMAIN).anyTimes();
    expect(entity.getstatus()).andReturn(AdRefStatus.Active).anyTimes();
    return entity;
}
#end_block

#method_before
public void add() {
    if (getWindow() != null) {
        return;
    }
    AdElementListModel model = new AdElementListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addUsersAndGroupsTitle());
    // $NON-NLS-1$
    model.setHashName("add_users_and_groups");
    model.setExcludeItems(DataProvider.GetUserList());
    model.setIsRoleListHidden(true);
    model.getIsEveryoneSelectionHidden().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAdd", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void add() {
    if (getWindow() != null) {
        return;
    }
    AdElementListModel model = new AdElementListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addUsersAndGroupsTitle());
    // $NON-NLS-1$
    model.setHashName("add_users_and_groups");
    model.setIsRoleListHidden(true);
    model.getIsEveryoneSelectionHidden().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAdd", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.getIsGroup()) {
            AddUserParameters tempVar = new AddUserParameters();
            tempVar.setVdcUser(new VdcUser(item.getuser_id(), item.getusername(), item.getdomain()));
            parameters.add(tempVar);
        } else {
            AddUserParameters tempVar2 = new AddUserParameters();
            tempVar2.setAdGroup(new AdGroups(item.getuser_id(), item.getname(), item.getdomain()));
            parameters.add(tempVar2);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddUser, parameters, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.getIsGroup()) {
            AddUserParameters tempVar = new AddUserParameters();
            tempVar.setVdcUser(new VdcUser(item.getuser_id(), item.getusername(), item.getdomain()));
            parameters.add(tempVar);
        } else {
            AddUserParameters tempVar2 = new AddUserParameters();
            tempVar2.setAdGroup(new LdapGroup(item.getuser_id(), item.getname(), item.getdomain()));
            parameters.add(tempVar2);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddUser, parameters, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void ExecuteQuery() {
    AdGroups group = InternalBrokerUtils.getGroupByGroupGuid(getGroupId());
    setReturnValue(group);
    if (group != null) {
        setSucceeded(true);
    } else {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void ExecuteQuery() {
    LdapGroup group = InternalBrokerUtils.getGroupByGroupGuid(getGroupId());
    setReturnValue(group);
    if (group != null) {
        setSucceeded(true);
    } else {
        setSucceeded(false);
    }
}
#end_block

#method_before
@Override
public permissions getForRoleAndAdElementAndObjectWithGroupCheck(Guid roleid, Guid elementid, Guid objectid) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", objectid);
    DbUser user = (DbUser) query.uniqueResult();
    query = getSession().createQuery("from ad_groups where name in :names");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<AdGroups> groups = query.list();
    List<Guid> ids = new ArrayList<Guid>();
    ids.add(user.getuser_id());
    for (AdGroups group : groups) {
        ids.add(group.getid());
    }
    return fillInPermissionDetails(findOneByCriteria(Restrictions.eq("roleId", roleid), Restrictions.eq("adElementId", elementid), Restrictions.eq("objectId", objectid), Restrictions.in("adElementId", ids)));
}
#method_after
@Override
public permissions getForRoleAndAdElementAndObjectWithGroupCheck(Guid roleid, Guid elementid, Guid objectid) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", objectid);
    DbUser user = (DbUser) query.uniqueResult();
    query = getSession().createQuery("from ad_groups where name in :names");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<LdapGroup> groups = query.list();
    List<Guid> ids = new ArrayList<Guid>();
    ids.add(user.getuser_id());
    for (LdapGroup group : groups) {
        ids.add(group.getid());
    }
    return fillInPermissionDetails(findOneByCriteria(Restrictions.eq("roleId", roleid), Restrictions.eq("adElementId", elementid), Restrictions.eq("objectId", objectid), Restrictions.in("adElementId", ids)));
}
#end_block

#method_before
public AdGroups getUserGroup() {
    return userGroup;
}
#method_after
public LdapGroup getUserGroup() {
    return userGroup;
}
#end_block

#method_before
protected List<AdGroups> getEntityList() {
    List<AdGroups> entities = new ArrayList<AdGroups>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#method_after
protected List<LdapGroup> getEntityList() {
    List<LdapGroup> entities = new ArrayList<LdapGroup>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#end_block

#method_before
protected AdGroups getEntity(int index) {
    return setUpEntityExpectations(control.createMock(AdGroups.class), index);
}
#method_after
protected LdapGroup getEntity(int index) {
    return setUpEntityExpectations(control.createMock(LdapGroup.class), index);
}
#end_block

#method_before
static AdGroups setUpEntityExpectations(AdGroups entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getname()).andReturn(NAMES[index]).anyTimes();
    return entity;
}
#method_after
static LdapGroup setUpEntityExpectations(LdapGroup entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getname()).andReturn(NAMES[index]).anyTimes();
    return entity;
}
#end_block

#method_before
private List<AdUser> searchAdUsers() {
    return adSearch(LdapQueryType.searchUsers, AdActionType.SearchUserByQuery);
}
#method_after
private List<LdapUser> searchAdUsers() {
    return adSearch(LdapQueryType.searchUsers, AdActionType.SearchUserByQuery);
}
#end_block

#method_before
private List<AdGroups> searchAdGroups() {
    return adSearch(LdapQueryType.searchGroups, AdActionType.SearchGroupsByQuery);
}
#method_after
private List<LdapGroup> searchAdGroups() {
    return adSearch(LdapQueryType.searchGroups, AdActionType.SearchGroupsByQuery);
}
#end_block

#method_before
private List<Quota> searchQuota() {
    return genericSearch(getDbFacade().getQuotaDao(), true, null);
}
#method_after
private List<Quota> searchQuota() {
    List<Quota> quotaList = genericSearch(getDbFacade().getQuotaDao(), true, null);
    QuotaManager.getInstance().updateUsage(quotaList);
    return quotaList;
}
#end_block

#method_before
protected AdUser populateUserData(AdUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, AdGroups> groupsDict = new java.util.HashMap<String, AdGroups>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    return user;
}
#end_block

#method_before
protected void PopulateGroup(LdapQueryData queryData, String domain, java.util.Map<String, AdGroups> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                PopulateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("PopulateGroup failed. Exception: {0}", e);
    }
}
#method_after
protected void PopulateGroup(LdapQueryData queryData, String domain, java.util.Map<String, LdapGroup> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                PopulateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("PopulateGroup failed. Exception: {0}", e);
    }
}
#end_block

#method_before
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, java.util.Map<String, AdGroups> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    proceedGroupsSearchResult(groupsList, groupsDict, generator);
}
#method_after
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, java.util.Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    proceedGroupsSearchResult(groupsList, groupsDict, generator);
}
#end_block

#method_before
private void proceedGroupsSearchResult(List<String> groupDNList, Map<String, AdGroups> groupsDict, GroupsDNQueryGenerator generator) {
    if (groupDNList == null) {
        return;
    }
    for (String groupDN : groupDNList) {
        String groupName = LdapBrokerUtils.generateGroupDisplayValue(groupDN);
        if (!groupsDict.containsKey(groupName)) {
            AdGroups group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
            if (group == null) {
                group = new AdGroups();
                group.setname(groupName);
            }
            group.setDistinguishedName(groupDN);
            groupsDict.put(groupName, group);
            generator.add(groupDN);
        }
    }
}
#method_after
private void proceedGroupsSearchResult(List<String> groupDNList, Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    if (groupDNList == null) {
        return;
    }
    for (String groupDN : groupDNList) {
        String groupName = LdapBrokerUtils.generateGroupDisplayValue(groupDN);
        if (!groupsDict.containsKey(groupName)) {
            LdapGroup group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
            if (group == null) {
                group = new LdapGroup();
                group.setname(groupName);
            }
            group.setDistinguishedName(groupDN);
            groupsDict.put(groupName, group);
            generator.add(groupDN);
        }
    }
}
#end_block

#method_before
protected GroupsDNQueryGenerator createGroupsGeneratorForUser(AdUser user) {
    List<String> dnsList = new ArrayList<String>();
    for (AdGroups adGroup : user.getGroups().values()) {
        dnsList.add(adGroup.getDistinguishedName());
    }
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator(new HashSet<String>(dnsList));
    return generator;
}
#method_after
protected GroupsDNQueryGenerator createGroupsGeneratorForUser(LdapUser user) {
    List<String> dnsList = new ArrayList<String>();
    for (LdapGroup adGroup : user.getGroups().values()) {
        dnsList.add(adGroup.getDistinguishedName());
    }
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator(new HashSet<String>(dnsList));
    return generator;
}
#end_block

#method_before
public void create() {
    log.infoFormat("UsersDomainsCacheManager: {0}", new java.util.Date());
    String authMethod = Config.<String>GetValue(ConfigValues.AuthenticationMethod);
    if (!authMethod.equalsIgnoreCase("LDAP")) {
        return;
    }
    List<String> domains = LdapBrokerUtils.getDomainsList(true);
    Map<String, LdapProviderType> domainLDAPProviders = parseLDAPProviders();
    fillLdapServersMap();
    fillLdapSecurityAuthenticationMap();
    fillUsersMap();
    fillPasswordsMap();
    for (String domainName : domains) {
        domainName = domainName.toLowerCase();
        domainsUsersInfoByUserNameAndDomainName.put(domainName, new ConcurrentHashMap<String, UserDomainInfo>());
        Domain domain = new Domain(domainName);
        domain.setLdapProviderType(domainLDAPProviders.get(domainName) == null ? LdapProviderType.general : domainLDAPProviders.get(domainName));
        domain.setLdapSecurityAuthentication(getDomainSecurityAuthentication(domainName));
        domainsByName.put(domainName, domain);
        domain.setUserName(userPerDomain.get(domainName));
        domain.setPassword(passwordPerDomain.get(domainName));
        // Each domain has LDAP servers that one of them should be used to
        // perform an LDAP query against the domain
        obtainLDAPServersForDomain(domain);
        groupsPerDomain.put(domain.getName(), new ConcurrentHashMap<String, AdGroups>());
    }
    DbUserCacheManager.getInstance().init();
    log.infoFormat("DbUserCacheManager: {0}", new java.util.Date());
}
#method_after
public void create() {
    log.infoFormat("UsersDomainsCacheManager: {0}", new java.util.Date());
    String authMethod = Config.<String>GetValue(ConfigValues.AuthenticationMethod);
    if (!authMethod.equalsIgnoreCase("LDAP")) {
        return;
    }
    List<String> domains = LdapBrokerUtils.getDomainsList(true);
    Map<String, LdapProviderType> domainLDAPProviders = parseLDAPProviders();
    fillLdapServersMap();
    fillLdapSecurityAuthenticationMap();
    fillUsersMap();
    fillPasswordsMap();
    for (String domainName : domains) {
        domainName = domainName.toLowerCase();
        domainsUsersInfoByUserNameAndDomainName.put(domainName, new ConcurrentHashMap<String, UserDomainInfo>());
        Domain domain = new Domain(domainName);
        domain.setLdapProviderType(domainLDAPProviders.get(domainName) == null ? LdapProviderType.general : domainLDAPProviders.get(domainName));
        domain.setLdapSecurityAuthentication(getDomainSecurityAuthentication(domainName));
        domainsByName.put(domainName, domain);
        domain.setUserName(userPerDomain.get(domainName));
        domain.setPassword(passwordPerDomain.get(domainName));
        // Each domain has LDAP servers that one of them should be used to
        // perform an LDAP query against the domain
        obtainLDAPServersForDomain(domain);
        groupsPerDomain.put(domain.getName(), new ConcurrentHashMap<String, LdapGroup>());
    }
    DbUserCacheManager.getInstance().init();
    log.infoFormat("DbUserCacheManager: {0}", new java.util.Date());
}
#end_block

#method_before
Group lookupGroup(Guid guid) {
    String id = guid.toString();
    for (AdGroups group : getGroupsFromDomain()) {
        if (group.getid().toString().equals(id))
            return mapAdGroup(group);
    }
    return notFound();
}
#method_after
Group lookupGroup(Guid guid) {
    String id = guid.toString();
    for (LdapGroup group : getGroupsFromDomain()) {
        if (group.getid().toString().equals(id))
            return mapAdGroup(group);
    }
    return notFound();
}
#end_block

#method_before
@Override
protected AdGroups getEntity(int index) {
    return setUpEntityExpectations(control.createMock(AdGroups.class), index);
}
#method_after
@Override
protected LdapGroup getEntity(int index) {
    return setUpEntityExpectations(control.createMock(LdapGroup.class), index);
}
#end_block

#method_before
protected List<AdGroups> getEntityList() {
    List<AdGroups> entities = new ArrayList<AdGroups>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#method_after
protected List<LdapGroup> getEntityList() {
    List<LdapGroup> entities = new ArrayList<LdapGroup>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#end_block

#method_before
@Override
public void remove(Guid id) {
    /*
         * This implementation was necessary in order to handle cascading deletes of what is in the tags_user_group_map
         * table. it can be moved to the default generic implementation when the association between ad_groups and tags
         * are handled via @OneToMany relationships.
         */
    Session session = getSession();
    Transaction transaction = session.beginTransaction();
    Query query = session.createQuery("delete from tags_user_group_map tugm where tugm.groupId = :group_id");
    query.setParameter("group_id", id);
    query.executeUpdate();
    AdGroups instance = get(id);
    if (instance != null) {
        session.delete(instance);
    }
    transaction.commit();
}
#method_after
@Override
public void remove(Guid id) {
    /*
         * This implementation was necessary in order to handle cascading deletes of what is in the tags_user_group_map
         * table. it can be moved to the default generic implementation when the association between ad_groups and tags
         * are handled via @OneToMany relationships.
         */
    Session session = getSession();
    Transaction transaction = session.beginTransaction();
    Query query = session.createQuery("delete from tags_user_group_map tugm where tugm.groupId = :group_id");
    query.setParameter("group_id", id);
    query.executeUpdate();
    LdapGroup instance = get(id);
    if (instance != null) {
        session.delete(instance);
    }
    transaction.commit();
}
#end_block

#method_before
@Override
public List<AdGroups> getAllTimeLeasedForPool(int id) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<LdapGroup> getAllTimeLeasedForPool(int id) {
    // TODO Auto-generated method stub
    return null;
}
#end_block

#method_before
public void setAdGroup(AdGroups adGroup) {
    this.adGroup = adGroup;
}
#method_after
public void setAdGroup(LdapGroup adGroup) {
    this.adGroup = adGroup;
}
#end_block

#method_before
public AdGroups getAdGroup() {
    return adGroup;
}
#method_after
public LdapGroup getAdGroup() {
    return adGroup;
}
#end_block

#method_before
public void setAdUser(AdUser adUser) {
    this.adUser = adUser;
}
#method_after
public void setAdUser(LdapUser ldapUser) {
    this.ldapUser = ldapUser;
}
#end_block

#method_before
public AdUser getAdUser() {
    return adUser;
}
#method_after
public LdapUser getAdUser() {
    return ldapUser;
}
#end_block

#method_before
protected AdGroups getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        mGroup = DbFacade.getInstance().getAdGroupDao().get(getGroupId());
    }
    return mGroup;
}
#method_after
protected LdapGroup getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        mGroup = DbFacade.getInstance().getAdGroupDao().get(getGroupId());
    }
    return mGroup;
}
#end_block

#method_before
public static AdGroups initAdGroup(AdGroups adGroup) {
    AdGroups dbGroup = DbFacade.getInstance().getAdGroupDao().get(adGroup.getid());
    if (dbGroup == null) {
        DbFacade.getInstance().getAdGroupDao().save(adGroup);
        dbGroup = adGroup;
    }
    return dbGroup;
}
#method_after
public static LdapGroup initAdGroup(LdapGroup adGroup) {
    LdapGroup dbGroup = DbFacade.getInstance().getAdGroupDao().get(adGroup.getid());
    if (dbGroup == null) {
        DbFacade.getInstance().getAdGroupDao().save(adGroup);
        dbGroup = adGroup;
    }
    return dbGroup;
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    String domain = (String) getDomain().getSelectedItem();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (getExcludeItems() != null) {
                for (Object item : getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            setusers(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                AdUser a = (AdUser) item;
                if (!excludeUsers.contains(a.getUserId())) {
                    DbUser tempVar = new DbUser();
                    tempVar.setuser_id(a.getUserId());
                    tempVar.setIsGroup(false);
                    tempVar.setname(a.getName());
                    tempVar.setsurname(a.getSurName());
                    tempVar.setusername(a.getUserName());
                    tempVar.setdomain(a.getDomainControler());
                    DbUser user = tempVar;
                    EntityModel tempVar2 = new EntityModel();
                    tempVar2.setEntity(user);
                    getusers().add(tempVar2);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                AdGroups a = (AdGroups) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setuser_id(a.getid());
                    tempVar3.setIsGroup(true);
                    tempVar3.setname(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setsurname("");
                    // $NON-NLS-1$
                    tempVar3.setusername("");
                    tempVar3.setdomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    String domain = (String) getDomain().getSelectedItem();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (getExcludeItems() != null) {
                for (Object item : getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            setusers(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapUser a = (LdapUser) item;
                if (!excludeUsers.contains(a.getUserId())) {
                    DbUser tempVar = new DbUser();
                    tempVar.setuser_id(a.getUserId());
                    tempVar.setIsGroup(false);
                    tempVar.setname(a.getName());
                    tempVar.setsurname(a.getSurName());
                    tempVar.setusername(a.getUserName());
                    tempVar.setdomain(a.getDomainControler());
                    DbUser user = tempVar;
                    EntityModel tempVar2 = new EntityModel();
                    tempVar2.setEntity(user);
                    getusers().add(tempVar2);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setuser_id(a.getid());
                    tempVar3.setIsGroup(true);
                    tempVar3.setname(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setsurname("");
                    // $NON-NLS-1$
                    tempVar3.setusername("");
                    tempVar3.setdomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
private void updateDBUserFromADUser(DbUser dbUser, AdUser adUser, HashSet<Guid> updatedUsers) {
    boolean succeded = false;
    // dbUser.domain);
    if ((adUser == null) || (adUser.getUserId().equals(Guid.Empty)) || (!adUser.getUserId().equals(dbUser.getuser_id()))) {
        if (dbUser.getstatus() != 0) {
            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getname());
            dbUser.setstatus(0);
            succeded = true;
        }
    } else {
        if (dbUser.getstatus() == 0) {
            log.warnFormat("Inactive User {0} found in directory server, its status switched to Active", dbUser.getname());
            dbUser.setstatus(1);
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getname(), adUser.getName())) {
            dbUser.setname(adUser.getName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getsurname(), adUser.getSurName())) {
            dbUser.setsurname(adUser.getSurName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getdomain(), adUser.getDomainControler())) {
            dbUser.setdomain(adUser.getDomainControler());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getusername(), adUser.getUserName())) {
            dbUser.setusername(adUser.getUserName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getgroups(), adUser.getGroup())) {
            dbUser.setgroups(adUser.getGroup());
            succeded = true;
            updatedUsers.add(dbUser.getuser_id());
        }
        if (!StringUtils.equals(dbUser.getdepartment(), adUser.getDepartment())) {
            dbUser.setdepartment(adUser.getDepartment());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getrole(), adUser.getTitle())) {
            dbUser.setrole(adUser.getTitle());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getemail(), adUser.getEmail())) {
            dbUser.setemail(adUser.getEmail());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupIds(), adUser.getGroupIds())) {
            dbUser.setGroupIds(adUser.getGroupIds());
            succeded = true;
        }
        if (succeded) {
            dbUser.setstatus(dbUser.getstatus() + 1);
        }
    }
    if (succeded) {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    } else {
    }
}
#method_after
private void updateDBUserFromADUser(DbUser dbUser, LdapUser adUser, HashSet<Guid> updatedUsers) {
    boolean succeded = false;
    // dbUser.domain);
    if ((adUser == null) || (adUser.getUserId().equals(Guid.Empty)) || (!adUser.getUserId().equals(dbUser.getuser_id()))) {
        if (dbUser.getstatus() != 0) {
            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getname());
            dbUser.setstatus(0);
            succeded = true;
        }
    } else {
        if (dbUser.getstatus() == 0) {
            log.warnFormat("Inactive User {0} found in directory server, its status switched to Active", dbUser.getname());
            dbUser.setstatus(1);
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getname(), adUser.getName())) {
            dbUser.setname(adUser.getName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getsurname(), adUser.getSurName())) {
            dbUser.setsurname(adUser.getSurName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getdomain(), adUser.getDomainControler())) {
            dbUser.setdomain(adUser.getDomainControler());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getusername(), adUser.getUserName())) {
            dbUser.setusername(adUser.getUserName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getgroups(), adUser.getGroup())) {
            dbUser.setgroups(adUser.getGroup());
            succeded = true;
            updatedUsers.add(dbUser.getuser_id());
        }
        if (!StringUtils.equals(dbUser.getdepartment(), adUser.getDepartment())) {
            dbUser.setdepartment(adUser.getDepartment());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getrole(), adUser.getTitle())) {
            dbUser.setrole(adUser.getTitle());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getemail(), adUser.getEmail())) {
            dbUser.setemail(adUser.getEmail());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupIds(), adUser.getGroupIds())) {
            dbUser.setGroupIds(adUser.getGroupIds());
            succeded = true;
        }
        if (succeded) {
            dbUser.setstatus(dbUser.getstatus() + 1);
        }
    }
    if (succeded) {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    } else {
    }
}
#end_block

#method_before
public void refreshAllUserData(List<AdGroups> updatedGroups) {
    try {
        log.info("DbUserCacheManager::refreshAllUserData() - entered");
        List<DbUser> allUsers = DbFacade.getInstance().getDbUserDao().getAll();
        List<String> domainsList = LdapBrokerUtils.getDomainsList(true);
        List<DbUser> filteredUsers = LinqUtils.filter(allUsers, new UsersPerDomainPredicate(domainsList));
        java.util.HashMap<String, java.util.HashMap<Guid, DbUser>> userByDomains = new java.util.HashMap<String, java.util.HashMap<Guid, DbUser>>();
        /**
         * Filter all users by domains
         */
        for (DbUser user : filteredUsers) {
            java.util.HashMap<Guid, DbUser> domainUser;
            if (!userByDomains.containsKey(user.getdomain())) {
                domainUser = new java.util.HashMap<Guid, DbUser>();
                userByDomains.put(user.getdomain(), domainUser);
            } else {
                domainUser = userByDomains.get(user.getdomain());
            }
            domainUser.put(user.getuser_id(), user);
        }
        if (userByDomains.size() != 0) {
            /**
             * refresh users in each domain separately
             */
            for (String domain : userByDomains.keySet()) {
                java.util.ArrayList<AdUser> adUsers = (java.util.ArrayList<AdUser>) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(domain, new java.util.ArrayList<Guid>(userByDomains.get(domain).keySet()), false)).getReturnValue();
                HashSet<Guid> updatedUsers = new HashSet<Guid>();
                if (adUsers == null) {
                    log.warn("No users returned from directory server during refresh users");
                } else {
                    LdapBrokerUtils.performGroupPopulationForUsers(adUsers, domain, updatedGroups);
                    for (AdUser adUser : adUsers) {
                        updateDBUserFromADUser(userByDomains.get(domain).get(adUser.getUserId()), adUser, updatedUsers);
                        userByDomains.get(domain).remove(adUser.getUserId());
                    }
                }
                Collection<DbUser> usersForDomain = userByDomains.get(domain).values();
                if (usersForDomain == null) {
                    log.warnFormat("No users for domain {0}", domain);
                } else {
                    for (DbUser dbUser : usersForDomain) {
                        if (dbUser.getstatus() != 0) {
                            log.warnFormat("User {0} not found in directory sevrer, its status switched to InActive", dbUser.getname());
                            dbUser.setstatus(AsyncTaskStatusEnum.unknown.getValue());
                            DbFacade.getInstance().getDbUserDao().update(dbUser);
                        }
                    }
                }
                // group or role was changed
                if (updatedUsers.size() > 0) {
                    DbFacade.getInstance().updateLastAdminCheckStatus(updatedUsers.toArray(new Guid[updatedUsers.size()]));
                }
            }
        }
    } catch (RuntimeException e) {
        log.error("DbUserCacheManager::refreshAllUserData() - failed with exception", e);
    }
}
#method_after
public void refreshAllUserData(List<LdapGroup> updatedGroups) {
    try {
        log.info("DbUserCacheManager::refreshAllUserData() - entered");
        List<DbUser> allUsers = DbFacade.getInstance().getDbUserDao().getAll();
        List<String> domainsList = LdapBrokerUtils.getDomainsList(true);
        List<DbUser> filteredUsers = LinqUtils.filter(allUsers, new UsersPerDomainPredicate(domainsList));
        java.util.HashMap<String, java.util.HashMap<Guid, DbUser>> userByDomains = new java.util.HashMap<String, java.util.HashMap<Guid, DbUser>>();
        /**
         * Filter all users by domains
         */
        for (DbUser user : filteredUsers) {
            java.util.HashMap<Guid, DbUser> domainUser;
            if (!userByDomains.containsKey(user.getdomain())) {
                domainUser = new java.util.HashMap<Guid, DbUser>();
                userByDomains.put(user.getdomain(), domainUser);
            } else {
                domainUser = userByDomains.get(user.getdomain());
            }
            domainUser.put(user.getuser_id(), user);
        }
        if (userByDomains.size() != 0) {
            /**
             * refresh users in each domain separately
             */
            for (String domain : userByDomains.keySet()) {
                java.util.ArrayList<LdapUser> adUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(domain, new java.util.ArrayList<Guid>(userByDomains.get(domain).keySet()), false)).getReturnValue();
                HashSet<Guid> updatedUsers = new HashSet<Guid>();
                if (adUsers == null) {
                    log.warn("No users returned from directory server during refresh users");
                } else {
                    LdapBrokerUtils.performGroupPopulationForUsers(adUsers, domain, updatedGroups);
                    for (LdapUser adUser : adUsers) {
                        updateDBUserFromADUser(userByDomains.get(domain).get(adUser.getUserId()), adUser, updatedUsers);
                        userByDomains.get(domain).remove(adUser.getUserId());
                    }
                }
                Collection<DbUser> usersForDomain = userByDomains.get(domain).values();
                if (usersForDomain == null) {
                    log.warnFormat("No users for domain {0}", domain);
                } else {
                    for (DbUser dbUser : usersForDomain) {
                        if (dbUser.getstatus() != 0) {
                            log.warnFormat("User {0} not found in directory sevrer, its status switched to InActive", dbUser.getname());
                            dbUser.setstatus(AsyncTaskStatusEnum.unknown.getValue());
                            DbFacade.getInstance().getDbUserDao().update(dbUser);
                        }
                    }
                }
                // group or role was changed
                if (updatedUsers.size() > 0) {
                    DbFacade.getInstance().updateLastAdminCheckStatus(updatedUsers.toArray(new Guid[updatedUsers.size()]));
                }
            }
        }
    } catch (RuntimeException e) {
        log.error("DbUserCacheManager::refreshAllUserData() - failed with exception", e);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    List<AdGroups> groups = updateGroups();
    refreshAllUserData(groups);
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    List<LdapGroup> groups = updateGroups();
    refreshAllUserData(groups);
}
#end_block

#method_before
private List<AdGroups> updateGroups() {
    List<AdGroups> groups = DbFacade.getInstance().getAdGroupDao().getAll();
    for (AdGroups group : groups) {
        // following code should not occur
        if (group.getdomain() == null && group.getname().contains("@")) {
            StringBuilder logMsg = new StringBuilder();
            logMsg.append("domain name for ad group ").append(group.getname()).append(" is null. This should not occur, please check that domain name is passed corectly from client");
            log.warn(logMsg.toString());
            String partAfterAtSign = group.getname().split("[@]", -1)[1];
            String newDomainName = partAfterAtSign;
            if (partAfterAtSign.contains("/")) {
                String partPreviousToSlashSign = partAfterAtSign.split("[/]", -1)[0];
                newDomainName = partPreviousToSlashSign;
            }
            group.setdomain(newDomainName);
        }
        // to fetch for them
        if (group.getdomain() != null && !group.getdomain().isEmpty()) {
            if (UsersDomainsCacheManagerService.getInstance().getDomain(group.getdomain()) == null) {
                log.errorFormat("Cannot query for group {0} from domain {1} because the domain is not configured. Please use the manage domains utility if you wish to add this domain.", group.getname(), group.getdomain());
            } else {
                AdGroups groupFromAD = (AdGroups) LdapFactory.getInstance(group.getdomain()).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(group.getdomain(), group.getid())).getReturnValue();
                if (group.getstatus() == AdRefStatus.Active && (groupFromAD == null || groupFromAD.getstatus() == AdRefStatus.Inactive)) {
                    group.setstatus(AdRefStatus.Inactive);
                    DbFacade.getInstance().getAdGroupDao().update(group);
                } else if (groupFromAD != null && (!StringUtils.equals(group.getname(), groupFromAD.getname()) || group.getstatus() != groupFromAD.getstatus() || !StringUtils.equals(group.getDistinguishedName(), groupFromAD.getDistinguishedName()))) {
                    DbFacade.getInstance().getAdGroupDao().update(groupFromAD);
                }
                // memberOf is not persistent and should be set in the returned groups list from the LDAP queries
                if (groupFromAD != null) {
                    group.setMemberOf(groupFromAD.getMemberOf());
                }
            }
        }
    }
    return groups;
}
#method_after
private List<LdapGroup> updateGroups() {
    List<LdapGroup> groups = DbFacade.getInstance().getAdGroupDao().getAll();
    for (LdapGroup group : groups) {
        // following code should not occur
        if (group.getdomain() == null && group.getname().contains("@")) {
            StringBuilder logMsg = new StringBuilder();
            logMsg.append("domain name for ad group ").append(group.getname()).append(" is null. This should not occur, please check that domain name is passed corectly from client");
            log.warn(logMsg.toString());
            String partAfterAtSign = group.getname().split("[@]", -1)[1];
            String newDomainName = partAfterAtSign;
            if (partAfterAtSign.contains("/")) {
                String partPreviousToSlashSign = partAfterAtSign.split("[/]", -1)[0];
                newDomainName = partPreviousToSlashSign;
            }
            group.setdomain(newDomainName);
        }
        // to fetch for them
        if (group.getdomain() != null && !group.getdomain().isEmpty()) {
            if (UsersDomainsCacheManagerService.getInstance().getDomain(group.getdomain()) == null) {
                log.errorFormat("Cannot query for group {0} from domain {1} because the domain is not configured. Please use the manage domains utility if you wish to add this domain.", group.getname(), group.getdomain());
            } else {
                LdapGroup groupFromAD = (LdapGroup) LdapFactory.getInstance(group.getdomain()).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(group.getdomain(), group.getid())).getReturnValue();
                if (group.getstatus() == AdRefStatus.Active && (groupFromAD == null || groupFromAD.getstatus() == AdRefStatus.Inactive)) {
                    group.setstatus(AdRefStatus.Inactive);
                    DbFacade.getInstance().getAdGroupDao().update(group);
                } else if (groupFromAD != null && (!StringUtils.equals(group.getname(), groupFromAD.getname()) || group.getstatus() != groupFromAD.getstatus() || !StringUtils.equals(group.getDistinguishedName(), groupFromAD.getDistinguishedName()))) {
                    DbFacade.getInstance().getAdGroupDao().update(groupFromAD);
                }
                // memberOf is not persistent and should be set in the returned groups list from the LDAP queries
                if (groupFromAD != null) {
                    group.setMemberOf(groupFromAD.getMemberOf());
                }
            }
        }
    }
    return groups;
}
#end_block

#method_before
@Override
protected AdGroups getEntity(int index) {
    AdGroups entity = new AdGroups();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#method_after
@Override
protected LdapGroup getEntity(int index) {
    LdapGroup entity = new LdapGroup();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#end_block

#method_before
private void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new AdGroups(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar4);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
private void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new LdapGroup(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar4);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
protected Guid getEntityGuid() {
    return DataProvider.GetEntityGuid(getEntity());
}
#method_after
protected Guid getEntityGuid() {
    return AsyncDataProvider.GetEntityGuid(getEntity());
}
#end_block

#method_before
protected VdcObjectType getObjectType() {
    if (getEntity() instanceof VM) {
        return VdcObjectType.VM;
    }
    if (getEntity() instanceof storage_pool) {
        return VdcObjectType.StoragePool;
    }
    if (getEntity() instanceof VDSGroup) {
        return VdcObjectType.VdsGroups;
    }
    if (getEntity() instanceof VDS) {
        return VdcObjectType.VDS;
    }
    if (getEntity() instanceof storage_domains) {
        return VdcObjectType.Storage;
    }
    if (getEntity() instanceof VmTemplate) {
        return VdcObjectType.VmTemplate;
    }
    if (getEntity() instanceof vm_pools) {
        return VdcObjectType.VmPool;
    }
    if (getEntity() instanceof Quota) {
        return VdcObjectType.Quota;
    }
    if (getEntity() instanceof GlusterVolumeEntity) {
        return VdcObjectType.GlusterVolume;
    }
    if (getEntity() instanceof DiskImage) {
        return VdcObjectType.Disk;
    }
    return VdcObjectType.Unknown;
}
#method_after
protected VdcObjectType getObjectType() {
    if (getEntity() instanceof VM) {
        return VdcObjectType.VM;
    }
    if (getEntity() instanceof storage_pool) {
        return VdcObjectType.StoragePool;
    }
    if (getEntity() instanceof VDSGroup) {
        return VdcObjectType.VdsGroups;
    }
    if (getEntity() instanceof VDS) {
        return VdcObjectType.VDS;
    }
    if (getEntity() instanceof storage_domains) {
        return VdcObjectType.Storage;
    }
    if (getEntity() instanceof VmTemplate) {
        return VdcObjectType.VmTemplate;
    }
    if (getEntity() instanceof vm_pools) {
        return VdcObjectType.VmPool;
    }
    if (getEntity() instanceof Quota) {
        return VdcObjectType.Quota;
    }
    if (getEntity() instanceof GlusterVolumeEntity) {
        return VdcObjectType.GlusterVolume;
    }
    if (getEntity() instanceof DiskImage) {
        return VdcObjectType.Disk;
    }
    if (getEntity() instanceof Network) {
        return VdcObjectType.Network;
    }
    return VdcObjectType.Unknown;
}
#end_block

#method_before
@Override
public AdGroups get(Guid id) {
    return getCallsHandler().executeRead("Getad_groupsByid", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("id", id));
}
#method_after
@Override
public LdapGroup get(Guid id) {
    return getCallsHandler().executeRead("Getad_groupsByid", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("id", id));
}
#end_block

#method_before
@Override
public AdGroups getByName(String name) {
    return getCallsHandler().executeRead("Getad_groupsByName", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("name", name));
}
#method_after
@Override
public LdapGroup getByName(String name) {
    return getCallsHandler().executeRead("Getad_groupsByName", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("name", name));
}
#end_block

#method_before
@Override
public List<AdGroups> getAll() {
    return getCallsHandler().executeReadList("GetAllFromad_groups", new ADGroupRowMapper(), getCustomMapSqlParameterSource());
}
#method_after
@Override
public List<LdapGroup> getAll() {
    return getCallsHandler().executeReadList("GetAllFromad_groups", new ADGroupRowMapper(), getCustomMapSqlParameterSource());
}
#end_block

#method_before
@Override
public List<AdGroups> getAllTimeLeasedForPool(int id) {
    return getCallsHandler().executeReadList("Gettime_leasedad_groups_by_vm_pool_id", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("vmPoolId", id));
}
#method_after
@Override
public List<LdapGroup> getAllTimeLeasedForPool(int id) {
    return getCallsHandler().executeReadList("Gettime_leasedad_groups_by_vm_pool_id", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("vmPoolId", id));
}
#end_block

#method_before
@Override
public void save(AdGroups group) {
    insertOrUpdate(group, "Insertad_groups");
}
#method_after
@Override
public void save(LdapGroup group) {
    insertOrUpdate(group, "Insertad_groups");
}
#end_block

#method_before
@Override
public void update(AdGroups group) {
    insertOrUpdate(group, "Updatead_groups");
}
#method_after
@Override
public void update(LdapGroup group) {
    insertOrUpdate(group, "Updatead_groups");
}
#end_block

#method_before
private void insertOrUpdate(final AdGroups group, final String storedProcName) {
    getCallsHandler().executeModification(storedProcName, getCustomMapSqlParameterSource().addValue("id", group.getid()).addValue("name", group.getname()).addValue("status", group.getstatus()).addValue("domain", group.getdomain()).addValue("distinguishedname", group.getDistinguishedName()));
}
#method_after
private void insertOrUpdate(final LdapGroup group, final String storedProcName) {
    getCallsHandler().executeModification(storedProcName, getCustomMapSqlParameterSource().addValue("id", group.getid()).addValue("name", group.getname()).addValue("status", group.getstatus()).addValue("domain", group.getdomain()).addValue("distinguishedname", group.getDistinguishedName()));
}
#end_block

#method_before
@Override
public AdGroups mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    AdGroups entity = new AdGroups();
    entity.setid(Guid.createGuidFromString(rs.getString("id")));
    entity.setname(rs.getString("name"));
    entity.setstatus(AdRefStatus.forValue(rs.getInt("status")));
    entity.setdomain(rs.getString("domain"));
    entity.setDistinguishedName(rs.getString("distinguishedname"));
    return entity;
}
#method_after
@Override
public LdapGroup mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    LdapGroup entity = new LdapGroup();
    entity.setid(Guid.createGuidFromString(rs.getString("id")));
    entity.setname(rs.getString("name"));
    entity.setstatus(AdRefStatus.forValue(rs.getInt("status")));
    entity.setdomain(rs.getString("domain"));
    entity.setDistinguishedName(rs.getString("distinguishedname"));
    return entity;
}
#end_block

#method_before
public static void performGroupPopulationForUsers(ArrayList<AdUser> adUsers, String domain, List<AdGroups> updatedGroups) {
    Domain domainObject = UsersDomainsCacheManagerService.getInstance().getDomain(domain.toLowerCase());
    String user = domainObject.getUserName();
    String password = domainObject.getPassword();
    performGroupPopulationForUsers(adUsers, user, password, domain, updatedGroups);
}
#method_after
public static void performGroupPopulationForUsers(List<LdapUser> users, String loginName, String password, String domainName, List<LdapGroup> updatedGroups) {
    // A list that holds the results of the LDAP queries for groups - both from this method + from previous LDAP
    // queries for groups that populated groups
    // that are now in updatedGroups list
    List<GroupSearchResult> results = new ArrayList<GroupSearchResult>();
    HashMap<String, java.util.HashMap<Guid, LdapUser>> groupsAdUsersMap = new java.util.HashMap<String, java.util.HashMap<Guid, LdapUser>>();
    Set<String> currentGroupsForSearch = new HashSet<String>();
    // Constructs a map that holds the groups that were already previously queried (for example, by
    // DbUserCacheManager.updateDbGroups
    Map<Guid, LdapGroup> alreadyQueriedGroups = new HashMap<Guid, LdapGroup>();
    if (updatedGroups != null) {
        for (LdapGroup adGroup : updatedGroups) {
            alreadyQueriedGroups.put(adGroup.getid(), adGroup);
        }
    }
    // Passes on all the users
    for (LdapUser user : users) {
        // Passes on all known groups of a given user.
        for (Map.Entry<String, LdapGroup> groupEntry : user.getGroups().entrySet()) {
            java.util.HashMap<Guid, LdapUser> map;
            String groupName = groupEntry.getKey();
            Guid groupId = groupEntry.getValue().getid();
            String groupDN = groupEntry.getValue().getDistinguishedName();
            // if so - add it to the search results list, and not to the groups to be queried
            if (!groupsAdUsersMap.containsKey(groupName)) {
                map = new java.util.HashMap<Guid, LdapUser>();
                groupsAdUsersMap.put(groupName, map);
                LdapGroup alreadyUpdatedGroup = alreadyQueriedGroups.get(groupId);
                // list
                if (alreadyUpdatedGroup != null) {
                    results.add(new GroupSearchResult(alreadyUpdatedGroup));
                } else {
                    // the group was not already queried - make sure it will be queried.
                    currentGroupsForSearch.add(groupDN);
                }
            } else {
                map = groupsAdUsersMap.get(groupName);
            }
            if (!map.containsKey(user.getUserId())) {
                map.put(user.getUserId(), user);
            }
        }
    }
    // Generate the LDAP query and pass the results (both the results from previous population and from
    // this population) to further processing
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator(currentGroupsForSearch);
    List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
    for (LdapQueryData queryData : partialQueries) {
        List<GroupSearchResult> searchResults = performGroupQuery(loginName, password, domainName, queryData);
        if (searchResults != null) {
            // Add all LDAP results to the results list - it now contains objects retreived from ldap, and objects
            // that
            // were previously queried.
            results.addAll(searchResults);
        }
    }
    for (GroupSearchResult groupSearchResult : results) {
        ProceedGroupsSearchResult(groupSearchResult, groupsAdUsersMap, currentGroupsForSearch);
    }
}
#end_block

#method_before
private static void AddGroupToUser(AdUser user, String groupName) {
    if (!user.getGroups().containsKey(groupName)) {
        AdGroups group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
        if (group != null) {
            user.getGroups().put(groupName, group);
        } else {
            user.getGroups().put(groupName, new AdGroups());
        }
    }
}
#method_after
private static void AddGroupToUser(LdapUser user, String groupName) {
    if (!user.getGroups().containsKey(groupName)) {
        LdapGroup group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
        if (group != null) {
            user.getGroups().put(groupName, group);
        } else {
            user.getGroups().put(groupName, new LdapGroup());
        }
    }
}
#end_block

#method_before
private static void ProceedGroupsSearchResult(GroupSearchResult searchResult, Map<String, java.util.HashMap<Guid, AdUser>> _groupsAdUsersMap, Set<String> currentGroupsForSearch) {
    List<String> memberOf = searchResult.getMemberOf();
    String groupName = searchResult.getDistinguishedName();
    groupName = generateGroupDisplayValue(groupName);
    java.util.HashMap<Guid, AdUser> groupUsers = _groupsAdUsersMap.get(groupName);
    if (memberOf == null) {
        return;
    }
    // The group may be a member of other groups - check for all the groups it is member in (all parent groups)
    for (String groupVal : memberOf) {
        String parentGroupName = generateGroupDisplayValue(groupVal);
        if (!_groupsAdUsersMap.containsKey(parentGroupName)) {
            currentGroupsForSearch.add(parentGroupName);
            java.util.HashMap<Guid, AdUser> map = new java.util.HashMap<Guid, AdUser>();
            if (groupUsers != null) {
                for (AdUser user : groupUsers.values()) {
                    map.put(user.getUserId(), user);
                    AddGroupToUser(user, parentGroupName);
                }
            }
            _groupsAdUsersMap.put(parentGroupName, map);
        } else {
            java.util.HashMap<Guid, AdUser> parentGroupUser = _groupsAdUsersMap.get(parentGroupName);
            if (parentGroupUser != null && groupUsers != null) {
                for (Guid userId : groupUsers.keySet()) {
                    if (!parentGroupUser.containsKey(userId)) {
                        parentGroupUser.put(userId, groupUsers.get(userId));
                        AddGroupToUser(groupUsers.get(userId), parentGroupName);
                    }
                }
            }
        }
    }
}
#method_after
private static void ProceedGroupsSearchResult(GroupSearchResult searchResult, Map<String, java.util.HashMap<Guid, LdapUser>> _groupsAdUsersMap, Set<String> currentGroupsForSearch) {
    List<String> memberOf = searchResult.getMemberOf();
    String groupName = searchResult.getDistinguishedName();
    groupName = generateGroupDisplayValue(groupName);
    java.util.HashMap<Guid, LdapUser> groupUsers = _groupsAdUsersMap.get(groupName);
    if (memberOf == null) {
        return;
    }
    // The group may be a member of other groups - check for all the groups it is member in (all parent groups)
    for (String groupVal : memberOf) {
        String parentGroupName = generateGroupDisplayValue(groupVal);
        if (!_groupsAdUsersMap.containsKey(parentGroupName)) {
            currentGroupsForSearch.add(parentGroupName);
            java.util.HashMap<Guid, LdapUser> map = new java.util.HashMap<Guid, LdapUser>();
            if (groupUsers != null) {
                for (LdapUser user : groupUsers.values()) {
                    map.put(user.getUserId(), user);
                    AddGroupToUser(user, parentGroupName);
                }
            }
            _groupsAdUsersMap.put(parentGroupName, map);
        } else {
            java.util.HashMap<Guid, LdapUser> parentGroupUser = _groupsAdUsersMap.get(parentGroupName);
            if (parentGroupUser != null && groupUsers != null) {
                for (Guid userId : groupUsers.keySet()) {
                    if (!parentGroupUser.containsKey(userId)) {
                        parentGroupUser.put(userId, groupUsers.get(userId));
                        AddGroupToUser(groupUsers.get(userId), parentGroupName);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(AdGroups.class).addAnnotatedClass(async_tasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(LdapGroup.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    Object group = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getGroupId() });
    queryData.setLdapQueryType(LdapQueryType.getGroupByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.FindOne(queryData);
    if (searchResult != null) {
        GroupSearchResult result = (GroupSearchResult) searchResult;
        Guid groupId = result.getGuid();
        if (!getGroupId().equals(groupId)) {
            /**
             * Cannot find group - group is Inactive
             */
            group = new AdGroups(getGroupId());
        } else {
            String distinguishedName = result.getDistinguishedName();
            List<String> memberOf = result.getMemberOf();
            String groupName = LdapBrokerUtils.generateGroupDisplayValue(distinguishedName);
            group = new AdGroups(groupId, groupName, getDomain(), distinguishedName, memberOf);
        }
    }
    setReturnValue(group);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    Object group = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getGroupId() });
    queryData.setLdapQueryType(LdapQueryType.getGroupByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.FindOne(queryData);
    if (searchResult != null) {
        GroupSearchResult result = (GroupSearchResult) searchResult;
        Guid groupId = result.getGuid();
        if (!getGroupId().equals(groupId)) {
            /**
             * Cannot find group - group is Inactive
             */
            group = new LdapGroup(getGroupId());
        } else {
            String distinguishedName = result.getDistinguishedName();
            List<String> memberOf = result.getMemberOf();
            String groupName = LdapBrokerUtils.generateGroupDisplayValue(distinguishedName);
            group = new LdapGroup(groupId, groupName, getDomain(), distinguishedName, memberOf);
        }
    }
    setReturnValue(group);
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid userid) {
    List<vm_pools> result = new ArrayList<vm_pools>();
    /* we need to get the user, then get the list of ad groups for that user */
    Query query = getSession().createQuery("from DbUser where id = :user_id");
    query.setParameter("user_id", userid);
    DbUser user = (DbUser) query.uniqueResult();
    if (user != null) {
        Criteria criteria = getSession().createCriteria(AdGroups.class).add(Restrictions.in("name", splitApartNames(user.getgroups())));
        List<AdGroups> adElements = criteria.list();
        Guid[] ids = new Guid[adElements.size() + 1];
        ids[0] = userid;
        for (int index = 0; index < adElements.size(); index++) {
            ids[index + 1] = adElements.get(index).getid();
        }
        query = getSession().createQuery("select pool " + "from vm_pools pool, permissions perms, roles role " + "where pool.id = perms.objectId " + "and perms.adElementId in ( :adElements ) " + "and perms.roleId = role.id " + "and role.type = 2");
        query.setParameterList("adElements", ids);
        result = query.list();
    }
    return result;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid userid) {
    List<vm_pools> result = new ArrayList<vm_pools>();
    /* we need to get the user, then get the list of ad groups for that user */
    Query query = getSession().createQuery("from DbUser where id = :user_id");
    query.setParameter("user_id", userid);
    DbUser user = (DbUser) query.uniqueResult();
    if (user != null) {
        Criteria criteria = getSession().createCriteria(LdapGroup.class).add(Restrictions.in("name", splitApartNames(user.getgroups())));
        List<LdapGroup> adElements = criteria.list();
        Guid[] ids = new Guid[adElements.size() + 1];
        ids[0] = userid;
        for (int index = 0; index < adElements.size(); index++) {
            ids[index + 1] = adElements.get(index).getid();
        }
        query = getSession().createQuery("select pool " + "from vm_pools pool, permissions perms, roles role " + "where pool.id = perms.objectId " + "and perms.adElementId in ( :adElements ) " + "and perms.roleId = role.id " + "and role.type = 2");
        query.setParameterList("adElements", ids);
        result = query.list();
    }
    return result;
}
#end_block

#method_before
@Override
protected AdGroups getExpectedResult() {
    return new AdGroups(Guid.NewGuid(), NAME_TO_SEARCH, DOMAIN);
}
#method_after
@Override
protected LdapGroup getExpectedResult() {
    return new LdapGroup(Guid.NewGuid(), NAME_TO_SEARCH, DOMAIN);
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getAdGroupDao());
    // create some test data
    newAdGroup = new AdGroups();
    newAdGroup.setid(Guid.NewGuid());
    newAdGroup.setdomain("domain");
    newAdGroup.setname("name");
    newAdGroup.setstatus(AdRefStatus.Active);
    existingAdGroup = dao.get(new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d1"));
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getAdGroupDao());
    // create some test data
    newAdGroup = new LdapGroup();
    newAdGroup.setid(Guid.NewGuid());
    newAdGroup.setdomain("domain");
    newAdGroup.setname("name");
    newAdGroup.setstatus(AdRefStatus.Active);
    existingAdGroup = dao.get(new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d1"));
}
#end_block

#method_before
@Test
public void testGetWithInvalidId() {
    AdGroups result = dao.get(Guid.NewGuid());
    assertNull(result);
}
#method_after
@Test
public void testGetWithInvalidId() {
    LdapGroup result = dao.get(Guid.NewGuid());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGet() {
    AdGroups result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#method_after
@Test
public void testGet() {
    LdapGroup result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#end_block

#method_before
@Test
public void testGetByNameWithInvalidName() {
    AdGroups result = dao.getByName("thisnameisinvalid");
    assertNull(result);
}
#method_after
@Test
public void testGetByNameWithInvalidName() {
    LdapGroup result = dao.getByName("thisnameisinvalid");
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetByName() {
    AdGroups result = dao.getByName(existingAdGroup.getname());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#method_after
@Test
public void testGetByName() {
    LdapGroup result = dao.getByName(existingAdGroup.getname());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#end_block

#method_before
@Test
public void testGetAll() {
    List<AdGroups> result = dao.getAll();
    assertEquals(AD_GROUP_COUNT, result.size());
}
#method_after
@Test
public void testGetAll() {
    List<LdapGroup> result = dao.getAll();
    assertEquals(AD_GROUP_COUNT, result.size());
}
#end_block

#method_before
@Test
public void testSave() {
    dao.save(newAdGroup);
    AdGroups result = dao.getByName(newAdGroup.getname());
    assertEquals(newAdGroup, result);
}
#method_after
@Test
public void testSave() {
    dao.save(newAdGroup);
    LdapGroup result = dao.getByName(newAdGroup.getname());
    assertEquals(newAdGroup, result);
}
#end_block

#method_before
@Test
public void testUpdate() {
    existingAdGroup.setname(existingAdGroup.getname().toUpperCase());
    existingAdGroup.setdomain(existingAdGroup.getdomain().toUpperCase());
    existingAdGroup.setstatus(AdRefStatus.Inactive);
    dao.update(existingAdGroup);
    AdGroups result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#method_after
@Test
public void testUpdate() {
    existingAdGroup.setname(existingAdGroup.getname().toUpperCase());
    existingAdGroup.setdomain(existingAdGroup.getdomain().toUpperCase());
    existingAdGroup.setstatus(AdRefStatus.Inactive);
    dao.update(existingAdGroup);
    LdapGroup result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#end_block

#method_before
@Test
public void testRemove() {
    dao.remove(existingAdGroup.getid());
    AdGroups result = dao.get(existingAdGroup.getid());
    assertNull(result);
}
#method_after
@Test
public void testRemove() {
    dao.remove(existingAdGroup.getid());
    LdapGroup result = dao.get(existingAdGroup.getid());
    assertNull(result);
}
#end_block

#method_before
private void OnAttach() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar = new permissions();
        tempVar.setad_element_id(user.getuser_id());
        tempVar.setrole_id(role.getId());
        permissions perm = tempVar;
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar2 = new PermissionsOperationsParametes();
            tempVar2.setPermission(perm);
            tempVar2.setAdGroup(new AdGroups(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar2);
        } else {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar3);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
private void OnAttach() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar = new permissions();
        tempVar.setad_element_id(user.getuser_id());
        tempVar.setrole_id(role.getId());
        permissions perm = tempVar;
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar2 = new PermissionsOperationsParametes();
            tempVar2.setPermission(perm);
            tempVar2.setAdGroup(new LdapGroup(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar2);
        } else {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar3);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid userId = null;
    String domain = null;
    if (getParameters().getVdcUser() != null) {
        AddCustomValue("NewUserName", getParameters().getVdcUser().getUserName());
        userId = getParameters().getVdcUser().getUserId();
        domain = getParameters().getVdcUser().getDomainControler();
        AdUser adUser = (AdUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // set the AD user on the parameters to save another roundtrip to the AD when adding the user
        getParameters().setAdUser(adUser);
    } else if (getParameters().getAdGroup() != null) {
        AddCustomValue("NewUserName", getParameters().getAdGroup().getname());
        userId = getParameters().getAdGroup().getid();
        domain = getParameters().getAdGroup().getdomain();
        AdGroups adGroup = (AdGroups) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adGroup == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    }
    if (userId == null) {
        addCanDoActionMessage(VdcBllMessages.MISSING_DIRECTORY_ELEMENT_ID);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid userId = null;
    String domain = null;
    if (getParameters().getVdcUser() != null) {
        AddCustomValue("NewUserName", getParameters().getVdcUser().getUserName());
        userId = getParameters().getVdcUser().getUserId();
        domain = getParameters().getVdcUser().getDomainControler();
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // set the AD user on the parameters to save another roundtrip to the AD when adding the user
        getParameters().setAdUser(adUser);
    } else if (getParameters().getAdGroup() != null) {
        AddCustomValue("NewUserName", getParameters().getAdGroup().getname());
        userId = getParameters().getAdGroup().getid();
        domain = getParameters().getAdGroup().getdomain();
        LdapGroup adGroup = (LdapGroup) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adGroup == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    }
    if (userId == null) {
        addCanDoActionMessage(VdcBllMessages.MISSING_DIRECTORY_ELEMENT_ID);
        return false;
    }
    return true;
}
#end_block

#method_before
public AdGroups getAdGroup() {
    return privateAdGroup;
}
#method_after
public LdapGroup getAdGroup() {
    return privateAdGroup;
}
#end_block

#method_before
public void setAdGroup(AdGroups value) {
    privateAdGroup = value;
}
#method_after
public void setAdGroup(LdapGroup value) {
    privateAdGroup = value;
}
#end_block

#method_before
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        AdGroups group = new AdGroups();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        LdapGroup group = new LdapGroup();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = Group.class)
public static Group map(DbUser entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getname());
    model.setId(entity.getuser_id().toString());
    if (!StringHelper.isNullOrEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getdomain());
        dom.setId(new NGuid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapGroup.class, to = Group.class)
public static Group map(LdapGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getname());
    model.setId(entity.getid().toString());
    if (!StringHelper.isNullOrEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getdomain());
        dom.setId(new NGuid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    java.util.ArrayList<AdGroups> groupList = new java.util.ArrayList<AdGroups>();
    List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.FindAll(getLdapQueryData());
    {
        for (GroupSearchResult searchResult : searchResults) {
            String distinguishedName = searchResult.getDistinguishedName();
            List<String> memberOf = searchResult.getMemberOf();
            if (distinguishedName != null) {
                String groupName = LdapBrokerUtils.generateGroupDisplayValue(searchResult.getDistinguishedName());
                AdGroups group = new AdGroups(searchResult.getGuid(), groupName, getDomain(), distinguishedName, memberOf);
                initGroupFromDb(group);
                groupList.add(group);
            }
        }
    }
    setReturnValue(groupList);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    java.util.ArrayList<LdapGroup> groupList = new java.util.ArrayList<LdapGroup>();
    List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.FindAll(getLdapQueryData());
    {
        for (GroupSearchResult searchResult : searchResults) {
            String distinguishedName = searchResult.getDistinguishedName();
            List<String> memberOf = searchResult.getMemberOf();
            if (distinguishedName != null) {
                String groupName = LdapBrokerUtils.generateGroupDisplayValue(searchResult.getDistinguishedName());
                LdapGroup group = new LdapGroup(searchResult.getGuid(), groupName, getDomain(), distinguishedName, memberOf);
                initGroupFromDb(group);
                groupList.add(group);
            }
        }
    }
    setReturnValue(groupList);
    setSucceeded(true);
}
#end_block

#method_before
private void initGroupFromDb(AdGroups group) {
    AdGroups dbGroup = DbFacade.getInstance().getAdGroupDao().get(group.getid());
}
#method_after
private void initGroupFromDb(LdapGroup group) {
    LdapGroup dbGroup = DbFacade.getInstance().getAdGroupDao().get(group.getid());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            AdGroups group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) == null) {
                tags_user_group_map map = new tags_user_group_map(groupGuid, getTagId());
                DbFacade.getInstance().getTagDao().attachUserGroupToTag(map);
                noActionDone = false;
                if (group != null) {
                    AppendCustomValue("AttachGroupsNames", group.getname(), ", ");
                }
            } else {
                if (group != null) {
                    AppendCustomValue("AttachGroupsNamesExists", group.getname(), ", ");
                }
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            LdapGroup group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) == null) {
                TagsUserGroupMap map = new TagsUserGroupMap(groupGuid, getTagId());
                DbFacade.getInstance().getTagDao().attachUserGroupToTag(map);
                noActionDone = false;
                if (group != null) {
                    AppendCustomValue("AttachGroupsNames", group.getname(), ", ");
                }
            } else {
                if (group != null) {
                    AppendCustomValue("AttachGroupsNamesExists", group.getname(), ", ");
                }
            }
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void setUpGetEntityExpectations(int index) throws Exception {
    AdGroups user = BackendGroupsResourceTest.setUpEntityExpectations(control.createMock(AdGroups.class), index);
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": name=*", SearchType.AdGroup, user);
}
#method_after
protected void setUpGetEntityExpectations(int index) throws Exception {
    LdapGroup user = BackendGroupsResourceTest.setUpEntityExpectations(control.createMock(LdapGroup.class), index);
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": name=*", SearchType.AdGroup, user);
}
#end_block

#method_before
public AdGroups getAdGroup() {
    return _adGroup;
}
#method_after
public LdapGroup getAdGroup() {
    return _adGroup;
}
#end_block

#method_before
protected Groups mapDomainGroupsCollection(List<AdGroups> entities) {
    Groups collection = new Groups();
    for (AdGroups entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#method_after
protected Groups mapDomainGroupsCollection(List<LdapGroup> entities) {
    Groups collection = new Groups();
    for (LdapGroup entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#end_block

#method_before
protected Group mapAdGroup(AdGroups entity) {
    return getMapper(AdGroups.class, Group.class).map(entity, null);
}
#method_after
protected Group mapAdGroup(LdapGroup entity) {
    return getMapper(LdapGroup.class, Group.class).map(entity, null);
}
#end_block

#method_before
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), AdGroups.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#method_after
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), LdapGroup.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#end_block

#method_before
protected AdGroups getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<AdGroups> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (AdGroups adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#method_after
protected LdapGroup getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<LdapGroup> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (LdapGroup adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#end_block

#method_before
protected List<AdGroups> getGroupsFromDomain() {
    return asCollection(AdGroups.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#method_after
protected List<LdapGroup> getGroupsFromDomain() {
    return asCollection(LdapGroup.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#end_block

#method_before
public AdGroups lookupGroupById(Guid id) {
    return getEntity(AdGroups.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#method_after
public LdapGroup lookupGroupById(Guid id) {
    return getEntity(LdapGroup.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#end_block

#method_before
@Override
public AdGroups lookupEntity(Guid nullId) {
    return lookupGroupById(id);
}
#method_after
@Override
public LdapGroup lookupEntity(Guid nullId) {
    return lookupGroupById(id);
}
#end_block

#method_before
public static AdGroups getGroupByGroupGuid(Guid groupGuid) {
    return null;
}
#method_after
public static LdapGroup getGroupByGroupGuid(Guid groupGuid) {
    return null;
}
#end_block

#method_before
public static AdUser getUserByUserGuid(Guid userGuid) {
    AdUser retVal = null;
    DbUser dbUser = getDbUserDAO().get(userGuid);
    if (dbUser != null) {
        retVal = new AdUser(dbUser);
    }
    return retVal;
}
#method_after
public static LdapUser getUserByUserGuid(Guid userGuid) {
    LdapUser retVal = null;
    DbUser dbUser = getDbUserDAO().get(userGuid);
    if (dbUser != null) {
        retVal = new LdapUser(dbUser);
    }
    return retVal;
}
#end_block

#method_before
public static AdUser getUserByUPN(String userName) {
    AdUser retVal = null;
    DbUser dbUser = getDbUserDAO().getByUsername(userName);
    if (dbUser != null) {
        retVal = new AdUser(dbUser);
    }
    return retVal;
}
#method_after
public static LdapUser getUserByUPN(String userName) {
    LdapUser retVal = null;
    DbUser dbUser = getDbUserDAO().getByUsername(userName);
    if (dbUser != null) {
        retVal = new LdapUser(dbUser);
    }
    return retVal;
}
#end_block

#method_before
public static List<AdGroups> getAllGroups() {
    return new ArrayList<AdGroups>();
}
#method_after
public static List<LdapGroup> getAllGroups() {
    return new ArrayList<LdapGroup>();
}
#end_block

#method_before
public static List<AdUser> getAllUsers() {
    List<AdUser> users = new ArrayList<AdUser>();
    AdUser user = getUserByUserGuid(ADMIN_GUID);
    if (user != null) {
        users.add(user);
    }
    return users;
}
#method_after
public static List<LdapUser> getAllUsers() {
    List<LdapUser> users = new ArrayList<LdapUser>();
    LdapUser user = getUserByUserGuid(ADMIN_GUID);
    if (user != null) {
        users.add(user);
    }
    return users;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            AdGroups group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) != null) {
                if (group != null) {
                    AppendCustomValue("DetachGroupsNames", group.getname(), ", ");
                }
                DbFacade.getInstance().getTagDao().detachUserGroupFromTag(getTagId(), groupGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            LdapGroup group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) != null) {
                if (group != null) {
                    AppendCustomValue("DetachGroupsNames", group.getname(), ", ");
                }
                DbFacade.getInstance().getTagDao().detachUserGroupFromTag(getTagId(), groupGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteQuery() {
    java.util.List<AdGroups> groupList = InternalBrokerUtils.getAllGroups();
    setReturnValue(groupList);
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteQuery() {
    java.util.List<LdapGroup> groupList = InternalBrokerUtils.getAllGroups();
    setReturnValue(groupList);
    setSucceeded(true);
}
#end_block

#method_before
@Mapping(from = AdUser.class, to = User.class)
public static User map(AdUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (AdGroups adgroup : entity.getGroups().values()) {
            Group group = new Group();
            group.setName(adgroup.getname());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringHelper.isNullOrEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setName(entity.getDomainControler());
        dom.setId(new NGuid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapUser.class, to = VdcUser.class)
public static VdcUser map(LdapUser adUser, VdcUser template) {
    VdcUser vdcUser = template != null ? template : new VdcUser();
    vdcUser.setUserId(adUser.getUserId());
    vdcUser.setUserName(adUser.getUserName());
    vdcUser.setSurName(adUser.getSurName());
    vdcUser.setDomainControler(adUser.getDomainControler());
    return vdcUser;
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
protected void HandleUserSession(LdapUser adUser) {
    if (!StringUtils.isEmpty(getParameters().getHttpSessionId())) {
        user_sessions user_sessions = new user_sessions("", "", new Date(), "", getParameters().getHttpSessionId(), adUser.getUserId());
        DbFacade.getInstance().getDbUserDao().saveSession(user_sessions);
    }
}
#method_after
protected void HandleUserSession(LdapUser ldapUser) {
    if (!StringUtils.isEmpty(getParameters().getHttpSessionId())) {
        user_sessions user_sessions = new user_sessions("", "", new Date(), "", getParameters().getHttpSessionId(), ldapUser.getUserId());
        DbFacade.getInstance().getDbUserDao().saveSession(user_sessions);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // add user session
    // todo : insert correct values of all arguments, separate
    HandleUserSession(_adUser);
    setActionReturnValue(getCurrentUser());
    // Persist the most updated version of the user
    UserCommandBase.persistAuthenticatedUser(_adUser);
    getReturnValue().setLoginResult(LoginResult.Autheticated);
    // Permissions for this user might been changed since last login so
    // update his isAdmin flag accordingly
    updateUserData();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // add user session
    // todo : insert correct values of all arguments, separate
    HandleUserSession(ldapUser);
    setActionReturnValue(getCurrentUser());
    // Persist the most updated version of the user
    UserCommandBase.persistAuthenticatedUser(ldapUser);
    getReturnValue().setLoginResult(LoginResult.Autheticated);
    // Permissions for this user might been changed since last login so
    // update his isAdmin flag accordingly
    updateUserData();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    boolean authenticated = false;
    IVdcUser vdcUser = SessionDataContainer.getInstance().getUser(false);
    if (vdcUser == null) {
        boolean domainFound = false;
        List<String> vdcDomains = LdapBrokerUtils.getDomainsList();
        for (String domain : vdcDomains) {
            if (StringUtils.equals(domain.toLowerCase(), getDomain().toLowerCase())) {
                domainFound = true;
                break;
            }
        }
        if (!domainFound) {
            addCanDoActionMessage(VdcBllMessages.USER_CANNOT_LOGIN_DOMAIN_NOT_SUPPORTED);
            return false;
        }
        UserAuthenticationResult result = authenticateUser();
        // error
        if (result == null) {
            result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
        _adUser = result.getUser();
        authenticated = result.isSuccessful();
        if ((!authenticated || _adUser == null)) {
            HandleAuthenticationError(result.getErrorMessages());
            authenticated = false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
    }
    if (authenticated) {
        /*
             * Check login permissions
             * We do it here and not via the getPermissionCheckSubjects mechanism, because we need the user to be logged in to
             * the system in order to perform this check. The user is indeed logged in when running every command
             * except the login command
             */
        if (!checkUserAndGroupsAuthorization(_adUser.getUserId(), _adUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        VdcUser currentUser = new VdcUser(_adUser);
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(currentUser);
        log.infoFormat("Checking if user {0} is an admin, result {1}", currentUser.getUserName(), isAdmin);
        currentUser.setAdmin(isAdmin);
        setCurrentUser(currentUser);
    }
    return authenticated;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    boolean authenticated = false;
    IVdcUser vdcUser = SessionDataContainer.getInstance().getUser(false);
    if (vdcUser == null) {
        boolean domainFound = false;
        List<String> vdcDomains = LdapBrokerUtils.getDomainsList();
        for (String domain : vdcDomains) {
            if (StringUtils.equals(domain.toLowerCase(), getDomain().toLowerCase())) {
                domainFound = true;
                break;
            }
        }
        if (!domainFound) {
            addCanDoActionMessage(VdcBllMessages.USER_CANNOT_LOGIN_DOMAIN_NOT_SUPPORTED);
            return false;
        }
        UserAuthenticationResult result = authenticateUser();
        // error
        if (result == null) {
            result = new UserAuthenticationResult(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
        ldapUser = result.getUser();
        authenticated = result.isSuccessful();
        if ((!authenticated || ldapUser == null)) {
            HandleAuthenticationError(result.getErrorMessages());
            authenticated = false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
    }
    if (authenticated) {
        /*
             * Check login permissions
             * We do it here and not via the getPermissionCheckSubjects mechanism, because we need the user to be logged in to
             * the system in order to perform this check. The user is indeed logged in when running every command
             * except the login command
             */
        if (!checkUserAndGroupsAuthorization(ldapUser.getUserId(), ldapUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        VdcUser currentUser = new VdcUser(ldapUser);
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(currentUser);
        log.infoFormat("Checking if user {0} is an admin, result {1}", currentUser.getUserName(), isAdmin);
        currentUser.setAdmin(isAdmin);
        setCurrentUser(currentUser);
    }
    return authenticated;
}
#end_block

#method_before
private void updateUserData() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            DbFacade.getInstance().updateLastAdminCheckStatus(_adUser.getUserId());
        }
    });
}
#method_after
private void updateUserData() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            DbFacade.getInstance().updateLastAdminCheckStatus(ldapUser.getUserId());
        }
    });
}
#end_block

#method_before
public void setAdUser(LdapUser adUser) {
    this.adUser = adUser;
}
#method_after
public void setAdUser(LdapUser ldapUser) {
    this.ldapUser = ldapUser;
}
#end_block

#method_before
public LdapUser getAdUser() {
    return adUser;
}
#method_after
public LdapUser getAdUser() {
    return ldapUser;
}
#end_block

#method_before
private List<Quota> searchQuota() {
    return genericSearch(getDbFacade().getQuotaDao(), true, null);
}
#method_after
private List<Quota> searchQuota() {
    List<Quota> quotaList = genericSearch(getDbFacade().getQuotaDao(), true, null);
    QuotaManager.getInstance().updateUsage(quotaList);
    return quotaList;
}
#end_block

#method_before
public static DbUser persistAuthenticatedUser(LdapUser adUser) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().get(adUser.getUserId());
    boolean newUser = dbUser == null;
    dbUser = new DbUser(adUser);
    if (newUser) {
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    } else {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    }
    return dbUser;
}
#method_after
public static DbUser persistAuthenticatedUser(LdapUser ldapUser) {
    DbUser dbUser = DbFacade.getInstance().getDbUserDao().get(ldapUser.getUserId());
    boolean newUser = dbUser == null;
    dbUser = new DbUser(ldapUser);
    if (newUser) {
        DbFacade.getInstance().getDbUserDao().save(dbUser);
    } else {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    }
    return dbUser;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = CanRemoveVds(getVdsId(), getReturnValue().getCanDoActionMessages());
    storage_pool storagePool = getStoragePoolDAO().getForVds(getParameters().getVdsId());
    if (returnValue && storagePool != null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!getStorageDomainDAO().getAllForStoragePool(storagePool.getId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_WITH_LOCAL_STORAGE);
            returnValue = false;
        }
    }
    if (isGlusterEnabled()) {
        // Check volume bricks on server only if force action is false.
        if (hasVolumeBricksOnServer() && !getParameters().isForceAction()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            returnValue = false;
        }
        if (clusterHasMultipleHosts()) {
            upServer = getClusterUtils().getUpServer(getVdsGroupId());
            // check if upserver is null, only if force action is false
            if (upServer == null && !getParameters().isForceAction()) {
                addCanDoActionMessage(String.format("$clusterName %1$s", getVdsGroup().getname()));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_UP_SERVER_FOUND);
                returnValue = false;
            }
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = CanRemoveVds(getVdsId(), getReturnValue().getCanDoActionMessages());
    storage_pool storagePool = getStoragePoolDAO().getForVds(getParameters().getVdsId());
    if (returnValue && storagePool != null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!getStorageDomainDAO().getAllForStoragePool(storagePool.getId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_WITH_LOCAL_STORAGE);
            returnValue = false;
        }
    }
    // Perform volume bricks on server and up server null check only when force action is false
    if (isGlusterEnabled() && !getParameters().isForceAction()) {
        if (hasVolumeBricksOnServer()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            returnValue = false;
        }
        if (clusterHasMultipleHosts()) {
            upServer = getClusterUtils().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(String.format("$clusterName %1$s", getVdsGroup().getname()));
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_UP_SERVER_FOUND);
                returnValue = false;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private void removeGlusterVolumesFromDb() {
    List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroupId());
    if (volumes.size() > 0) {
        for (GlusterVolumeEntity volume : volumes) {
            getGlusterVolumeDao().remove(volume.getId());
        }
    }
}
#method_after
private void removeGlusterVolumesFromDb() {
    getGlusterVolumeDao().removeByClusterId(getVdsGroupId());
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBiosPresenter.class, SubTabHostBiosPresenter.ViewDef.class, SubTabHostBiosView.class, SubTabHostBiosPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
}
#end_block

#method_before
public void New() {
    if (getWindow() != null) {
        return;
    }
    final HostModel hostModel = new HostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getPmType().setSelectedItem(null);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (storage_pool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        storage_pool selectDataCenter = (storage_pool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.FirstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.FirstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#method_after
public void New() {
    if (getWindow() != null) {
        return;
    }
    final HostModel hostModel = new HostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getPmType().setSelectedItem(null);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    AsyncDataProvider.GetDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (storage_pool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        storage_pool selectDataCenter = (storage_pool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.FirstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.FirstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void Edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            HostModel hostModel = new HostModel();
            hostListModel.setWindow(hostModel);
            VDS host = (VDS) hostListModel.getSelectedItem();
            PrepareModelForApproveEdit(host, hostModel, dataCenters, isEditWithPMemphasis);
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSaveFalse", hostListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            hostModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", hostListModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            hostModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#method_after
public void Edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new HostModel();
            hostListModel.setWindow(hostModel);
            PrepareModelForApproveEdit(host, hostModel, dataCenters, isEditWithPMemphasis);
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.GetDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void OnSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setvds_name((String) model.getName().getEntity());
    host.sethost_name((String) model.getHost().getEntity());
    host.setManagmentIp((String) model.getManagementIp().getEntity());
    host.setport(Integer.parseInt(model.getPort().getEntity().toString()));
    Guid oldClusterId = host.getvds_group_id();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setvds_group_id(newClusterId);
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setpm_user((String) model.getPmUserName().getEntity());
    host.setpm_password((String) model.getPmPassword().getEntity());
    host.setpm_type((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    CancelConfirm();
    model.StartProgress(null);
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setRootPassword((String) model.getRootPassword().getEntity());
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.PostOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setRootPassword("");
        parameters.setInstallVds(false);
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.PostOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().StopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            PostOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void OnSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setvds_name((String) model.getName().getEntity());
    host.sethost_name((String) model.getHost().getEntity());
    host.setManagmentIp((String) model.getManagementIp().getEntity());
    host.setport(Integer.parseInt(model.getPort().getEntity().toString()));
    Guid oldClusterId = host.getvds_group_id();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setvds_group_id(newClusterId);
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setpm_user((String) model.getPmUserName().getEntity());
    host.setpm_password((String) model.getPmPassword().getEntity());
    host.setpm_type((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    CancelConfirm();
    model.StartProgress(null);
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setRootPassword((String) model.getRootPassword().getEntity());
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.PostOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setRootPassword("");
        parameters.setInstallVds(false);
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.PostOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().StopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            PostOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().hostsMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>Cast(getSelectedItems())) {
        list.add(item.getvds_name());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().hostsMsg());
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>Cast(getSelectedItems())) {
        list.add(item.getvds_name());
        clusters.add(item.getvds_group_id());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.StartProgress(null);
        AsyncDataProvider.GetClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.StopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void OnRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new RemoveVdsParameters(vds.getId()));
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.RemoveVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
public void OnRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    boolean force = (Boolean) model.getForce().getEntity();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new RemoveVdsParameters(vds.getId(), force));
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.RemoveVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostBiosModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(Guid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setManagmentIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setserver_SSL_enabled(rs.getBoolean("server_SSL_enabled"));
    entity.sethost_name(rs.getString("host_name"));
    entity.setport(rs.getInt("port"));
    entity.setstatus(VDSStatus.forValue(rs.getInt("status")));
    entity.sethost_manufacturer(rs.getString("host_manufacturer"));
    entity.sethost_product_name(rs.getString("host_product_name"));
    entity.sethost_version(rs.getString("host_version"));
    entity.sethost_serial_number(rs.getString("host_serial_number"));
    entity.sethost_uuid(rs.getString("host_uuid"));
    entity.sethost_family(rs.getString("host_family"));
    entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
    entity.setcpu_model(rs.getString("cpu_model"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
    entity.setif_total_speed(rs.getString("if_total_speed"));
    entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
    entity.setcpu_idle(rs.getDouble("cpu_idle"));
    entity.setcpu_load(rs.getDouble("cpu_load"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setmem_commited((Integer) rs.getObject("mem_commited"));
    entity.setvm_active((Integer) rs.getObject("vm_active"));
    entity.setvm_count((Integer) rs.getObject("vm_count"));
    entity.setvms_cores_count((Integer) rs.getObject("vms_cores_count"));
    entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
    entity.setguest_overhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setsoftware_version(rs.getString("software_version"));
    entity.setversion_name(rs.getString("version_name"));
    entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setmem_available(rs.getLong("mem_available"));
    entity.setmem_shared(rs.getLong("mem_shared"));
    entity.setvds_type(VDSType.forValue(rs.getInt("vds_type")));
    entity.setcpu_flags(rs.getString("cpu_flags"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
    entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.sethigh_utilization(rs.getInt("high_utilization"));
    entity.setlow_utilization(rs.getInt("low_utilization"));
    entity.setcpu_over_commit_duration_minutes(rs.getInt("cpu_over_commit_duration_minutes"));
    entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
    entity.setvds_strength(rs.getInt("vds_strength"));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
    entity.setvds_spm_id((Integer) rs.getObject("vds_spm_id"));
    entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setpm_type(rs.getString("pm_type"));
    entity.setpm_user(rs.getString("pm_user"));
    entity.setpm_password(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setpm_port((Integer) rs.getObject("pm_port"));
    entity.setpm_options(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setspm_status(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setswap_free(rs.getLong("swap_free"));
    entity.setswap_total(rs.getLong("swap_total"));
    entity.setksm_cpu_percent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setksm_pages(rs.getLong("ksm_pages"));
    entity.setksm_state((Boolean) rs.getObject("ksm_state"));
    entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
    entity.setsupported_engines(rs.getString("supported_engines"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.sethost_os(rs.getString("host_os"));
    entity.setkvm_version(rs.getString("kvm_version"));
    entity.setspice_version(rs.getString("spice_version"));
    entity.setkernel_version(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSSHKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(Guid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setManagmentIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setserver_SSL_enabled(rs.getBoolean("server_SSL_enabled"));
    entity.sethost_name(rs.getString("host_name"));
    entity.setport(rs.getInt("port"));
    entity.setstatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setcpu_model(rs.getString("cpu_model"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
    entity.setif_total_speed(rs.getString("if_total_speed"));
    entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
    entity.setcpu_idle(rs.getDouble("cpu_idle"));
    entity.setcpu_load(rs.getDouble("cpu_load"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setmem_commited((Integer) rs.getObject("mem_commited"));
    entity.setvm_active((Integer) rs.getObject("vm_active"));
    entity.setvm_count((Integer) rs.getObject("vm_count"));
    entity.setvms_cores_count((Integer) rs.getObject("vms_cores_count"));
    entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
    entity.setguest_overhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setsoftware_version(rs.getString("software_version"));
    entity.setversion_name(rs.getString("version_name"));
    entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setmem_available(rs.getLong("mem_available"));
    entity.setmem_shared(rs.getLong("mem_shared"));
    entity.setvds_type(VDSType.forValue(rs.getInt("vds_type")));
    entity.setcpu_flags(rs.getString("cpu_flags"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
    entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.sethigh_utilization(rs.getInt("high_utilization"));
    entity.setlow_utilization(rs.getInt("low_utilization"));
    entity.setcpu_over_commit_duration_minutes(rs.getInt("cpu_over_commit_duration_minutes"));
    entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
    entity.setvds_strength(rs.getInt("vds_strength"));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
    entity.setvds_spm_id((Integer) rs.getObject("vds_spm_id"));
    entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setpm_type(rs.getString("pm_type"));
    entity.setpm_user(rs.getString("pm_user"));
    entity.setpm_password(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setpm_port((Integer) rs.getObject("pm_port"));
    entity.setpm_options(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setspm_status(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setswap_free(rs.getLong("swap_free"));
    entity.setswap_total(rs.getLong("swap_total"));
    entity.setksm_cpu_percent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setksm_pages(rs.getLong("ksm_pages"));
    entity.setksm_state((Boolean) rs.getObject("ksm_state"));
    entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
    entity.setsupported_engines(rs.getString("supported_engines"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.sethost_os(rs.getString("host_os"));
    entity.setkvm_version(rs.getString("kvm_version"));
    entity.setlibvirt_version(rs.getString("libvirt_version"));
    entity.setspice_version(rs.getString("spice_version"));
    entity.setkernel_version(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSSHKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.calculateFreeVirtualMemory();
    return entity;
}
#end_block

#method_before
@Override
public VdsDynamic get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VdsDynamic> mapper = new ParameterizedRowMapper<VdsDynamic>() {

        @Override
        public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VdsDynamic entity = new VdsDynamic();
            entity.sethost_manufacturer(rs.getString("host_manufacturer"));
            entity.sethost_product_name(rs.getString("host_product_name"));
            entity.sethost_version(rs.getString("host_version"));
            entity.sethost_serial_number(rs.getString("host_serial_number"));
            entity.sethost_uuid(rs.getString("host_uuid"));
            entity.sethost_family(rs.getString("host_family"));
            entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
            entity.setcpu_model(rs.getString("cpu_model"));
            entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
            entity.setif_total_speed(rs.getString("if_total_speed"));
            entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
            entity.setmem_commited((Integer) rs.getObject("mem_commited"));
            entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
            entity.setstatus(VDSStatus.forValue(rs.getInt("status")));
            entity.setId(Guid.createGuidFromString(rs.getString("vds_id")));
            entity.setvm_active((Integer) rs.getObject("vm_active"));
            entity.setvm_count((Integer) rs.getObject("vm_count"));
            entity.setvms_cores_count((Integer) rs.getObject("vms_cores_count"));
            entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
            entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
            entity.setguest_overhead((Integer) rs.getObject("guest_overhead"));
            entity.setsoftware_version(rs.getString("software_version"));
            entity.setversion_name(rs.getString("version_name"));
            entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
            entity.setbuild_name(rs.getString("build_name"));
            entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
            entity.setcpu_flags(rs.getString("cpu_flags"));
            entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
            entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
            entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
            entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
            entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
            entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
            entity.setsupported_engines(rs.getString("supported_engines"));
            entity.sethost_os(rs.getString("host_os"));
            entity.setkvm_version(rs.getString("kvm_version"));
            entity.setspice_version(rs.getString("spice_version"));
            entity.setkernel_version(rs.getString("kernel_version"));
            entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
            entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
            entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
            entity.setHooksStr(rs.getString("hooks"));
            entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetVdsDynamicByVdsId", mapper, parameterSource);
}
#method_after
@Override
public VdsDynamic get(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    ParameterizedRowMapper<VdsDynamic> mapper = new ParameterizedRowMapper<VdsDynamic>() {

        @Override
        public VdsDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VdsDynamic entity = new VdsDynamic();
            entity.setcpu_cores((Integer) rs.getObject("cpu_cores"));
            entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
            entity.setcpu_model(rs.getString("cpu_model"));
            entity.setcpu_speed_mh(rs.getDouble("cpu_speed_mh"));
            entity.setif_total_speed(rs.getString("if_total_speed"));
            entity.setkvm_enabled((Boolean) rs.getObject("kvm_enabled"));
            entity.setmem_commited((Integer) rs.getObject("mem_commited"));
            entity.setphysical_mem_mb((Integer) rs.getObject("physical_mem_mb"));
            entity.setstatus(VDSStatus.forValue(rs.getInt("status")));
            entity.setId(Guid.createGuidFromString(rs.getString("vds_id")));
            entity.setvm_active((Integer) rs.getObject("vm_active"));
            entity.setvm_count((Integer) rs.getObject("vm_count"));
            entity.setvms_cores_count((Integer) rs.getObject("vms_cores_count"));
            entity.setvm_migrating((Integer) rs.getObject("vm_migrating"));
            entity.setreserved_mem((Integer) rs.getObject("reserved_mem"));
            entity.setguest_overhead((Integer) rs.getObject("guest_overhead"));
            entity.setsoftware_version(rs.getString("software_version"));
            entity.setversion_name(rs.getString("version_name"));
            entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
            entity.setbuild_name(rs.getString("build_name"));
            entity.setprevious_status(VDSStatus.forValue(rs.getInt("previous_status")));
            entity.setcpu_flags(rs.getString("cpu_flags"));
            entity.setcpu_over_commit_time_stamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
            entity.setpending_vcpus_count((Integer) rs.getObject("pending_vcpus_count"));
            entity.setpending_vmem_size(rs.getInt("pending_vmem_size"));
            entity.setcpu_sockets((Integer) rs.getObject("cpu_sockets"));
            entity.setnet_config_dirty((Boolean) rs.getObject("net_config_dirty"));
            entity.setsupported_cluster_levels(rs.getString("supported_cluster_levels"));
            entity.setsupported_engines(rs.getString("supported_engines"));
            entity.sethost_os(rs.getString("host_os"));
            entity.setkvm_version(rs.getString("kvm_version"));
            entity.setlibvirt_version(rs.getString("libvirt_version"));
            entity.setspice_version(rs.getString("spice_version"));
            entity.setkernel_version(rs.getString("kernel_version"));
            entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
            entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
            entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
            entity.setHooksStr(rs.getString("hooks"));
            entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
            entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
            entity.setHardwareProductName(rs.getString("hw_product_name"));
            entity.setHardwareVersion(rs.getString("hw_version"));
            entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
            entity.setHardwareUUID(rs.getString("hw_uuid"));
            entity.setHardwareFamily(rs.getString("hw_family"));
            return entity;
        }
    };
    return getCallsHandler().executeRead("GetVdsDynamicByVdsId", mapper, parameterSource);
}
#end_block

#method_before
@Override
public void save(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("host_manufacturer", vds.gethost_manufacturer()).addValue("host_product_name", vds.gethost_product_name()).addValue("host_version", vds.gethost_version()).addValue("host_serial_number", vds.gethost_serial_number()).addValue("host_uuid", vds.gethost_uuid()).addValue("host_family", vds.gethost_family()).addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getstatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("spice_version", vds.getspice_version()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue());
    getCallsHandler().executeModification("InsertVdsDynamic", parameterSource);
}
#method_after
@Override
public void save(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getstatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version()).addValue("spice_version", vds.getspice_version()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily());
    getCallsHandler().executeModification("InsertVdsDynamic", parameterSource);
}
#end_block

#method_before
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("host_manufacturer", vds.gethost_manufacturer()).addValue("host_product_name", vds.gethost_product_name()).addValue("host_version", vds.gethost_version()).addValue("host_serial_number", vds.gethost_serial_number()).addValue("host_uuid", vds.gethost_uuid()).addValue("host_family", vds.gethost_family()).addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getstatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("spice_version", vds.getspice_version()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#method_after
@Override
public void update(VdsDynamic vds) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("cpu_cores", vds.getcpu_cores()).addValue("cpu_threads", vds.getCpuThreads()).addValue("cpu_model", vds.getcpu_model()).addValue("cpu_speed_mh", vds.getcpu_speed_mh()).addValue("if_total_speed", vds.getif_total_speed()).addValue("kvm_enabled", vds.getkvm_enabled()).addValue("mem_commited", vds.getmem_commited()).addValue("physical_mem_mb", vds.getphysical_mem_mb()).addValue("status", vds.getstatus()).addValue("vds_id", vds.getId()).addValue("vm_active", vds.getvm_active()).addValue("vm_count", vds.getvm_count()).addValue("vms_cores_count", vds.getvms_cores_count()).addValue("vm_migrating", vds.getvm_migrating()).addValue("reserved_mem", vds.getreserved_mem()).addValue("guest_overhead", vds.getguest_overhead()).addValue("rpm_version", vds.getVersion().getRpmName()).addValue("software_version", vds.getsoftware_version()).addValue("version_name", vds.getversion_name()).addValue("build_name", vds.getbuild_name()).addValue("previous_status", vds.getprevious_status()).addValue("cpu_flags", vds.getcpu_flags()).addValue("cpu_over_commit_time_stamp", vds.getcpu_over_commit_time_stamp()).addValue("pending_vcpus_count", vds.getpending_vcpus_count()).addValue("pending_vmem_size", vds.getpending_vmem_size()).addValue("cpu_sockets", vds.getcpu_sockets()).addValue("net_config_dirty", vds.getnet_config_dirty()).addValue("supported_cluster_levels", vds.getsupported_cluster_levels()).addValue("supported_engines", vds.getsupported_engines()).addValue("host_os", vds.gethost_os()).addValue("kvm_version", vds.getkvm_version()).addValue("libvirt_version", vds.getlibvirt_version()).addValue("spice_version", vds.getspice_version()).addValue("kernel_version", vds.getkernel_version()).addValue("iscsi_initiator_name", vds.getIScsiInitiatorName()).addValue("transparent_hugepages_state", vds.getTransparentHugePagesState().getValue()).addValue("anonymous_hugepages", vds.getAnonymousHugePages()).addValue("hooks", vds.getHooksStr()).addValue("non_operational_reason", vds.getNonOperationalReason().getValue()).addValue("hw_manufacturer", vds.getHardwareManufacturer()).addValue("hw_product_name", vds.getHardwareProductName()).addValue("hw_version", vds.getHardwareVersion()).addValue("hw_serial_number", vds.getHardwareSerialNumber()).addValue("hw_uuid", vds.getHardwareUUID()).addValue("hw_family", vds.getHardwareFamily());
    getCallsHandler().executeModification("UpdateVdsDynamic", parameterSource);
}
#end_block

#method_before
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextString(10), random.nextInt(), Guid.NewGuid(), Guid.NewGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class));
    vdsStatic.setpm_options("option1=value1,option2=value2");
    Object[][] data = new Object[][] { { vdsStatic }, { new VdsDynamic(random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextInt(), random.nextString(10), random.nextDouble(), random.nextString(10), random.nextBoolean(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.NewGuid(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextEnum(VDSStatus.class), random.nextNumericString(5) + "." + random.nextNumericString(5), random.nextString(10), random.nextString(10), new Date(random.nextLong()), random.nextInt(), random.nextInt(), random.nextBoolean()) }, { new VdsStatistics(random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextLong(), random.nextLong(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.NewGuid()) }, { new vds_spm_id_map(Guid.NewGuid(), Guid.NewGuid(), random.nextInt()) }, { new storage_domain_static(Guid.NewGuid(), random.nextString(10), random.nextInt(StorageDomainType.values().length), random.nextString(10)) }, { new storage_domain_dynamic(random.nextInt(), Guid.NewGuid(), random.nextInt()) }, { new storage_pool(random.nextString(10), Guid.NewGuid(), random.nextString(10), random.nextEnum(StorageType.class).getValue(), random.nextInt(StoragePoolStatus.values().length)) }, { new storage_pool_iso_map(Guid.NewGuid(), Guid.NewGuid(), random.nextEnum(StorageDomainStatus.class)) }, { new Role(random.nextString(10), Guid.NewGuid(), random.nextString(10)) }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.NewGuid(), Guid.NewGuid(), random.nextInt())) }, { new IdContainerClass<NGuid>(new NGuid(NGuid.NewGuid().toString())) }, { new IdContainerClass<Guid>(Guid.NewGuid()) } };
    return Arrays.asList(data);
}
#method_after
@Parameters
public static Collection<Object[]> data() {
    RandomUtils random = RandomUtils.instance();
    VdsStatic vdsStatic = new VdsStatic(random.nextString(10), random.nextString(10), random.nextString(10), random.nextInt(), Guid.NewGuid(), Guid.NewGuid(), random.nextString(10), random.nextBoolean(), random.nextEnum(VDSType.class));
    vdsStatic.setpm_options("option1=value1,option2=value2");
    Object[][] data = new Object[][] { { vdsStatic }, { new VdsDynamic(random.nextInt(), random.nextInt(), random.nextString(10), random.nextDouble(), random.nextString(10), random.nextBoolean(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.NewGuid(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextInt(), random.nextEnum(VDSStatus.class), random.nextNumericString(5) + "." + random.nextNumericString(5), random.nextString(10), random.nextString(10), new Date(random.nextLong()), random.nextInt(), random.nextInt(), random.nextBoolean(), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10), random.nextString(10)) }, { new VdsStatistics(random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextDouble(), random.nextLong(), random.nextLong(), random.nextInt(), random.nextInt(), random.nextInt(), Guid.NewGuid()) }, { new vds_spm_id_map(Guid.NewGuid(), Guid.NewGuid(), random.nextInt()) }, { new StorageDomainStatic(Guid.NewGuid(), random.nextString(10), random.nextInt(StorageDomainType.values().length), random.nextString(10)) }, { new StorageDomainDynamic(random.nextInt(), Guid.NewGuid(), random.nextInt()) }, { new storage_pool(random.nextString(10), Guid.NewGuid(), random.nextString(10), random.nextEnum(StorageType.class).getValue(), random.nextInt(StoragePoolStatus.values().length)) }, { new StoragePoolIsoMap(Guid.NewGuid(), Guid.NewGuid(), random.nextEnum(StorageDomainStatus.class)) }, { new Role(random.nextString(10), Guid.NewGuid(), random.nextString(10)) }, { new IdContainerClass<vds_spm_id_map>(new vds_spm_id_map(Guid.NewGuid(), Guid.NewGuid(), random.nextInt())) }, { new IdContainerClass<NGuid>(new NGuid(NGuid.NewGuid().toString())) }, { new IdContainerClass<Guid>(Guid.NewGuid()) } };
    return Arrays.asList(data);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((_supportedClusterVersionsSet == null) ? 0 : _supportedClusterVersionsSet.hashCode());
    result = prime * result + ((_supportedENGINESVersionsSet == null) ? 0 : _supportedENGINESVersionsSet.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + ((buildName == null) ? 0 : buildName.hashCode());
    result = prime * result + ((cpu_cores == null) ? 0 : cpu_cores.hashCode());
    result = prime * result + ((host_manufacturer == null) ? 0 : host_manufacturer.hashCode());
    result = prime * result + ((host_product_name == null) ? 0 : host_product_name.hashCode());
    result = prime * result + ((host_version == null) ? 0 : host_version.hashCode());
    result = prime * result + ((host_serial_number == null) ? 0 : host_serial_number.hashCode());
    result = prime * result + ((host_uuid == null) ? 0 : host_uuid.hashCode());
    result = prime * result + ((host_family == null) ? 0 : host_family.hashCode());
    result = prime * result + ((cpu_flags == null) ? 0 : cpu_flags.hashCode());
    result = prime * result + ((cpu_model == null) ? 0 : cpu_model.hashCode());
    result = prime * result + ((cpu_over_commit_time_stamp == null) ? 0 : cpu_over_commit_time_stamp.hashCode());
    result = prime * result + ((cpu_sockets == null) ? 0 : cpu_sockets.hashCode());
    result = prime * result + ((cpu_speed_mh == null) ? 0 : cpu_speed_mh.hashCode());
    result = prime * result + ((guest_overhead == null) ? 0 : guest_overhead.hashCode());
    result = prime * result + ((hooksStr == null) ? 0 : hooksStr.hashCode());
    result = prime * result + ((host_os == null) ? 0 : host_os.hashCode());
    result = prime * result + ((iScsiInitiatorName == null) ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((if_total_speed == null) ? 0 : if_total_speed.hashCode());
    result = prime * result + ((kernel_version == null) ? 0 : kernel_version.hashCode());
    result = prime * result + ((kvm_enabled == null) ? 0 : kvm_enabled.hashCode());
    result = prime * result + ((kvm_version == null) ? 0 : kvm_version.hashCode());
    result = prime * result + ((rpmVersion == null) ? 0 : rpmVersion.hashCode());
    result = prime * result + ((mem_commited == null) ? 0 : mem_commited.hashCode());
    result = prime * result + ((net_config_dirty == null) ? 0 : net_config_dirty.hashCode());
    result = prime * result + ((nonOperationalReason == null) ? 0 : nonOperationalReason.hashCode());
    result = prime * result + ((pending_vcpus_count == null) ? 0 : pending_vcpus_count.hashCode());
    result = prime * result + ((pending_vmem_size == null) ? 0 : pending_vmem_size.hashCode());
    result = prime * result + ((physical_mem_mb == null) ? 0 : physical_mem_mb.hashCode());
    result = prime * result + ((previous_status == null) ? 0 : previous_status.hashCode());
    result = prime * result + ((reserved_mem == null) ? 0 : reserved_mem.hashCode());
    result = prime * result + ((softwareVersion == null) ? 0 : softwareVersion.hashCode());
    result = prime * result + ((spice_version == null) ? 0 : spice_version.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((supported_cluster_levels == null) ? 0 : supported_cluster_levels.hashCode());
    result = prime * result + ((supported_engines == null) ? 0 : supported_engines.hashCode());
    result = prime * result + ((transparentHugePagesState == null) ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + ((versionName == null) ? 0 : versionName.hashCode());
    result = prime * result + ((vm_active == null) ? 0 : vm_active.hashCode());
    result = prime * result + vm_count;
    result = prime * result + ((vm_migrating == null) ? 0 : vm_migrating.hashCode());
    result = prime * result + ((vms_cores_count == null) ? 0 : vms_cores_count.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((_supportedClusterVersionsSet == null) ? 0 : _supportedClusterVersionsSet.hashCode());
    result = prime * result + ((_supportedENGINESVersionsSet == null) ? 0 : _supportedENGINESVersionsSet.hashCode());
    result = prime * result + anonymousHugePages;
    result = prime * result + ((buildName == null) ? 0 : buildName.hashCode());
    result = prime * result + ((cpu_cores == null) ? 0 : cpu_cores.hashCode());
    result = prime * result + ((cpuThreads == null) ? 0 : cpuThreads.hashCode());
    result = prime * result + ((cpu_flags == null) ? 0 : cpu_flags.hashCode());
    result = prime * result + ((cpu_model == null) ? 0 : cpu_model.hashCode());
    result = prime * result + ((cpu_over_commit_time_stamp == null) ? 0 : cpu_over_commit_time_stamp.hashCode());
    result = prime * result + ((cpu_sockets == null) ? 0 : cpu_sockets.hashCode());
    result = prime * result + ((cpu_speed_mh == null) ? 0 : cpu_speed_mh.hashCode());
    result = prime * result + ((guest_overhead == null) ? 0 : guest_overhead.hashCode());
    result = prime * result + ((hooksStr == null) ? 0 : hooksStr.hashCode());
    result = prime * result + ((host_os == null) ? 0 : host_os.hashCode());
    result = prime * result + ((iScsiInitiatorName == null) ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((if_total_speed == null) ? 0 : if_total_speed.hashCode());
    result = prime * result + ((kernel_version == null) ? 0 : kernel_version.hashCode());
    result = prime * result + ((kvm_enabled == null) ? 0 : kvm_enabled.hashCode());
    result = prime * result + ((kvm_version == null) ? 0 : kvm_version.hashCode());
    result = prime * result + ((libvirt_version == null) ? 0 : libvirt_version.hashCode());
    result = prime * result + ((rpmVersion == null) ? 0 : rpmVersion.hashCode());
    result = prime * result + ((mem_commited == null) ? 0 : mem_commited.hashCode());
    result = prime * result + ((net_config_dirty == null) ? 0 : net_config_dirty.hashCode());
    result = prime * result + ((nonOperationalReason == null) ? 0 : nonOperationalReason.hashCode());
    result = prime * result + ((pending_vcpus_count == null) ? 0 : pending_vcpus_count.hashCode());
    result = prime * result + ((pending_vmem_size == null) ? 0 : pending_vmem_size.hashCode());
    result = prime * result + ((physical_mem_mb == null) ? 0 : physical_mem_mb.hashCode());
    result = prime * result + ((previous_status == null) ? 0 : previous_status.hashCode());
    result = prime * result + ((reserved_mem == null) ? 0 : reserved_mem.hashCode());
    result = prime * result + ((softwareVersion == null) ? 0 : softwareVersion.hashCode());
    result = prime * result + ((spice_version == null) ? 0 : spice_version.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((supported_cluster_levels == null) ? 0 : supported_cluster_levels.hashCode());
    result = prime * result + ((supported_engines == null) ? 0 : supported_engines.hashCode());
    result = prime * result + ((transparentHugePagesState == null) ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + ((versionName == null) ? 0 : versionName.hashCode());
    result = prime * result + ((vm_active == null) ? 0 : vm_active.hashCode());
    result = prime * result + vm_count;
    result = prime * result + ((vm_migrating == null) ? 0 : vm_migrating.hashCode());
    result = prime * result + ((vms_cores_count == null) ? 0 : vms_cores_count.hashCode());
    result = prime * result + ((hwManufacturer == null) ? 0 : hwManufacturer.hashCode());
    result = prime * result + ((hwProductName == null) ? 0 : hwProductName.hashCode());
    result = prime * result + ((hwVersion == null) ? 0 : hwVersion.hashCode());
    result = prime * result + ((hwSerialNumber == null) ? 0 : hwSerialNumber.hashCode());
    result = prime * result + ((hwUUID == null) ? 0 : hwUUID.hashCode());
    result = prime * result + ((hwFamily == null) ? 0 : hwFamily.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdsDynamic other = (VdsDynamic) obj;
    if (_supportedClusterVersionsSet == null) {
        if (other._supportedClusterVersionsSet != null)
            return false;
    } else if (!_supportedClusterVersionsSet.equals(other._supportedClusterVersionsSet))
        return false;
    if (_supportedENGINESVersionsSet == null) {
        if (other._supportedENGINESVersionsSet != null)
            return false;
    } else if (!_supportedENGINESVersionsSet.equals(other._supportedENGINESVersionsSet))
        return false;
    if (anonymousHugePages != other.anonymousHugePages)
        return false;
    if (buildName == null) {
        if (other.buildName != null)
            return false;
    } else if (!buildName.equals(other.buildName))
        return false;
    if (host_manufacturer == null) {
        if (other.host_manufacturer != null)
            return false;
    } else if (!host_manufacturer.equals(other.host_manufacturer))
        return false;
    if (host_product_name == null) {
        if (other.host_product_name != null)
            return false;
    } else if (!host_product_name.equals(other.host_product_name))
        return false;
    if (host_version == null) {
        if (other.host_version != null)
            return false;
    } else if (!host_version.equals(other.host_version))
        return false;
    if (host_serial_number == null) {
        if (other.host_serial_number != null)
            return false;
    } else if (!host_serial_number.equals(other.host_serial_number))
        return false;
    if (host_uuid == null) {
        if (other.host_uuid != null)
            return false;
    } else if (!host_uuid.equals(other.host_uuid))
        return false;
    if (host_family == null) {
        if (other.host_family != null)
            return false;
    } else if (!host_family.equals(other.host_family))
        return false;
    if (cpu_cores == null) {
        if (other.cpu_cores != null)
            return false;
    } else if (!cpu_cores.equals(other.cpu_cores))
        return false;
    if (cpu_flags == null) {
        if (other.cpu_flags != null)
            return false;
    } else if (!cpu_flags.equals(other.cpu_flags))
        return false;
    if (cpu_model == null) {
        if (other.cpu_model != null)
            return false;
    } else if (!cpu_model.equals(other.cpu_model))
        return false;
    if (cpu_over_commit_time_stamp == null) {
        if (other.cpu_over_commit_time_stamp != null)
            return false;
    } else if (!cpu_over_commit_time_stamp.equals(other.cpu_over_commit_time_stamp))
        return false;
    if (cpu_sockets == null) {
        if (other.cpu_sockets != null)
            return false;
    } else if (!cpu_sockets.equals(other.cpu_sockets))
        return false;
    if (cpu_speed_mh == null) {
        if (other.cpu_speed_mh != null)
            return false;
    } else if (!cpu_speed_mh.equals(other.cpu_speed_mh))
        return false;
    if (guest_overhead == null) {
        if (other.guest_overhead != null)
            return false;
    } else if (!guest_overhead.equals(other.guest_overhead))
        return false;
    if (hooksStr == null) {
        if (other.hooksStr != null)
            return false;
    } else if (!hooksStr.equals(other.hooksStr))
        return false;
    if (host_os == null) {
        if (other.host_os != null)
            return false;
    } else if (!host_os.equals(other.host_os))
        return false;
    if (iScsiInitiatorName == null) {
        if (other.iScsiInitiatorName != null)
            return false;
    } else if (!iScsiInitiatorName.equals(other.iScsiInitiatorName))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (if_total_speed == null) {
        if (other.if_total_speed != null)
            return false;
    } else if (!if_total_speed.equals(other.if_total_speed))
        return false;
    if (kernel_version == null) {
        if (other.kernel_version != null)
            return false;
    } else if (!kernel_version.equals(other.kernel_version))
        return false;
    if (kvm_enabled == null) {
        if (other.kvm_enabled != null)
            return false;
    } else if (!kvm_enabled.equals(other.kvm_enabled))
        return false;
    if (kvm_version == null) {
        if (other.kvm_version != null)
            return false;
    } else if (!kvm_version.equals(other.kvm_version))
        return false;
    if (rpmVersion == null) {
        if (other.rpmVersion != null)
            return false;
    } else if (!rpmVersion.equals(other.rpmVersion))
        return false;
    if (mem_commited == null) {
        if (other.mem_commited != null)
            return false;
    } else if (!mem_commited.equals(other.mem_commited))
        return false;
    if (net_config_dirty == null) {
        if (other.net_config_dirty != null)
            return false;
    } else if (!net_config_dirty.equals(other.net_config_dirty))
        return false;
    if (nonOperationalReason != other.nonOperationalReason)
        return false;
    if (pending_vcpus_count == null) {
        if (other.pending_vcpus_count != null)
            return false;
    } else if (!pending_vcpus_count.equals(other.pending_vcpus_count))
        return false;
    if (pending_vmem_size == null) {
        if (other.pending_vmem_size != null)
            return false;
    } else if (!pending_vmem_size.equals(other.pending_vmem_size))
        return false;
    if (physical_mem_mb == null) {
        if (other.physical_mem_mb != null)
            return false;
    } else if (!physical_mem_mb.equals(other.physical_mem_mb))
        return false;
    if (previous_status != other.previous_status)
        return false;
    if (reserved_mem == null) {
        if (other.reserved_mem != null)
            return false;
    } else if (!reserved_mem.equals(other.reserved_mem))
        return false;
    if (getsoftware_version() == null) {
        if (other.getsoftware_version() != null)
            return false;
    } else if (!getsoftware_version().equals(other.getsoftware_version()))
        return false;
    if (spice_version == null) {
        if (other.spice_version != null)
            return false;
    } else if (!spice_version.equals(other.spice_version))
        return false;
    if (status != other.status)
        return false;
    if (supported_cluster_levels == null) {
        if (other.supported_cluster_levels != null)
            return false;
    } else if (!supported_cluster_levels.equals(other.supported_cluster_levels))
        return false;
    if (supported_engines == null) {
        if (other.supported_engines != null)
            return false;
    } else if (!supported_engines.equals(other.supported_engines))
        return false;
    if (transparentHugePagesState != other.transparentHugePagesState)
        return false;
    if (versionName == null) {
        if (other.versionName != null)
            return false;
    } else if (!versionName.equals(other.versionName))
        return false;
    if (vm_active == null) {
        if (other.vm_active != null)
            return false;
    } else if (!vm_active.equals(other.vm_active))
        return false;
    if (vm_count != other.vm_count)
        return false;
    if (vm_migrating == null) {
        if (other.vm_migrating != null)
            return false;
    } else if (!vm_migrating.equals(other.vm_migrating))
        return false;
    if (vms_cores_count == null) {
        if (other.vms_cores_count != null)
            return false;
    } else if (!vms_cores_count.equals(other.vms_cores_count))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdsDynamic other = (VdsDynamic) obj;
    if (_supportedClusterVersionsSet == null) {
        if (other._supportedClusterVersionsSet != null)
            return false;
    } else if (!_supportedClusterVersionsSet.equals(other._supportedClusterVersionsSet))
        return false;
    if (_supportedENGINESVersionsSet == null) {
        if (other._supportedENGINESVersionsSet != null)
            return false;
    } else if (!_supportedENGINESVersionsSet.equals(other._supportedENGINESVersionsSet))
        return false;
    if (anonymousHugePages != other.anonymousHugePages)
        return false;
    if (buildName == null) {
        if (other.buildName != null)
            return false;
    } else if (!buildName.equals(other.buildName))
        return false;
    if (cpu_cores == null) {
        if (other.cpu_cores != null)
            return false;
    } else if (!cpu_cores.equals(other.cpu_cores))
        return false;
    if (cpuThreads == null) {
        if (other.cpuThreads != null)
            return false;
    } else if (!cpuThreads.equals(other.cpuThreads))
        return false;
    if (cpu_flags == null) {
        if (other.cpu_flags != null)
            return false;
    } else if (!cpu_flags.equals(other.cpu_flags))
        return false;
    if (cpu_model == null) {
        if (other.cpu_model != null)
            return false;
    } else if (!cpu_model.equals(other.cpu_model))
        return false;
    if (cpu_over_commit_time_stamp == null) {
        if (other.cpu_over_commit_time_stamp != null)
            return false;
    } else if (!cpu_over_commit_time_stamp.equals(other.cpu_over_commit_time_stamp))
        return false;
    if (cpu_sockets == null) {
        if (other.cpu_sockets != null)
            return false;
    } else if (!cpu_sockets.equals(other.cpu_sockets))
        return false;
    if (cpu_speed_mh == null) {
        if (other.cpu_speed_mh != null)
            return false;
    } else if (!cpu_speed_mh.equals(other.cpu_speed_mh))
        return false;
    if (guest_overhead == null) {
        if (other.guest_overhead != null)
            return false;
    } else if (!guest_overhead.equals(other.guest_overhead))
        return false;
    if (hooksStr == null) {
        if (other.hooksStr != null)
            return false;
    } else if (!hooksStr.equals(other.hooksStr))
        return false;
    if (host_os == null) {
        if (other.host_os != null)
            return false;
    } else if (!host_os.equals(other.host_os))
        return false;
    if (iScsiInitiatorName == null) {
        if (other.iScsiInitiatorName != null)
            return false;
    } else if (!iScsiInitiatorName.equals(other.iScsiInitiatorName))
        return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (if_total_speed == null) {
        if (other.if_total_speed != null)
            return false;
    } else if (!if_total_speed.equals(other.if_total_speed))
        return false;
    if (kernel_version == null) {
        if (other.kernel_version != null)
            return false;
    } else if (!kernel_version.equals(other.kernel_version))
        return false;
    if (kvm_enabled == null) {
        if (other.kvm_enabled != null)
            return false;
    } else if (!kvm_enabled.equals(other.kvm_enabled))
        return false;
    if (kvm_version == null) {
        if (other.kvm_version != null)
            return false;
    } else if (!kvm_version.equals(other.kvm_version))
        return false;
    if (libvirt_version == null) {
        if (other.libvirt_version != null)
            return false;
    } else if (!libvirt_version.equals(other.libvirt_version))
        return false;
    if (rpmVersion == null) {
        if (other.rpmVersion != null)
            return false;
    } else if (!rpmVersion.equals(other.rpmVersion))
        return false;
    if (mem_commited == null) {
        if (other.mem_commited != null)
            return false;
    } else if (!mem_commited.equals(other.mem_commited))
        return false;
    if (net_config_dirty == null) {
        if (other.net_config_dirty != null)
            return false;
    } else if (!net_config_dirty.equals(other.net_config_dirty))
        return false;
    if (nonOperationalReason != other.nonOperationalReason)
        return false;
    if (pending_vcpus_count == null) {
        if (other.pending_vcpus_count != null)
            return false;
    } else if (!pending_vcpus_count.equals(other.pending_vcpus_count))
        return false;
    if (pending_vmem_size == null) {
        if (other.pending_vmem_size != null)
            return false;
    } else if (!pending_vmem_size.equals(other.pending_vmem_size))
        return false;
    if (physical_mem_mb == null) {
        if (other.physical_mem_mb != null)
            return false;
    } else if (!physical_mem_mb.equals(other.physical_mem_mb))
        return false;
    if (previous_status != other.previous_status)
        return false;
    if (reserved_mem == null) {
        if (other.reserved_mem != null)
            return false;
    } else if (!reserved_mem.equals(other.reserved_mem))
        return false;
    if (getsoftware_version() == null) {
        if (other.getsoftware_version() != null)
            return false;
    } else if (!getsoftware_version().equals(other.getsoftware_version()))
        return false;
    if (spice_version == null) {
        if (other.spice_version != null)
            return false;
    } else if (!spice_version.equals(other.spice_version))
        return false;
    if (status != other.status)
        return false;
    if (supported_cluster_levels == null) {
        if (other.supported_cluster_levels != null)
            return false;
    } else if (!supported_cluster_levels.equals(other.supported_cluster_levels))
        return false;
    if (supported_engines == null) {
        if (other.supported_engines != null)
            return false;
    } else if (!supported_engines.equals(other.supported_engines))
        return false;
    if (transparentHugePagesState != other.transparentHugePagesState)
        return false;
    if (versionName == null) {
        if (other.versionName != null)
            return false;
    } else if (!versionName.equals(other.versionName))
        return false;
    if (vm_active == null) {
        if (other.vm_active != null)
            return false;
    } else if (!vm_active.equals(other.vm_active))
        return false;
    if (vm_count != other.vm_count)
        return false;
    if (vm_migrating == null) {
        if (other.vm_migrating != null)
            return false;
    } else if (!vm_migrating.equals(other.vm_migrating))
        return false;
    if (vms_cores_count == null) {
        if (other.vms_cores_count != null)
            return false;
    } else if (!vms_cores_count.equals(other.vms_cores_count))
        return false;
    if (hwManufacturer == null) {
        if (other.hwManufacturer != null)
            return false;
    } else if (!hwManufacturer.equals(other.hwManufacturer))
        return false;
    if (hwProductName == null) {
        if (other.hwProductName != null)
            return false;
    } else if (!hwProductName.equals(other.hwProductName))
        return false;
    if (hwVersion == null) {
        if (other.hwVersion != null)
            return false;
    } else if (!hwVersion.equals(other.hwVersion))
        return false;
    if (hwSerialNumber == null) {
        if (other.hwSerialNumber != null)
            return false;
    } else if (!hwSerialNumber.equals(other.hwSerialNumber))
        return false;
    if (hwUUID == null) {
        if (other.hwUUID != null)
            return false;
    } else if (!hwUUID.equals(other.hwUUID))
        return false;
    if (hwFamily == null) {
        if (other.hwFamily != null)
            return false;
    } else if (!hwFamily.equals(other.hwFamily))
        return false;
    return true;
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS(Guid.createGuidFromString(getvds_group_id().toString()), getvds_group_name(), getvds_group_description(), Guid.createGuidFromString(getId().toString()), getvds_name(), getManagmentIp(), gethost_name(), getport(), getstatus().getValue(), gethost_manufacturer(), gethost_product_name(), gethost_version(), gethost_serial_number(), gethost_uuid(), gethost_family(), getcpu_cores(), getcpu_model(), getcpu_speed_mh(), getif_total_speed(), getkvm_enabled(), getphysical_mem_mb(), getcpu_idle(), getcpu_load(), getcpu_sys(), getcpu_user(), getmem_commited(), getvm_active(), getvm_count(), getvm_migrating(), getusage_mem_percent(), getusage_cpu_percent(), getusage_network_percent(), getreserved_mem(), getguest_overhead(), getprevious_status(), getsoftware_version(), getversion_name(), getbuild_name(), getmem_available(), getmem_shared(), getserver_SSL_enabled(), getvds_group_cpu_name(), "", getnet_config_dirty(), getpm_type(), getpm_user(), getpm_password(), getpm_port(), getpm_options(), getpm_enabled());
    vds.setcpu_flags(getcpu_flags());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setkernel_version(getkernel_version());
    vds.setkvm_version(getkvm_version());
    vds.setHooksStr(getHooksStr());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS(Guid.createGuidFromString(getvds_group_id().toString()), getvds_group_name(), getvds_group_description(), Guid.createGuidFromString(getId().toString()), getvds_name(), getManagmentIp(), gethost_name(), getport(), getstatus().getValue(), getcpu_cores(), getCpuThreads(), getcpu_model(), getHardwareManufacturer(), getHardwareProductName(), getHardwareVersion(), getHardwareSerialNumber(), getHardwareUUID(), getHardwareFamily(), getcpu_speed_mh(), getif_total_speed(), getkvm_enabled(), getphysical_mem_mb(), getcpu_idle(), getcpu_load(), getcpu_sys(), getcpu_user(), getmem_commited(), getvm_active(), getvm_count(), getvm_migrating(), getusage_mem_percent(), getusage_cpu_percent(), getusage_network_percent(), getreserved_mem(), getguest_overhead(), getprevious_status(), getsoftware_version(), getversion_name(), getbuild_name(), getmem_available(), getmem_shared(), getserver_SSL_enabled(), getvds_group_cpu_name(), "", getnet_config_dirty(), getpm_type(), getpm_user(), getpm_password(), getpm_port(), getpm_options(), getpm_enabled());
    vds.setcpu_flags(getcpu_flags());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setkernel_version(getkernel_version());
    vds.setkvm_version(getkvm_version());
    vds.setlibvirt_version(getlibvirt_version());
    vds.setHooksStr(getHooksStr());
    return vds;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, XmlRpcStruct xmlRpcStruct) {
    if (xmlRpcStruct.contains(VdsProperties.vm_guid)) {
        try {
            vm.setId(new Guid((String) xmlRpcStruct.getItem(VdsProperties.vm_guid)));
        } catch (FormatException e) {
            log.info("vm id is not in uuid format, ", e);
            vm.setId(new Guid());
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.getItem(VdsProperties.session);
        try {
            vm.setsession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.kvmEnable)) {
        vm.setkvm_enable(Boolean.parseBoolean((String) xmlRpcStruct.getItem(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.contains(VdsProperties.acpiEnable)) {
        vm.setacpi_enable(Boolean.parseBoolean((String) xmlRpcStruct.getItem(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.contains(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.getItem(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.contains(VdsProperties.status)) {
        vm.setstatus(convertToVmStatus((String) xmlRpcStruct.getItem(VdsProperties.status)));
    }
    if (xmlRpcStruct.contains(VdsProperties.display_port)) {
        try {
            vm.setdisplay(Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.getItem(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.contains(VdsProperties.display)) {
        try {
            vm.setdisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.getItem(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.display_secure_port)) {
        try {
            vm.setdisplay_secure_port(Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.getItem(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.contains((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.getItem(VdsProperties.displayType).toString();
        try {
            vm.setdisplay_type(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.contains((VdsProperties.displayIp))) {
        vm.setdisplay_ip((String) xmlRpcStruct.getItem(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.contains((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.getItem(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setutc_diff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.getItem(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.contains(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setguest_last_login_time(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setvm_host(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    initAppsList(xmlRpcStruct, vm);
    vm.setguest_os(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    vm.setvm_ip(AssignStringValue(xmlRpcStruct, VdsProperties.vm_ip));
    if (vm.getvm_ip() != null) {
        if (vm.getvm_ip().startsWith("127.0.")) {
            vm.setvm_ip(null);
        } else {
            vm.setvm_ip(vm.getvm_ip().trim());
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.getItem(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.contains(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.getItem(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.contains(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setstatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.clientIp)) {
        vm.setclient_ip(xmlRpcStruct.getItem(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.contains(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.getItem(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, XmlRpcStruct xmlRpcStruct) {
    if (xmlRpcStruct.contains(VdsProperties.vm_guid)) {
        try {
            vm.setId(new Guid((String) xmlRpcStruct.getItem(VdsProperties.vm_guid)));
        } catch (FormatException e) {
            log.info("vm id is not in uuid format, ", e);
            vm.setId(new Guid());
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.getItem(VdsProperties.session);
        try {
            vm.setsession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.kvmEnable)) {
        vm.setkvm_enable(Boolean.parseBoolean((String) xmlRpcStruct.getItem(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.contains(VdsProperties.acpiEnable)) {
        vm.setacpi_enable(Boolean.parseBoolean((String) xmlRpcStruct.getItem(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.contains(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.getItem(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.contains(VdsProperties.status)) {
        vm.setstatus(convertToVmStatus((String) xmlRpcStruct.getItem(VdsProperties.status)));
    }
    if (xmlRpcStruct.contains(VdsProperties.display_port)) {
        try {
            vm.setdisplay(Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.getItem(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.contains(VdsProperties.display)) {
        try {
            vm.setdisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.getItem(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.display_secure_port)) {
        try {
            vm.setdisplay_secure_port(Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.getItem(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.contains((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.getItem(VdsProperties.displayType).toString();
        try {
            vm.setdisplay_type(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.contains((VdsProperties.displayIp))) {
        vm.setdisplay_ip((String) xmlRpcStruct.getItem(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.contains((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.getItem(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setutc_diff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.getItem(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.contains(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setguest_last_login_time(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setvm_host(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setguest_cur_user_name(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setguest_os(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    vm.setvm_ip(AssignStringValue(xmlRpcStruct, VdsProperties.vm_ip));
    if (vm.getvm_ip() != null) {
        if (vm.getvm_ip().startsWith("127.0.")) {
            vm.setvm_ip(null);
        } else {
            vm.setvm_ip(vm.getvm_ip().trim());
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.getItem(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.contains(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.getItem(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.contains(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.getItem(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setstatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.clientIp)) {
        vm.setclient_ip(xmlRpcStruct.getItem(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.contains(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.getItem(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, XmlRpcStruct xmlRpcStruct) {
    if (xmlRpcStruct.contains(VdsProperties.vm_guid)) {
        try {
            vm.setId(new Guid((String) xmlRpcStruct.getItem(VdsProperties.vm_guid)));
        } catch (FormatException e) {
            log.info("vm id is not in uuid format, ", e);
            vm.setId(new Guid());
        }
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.vm_network)) {
        Map networkStruct = (Map) xmlRpcStruct.getItem(VdsProperties.vm_network);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            XmlRpcStruct nic = new XmlRpcStruct((Map) tempNic);
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.if_name)) {
                stats.setName((String) ((nic.getItem(VdsProperties.if_name) instanceof String) ? nic.getItem(VdsProperties.if_name) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.getItem(VdsProperties.mac_addr) instanceof String) ? nic.getItem(VdsProperties.mac_addr) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.if_speed));
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, XmlRpcStruct xmlRpcStruct) {
    if (xmlRpcStruct.contains(VdsProperties.vm_guid)) {
        try {
            vm.setId(new Guid((String) xmlRpcStruct.getItem(VdsProperties.vm_guid)));
        } catch (FormatException e) {
            log.info("vm id is not in uuid format, ", e);
            vm.setId(new Guid());
        }
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.vm_network)) {
        Map networkStruct = (Map) xmlRpcStruct.getItem(VdsProperties.vm_network);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            XmlRpcStruct nic = new XmlRpcStruct((Map) tempNic);
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.getItem(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.getItem(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.getItem(VdsProperties.mac_addr) instanceof String) ? nic.getItem(VdsProperties.mac_addr) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.if_speed));
        }
    }
    if (xmlRpcStruct.contains(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.sethost_manufacturer(AssignStringValue(xmlRpcStruct, VdsProperties.host_manufacturer));
    vds.sethost_product_name(AssignStringValue(xmlRpcStruct, VdsProperties.host_product_name));
    vds.sethost_version(AssignStringValue(xmlRpcStruct, VdsProperties.host_version));
    vds.sethost_serial_number(AssignStringValue(xmlRpcStruct, VdsProperties.host_serial_number));
    vds.sethost_uuid(AssignStringValue(xmlRpcStruct, VdsProperties.host_uuid));
    vds.sethost_family(AssignStringValue(xmlRpcStruct, VdsProperties.host_family));
    vds.setcpu_cores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setcpu_sockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setcpu_model(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setcpu_speed_mh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setphysical_mem_mb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setkvm_enabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setreserved_mem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setguest_overhead(guestOverhead != null ? guestOverhead : 0);
    vds.setcpu_flags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setsupported_cluster_levels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setsupported_engines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.getItem(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
}
#method_after
public static void updateVDSDynamicData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setcpu_cores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setcpu_sockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setcpu_model(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setcpu_speed_mh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setphysical_mem_mb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setkvm_enabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setreserved_mem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setguest_overhead(guestOverhead != null ? guestOverhead : 0);
    vds.setcpu_flags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setsupported_cluster_levels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setsupported_engines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.getItem(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
}
#end_block

#method_before
private static void UpdatePackagesVersions(VDS vds, XmlRpcStruct xmlRpcStruct) {
    vds.setversion_name(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setsoftware_version(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setbuild_name(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.contains(VdsProperties.host_os)) {
        vds.sethost_os(GetPackageVersionFormated(new XmlRpcStruct((Map) xmlRpcStruct.getItem(VdsProperties.host_os)), true));
    }
    if (xmlRpcStruct.contains(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.getItem(VdsProperties.packages)) {
            XmlRpcStruct hostPackage = new XmlRpcStruct((Map) hostPackageMap);
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setkvm_version(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setspice_version(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setkernel_version(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.contains(VdsProperties.packages2)) {
        Map packages = (Map) xmlRpcStruct.getItem(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map vdsm = (Map) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map kvm = (Map) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setkvm_version(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map spice = (Map) packages.get(VdsProperties.spiceServerPackageName);
            vds.setspice_version(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map kernel = (Map) packages.get(VdsProperties.kernelPackageName);
            vds.setkernel_version(getPackageVersionFormated2(kernel));
        }
    }
}
#method_after
private static void UpdatePackagesVersions(VDS vds, XmlRpcStruct xmlRpcStruct) {
    vds.setversion_name(AssignStringValue(xmlRpcStruct, VdsProperties.version_name));
    vds.setsoftware_version(AssignStringValue(xmlRpcStruct, VdsProperties.software_version));
    vds.setbuild_name(AssignStringValue(xmlRpcStruct, VdsProperties.build_name));
    if (xmlRpcStruct.contains(VdsProperties.host_os)) {
        vds.sethost_os(GetPackageVersionFormated(new XmlRpcStruct((Map) xmlRpcStruct.getItem(VdsProperties.host_os)), true));
    }
    if (xmlRpcStruct.contains(VdsProperties.packages)) {
        // release.. of a package)
        for (Object hostPackageMap : (Object[]) xmlRpcStruct.getItem(VdsProperties.packages)) {
            XmlRpcStruct hostPackage = new XmlRpcStruct((Map) hostPackageMap);
            String packageName = AssignStringValue(hostPackage, VdsProperties.package_name);
            if (VdsProperties.kvmPackageName.equals(packageName)) {
                vds.setkvm_version(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.libvirtPackageName.equals(packageName)) {
                vds.setlibvirt_version(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.spicePackageName.equals(packageName)) {
                vds.setspice_version(GetPackageVersionFormated(hostPackage, false));
            } else if (VdsProperties.kernelPackageName.equals(packageName)) {
                vds.setkernel_version(GetPackageVersionFormated(hostPackage, false));
            }
        }
    } else if (xmlRpcStruct.contains(VdsProperties.packages2)) {
        Map packages = (Map) xmlRpcStruct.getItem(VdsProperties.packages2);
        if (packages.containsKey(VdsProperties.vdsmPackageName)) {
            Map vdsm = (Map) packages.get(VdsProperties.vdsmPackageName);
            vds.setVersion(getPackageRpmVersion("vdsm", vdsm));
        }
        if (packages.containsKey(VdsProperties.qemuKvmPackageName)) {
            Map kvm = (Map) packages.get(VdsProperties.qemuKvmPackageName);
            vds.setkvm_version(getPackageVersionFormated2(kvm));
        }
        if (packages.containsKey(VdsProperties.libvirtPackageName)) {
            Map libvirt = (Map) packages.get(VdsProperties.libvirtPackageName);
            vds.setlibvirt_version(getPackageVersionFormated2(libvirt));
        }
        if (packages.containsKey(VdsProperties.spiceServerPackageName)) {
            Map spice = (Map) packages.get(VdsProperties.spiceServerPackageName);
            vds.setspice_version(getPackageVersionFormated2(spice));
        }
        if (packages.containsKey(VdsProperties.kernelPackageName)) {
            Map kernel = (Map) packages.get(VdsProperties.kernelPackageName);
            vds.setkernel_version(getPackageVersionFormated2(kernel));
        }
    }
}
#end_block

#method_before
private static void initDisks(XmlRpcStruct vmStruct, VmDynamic vm) {
    Map disks = (Map) vmStruct.getItem(VdsProperties.vm_disks);
    ArrayList<DiskImageDynamic> disksData = new ArrayList<DiskImageDynamic>();
    List<Disk> vmDisksFromDb = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
    for (Object diskAsObj : disks.values()) {
        XmlRpcStruct disk = new XmlRpcStruct((Map) diskAsObj);
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = AssignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            DiskImage vmCurrentDisk = null;
            for (Disk vmDisk : vmDisksFromDb) {
                if (vmDisk.getId() != null && imageGroupIdGuid.equals(vmDisk.getId().getValue()) && vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    vmCurrentDisk = (DiskImage) vmDisk;
                    break;
                }
            }
            if (vmCurrentDisk != null) {
                diskData.setId(vmCurrentDisk.getImageId());
                diskData.setread_rate(AssignIntValue(disk, VdsProperties.vm_disk_read_rate));
                diskData.setwrite_rate(AssignIntValue(disk, VdsProperties.vm_disk_write_rate));
                if (disk.contains(VdsProperties.disk_actual_size)) {
                    Long size = AssignLongValue(disk, VdsProperties.disk_actual_size);
                    diskData.setactual_size(size != null ? size * 512 : 0);
                } else if (disk.contains(VdsProperties.disk_true_size)) {
                    Long size = AssignLongValue(disk, VdsProperties.disk_true_size);
                    diskData.setactual_size(size != null ? size : 0);
                }
                if (disk.contains(VdsProperties.vm_disk_read_latency)) {
                    diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
                }
                if (disk.contains(VdsProperties.vm_disk_write_latency)) {
                    diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
                }
                if (disk.contains(VdsProperties.vm_disk_flush_latency)) {
                    diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
                }
                disksData.add(diskData);
            }
        }
    }
    vm.setDisks(disksData);
}
#method_after
private static void initDisks(XmlRpcStruct vmStruct, VmDynamic vm) {
    Map disks = (Map) vmStruct.getItem(VdsProperties.vm_disks);
    ArrayList<DiskImageDynamic> disksData = new ArrayList<DiskImageDynamic>();
    for (Object diskAsObj : disks.values()) {
        XmlRpcStruct disk = new XmlRpcStruct((Map) diskAsObj);
        DiskImageDynamic diskData = new DiskImageDynamic();
        String imageGroupIdString = AssignStringValue(disk, VdsProperties.image_group_id);
        if (!StringUtils.isEmpty(imageGroupIdString)) {
            Guid imageGroupIdGuid = new Guid(imageGroupIdString);
            diskData.setId(imageGroupIdGuid);
            diskData.setread_rate(AssignIntValue(disk, VdsProperties.vm_disk_read_rate));
            diskData.setwrite_rate(AssignIntValue(disk, VdsProperties.vm_disk_write_rate));
            if (disk.contains(VdsProperties.disk_actual_size)) {
                Long size = AssignLongValue(disk, VdsProperties.disk_actual_size);
                diskData.setactual_size(size != null ? size * 512 : 0);
            } else if (disk.contains(VdsProperties.disk_true_size)) {
                Long size = AssignLongValue(disk, VdsProperties.disk_true_size);
                diskData.setactual_size(size != null ? size : 0);
            }
            if (disk.contains(VdsProperties.vm_disk_read_latency)) {
                diskData.setReadLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_read_latency) / NANO_SECONDS);
            }
            if (disk.contains(VdsProperties.vm_disk_write_latency)) {
                diskData.setWriteLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_write_latency) / NANO_SECONDS);
            }
            if (disk.contains(VdsProperties.vm_disk_flush_latency)) {
                diskData.setFlushLatency(assignDoubleValueWithNullProtection(disk, VdsProperties.vm_disk_flush_latency) / NANO_SECONDS);
            }
            disksData.add(diskData);
        }
    }
    vm.setDisks(disksData);
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetType()) {
        entity.setpm_type(model.getType());
    }
    if (model.isSetEnabled()) {
        entity.setpm_enabled(model.isEnabled());
    }
    if (model.isSetAddress()) {
        entity.setManagmentIp(model.getAddress());
    }
    if (model.isSetUsername()) {
        entity.setpm_user(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setpm_password(model.getPassword());
    }
    if (model.isSetOptions()) {
        entity.setpm_options(map(model.getOptions(), null));
    }
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetType()) {
        entity.setpm_type(model.getType());
    }
    if (model.isSetEnabled()) {
        entity.setpm_enabled(model.isEnabled());
    }
    if (model.isSetAddress()) {
        entity.setManagmentIp(model.getAddress());
    }
    if (model.isSetUsername()) {
        entity.setpm_user(model.getUsername());
    }
    if (model.isSetPassword()) {
        entity.setpm_password(model.getPassword());
    }
    if (model.isSetOptions()) {
        entity.setpm_options(map(model.getOptions(), null));
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
        }
    }
    if (entity.getcpu_ht_enabled() != null) {
        cpuTopology.setHtEnabled(entity.getcpu_ht_enabled());
    }
    if (entity.getvdsm_count_threads_as_cores() != null) {
        cpuTopology.setVdsmCountThreadsAsCores(entity.getvdsm_count_threads_as_cores());
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getcpu_cores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    return model;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getpm_type());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagmentIp());
    model.setUsername(entity.getpm_user());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = PowerManagement.class)
public static PowerManagement map(VDS entity, PowerManagement template) {
    PowerManagement model = template != null ? template : new PowerManagement();
    model.setType(entity.getpm_type());
    model.setEnabled(entity.getpm_enabled());
    model.setAddress(entity.getManagmentIp());
    model.setUsername(entity.getpm_user());
    if (entity.getPmOptionsMap() != null) {
        model.setOptions(map(entity.getPmOptionsMap(), null));
    }
    if (entity.getPmProxyPreferences() != null) {
        PmProxies pmProxies = new PmProxies();
        String[] proxies = StringUtils.split(entity.getPmProxyPreferences(), ",");
        for (String proxy : proxies) {
            PmProxy pmProxy = new PmProxy();
            pmProxy.setType(proxy);
            pmProxies.getPmProxy().add(pmProxy);
        }
        model.setPmProxies(pmProxies);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VDSType.class, to = HostType.class)
public static HostType map(VDSType type, HostType template) {
    switch(type) {
        case VDS:
            return HostType.RHEL;
        case oVirtNode:
            return HostType.RHEV_H;
        default:
            return null;
    }
}
#method_after
@Mapping(from = HashMap.class, to = Hooks.class)
public static Hooks map(HashMap<String, HashMap<String, HashMap<String, String>>> dictionary, Hooks hooks) {
    if (hooks == null) {
        hooks = new Hooks();
    }
    for (Map.Entry<String, HashMap<String, HashMap<String, String>>> keyValuePair : dictionary.entrySet()) {
        // events
        for (Map.Entry<String, HashMap<String, String>> keyValuePair1 : // hooks
        keyValuePair.getValue().entrySet()) {
            Hook hook = createHook(keyValuePair, keyValuePair1);
            hooks.getHooks().add(hook);
        }
    }
    return hooks;
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(new Guid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetCountThreadsAsCores()) {
        entity.setcount_threads_as_cores(model.isCountThreadsAsCores());
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(new Guid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getname());
    model.setDescription(entity.getdescription());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setCountThreadsAsCores(entity.getcount_threads_as_cores());
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getname());
    model.setDescription(entity.getdescription());
    if (entity.getcpu_name() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getcpu_name());
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getcompatibility_version() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getcompatibility_version().getMajor());
        model.getVersion().setMinor(entity.getcompatibility_version().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    return model;
}
#end_block

#method_before
@Test
public void testCpuMapping() {
    VDS vds = new VDS();
    vds.setId(Guid.Empty);
    vds.setcpu_cores(6);
    vds.setcpu_sockets(3);
    vds.setcpu_ht_enabled(true);
    vds.setvdsm_count_threads_as_cores(false);
    vds.setcpu_model("some cpu model");
    vds.setcpu_speed_mh(5.5);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getCpu());
    assertEquals(new Integer(host.getCpu().getTopology().getCores()), new Integer(2));
    assertEquals(new Integer(host.getCpu().getTopology().getSockets()), new Integer(3));
    assertEquals(new Boolean(host.getCpu().getTopology().isHtEnabled()), new Boolean(true));
    assertEquals(new Boolean(host.getCpu().getTopology().isVdsmCountThreadsAsCores()), new Boolean(false));
    assertEquals(host.getCpu().getName(), "some cpu model");
    assertEquals(host.getCpu().getSpeed(), new BigDecimal(5.5));
}
#method_after
@Test
public void testCpuMapping() {
    VDS vds = new VDS();
    vds.setId(Guid.Empty);
    vds.setcpu_cores(6);
    vds.setcpu_sockets(3);
    vds.setCpuThreads(12);
    vds.setcpu_model("some cpu model");
    vds.setcpu_speed_mh(5.5);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getCpu());
    assertEquals(new Integer(host.getCpu().getTopology().getCores()), new Integer(2));
    assertEquals(new Integer(host.getCpu().getTopology().getSockets()), new Integer(3));
    assertEquals(new Integer(host.getCpu().getTopology().getThreads()), new Integer(2));
    assertEquals(host.getCpu().getName(), "some cpu model");
    assertEquals(host.getCpu().getSpeed(), new BigDecimal(5.5));
}
#end_block

#method_before
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    return features;
}
#method_after
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    return features;
}
#end_block

#method_before
private void addFeatureHostSockets(Features features) {
    Feature feature = new Feature();
    feature.setHost(new Host());
    feature.setName("Display Host Sockets");
    feature.setDescription("Number of host sockets displayed. 'cores' now show num of cores per socket --> total cores in host is: cores*sockets");
    feature.getHost().setCpu(new CPU());
    feature.getHost().getCpu().setTopology(new CpuTopology());
    feature.getHost().getCpu().getTopology().setSockets(4);
    feature.getHost().getCpu().getTopology().setHtEnabled(true);
    feature.getHost().getCpu().getTopology().setVdsmCountThreadsAsCores(false);
    features.getFeature().add(feature);
}
#method_after
private void addFeatureHostSockets(Features features, Version version) {
    Feature feature = new Feature();
    feature.setHost(new Host());
    feature.setName("Display Host Sockets");
    feature.setDescription("Number of host sockets displayed. 'cores' now show num of cores per socket --> total cores in host is: cores*sockets");
    feature.getHost().setCpu(new CPU());
    feature.getHost().getCpu().setTopology(new CpuTopology());
    feature.getHost().getCpu().getTopology().setSockets(4);
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_2)) {
        feature.getHost().getCpu().getTopology().setThreads(2);
    }
    features.getFeature().add(feature);
}
#end_block

#method_before
@Override
public List<Quota> getQuotaByAdElementId(Guid adElementId, Guid storagePoolId) {
    MapSqlParameterSource quotaParameterSource = getCustomMapSqlParameterSource();
    quotaParameterSource.addValue("ad_element_id", adElementId);
    quotaParameterSource.addValue("storage_pool_id", storagePoolId);
    List<Quota> quotaEntityList = getCallsHandler().executeReadList("GetQuotaByAdElementId", getQuotaMetaDataFromResultSet(), quotaParameterSource);
    return quotaEntityList;
}
#method_after
@Override
public List<Quota> getQuotaByAdElementId(Guid adElementId, Guid storagePoolId, boolean recursive) {
    MapSqlParameterSource quotaParameterSource = getCustomMapSqlParameterSource();
    quotaParameterSource.addValue("ad_element_id", adElementId);
    quotaParameterSource.addValue("storage_pool_id", storagePoolId);
    quotaParameterSource.addValue("recursive", recursive);
    List<Quota> quotaEntityList = getCallsHandler().executeReadList("GetQuotaByAdElementId", getQuotaMetaDataFromResultSet(), quotaParameterSource);
    return quotaEntityList;
}
#end_block

#method_before
@Override
public List<QuotaStorage> getAllQuotaStorageIncludingConsumption() {
    MapSqlParameterSource parameterSource = new MapSqlParameterSource();
    return getCallsHandler().executeReadList("CalculateAllStorageUsage", getQuotaStorageResultSet(), parameterSource);
}
#method_after
@Override
public List<QuotaStorage> getAllQuotaStorageIncludingConsumption() {
    MapSqlParameterSource parameterSource = new MapSqlParameterSource();
    return getCallsHandler().executeReadList("calculateAllStorageUsage", getQuotaStorageResultSet(), parameterSource);
}
#end_block

#method_before
@Override
public int getQuotaCount() {
    MapSqlParameterSource parameterSource = new MapSqlParameterSource();
    return getCallsHandler().executeRead("GetQuotaCount", new ParameterizedRowMapper<Integer>() {

        @Override
        public Integer mapRow(ResultSet resultSet, int i) throws SQLException {
            return (Integer) resultSet.getObject("num_quota");
        }
    }, parameterSource);
}
#method_after
@Override
public int getQuotaCount() {
    MapSqlParameterSource parameterSource = new MapSqlParameterSource();
    return getCallsHandler().executeRead("getQuotaCount", longMapper, parameterSource).intValue();
}
#end_block

#method_before
@Override
public List<Quota> getAllQuotaIncludingConsumption() {
    MapSqlParameterSource parameterSource = new MapSqlParameterSource();
    // get thin quota (only basic quota meta data)
    List<Quota> allThinQuota = getCallsHandler().executeReadList("GetAllThinQuota", getQuotaFromResultSet(), parameterSource);
    if (allThinQuota != null && !allThinQuota.isEmpty()) {
        Map<Guid, Quota> allQuotaMap = new HashMap<Guid, Quota>();
        for (Quota quota : allThinQuota) {
            allQuotaMap.put(quota.getId(), quota);
        }
        List<QuotaStorage> quotaStorageList = getAllQuotaStorageIncludingConsumption();
        List<QuotaVdsGroup> quotaVdsGroupList = getALLQuotaVdsGroupIncludingConsumption();
        if (quotaStorageList != null) {
            for (QuotaStorage quotaStorage : quotaStorageList) {
                Quota quota = allQuotaMap.get(quotaStorage.getQuotaId());
                if (quotaStorage.getStorageId() == null) {
                    quota.setGlobalQuotaStorage(quotaStorage);
                } else {
                    if (quota.getQuotaStorages() == null) {
                        quota.setQuotaStorages(new ArrayList<QuotaStorage>());
                    }
                    quota.getQuotaStorages().add(quotaStorage);
                }
            }
        }
        if (quotaVdsGroupList != null) {
            for (QuotaVdsGroup quotaVdsGroup : quotaVdsGroupList) {
                Quota quota = allQuotaMap.get(quotaVdsGroup.getQuotaId());
                if (quotaVdsGroup.getVdsGroupId() == null) {
                    quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
                } else {
                    if (quota.getQuotaVdsGroups() == null) {
                        quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
                    }
                    quota.getQuotaVdsGroups().add(quotaVdsGroup);
                }
            }
        }
    }
    // The thin quota were all filled
    return allThinQuota;
}
#method_after
@Override
public List<Quota> getAllQuotaIncludingConsumption() {
    MapSqlParameterSource parameterSource = new MapSqlParameterSource();
    // get thin quota (only basic quota meta data)
    List<Quota> allThinQuota = getCallsHandler().executeReadList("getAllThinQuota", getQuotaMetaDataFromResultSet(), parameterSource);
    if (allThinQuota != null && !allThinQuota.isEmpty()) {
        Map<Guid, Quota> allQuotaMap = new HashMap<Guid, Quota>();
        for (Quota quota : allThinQuota) {
            allQuotaMap.put(quota.getId(), quota);
        }
        List<QuotaStorage> quotaStorageList = getAllQuotaStorageIncludingConsumption();
        List<QuotaVdsGroup> quotaVdsGroupList = getAllQuotaVdsGroupIncludingConsumption();
        if (quotaStorageList != null) {
            for (QuotaStorage quotaStorage : quotaStorageList) {
                Quota quota = allQuotaMap.get(quotaStorage.getQuotaId());
                if (quota != null) {
                    if (quotaStorage.getStorageId() == null || quotaStorage.getStorageId().equals(Guid.Empty)) {
                        quota.setGlobalQuotaStorage(quotaStorage);
                    } else {
                        if (quota.getQuotaStorages() == null) {
                            quota.setQuotaStorages(new ArrayList<QuotaStorage>());
                        }
                        quota.getQuotaStorages().add(quotaStorage);
                    }
                }
            }
        }
        if (quotaVdsGroupList != null) {
            for (QuotaVdsGroup quotaVdsGroup : quotaVdsGroupList) {
                Quota quota = allQuotaMap.get(quotaVdsGroup.getQuotaId());
                if (quota != null) {
                    if (quotaVdsGroup.getVdsGroupId() == null || quotaVdsGroup.getVdsGroupId().equals(Guid.Empty)) {
                        quota.setGlobalQuotaVdsGroup(quotaVdsGroup);
                    } else {
                        if (quota.getQuotaVdsGroups() == null) {
                            quota.setQuotaVdsGroups(new ArrayList<QuotaVdsGroup>());
                        }
                        quota.getQuotaVdsGroups().add(quotaVdsGroup);
                    }
                }
            }
        }
    }
    // The thin quota were all filled
    return allThinQuota;
}
#end_block

#method_before
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        corruptedParameters.add(param);
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        corruptedParameters.add(param);
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#method_after
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        corruptedParameters.add(param);
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        parameters.getCanDoActionMessages().add(String.format("$VmName %1$s", parameters.getAuditLogable().getVmName()));
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        corruptedParameters.add(param);
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#end_block

#method_before
public List<QuotaUsagePerUser> generatePerUserUsageReport(List<Quota> quotaIdsList, List<VM> vms) {
    Map<Guid, QuotaUsagePerUser> quotaPerUserUsageEntityMap = new HashMap<Guid, QuotaUsagePerUser>();
    List<Quota> needToCache = new ArrayList<Quota>();
    if (quotaIdsList != null) {
        lock.readLock().lock();
        try {
            for (Quota quotaExternal : quotaIdsList) {
                // look for the quota in the cache
                Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(quotaExternal.getStoragePoolId());
                Quota quota = null;
                if (quotaMap != null) {
                    quota = quotaMap.get(quotaExternal.getId());
                }
                // if quota not in cache look for it in DB and add it to cache
                if (quota == null) {
                    needToCache.add(quotaExternal);
                } else {
                    QuotaUsagePerUser usagePerUser = addQuotaEntry(quota);
                    if (usagePerUser != null) {
                        quotaPerUserUsageEntityMap.put(quota.getId(), usagePerUser);
                    }
                }
            }
        } finally {
            lock.readLock().unlock();
        }
        if (!needToCache.isEmpty()) {
            lock.writeLock().lock();
            try {
                for (Quota quotaExternal : needToCache) {
                    // look for the quota in the cache again (it may have been added by now)
                    if (!storagePoolQuotaMap.containsKey(quotaExternal.getStoragePoolId())) {
                        storagePoolQuotaMap.put(quotaExternal.getStoragePoolId(), new HashMap<Guid, Quota>());
                    }
                    Quota quota = fetchQuotaFromCache(quotaExternal.getId(), quotaExternal.getStoragePoolId());
                    QuotaUsagePerUser usagePerUser = addQuotaEntry(quota);
                    if (usagePerUser != null) {
                        quotaPerUserUsageEntityMap.put(quota.getId(), usagePerUser);
                    }
                }
            } finally {
                lock.writeLock().unlock();
            }
        }
    }
    countPersonalUsage(vms, quotaPerUserUsageEntityMap);
    return new ArrayList<QuotaUsagePerUser>(quotaPerUserUsageEntityMap.values());
}
#method_after
public Map<Guid, QuotaUsagePerUser> generatePerUserUsageReport(List<Quota> quotaIdsList) {
    Map<Guid, QuotaUsagePerUser> quotaPerUserUsageEntityMap = new HashMap<Guid, QuotaUsagePerUser>();
    List<Quota> needToCache = new ArrayList<Quota>();
    if (quotaIdsList != null) {
        lock.readLock().lock();
        try {
            for (Quota quotaExternal : quotaIdsList) {
                // look for the quota in the cache
                Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(quotaExternal.getStoragePoolId());
                Quota quota = null;
                if (quotaMap != null) {
                    quota = quotaMap.get(quotaExternal.getId());
                }
                // if quota not in cache look for it in DB and add it to cache
                if (quota == null) {
                    needToCache.add(quotaExternal);
                } else {
                    QuotaUsagePerUser usagePerUser = addQuotaEntry(quota);
                    if (usagePerUser != null) {
                        quotaPerUserUsageEntityMap.put(quota.getId(), usagePerUser);
                    }
                }
            }
        } finally {
            lock.readLock().unlock();
        }
        if (!needToCache.isEmpty()) {
            lock.writeLock().lock();
            try {
                for (Quota quotaExternal : needToCache) {
                    // look for the quota in the cache again (it may have been added by now)
                    if (!storagePoolQuotaMap.containsKey(quotaExternal.getStoragePoolId())) {
                        storagePoolQuotaMap.put(quotaExternal.getStoragePoolId(), new HashMap<Guid, Quota>());
                    }
                    Quota quota = fetchQuotaFromCache(quotaExternal.getId(), quotaExternal.getStoragePoolId());
                    QuotaUsagePerUser usagePerUser = addQuotaEntry(quota);
                    if (usagePerUser != null) {
                        quotaPerUserUsageEntityMap.put(quota.getId(), usagePerUser);
                    }
                }
            } finally {
                lock.writeLock().unlock();
            }
        }
    }
    return quotaPerUserUsageEntityMap;
}
#end_block

#method_before
private void setupMock() {
    vdsStaticDaoMock = mock(VdsStaticDAO.class);
    doReturn(vdsStaticDaoMock).when(getQuery()).getVdsStaticDao();
    doReturn(getVdsStatic()).when(vdsStaticDaoMock).get(NEW_SERVER);
    clientMock = mock(SSHClient.class);
    doReturn(clientMock).when(getQuery()).createSSHClient();
}
#method_after
private void setupMock() {
    vdsStaticDaoMock = mock(VdsStaticDAO.class);
    doReturn(vdsStaticDaoMock).when(getQuery()).getVdsStaticDao();
    doReturn(getVdsStatic()).when(vdsStaticDaoMock).getAllForHost(NEW_SERVER);
    doReturn(getVdsStatic()).when(vdsStaticDaoMock).getAllWithIpAddress(NEW_SERVER);
    clientMock = mock(SSHClient.class);
    doReturn(clientMock).when(getQuery()).createSSHClient();
}
#end_block

#method_before
private VdsStatic getVdsStatic() {
    VdsStatic vds = new VdsStatic();
    vds.setId(new Guid());
    vds.sethost_name(NEW_SERVER);
    return vds;
}
#method_after
private List<VdsStatic> getVdsStatic() {
    VdsStatic vds = new VdsStatic();
    vds.setId(new Guid());
    vds.sethost_name(NEW_SERVER);
    return Collections.singletonList(vds);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Check whether the given server is already part of the cluster
    if (getVdsStaticDao().get(getParameters().getServerName()) != null) {
        getQueryReturnValue().setSucceeded(false);
        getQueryReturnValue().setExceptionString(VdcBllMessages.SERVER_ALREADY_EXIST_IN_ANOTHER_CLUSTER.name());
        return;
    }
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        Map<String, String> serverFingerPrint = extractServers(serversXml);
        if (serverFingerPrint == null) {
            getQueryReturnValue().setSucceeded(false);
            getQueryReturnValue().setExceptionString(VdcBllMessages.SERVER_ALREADY_EXIST_IN_ANOTHER_CLUSTER.name());
            return;
        }
        getQueryReturnValue().setReturnValue(serverFingerPrint);
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    // Check whether the given server is already part of the cluster
    if (getVdsStaticDao().getAllForHost(getParameters().getServerName()).size() > 0 || getVdsStaticDao().getAllWithIpAddress(getParameters().getServerName()).size() > 0) {
        setReturnMessage();
    }
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        Map<String, String> serverFingerPrint = extractServers(serversXml);
        // Check if any of the server in the map is already part of some other cluster.
        if (!validateServers(serverFingerPrint.keySet())) {
            setReturnMessage();
        }
        getQueryReturnValue().setReturnValue(serverFingerPrint);
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
private Map<String, String> getServerFingerprints(NodeList listOfPeers) {
    Map<String, String> fingerprints = new HashMap<String, String>();
    // Add current server finger print also in the map
    fingerprints.put(getParameters().getServerName(), getParameters().getFingerprint());
    for (int i = 0; i < listOfPeers.getLength(); i++) {
        Node firstPeer = listOfPeers.item(i);
        if (firstPeer.getNodeType() == Node.ELEMENT_NODE) {
            Element firstHostElement = (Element) firstPeer;
            int state = XmlUtils.getIntValue(firstHostElement, STATE);
            // Add the server only if the state is 3
            if (state == PEER_IN_CLUSTER) {
                String hostName = XmlUtils.getTextValue(firstHostElement, HOST_NAME);
                // Check if any of the server in the peer list is already part of some other cluster.
                if (getVdsStaticDao().get(hostName) != null) {
                    return null;
                }
                fingerprints.put(hostName, getFingerprint(hostName));
            }
        }
    }
    return fingerprints;
}
#method_after
private Map<String, String> getServerFingerprints(NodeList listOfPeers) {
    Map<String, String> fingerprints = new HashMap<String, String>();
    // Add current server finger print also in the map
    fingerprints.put(getParameters().getServerName(), getParameters().getFingerprint());
    for (int i = 0; i < listOfPeers.getLength(); i++) {
        Node firstPeer = listOfPeers.item(i);
        if (firstPeer.getNodeType() == Node.ELEMENT_NODE) {
            Element firstHostElement = (Element) firstPeer;
            int state = XmlUtils.getIntValue(firstHostElement, STATE);
            // Add the server only if the state is 3
            if (state == PEER_IN_CLUSTER) {
                String hostName = XmlUtils.getTextValue(firstHostElement, HOST_NAME);
                fingerprints.put(hostName, getFingerprint(hostName));
            }
        }
    }
    return fingerprints;
}
#end_block

#method_before
public static void GetDiskPresetList(AsyncQuery aQuery, StorageType storageType) {
    aQuery.setData(new Object[] { storageType });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return null;
            }
            ArrayList<DiskImageBase> list = new ArrayList<DiskImageBase>();
            StorageType storageType = (StorageType) _asyncQuery.Data[0];
            boolean hasBootDisk = false;
            for (DiskImageBase disk : (ArrayList<DiskImageBase>) source) {
                if (!hasBootDisk) {
                    disk.setBoot(true);
                    hasBootDisk = true;
                }
                disk.setvolume_type(storageType == StorageType.ISCSI || storageType == StorageType.FCP ? VolumeType.Preallocated : VolumeType.Sparse);
                disk.setvolume_format(AsyncDataProvider.GetDiskVolumeFormat(disk.getvolume_type(), storageType));
                list.add(disk);
            }
            return list;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetDiskConfigurationList, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void GetDiskPresetList(AsyncQuery aQuery, StorageType storageType) {
    aQuery.setData(new Object[] { storageType });
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return null;
            }
            ArrayList<DiskImageBase> list = new ArrayList<DiskImageBase>();
            StorageType storageType = (StorageType) _asyncQuery.Data[0];
            boolean hasBootDisk = false;
            for (DiskImageBase disk : (ArrayList<DiskImageBase>) source) {
                if (!hasBootDisk) {
                    disk.setBoot(true);
                    hasBootDisk = true;
                }
                disk.setvolume_type(storageType == StorageType.ISCSI || storageType == StorageType.FCP ? VolumeType.Preallocated : VolumeType.Sparse);
                disk.setvolume_format(GetDiskVolumeFormat(disk.getvolume_type(), storageType));
                list.add(disk);
            }
            return list;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetDiskConfigurationList, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void GetGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeOptionInfo> list = new ArrayList<GlusterVolumeOptionInfo>((Set<GlusterVolumeOptionInfo>) source);
                // user.cifs option will be present in the list by default, so adding it now
                GlusterVolumeOptionInfo cifsOption = new GlusterVolumeOptionInfo();
                // $NON-NLS-1$
                cifsOption.setKey("user.cifs");
                list.add(cifsOption);
                return list;
            }
            return new ArrayList<GlusterVolumeOptionInfo>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#method_after
public static void GetGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#method_after
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#end_block

#method_before
public static void GetGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, String volume, String brick) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volume, brick, true);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public static void GetGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, String volume, String brick) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volume, brick, true);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void GetStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (storage_server_connections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.RunQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#method_after
public static void GetStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.RunQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#end_block

#method_before
public static void GetRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                tags tag = (tags) source;
                tags root = new tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    DataProvider.fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new tags();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void GetRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                tags tag = (tags) source;
                tags root = new tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new tags();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    getAllFromExportDomainQueryParamenters.setGetAll(true);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static void GetMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return ((Integer) source).intValue();
        }
    };
    GetConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, Config.DefaultConfigurationVersion), aQuery);
}
#method_after
public static int GetMaxVmPriority() {
    return (Integer) GetConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, Config.DefaultConfigurationVersion);
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    // USB policy will be updated outside of this method because there's
    // a different mapping for it on create and update VM operations
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setis_stateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                entity.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        entity.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setis_stateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                entity.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        entity.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    // USB policy will be updated outside of this method because there's
    // a different mapping for it on create and update VM operations
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getRunOnVds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getRunOnVds().toString());
    }
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getVmIp().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getRunOnVds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getRunOnVds().toString());
    }
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getVmIp().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        case WINDOWS_2012X64:
            return VmOsType.Windows2012x64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    Payload model = template != null ? template : new Payload();
    if (entity.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
        if (deviceType != null) {
            model.setType(deviceType.value());
        }
    }
    PayloadFile file = new PayloadFile();
    file.setName(entity.getFileName());
    file.setContent(entity.getContent());
    model.setFile(file);
    return model;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFileName() != null) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        if (entity.getFileName() != null) {
            PayloadFile file = new PayloadFile();
            file.setName(entity.getFileName());
            file.setContent(entity.getContent());
            model.setFile(file);
        }
        return model;
    }
    return null;
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(template));
    if (namedCluster(template)) {
        staticVm.setvds_group_id(getClusterId(template));
    }
    staticVm.setusb_policy(UsbResourceUtils.getUsbPolicyOnCreate(template.getUsb(), lookupCluster(staticVm.getvds_group_id())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    return performCreation(VdcActionType.AddVmTemplate, params, new QueryIdResolver(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(template));
    if (namedCluster(template)) {
        staticVm.setvds_group_id(getClusterId(template));
    }
    staticVm.setusb_policy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), lookupCluster(staticVm.getvds_group_id())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    return performCreation(VdcActionType.AddVmTemplate, params, new QueryIdResolver(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        staticVm.setusb_policy(UsbResourceUtils.getUsbPolicyOnCreate(vm.getUsb(), lookupCluster(staticVm.getvds_group_id())));
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        staticVm.setusb_policy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), lookupCluster(staticVm.getvds_group_id())));
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
protected Guid getTemplateId(VM vm) {
    return vm.getTemplate().isSetId() ? asGuid(vm.getTemplate().getId()) : getEntity(VmTemplate.class, SearchType.VmTemplate, "Template: name=" + vm.getTemplate().getName()).getId();
}
#method_after
protected Guid getTemplateId(VM vm) {
    return vm.getTemplate().isSetId() ? asGuid(vm.getTemplate().getId()) : getTemplateByName(vm).getId();
}
#end_block

#method_before
protected Guid getClusterId(VM vm) {
    return getEntity(VDSGroup.class, SearchType.Cluster, "Cluster: name=" + vm.getCluster().getName()).getId();
}
#method_after
protected Guid getClusterId(VM vm) {
    return isFiltered() ? lookupClusterByName(vm.getCluster().getName()).getId() : getEntity(VDSGroup.class, SearchType.Cluster, "Cluster: name=" + vm.getCluster().getName()).getId();
}
#end_block

#method_before
protected Guid getStorageDomainId(Action action) {
    if (action.getStorageDomain().isSetId()) {
        return asGuid(action.getStorageDomain().getId());
    } else {
        return lookupStorageDomainIdByName(action.getStorageDomain().getName());
    }
}
#method_after
@Override
protected Guid getStorageDomainId(Action action) {
    if (action.getStorageDomain().isSetId()) {
        return asGuid(action.getStorageDomain().getId());
    } else {
        return lookupStorageDomainIdByName(action.getStorageDomain().getName());
    }
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(storage_domains.class, SearchType.StorageDomain, "Storage: name=" + name).getId();
}
#method_after
@Override
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(storage_domains.class, SearchType.StorageDomain, "Storage: name=" + name).getId();
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setusb_policy(UsbResourceUtils.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy()));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        params.setVmPayload(parent.getPayload(incoming));
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setusb_policy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getvds_group_id())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setusb_policy(UsbResourceUtils.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getusb_policy()));
    return new UpdateVmTemplateParameters(updated);
}
#method_after
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setusb_policy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getusb_policy(), lookupCluster(updated.getvds_group_id())));
    return new UpdateVmTemplateParameters(updated);
}
#end_block

#method_before
public static boolean hasCpuToRunVM(VDS vds, VM vm) {
    if (vds.getusage_cpu_percent() == null || vm.getUsageCpuPercent() == null) {
        return false;
    }
    // The predicted CPU is actually the CPU that the VM will take considering how many cores it has and now many
    // cores the host has. This is why we take both parameters into consideration.
    int predictedVmCpu = (vm.getUsageCpuPercent() * vm.getNumOfCpus()) / vds.getcpu_cores();
    boolean result = vds.getusage_cpu_percent() + predictedVmCpu <= vds.gethigh_utilization();
    if (log.isDebugEnabled()) {
        log.debugFormat("Host {0} has {1}% CPU load; VM {2} is predicted to have {3}% CPU load; " + "High threshold is {4}%. Host is {5}suitable in terms of CPU.", vds.getvds_name(), vds.getusage_cpu_percent(), vm.getVmName(), predictedVmCpu, vds.gethigh_utilization(), (result ? "" : "not "));
    }
    return result;
}
#method_after
public static boolean hasCpuToRunVM(VDS vds, VM vm) {
    if (vds.getusage_cpu_percent() == null || vm.getUsageCpuPercent() == null) {
        return false;
    }
    // The predicted CPU is actually the CPU that the VM will take considering how many cores it has and now many
    // cores the host has. This is why we take both parameters into consideration.
    int predictedVmCpu = (vm.getUsageCpuPercent() * vm.getNumOfCpus()) / VdsSelector.getEffectiveCpuCores(vds);
    boolean result = vds.getusage_cpu_percent() + predictedVmCpu <= vds.gethigh_utilization();
    if (log.isDebugEnabled()) {
        log.debugFormat("Host {0} has {1}% CPU load; VM {2} is predicted to have {3}% CPU load; " + "High threshold is {4}%. Host is {5}suitable in terms of CPU.", vds.getvds_name(), vds.getusage_cpu_percent(), vm.getVmName(), predictedVmCpu, vds.gethigh_utilization(), (result ? "" : "not "));
    }
    return result;
}
#end_block

#method_before
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values());
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<storage_server_connections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
        if (!lun.getLunConnections().isEmpty() && !StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).ConnectStorageToLunByVdsId(null, hostId, lun, getVm().getStoragePoolId())) {
            log.infoFormat("Failed to connect  a lun disk to vdsm {0} skiping it", hostId);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean connectLunDisks(Guid hostId) {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<LunDisk> lunDisks = ImagesHandler.filterDiskBasedOnLuns(getVm().getDiskMap().values());
    for (LunDisk lunDisk : lunDisks) {
        LUNs lun = lunDisk.getLun();
        lun.setLunConnections(new ArrayList<StorageServerConnections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
        if (!lun.getLunConnections().isEmpty() && !StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).ConnectStorageToLunByVdsId(null, hostId, lun, getVm().getStoragePoolId())) {
            log.infoFormat("Failed to connect  a lun disk to vdsm {0} skiping it", hostId);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
void initTable() {
    TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>> nameColumn = new TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public String getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getFirst().getname();
        }
    };
    getTable().addColumn(nameColumn, constants.nameCluster());
    TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>> versionColumn = new TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public String getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getFirst().getcompatibility_version().getValue();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "130px");
    CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>> attachedColumn = new CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public Boolean getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getSecond() != null;
        }

        @Override
        protected boolean canEdit(PairQueryable<VDSGroup, NetworkCluster> object) {
            return false;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(attachedColumn, constants.attachedNetworkCluster(), "120px");
    // $NON-NLS-1$
    getTable().addColumn(new NetworkClusterStatusColumn(), constants.networkStatus(), "120px");
    CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>> netRequiredColumn = new CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public Boolean getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            if (object.getSecond() != null) {
                return object.getSecond().isRequired();
            }
            return false;
        }

        @Override
        protected boolean canEdit(PairQueryable<VDSGroup, NetworkCluster> object) {
            return false;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netRequiredColumn, constants.requiredNetCluster(), "120px");
    SafeHtmlWithSafeHtmlTooltipColumn<PairQueryable<VDSGroup, NetworkCluster>> netRoleColumn = new SafeHtmlWithSafeHtmlTooltipColumn<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public SafeHtml getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            if (object.getSecond() != null) {
                if (object.getSecond().getis_display()) {
                    return templates.image(dispalyImage);
                }
                return null;
            }
            // $NON-NLS-1$
            return templates.image(SafeHtmlUtils.fromTrustedString(""));
        }

        @Override
        public SafeHtml getTooltip(PairQueryable<VDSGroup, NetworkCluster> object) {
            if (object.getSecond() != null && object.getSecond().getis_display()) {
                return (templates.imageTextSetupNetwork(dispalyImage, constants.displayItemInfo()));
            }
            // $NON-NLS-1$
            return SafeHtmlUtils.fromTrustedString("");
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netRoleColumn, constants.roleNetCluster(), "120px");
    TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>> dsecriptionColumn = new TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public String getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getFirst().getdescription();
        }
    };
    getTable().addColumn(dsecriptionColumn, constants.descriptionCluster());
    getTable().addActionButton(new WebAdminButtonDefinition<PairQueryable<VDSGroup, NetworkCluster>>(constants.assignUnassignNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getManageCommand();
        }
    });
}
#method_after
void initTable() {
    TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>> nameColumn = new TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public String getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getFirst().getname();
        }
    };
    getTable().addColumn(nameColumn, constants.nameCluster());
    TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>> versionColumn = new TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public String getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getFirst().getcompatibility_version().getValue();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "130px");
    CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>> attachedColumn = new CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>>(true) {

        @Override
        public Boolean getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getSecond() != null;
        }

        @Override
        protected boolean canEdit(PairQueryable<VDSGroup, NetworkCluster> object) {
            return false;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(attachedColumn, constants.attachedNetworkCluster(), "120px");
    // $NON-NLS-1$
    getTable().addColumn(new NetworkClusterStatusColumn(), constants.networkStatus(), "120px");
    CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>> netRequiredColumn = new CheckboxColumn<PairQueryable<VDSGroup, NetworkCluster>>(true) {

        @Override
        public Boolean getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            if (object.getSecond() != null) {
                return object.getSecond().isRequired();
            }
            return false;
        }

        @Override
        protected boolean canEdit(PairQueryable<VDSGroup, NetworkCluster> object) {
            return false;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netRequiredColumn, constants.requiredNetCluster(), "120px");
    SafeHtmlWithSafeHtmlTooltipColumn<PairQueryable<VDSGroup, NetworkCluster>> netRoleColumn = new SafeHtmlWithSafeHtmlTooltipColumn<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public SafeHtml getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            if (object.getSecond() != null) {
                if (object.getSecond().getis_display()) {
                    return templates.image(dispalyImage);
                }
                return null;
            }
            // $NON-NLS-1$
            return templates.image(SafeHtmlUtils.fromTrustedString(""));
        }

        @Override
        public SafeHtml getTooltip(PairQueryable<VDSGroup, NetworkCluster> object) {
            if (object.getSecond() != null && object.getSecond().getis_display()) {
                return (templates.imageTextSetupNetwork(dispalyImage, constants.displayItemInfo()));
            }
            // $NON-NLS-1$
            return SafeHtmlUtils.fromTrustedString("");
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netRoleColumn, constants.roleNetCluster(), "120px");
    TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>> dsecriptionColumn = new TextColumnWithTooltip<PairQueryable<VDSGroup, NetworkCluster>>() {

        @Override
        public String getValue(PairQueryable<VDSGroup, NetworkCluster> object) {
            return object.getFirst().getdescription();
        }
    };
    getTable().addColumn(dsecriptionColumn, constants.descriptionCluster());
    getTable().addActionButton(new WebAdminButtonDefinition<PairQueryable<VDSGroup, NetworkCluster>>(constants.assignUnassignNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getManageCommand();
        }
    });
}
#end_block

#method_before
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    if (succeeded) {
        cancel();
    } else {
        StopProgress();
        return;
    }
    StopProgress();
    Guid networkId = network.getId() == null ? networkGuid : network.getId();
    ArrayList<VDSGroup> attachNetworkToClusters = Linq.Except(getnewClusters(), getOriginalClusters());
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup attachNetworkToCluster : attachNetworkToClusters) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setname(network.getname());
        // Init default network_cluster values (required, display, status)
        tempVar.setCluster(new NetworkCluster());
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(attachNetworkToCluster, tempVar));
    }
    Frontend.RunMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
}
#method_after
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    if (succeeded) {
        cancel();
    } else {
        StopProgress();
        return;
    }
    StopProgress();
    Guid networkId = network.getId() == null ? networkGuid : network.getId();
    ArrayList<VDSGroup> attachNetworkToClusters = Linq.Except(getnewClusters(), getOriginalClusters());
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup attachNetworkToCluster : attachNetworkToClusters) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setname(network.getname());
        // Init default NetworkCluster values (required, display, status)
        tempVar.setCluster(new NetworkCluster());
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(attachNetworkToCluster, tempVar));
    }
    Frontend.RunMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
}
#end_block

#method_before
@Override
protected void init() {
    setApplyCommand(new UICommand(APPLY_COMMAND_NAME, getSourceListModel()));
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getname());
    getDescription().setEntity(getNetwork().getdescription());
    getIsStpEnabled().setEntity(getNetwork().getstp());
    getHasVLanTag().setEntity(getNetwork().getvlan_id() != null);
    getVLanTag().setEntity((getNetwork().getvlan_id() == null ? 0 : getNetwork().getvlan_id()));
    initMtu();
    initIsVm();
}
#method_after
private void init() {
    setApplyCommand(new UICommand(APPLY_COMMAND_NAME, getSourceListModel()));
    setTitle(ConstantsManager.getInstance().getConstants().editLogicalNetworkTitle());
    // $NON-NLS-1$
    setHashName("edit_logical_network");
    getName().setEntity(getNetwork().getname());
    getDescription().setEntity(getNetwork().getdescription());
    getIsStpEnabled().setEntity(getNetwork().getstp());
    getHasVLanTag().setEntity(getNetwork().getvlan_id() != null);
    getVLanTag().setEntity((getNetwork().getvlan_id() == null ? 0 : getNetwork().getvlan_id()));
    initMtu();
    initIsVm();
}
#end_block

#method_before
public void onApply() {
    final ConfirmationModel confirmationModel = (ConfirmationModel) getSourceListModel().getConfirmWindow();
    if (!confirmationModel.Validate()) {
        return;
    }
    // Init default network_cluster values (required, display, status)
    getNetwork().setCluster(new NetworkCluster());
    final ArrayList<VDSGroup> detachNetworkFromClusters = Linq.Except(getOriginalClusters(), getnewClusters());
    final ArrayList<VdcActionParametersBase> toDetach = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup detachNetworkFromCluster : detachNetworkFromClusters) {
        toDetach.add(new AttachNetworkToVdsGroupParameter(detachNetworkFromCluster, getNetwork()));
    }
    final ArrayList<VDSGroup> attachNetworkToClusters = Linq.Except(getnewClusters(), getOriginalClusters());
    final ArrayList<VdcActionParametersBase> toAttach = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup attachNetworkToCluster : attachNetworkToClusters) {
        toAttach.add(new AttachNetworkToVdsGroupParameter(attachNetworkToCluster, getNetwork()));
    }
    if (!toAttach.isEmpty() || !toDetach.isEmpty()) {
        confirmationModel.StartProgress(null);
    } else {
        cancelConfirmation();
    }
    ;
    getOriginalClusters().clear();
    getOriginalClusters().addAll(attachNetworkToClusters);
    firstFinished = toAttach.isEmpty() || toDetach.isEmpty();
    if (!toAttach.isEmpty()) {
        Frontend.RunMultipleAction(VdcActionType.AttachNetworkToVdsGroup, toAttach, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                executedAttachDetach(attachNetworkToClusters, result);
            }
        }, null);
    }
    if (!toDetach.isEmpty()) {
        Frontend.RunMultipleAction(VdcActionType.DetachNetworkToVdsGroup, toDetach, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                executedAttachDetach(detachNetworkFromClusters, result);
            }
        }, null);
    }
}
#method_after
public void onApply() {
    final ConfirmationModel confirmationModel = (ConfirmationModel) getSourceListModel().getConfirmWindow();
    if (!confirmationModel.Validate()) {
        return;
    }
    // Init default NetworkCluster values (required, display, status)
    getNetwork().setCluster(new NetworkCluster());
    final ArrayList<VDSGroup> detachNetworkFromClusters = Linq.Except(getOriginalClusters(), getnewClusters());
    final ArrayList<VdcActionParametersBase> toDetach = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup detachNetworkFromCluster : detachNetworkFromClusters) {
        toDetach.add(new AttachNetworkToVdsGroupParameter(detachNetworkFromCluster, getNetwork()));
    }
    final ArrayList<VDSGroup> attachNetworkToClusters = Linq.Except(getnewClusters(), getOriginalClusters());
    final ArrayList<VdcActionParametersBase> toAttach = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup attachNetworkToCluster : attachNetworkToClusters) {
        toAttach.add(new AttachNetworkToVdsGroupParameter(attachNetworkToCluster, getNetwork()));
    }
    if (!toAttach.isEmpty() || !toDetach.isEmpty()) {
        confirmationModel.StartProgress(null);
    } else {
        cancelConfirmation();
    }
    ;
    getOriginalClusters().clear();
    getOriginalClusters().addAll(attachNetworkToClusters);
    firstFinished = toAttach.isEmpty() || toDetach.isEmpty();
    if (!toAttach.isEmpty()) {
        Frontend.RunMultipleAction(VdcActionType.AttachNetworkToVdsGroup, toAttach, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                executedAttachDetach(attachNetworkToClusters, result);
            }
        }, null);
    }
    if (!toDetach.isEmpty()) {
        Frontend.RunMultipleAction(VdcActionType.DetachNetworkToVdsGroup, toDetach, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                executedAttachDetach(detachNetworkFromClusters, result);
            }
        }, null);
    }
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getVmName());
    createInfo.add(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.add(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getNumOfCpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.add(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getNiceLevel())).toString());
    if (vm.getStatus() == VMStatus.Suspended && !StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getVmOs().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#method_after
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getVmName());
    createInfo.add(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.add(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getNumOfCpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.add(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.add(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getNiceLevel())).toString());
    if (vm.getStatus() == VMStatus.Suspended && !StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getVmOs().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("network_cluster {id=").append(getId()).append(", status=").append(getstatus()).append(", is_display=").append(getis_display()).append(", required=").append(isRequired()).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("NetworkCluster {id=").append(getId()).append(", status=").append(getstatus()).append(", is_display=").append(getis_display()).append(", required=").append(isRequired()).append("}");
    return builder.toString();
}
#end_block

#method_before
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return CloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return CloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return CloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof storage_pool) {
        return CloneStorage_pool((storage_pool) instance);
    }
    if (instance instanceof Network) {
        return CloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return CloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof vm_pools) {
        return CloneVmPool((vm_pools) instance);
    }
    if (instance instanceof storage_domain_static) {
        return CloneStorageDomainStatic((storage_domain_static) instance);
    }
    if (instance instanceof VmTemplate) {
        return CloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return CloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return CloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return CloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return CloneVersion((Version) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#method_after
public static Object clone(Object instance) {
    if (instance instanceof VM) {
        return CloneVM((VM) instance);
    }
    if (instance instanceof VDS) {
        return CloneVDS((VDS) instance);
    }
    if (instance instanceof VDSGroup) {
        return CloneVDSGroup((VDSGroup) instance);
    }
    if (instance instanceof storage_pool) {
        return CloneStorage_pool((storage_pool) instance);
    }
    if (instance instanceof Network) {
        return CloneNetwork((Network) instance);
    }
    if (instance instanceof NetworkCluster) {
        return CloneNetworkCluster((NetworkCluster) instance);
    }
    if (instance instanceof vm_pools) {
        return CloneVmPool((vm_pools) instance);
    }
    if (instance instanceof StorageDomainStatic) {
        return CloneStorageDomainStatic((StorageDomainStatic) instance);
    }
    if (instance instanceof VmTemplate) {
        return CloneVmTemplate((VmTemplate) instance);
    }
    if (instance instanceof VmNetworkInterface) {
        return CloneVmNetworkInterface((VmNetworkInterface) instance);
    }
    if (instance instanceof VdsNetworkInterface) {
        return CloneVdsNetworkInterface((VdsNetworkInterface) instance);
    }
    if (instance instanceof VmStatic) {
        return CloneVmStatic((VmStatic) instance);
    }
    if (instance instanceof Version) {
        return CloneVersion((Version) instance);
    }
    // Throw exception to determine development needs.
    throw new NotImplementedException();
}
#end_block

#method_before
private static Object CloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setGuestCurUserId(instance.getGuestCurUserId());
    vm.setGuestCurUserName(instance.getGuestCurUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setAutoSuspend(instance.isAutoSuspend());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid/NGuid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getmigrating_to_vds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setVmName(instance.getVmName());
    vm.setVmOs(instance.getVmOs());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    return vm;
}
#method_after
private static Object CloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setAutoSuspend(instance.isAutoSuspend());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid/NGuid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getmigrating_to_vds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setVmDomain(instance.getVmDomain());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setVmName(instance.getVmName());
    vm.setVmOs(instance.getVmOs());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    return vm;
}
#end_block

#method_before
private static VDSGroup CloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setname(instance.getname());
    obj.setdescription(instance.getdescription());
    obj.setcpu_name(instance.getcpu_name());
    obj.setselection_algorithm(instance.getselection_algorithm());
    obj.sethigh_utilization(instance.gethigh_utilization());
    obj.setlow_utilization(instance.getlow_utilization());
    obj.setcpu_over_commit_duration_minutes(instance.getcpu_over_commit_duration_minutes());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    return obj;
}
#method_after
private static VDSGroup CloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setname(instance.getname());
    obj.setdescription(instance.getdescription());
    obj.setcpu_name(instance.getcpu_name());
    obj.setselection_algorithm(instance.getselection_algorithm());
    obj.sethigh_utilization(instance.gethigh_utilization());
    obj.setlow_utilization(instance.getlow_utilization());
    obj.setcpu_over_commit_duration_minutes(instance.getcpu_over_commit_duration_minutes());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    return obj;
}
#end_block

#method_before
private static storage_domain_static CloneStorageDomainStatic(storage_domain_static instance) {
    storage_domain_static obj = new storage_domain_static();
    obj.setConnection(instance.getConnection());
    obj.setId(instance.getId());
    obj.setstorage(instance.getstorage());
    obj.setstorage_domain_type(instance.getstorage_domain_type());
    obj.setstorage_type(instance.getstorage_type());
    obj.setstorage_name(instance.getstorage_name());
    obj.setStorageFormat(instance.getStorageFormat());
    return obj;
}
#method_after
private static StorageDomainStatic CloneStorageDomainStatic(StorageDomainStatic instance) {
    StorageDomainStatic obj = new StorageDomainStatic();
    obj.setConnection(instance.getConnection());
    obj.setId(instance.getId());
    obj.setstorage(instance.getstorage());
    obj.setstorage_domain_type(instance.getstorage_domain_type());
    obj.setstorage_type(instance.getstorage_type());
    obj.setstorage_name(instance.getstorage_name());
    obj.setStorageFormat(instance.getStorageFormat());
    return obj;
}
#end_block

#method_before
private static Object CloneVmNetworkInterface(VmNetworkInterface vmNetworkInterface) {
    VmNetworkInterface obj = new VmNetworkInterface();
    obj.setId(vmNetworkInterface.getId());
    obj.setMacAddress(vmNetworkInterface.getMacAddress());
    obj.setName(vmNetworkInterface.getName());
    obj.setNetworkName(vmNetworkInterface.getNetworkName());
    obj.setSpeed(vmNetworkInterface.getSpeed());
    obj.setType(vmNetworkInterface.getType());
    obj.setVmId(vmNetworkInterface.getVmId());
    obj.setVmName(vmNetworkInterface.getVmName());
    obj.setVmTemplateId(vmNetworkInterface.getVmTemplateId());
    obj.setStatistics(CloneVmNetworkStatistics(vmNetworkInterface.getStatistics()));
    return obj;
}
#method_after
private static Object CloneVmNetworkInterface(VmNetworkInterface vmNetworkInterface) {
    VmNetworkInterface obj = new VmNetworkInterface();
    obj.setId(vmNetworkInterface.getId());
    obj.setMacAddress(vmNetworkInterface.getMacAddress());
    obj.setName(vmNetworkInterface.getName());
    obj.setNetworkName(vmNetworkInterface.getNetworkName());
    obj.setLinked(vmNetworkInterface.isLinked());
    obj.setSpeed(vmNetworkInterface.getSpeed());
    obj.setType(vmNetworkInterface.getType());
    obj.setVmId(vmNetworkInterface.getVmId());
    obj.setVmName(vmNetworkInterface.getVmName());
    obj.setVmTemplateId(vmNetworkInterface.getVmTemplateId());
    obj.setStatistics(CloneVmNetworkStatistics(vmNetworkInterface.getStatistics()));
    return obj;
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<Guid> ids = new ArrayList<Guid>();
    ids.add(getUser().getUserId());
    ids.addAll(GuidUtils.getGuidListFromString(getUser().getGroupIds()));
    List<Quota> quotaList = new ArrayList<Quota>();
    for (Guid id : ids) {
        quotaList.addAll(getDbFacade().getQuotaDao().getQuotaByAdElementId(id, null));
    }
    getQueryReturnValue().setReturnValue(QuotaManager.getInstance().generatePerUserUsageReport(quotaList));
}
#method_after
@Override
protected void executeQueryCommand() {
    List<Quota> quotaList = getDbFacade().getQuotaDao().getQuotaByAdElementId(getUser().getUserId(), null, true);
    getQueryReturnValue().setReturnValue(QuotaManager.getInstance().generatePerUserUsageReport(quotaList));
}
#end_block

#method_before
private void Edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.setVmType(vm.getVmType());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().editVmTitle(vm.getVmType() == VmType.Server ? ConstantsManager.getInstance().getConstants().serverVmType() : ConstantsManager.getInstance().getConstants().desktopVmType()));
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    model.setHashName("edit_" + (vm.getVmType() == VmType.Server ? "server" : "desktop"));
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.Initialize(this.getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void Edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.setVmType(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().editVmTitle(vm.getVmType() == VmType.Server ? ConstantsManager.getInstance().getConstants().serverVmType() : ConstantsManager.getInstance().getConstants().desktopVmType()));
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    model.setHashName("edit_" + (vm.getVmType() == VmType.Server ? "server" : "desktop"));
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.Initialize(this.getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isEditCommandExecutionAllowed(List items) {
    if (items == null) {
        return false;
    }
    if (items.size() != 1) {
        return false;
    }
    VM selectedItem = (VM) items.get(0);
    return selectedItem.getVmPoolId() == null;
}
#method_after
private boolean isEditCommandExecutionAllowed(List items) {
    if (items == null) {
        return false;
    }
    if (items.size() != 1) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void Spice_Disconnected(Object sender, ErrorCodeEventArgs e) {
    getspice().getDisconnectedEvent().removeListener(this);
    getspice().getMenuItemSelectedEvent().removeListener(this);
    setIsConnected(false);
    UpdateActionAvailability();
    if (e.getErrorCode() > 100) {
        getErrorEvent().raise(this, e);
    }
    // save console flag
    Frontend.RunAction(VdcActionType.UpdateVmConsoleData, new UpdateVmConsoleDataParameters(getEntity().getId(), null), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        // TODO Auto-generated method stub
        }
    });
}
#method_after
private void Spice_Disconnected(Object sender, ErrorCodeEventArgs e) {
    getspice().getDisconnectedEvent().removeListener(this);
    getspice().getMenuItemSelectedEvent().removeListener(this);
    setIsConnected(false);
    UpdateActionAvailability();
    if (e.getErrorCode() > 100) {
        getErrorEvent().raise(this, e);
    }
    // save console flag
    Frontend.RunAction(VdcActionType.UpdateVmConsoleData, new UpdateVmConsoleDataParameters(getEntity().getId(), null), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        // Ignore result, this tries to update vm console data
        // nothing to do with result
        }
    });
}
#end_block

#method_before
private static VDSGroup CloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setname(instance.getname());
    obj.setdescription(instance.getdescription());
    obj.setcpu_name(instance.getcpu_name());
    obj.setselection_algorithm(instance.getselection_algorithm());
    obj.sethigh_utilization(instance.gethigh_utilization());
    obj.setlow_utilization(instance.getlow_utilization());
    obj.setcpu_over_commit_duration_minutes(instance.getcpu_over_commit_duration_minutes());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    return obj;
}
#method_after
private static VDSGroup CloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setname(instance.getname());
    obj.setdescription(instance.getdescription());
    obj.setcpu_name(instance.getcpu_name());
    obj.setselection_algorithm(instance.getselection_algorithm());
    obj.sethigh_utilization(instance.gethigh_utilization());
    obj.setlow_utilization(instance.getlow_utilization());
    obj.setcpu_over_commit_duration_minutes(instance.getcpu_over_commit_duration_minutes());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    return obj;
}
#end_block

#method_before
private static Object CloneVmNetworkInterface(VmNetworkInterface vmNetworkInterface) {
    VmNetworkInterface obj = new VmNetworkInterface();
    obj.setId(vmNetworkInterface.getId());
    obj.setMacAddress(vmNetworkInterface.getMacAddress());
    obj.setName(vmNetworkInterface.getName());
    obj.setNetworkName(vmNetworkInterface.getNetworkName());
    obj.setSpeed(vmNetworkInterface.getSpeed());
    obj.setType(vmNetworkInterface.getType());
    obj.setVmId(vmNetworkInterface.getVmId());
    obj.setVmName(vmNetworkInterface.getVmName());
    obj.setVmTemplateId(vmNetworkInterface.getVmTemplateId());
    obj.setStatistics(CloneVmNetworkStatistics(vmNetworkInterface.getStatistics()));
    return obj;
}
#method_after
private static Object CloneVmNetworkInterface(VmNetworkInterface vmNetworkInterface) {
    VmNetworkInterface obj = new VmNetworkInterface();
    obj.setId(vmNetworkInterface.getId());
    obj.setMacAddress(vmNetworkInterface.getMacAddress());
    obj.setName(vmNetworkInterface.getName());
    obj.setNetworkName(vmNetworkInterface.getNetworkName());
    obj.setLinked(vmNetworkInterface.isLinked());
    obj.setSpeed(vmNetworkInterface.getSpeed());
    obj.setType(vmNetworkInterface.getType());
    obj.setVmId(vmNetworkInterface.getVmId());
    obj.setVmName(vmNetworkInterface.getVmName());
    obj.setVmTemplateId(vmNetworkInterface.getVmTemplateId());
    obj.setStatistics(CloneVmNetworkStatistics(vmNetworkInterface.getStatistics()));
    return obj;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    // if user sent drive check that its not in use
    returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
    if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfImageDiskCanBeAdded(vm);
    }
    if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfLunDiskCanBeAdded();
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    if (returnValue && vm != null) {
        // if user sent drive check that its not in use
        returnValue = isDiskCanBeAddedToVm(getParameters().getDiskInfo()) && isDiskPassPciAndIdeLimit(getParameters().getDiskInfo());
    }
    if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfImageDiskCanBeAdded(vm);
    }
    if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfLunDiskCanBeAdded();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (storage_server_connections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    return true;
}
#end_block

#method_before
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    returnValue = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (returnValue && vm != null && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomainId().getValue(), vm.getstorage_pool_id())) == null) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_OF_VM_NOT_MATCH);
    }
    returnValue = returnValue && checkImageConfiguration() && (vm == null || isDiskPassPciAndIdeLimit(getParameters().getDiskInfo()));
    returnValue = returnValue && (vm == null || performImagesChecks(vm));
    if (returnValue && !hasFreeSpace(getStorageDomain())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    if (returnValue && isExceedMaxBlockDiskSize()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED);
        getReturnValue().getCanDoActionMessages().add(String.format("$max_disk_size %1$s", Config.<Integer>GetValue(ConfigValues.MaxBlockDiskSize)));
        returnValue = false;
    }
    if (returnValue && getParameters().getDiskInfo().isShareable()) {
        if (!Config.<Boolean>GetValue(ConfigValues.ShareableDiskEnabled, getStoragePool().getcompatibility_version().getValue())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        } else if (!isVolumeFormatSupportedForShareable(((DiskImage) getParameters().getDiskInfo()).getvolume_format())) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    }
    return returnValue && (vm == null || validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId())));
}
#method_after
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    // vm agnostic checks
    returnValue = new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && checkImageConfiguration() && checkFreeSpace() && checkExceedingMaxBlockDiskSize() && canAddShareableDisk();
    if (returnValue && vm != null) {
        returnValue = isStoragePoolMatching(vm) && performImagesChecks(vm) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()));
    }
    return returnValue;
}
#end_block

#method_before
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, true, false, false, true, false, false, true, Collections.emptyList());
}
#method_after
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getStoragePoolId(), getStorageDomainId().getValue(), false, true, false, false, true, false, false, true, Collections.emptyList());
}
#end_block

#method_before
private Guid getDisksStorageDomainId() {
    Disk disk = getVm().getDiskMap().values().iterator().next();
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        return ((DiskImage) disk).getstorage_ids().get(0);
    } else {
        return Guid.Empty;
    }
}
#method_after
private Guid getDisksStorageDomainId() {
    for (Disk disk : getVm().getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            return ((DiskImage) disk).getstorage_ids().get(0);
        }
    }
    return Guid.Empty;
}
#end_block

#method_before
@Override
public NGuid getStorageDomainId() {
    Guid storageDomainId = getParameters().getStorageDomainId();
    if (Guid.Empty.equals(storageDomainId) && getVm() != null && getVm().getDiskMap() != null && !getVm().getDiskMap().isEmpty()) {
        return getDisksStorageDomainId();
    }
    return storageDomainId == null ? Guid.Empty : storageDomainId;
}
#method_after
@Override
public NGuid getStorageDomainId() {
    if (super.getStorageDomainId() == null) {
        Guid storageDomainId = getParameters().getStorageDomainId();
        if (Guid.Empty.equals(storageDomainId) && getParameters().getDiskInfo().getDiskStorageType() == DiskStorageType.IMAGE && getVm() != null) {
            updateDisksFromDb();
            storageDomainId = getDisksStorageDomainId();
            getParameters().setStorageDomainId(storageDomainId);
        } else if (storageDomainId == null) {
            storageDomainId = Guid.Empty;
            getParameters().setStorageDomainId(storageDomainId);
        }
        setStorageDomainId(storageDomainId);
        return storageDomainId;
    }
    return super.getStorageDomainId();
}
#end_block

#method_before
private void createDiskBasedOnLun() {
    final LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getstatus() == VMStatus.Down, false);
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    setSucceeded(true);
}
#method_after
private void createDiskBasedOnLun() {
    final LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getStatus() == VMStatus.Down, false);
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    setSucceeded(true);
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getstorage_type();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setParentCommand(VdcActionType.AddDisk);
    parameters.setEntityId(getParameters().getEntityId());
    parameters.setStoragePoolId(getStorageDomain().getstorage_pool_id().getValue());
    getParameters().getImagesParameters().add(parameters);
    parameters.setParentParameters(getParameters());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getstatus() == VMStatus.Down, false));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        StorageType storageType = getStorageDomain().getstorage_type();
        getParameters().getDiskInfo().setWipeAfterDelete(WipeAfterDeleteUtils.getDefaultWipeAfterDeleteFlag(storageType));
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setParentCommand(VdcActionType.AddDisk);
    parameters.setEntityId(getParameters().getEntityId());
    parameters.setStoragePoolId(getStorageDomain().getstorage_pool_id().getValue());
    getParameters().getImagesParameters().add(parameters);
    parameters.setParentParameters(getParameters());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getStatus() == VMStatus.Down, false));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDao().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateNic();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    this.setVmName(getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateNic();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
private void addInterfaceToDb(VmNetworkInterface vmNetworkInterface) {
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDao().save(vmNetworkInterface);
    getCompensationContext().snapshotNewEntity(vmNetworkInterface);
    dbFacade.getVmNetworkStatisticsDao().save(vmNetworkInterface.getStatistics());
    getCompensationContext().snapshotNewEntity(vmNetworkInterface.getStatistics());
}
#method_after
private void addInterfaceToDb(VmNetworkInterface vmNetworkInterface) {
    getVmNetworkInterfaceDao().save(vmNetworkInterface);
    getCompensationContext().snapshotNewEntity(vmNetworkInterface);
    getDbFacade().getVmNetworkStatisticsDao().save(vmNetworkInterface.getStatistics());
    getCompensationContext().snapshotNewEntity(vmNetworkInterface.getStatistics());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDao().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    boolean unlinkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!unlinkingSupported) {
        if (!getParameters().getInterface().isLinked()) {
            addCanDoActionMessage(VdcBllMessages.UNLINKING_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getParameters().getInterface().getNetworkName() == null) {
            addCanDoActionMessage(VdcBllMessages.NULL_NETWORK_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
    }
    if (getParameters().getInterface().getNetworkName() != null) {
        // check that the exists in current cluster
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vm.getvds_group_id());
        Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getParameters().getInterface().getNetworkName());
            }
        });
        if (interfaceNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!interfaceNetwork.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    String compatibilityVersion = getVm().getVdsGroupCompatibilityVersion().getValue();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), compatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.networkNameValid())) {
        return false;
    }
    if (getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = getNetworkDAO().getAllForCluster(vm.getvds_group_id());
        Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getNetworkName());
            }
        });
        if (interfaceNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!interfaceNetwork.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && StringUtils.isNotEmpty(getNetworkName()) && getVm() != null) {
        Network network = getNetworkDAO().getByNameAndCluster(getNetworkName(), getVm().getVdsGroupId());
        if (getParameters().getInterface().isPortMirroring()) {
            permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, ActionGroup.PORT_MIRRORING));
        } else {
            permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, getActionType().getActionGroup()));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    // check if display type was changed in given parameters
    if (vm.getdisplay_type() != vm.getdefault_display_type()) {
        if (vm.getdisplay_type() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // check if display type was changed in given parameters
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        if (vm.getDisplayType() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmDrives() {
    // \\int ideCount = 0, pciCount = 0;
    List<Disk> disks = getSortedDisks();
    for (Disk disk : disks) {
        XmlRpcStruct struct = new XmlRpcStruct();
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDao().get(new VmDeviceId(disk.getId(), vm.getId()));
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.add(VdsProperties.Iface, "ide");
                    // \\ideCount++;
                    break;
                case VirtIO:
                    struct.add(VdsProperties.Iface, VdsProperties.Virtio);
                    // \\pciCount++;
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first.
            if (disk.isBoot()) {
                struct.add(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.add(VdsProperties.PoolId, diskImage.getstorage_pool_id().toString());
                struct.add(VdsProperties.DomainId, diskImage.getstorage_ids().get(0).toString());
                struct.add(VdsProperties.ImageId, diskImage.getId().toString());
                struct.add(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.add(VdsProperties.Format, diskImage.getvolume_format().toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.add(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.add(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.add(VdsProperties.Shareable, String.valueOf(disk.isShareable()));
            struct.add(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.add(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmDrives() {
    List<Disk> disks = getSortedDisks();
    for (Disk disk : disks) {
        XmlRpcStruct struct = new XmlRpcStruct();
        // get vm device for this disk from DB
        VmDevice vmDevice = DbFacade.getInstance().getVmDeviceDao().get(new VmDeviceId(disk.getId(), vm.getId()));
        // skip unamanged devices (handled separtely)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            switch(disk.getDiskInterface()) {
                case IDE:
                    struct.add(VdsProperties.Iface, "ide");
                    break;
                case VirtIO:
                    struct.add(VdsProperties.Iface, VdsProperties.Virtio);
                    break;
                default:
                    // ISCI not supported
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first.
            if (disk.isBoot()) {
                struct.add(VdsProperties.Index, 0);
            }
            addAddress(vmDevice, struct);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                struct.add(VdsProperties.PoolId, diskImage.getstorage_pool_id().toString());
                struct.add(VdsProperties.DomainId, diskImage.getstorage_ids().get(0).toString());
                struct.add(VdsProperties.ImageId, diskImage.getId().toString());
                struct.add(VdsProperties.VolumeId, diskImage.getImageId().toString());
                struct.add(VdsProperties.Format, diskImage.getvolume_format().toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
            } else {
                LunDisk lunDisk = (LunDisk) disk;
                struct.add(VdsProperties.Guid, lunDisk.getLun().getLUN_id());
                struct.add(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                struct.add(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            }
            addBootOrder(vmDevice, struct);
            struct.add(VdsProperties.Shareable, String.valueOf(disk.isShareable()));
            struct.add(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.add(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Boolean useRtl8139_pv = Config.<Boolean>GetValue(ConfigValues.UseRtl8139_pv, vm.getvds_group_compatibility_version().toString());
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (!useRtl8139_pv) {
                    if (vm.getHasAgent()) {
                        addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                    } else {
                        addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                    }
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                    // Doual Mode: in this case we have to insert 2 interfaces with the same entries except nicModel
                    XmlRpcStruct rtl8139Struct = new XmlRpcStruct();
                    addNetworkInterfaceProperties(rtl8139Struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                    devices.add(rtl8139Struct);
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getvds_group_compatibility_version());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (vm.getHasAgent()) {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getVdsGroupCompatibilityVersion());
                    // Doual Mode: in this case we have to insert 2 interfaces with the same entries except nicModel
                    XmlRpcStruct rtl8139Struct = new XmlRpcStruct();
                    addNetworkInterfaceProperties(rtl8139Struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getVdsGroupCompatibilityVersion());
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getVdsGroupCompatibilityVersion());
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getVdsGroupCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmSoundDevices() {
    if (vm.getVmType() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                String deviceId = (String) struct.getItem(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.getKeys().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                String deviceId = (String) struct.getItem(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.getKeys().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
private static void addNetworkInterfaceProperties(XmlRpcStruct struct, VmNetworkInterface vmInterface, VmDevice vmDevice, String nicModel, Version clusterVersion) {
    struct.add(VdsProperties.Type, vmDevice.getType());
    struct.add(VdsProperties.Device, vmDevice.getDevice());
    if (vmInterface.getNetworkName() != null) {
        struct.add(VdsProperties.network, vmInterface.getNetworkName());
    }
    struct.add(VdsProperties.linkState, vmInterface.isLinked() ? "up" : "down");
    addAddress(vmDevice, struct);
    struct.add(VdsProperties.mac_addr, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.add(VdsProperties.nic_type, nicModel);
    if (vmInterface.isPortMirroring()) {
        List<String> networks = new ArrayList<String>();
        networks.add(vmInterface.getNetworkName());
        struct.add(VdsProperties.portMirroring, networks);
    }
    addNetworkFiltersToNic(struct, clusterVersion);
}
#method_after
private static void addNetworkInterfaceProperties(XmlRpcStruct struct, VmNetworkInterface vmInterface, VmDevice vmDevice, String nicModel, Version clusterVersion) {
    struct.add(VdsProperties.Type, vmDevice.getType());
    struct.add(VdsProperties.Device, vmDevice.getDevice());
    struct.add(VdsProperties.network, StringUtils.defaultString(vmInterface.getNetworkName()));
    boolean linkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, clusterVersion.getValue());
    if (linkingSupported) {
        struct.add(VdsProperties.linkActive, String.valueOf(vmInterface.isLinked()));
    }
    addAddress(vmDevice, struct);
    struct.add(VdsProperties.mac_addr, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.add(VdsProperties.nic_type, nicModel);
    if (vmInterface.isPortMirroring()) {
        List<String> networks = new ArrayList<String>();
        if (vmInterface.getNetworkName() != null) {
            networks.add(vmInterface.getNetworkName());
        }
        struct.add(VdsProperties.portMirroring, networks);
    }
    addNetworkFiltersToNic(struct, clusterVersion);
}
#end_block

#method_before
@Override
protected VDS getDestinationVds() {
    if (_destinationVds == null) {
        Guid vdsId = getParameters().getDestinationVdsId() != null ? getParameters().getDestinationVdsId() : getVm().getdedicated_vm_for_vds() != null ? new Guid(getVm().getdedicated_vm_for_vds().toString()) : null;
        if (vdsId != null) {
            _destinationVds = getVdsDAO().get(vdsId);
        }
    }
    return _destinationVds;
}
#method_after
@Override
protected VDS getDestinationVds() {
    if (_destinationVds == null) {
        Guid vdsId = getParameters().getDestinationVdsId() != null ? getParameters().getDestinationVdsId() : getVm().getDedicatedVmForVds() != null ? new Guid(getVm().getDedicatedVmForVds().toString()) : null;
        if (vdsId != null) {
            _destinationVds = getVdsDAO().get(vdsId);
        }
    }
    return _destinationVds;
}
#end_block

#method_before
private void initRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringUtils.isEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringUtils.isEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getId() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true, new VdsFreeMemoryChecker(this)));
        refreshBootParameters(runVmParameters);
        getVm().setLastStartTime(new Date());
        // set vm disks
        VmHandler.updateDisksForVm(getVm(), getDiskDao().getAllForVm(getVm().getId()));
    }
}
#method_after
private void initRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringUtils.isEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getStoragePoolId());
    }
    if (!StringUtils.isEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getStoragePoolId());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getId() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true, new VdsFreeMemoryChecker(this)));
        refreshBootParameters(runVmParameters);
        getVm().setLastStartTime(new Date());
        // set vm disks
        VmHandler.updateDisksForVm(getVm(), getDiskDao().getAllForVm(getVm().getId()));
    }
}
#end_block

#method_before
protected void refreshBootParameters(RunVmParams runVmParameters) {
    if (runVmParameters == null) {
        return;
    }
    getVm().setboot_sequence(getVm().getdefault_boot_sequence());
}
#method_after
protected void refreshBootParameters(RunVmParams runVmParameters) {
    if (runVmParameters == null) {
        return;
    }
    getVm().setBootSequence(getVm().getDefaultBootSequence());
}
#end_block

#method_before
protected String cdPathWindowsToLinux(String url) {
    return ImagesHandler.cdPathWindowsToLinux(url, getVm().getstorage_pool_id());
}
#method_after
protected String cdPathWindowsToLinux(String url) {
    return ImagesHandler.cdPathWindowsToLinux(url, getVm().getStoragePoolId());
}
#end_block

#method_before
private void resumeVm() {
    mResume = true;
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            incrementVdsPendingVmsCount();
            VDSReturnValue result = getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
private void resumeVm() {
    mResume = true;
    setVdsId(new Guid(getVm().getRunOnVds().toString()));
    if (getVds() != null) {
        try {
            incrementVdsPendingVmsCount();
            VDSReturnValue result = getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                case // probably wrong xml format sent.
                PROTOCOL_ERROR:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                case // probably wrong xml format sent.
                PROTOCOL_ERROR:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getVmName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to configuration option
    // change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    if (initVm()) {
        if (getVm().getstatus() == VMStatus.Paused) {
            // resume
            resumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && getVm().getstatus() != VMStatus.Suspended) {
                if (getVm().getDiskList().isEmpty()) {
                    // If there are no snappable disks, there is no meaning for
                    // running as stateless, log a warning and run normally
                    warnIfNotAllDisksPermitSnapshots();
                    runVm();
                } else {
                    statelessVmTreatment();
                }
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getstatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                runVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
@Override
protected void executeVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to configuration option
    // change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    if (initVm()) {
        if (getVm().getStatus() == VMStatus.Paused) {
            // resume
            resumeVm();
        } else {
            // run vm
            if (!_isRerun && Boolean.TRUE.equals(getParameters().getRunAsStateless()) && getVm().getStatus() != VMStatus.Suspended) {
                if (getVm().getDiskList().isEmpty()) {
                    // If there are no snappable disks, there is no meaning for
                    // running as stateless, log a warning and run normally
                    warnIfNotAllDisksPermitSnapshots();
                    runVm();
                } else {
                    statelessVmTreatment();
                }
            } else if (!getParameters().getIsInternal() && !_isRerun && getVm().getStatus() != VMStatus.Suspended && statelessSnapshotExistsForVm()) {
                removeVmStatlessImages();
            } else {
                runVm();
            }
        }
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
private void attachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (getVmRunHandler().findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringUtils.isEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            guestToolsVersionTreatment();
            if (getVm().getboot_sequence() != null && getVm().getboot_sequence().containsSubsequence(BootSequence.D)) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringUtils.isEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        setSucceeded(false);
        throw new VdcBLLException(VdcBllErrors.NO_ACTIVE_ISO_DOMAIN_IN_DATA_CENTER);
    }
}
#method_after
private void attachCd() {
    Guid storagePoolId = getVm().getStoragePoolId();
    boolean isIsoFound = (getVmRunHandler().findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringUtils.isEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getIsoPath());
            guestToolsVersionTreatment();
            if (getVm().getBootSequence() != null && getVm().getBootSequence().containsSubsequence(BootSequence.D)) {
                getVm().setCdPath(getVm().getIsoPath());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getStoragePoolId()));
        }
    } else if (!StringUtils.isEmpty(getVm().getIsoPath())) {
        getVm().setCdPath("");
        setSucceeded(false);
        throw new VdcBLLException(VdcBllErrors.NO_ACTIVE_ISO_DOMAIN_IN_DATA_CENTER);
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(getActionType());
        tempVar.setParentParameters(getParameters());
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getVmName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getVmName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(getActionType());
        tempVar.setParentParameters(getParameters());
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getVmName());
        }
    }
}
#end_block

#method_before
protected VMStatus createVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    getVm().setLastStartTime(new Date());
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getinitrd_url())) {
        getVm().setinitrd_url(getIsoPrefixFilePath(getVm().getinitrd_url()));
    }
    if (!StringUtils.isEmpty(getVm().getkernel_url())) {
        getVm().setkernel_url(getIsoPrefixFilePath(getVm().getkernel_url()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initVdsCreateVmParams(), this).getReturnValue();
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    getVm().setLastStartTime(new Date());
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initVdsCreateVmParams(), this).getReturnValue();
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getDedicatedVmForVds() != null && !getVm().getRunOnVds().equals(getVm().getDedicatedVmForVds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getstatus() == VMStatus.ImageIllegal) || (getVm().getstatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getstatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getstatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setkvm_enable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setacpi_enable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getVmRunHandler().shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setdisplay_type(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setdisplay_type(getVm().getdefault_display_type());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getVm().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setvds_group_cpu_flags_data(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getvds_group_cpu_name(), getVm().getvds_group_compatibility_version()));
        return true;
    }
}
#method_after
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getVmRunHandler().shouldVmRunAsStateless(getParameters(), getVm()));
        // once command
        if (getParameters().getUseVnc() != null) {
            getVm().setDisplayType(getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl);
        } else {
            getVm().setDisplayType(getVm().getDefaultDisplayType());
        }
        if (getParameters().getReinitialize()) {
            getVm().setUseSysPrep(true);
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getVm().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#end_block

#method_before
private void guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (getVm().getvm_os().isWindows() && (null != (isoDomain = LinqUtils.firstOrNull(getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringUtils.isEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getId(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.getRegexToolPattern()).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        rhevToolsPath = Path.Combine(isoDir, rhevToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(rhevToolsPath, getVm().getstorage_pool_id()));
    }
}
#method_after
private void guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (getVm().getVmOs().isWindows() && (null != (isoDomain = LinqUtils.firstOrNull(getStorageDomainDAO().getAllForStoragePool(getVm().getStoragePoolId()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringUtils.isEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getId(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.getRegexToolPattern()).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getVdsGroupCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = Path.Combine(isoDir, rhevToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(rhevToolsPath, getVm().getStoragePoolId()));
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        getParameters().setIsInternal(true);
        // The iternal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    setIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        getParameters().setIsInternal(true);
        // The iternal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getVmName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
private boolean validateNetworkInterfaces() {
    Map<String, VmNetworkInterface> interfaceNetworkMap = Entities.interfacesByNetworkName(getVm().getInterfaces());
    Set<String> interfaceNetworkNames = interfaceNetworkMap.keySet();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(getVm().getvds_group_id());
    Set<String> clusterNetworksNames = Entities.objectNames(clusterNetworks);
    boolean returnValue;
    // Checking that the interfaces are all configured
    // If network linking is supported, interfaces with no network are allowed.
    // Otherwise, canDoAction should be thrown.
    returnValue = isVmInterfacesConfigured(interfaceNetworkMap);
    // Remove interfaces with no network
    interfaceNetworkMap.remove(null);
    // and they are attached to VM networks
    return returnValue && isVmInterfacesAttachedToClusterNetworks(clusterNetworksNames, interfaceNetworkNames) && isVmInterfacesAttachedToVmNetworks(clusterNetworks, interfaceNetworkNames);
}
#method_after
private boolean validateNetworkInterfaces() {
    Map<String, VmNetworkInterface> interfaceNetworkMap = Entities.interfacesByNetworkName(getVm().getInterfaces());
    Set<String> interfaceNetworkNames = interfaceNetworkMap.keySet();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(getVm().getVdsGroupId());
    Set<String> clusterNetworksNames = Entities.objectNames(clusterNetworks);
    return isVmInterfacesConfigured() && isVmInterfacesAttachedToClusterNetworks(clusterNetworksNames, interfaceNetworkNames) && isVmInterfacesAttachedToVmNetworks(clusterNetworks, interfaceNetworkNames);
}
#end_block

#method_before
private boolean isVmInterfacesConfigured(Map<String, VmNetworkInterface> interfacesMap) {
    if (interfacesMap.containsKey(null)) {
        boolean networkLinkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVm().getvds_group_compatibility_version().getValue());
        // If linking is not supported the interface must have a network.
        if (!networkLinkingSupported) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
            return false;
        }
    }
    return true;
}
#method_after
private boolean isVmInterfacesConfigured() {
    for (VmNetworkInterface nic : getVm().getInterfaces()) {
        if (nic.getNetworkName() == null) {
            if (!VmNicValidator.networkLinkingSupported(getVm().getVdsGroupCompatibilityVersion().getValue())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
                return false;
            } else {
                return true;
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean isVmInterfacesAttachedToClusterNetworks(final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    // attached to the cluster
    if (result.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER);
        addCanDoActionMessage(String.format("$networks %1$s", StringUtils.join(result, ",")));
        return false;
    }
    return true;
}
#method_after
private boolean isVmInterfacesAttachedToClusterNetworks(final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (VmNicValidator.networkLinkingSupported(getVm().getVdsGroupCompatibilityVersion().getValue())) {
        result.remove(null);
    }
    // attached to the cluster
    if (result.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER);
        addCanDoActionMessage(String.format("$networks %1$s", StringUtils.join(result, ",")));
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getvds_group_id(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getVm().getVdsGroupId(), getVm().getCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
    return list;
}
#end_block

#method_before
private XmlRpcStruct initNicStructure() {
    XmlRpcStruct map = new XmlRpcStruct();
    VmNetworkInterface nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    map.add(VdsProperties.Type, VmDeviceType.INTERFACE.getName());
    map.add(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
    map.add(VdsProperties.mac_addr, nic.getMacAddress());
    if (nic.getNetworkName() != null) {
        map.add(VdsProperties.network, nic.getNetworkName());
    }
    map.add(VdsProperties.linkState, nic.isLinked() ? "up" : "down");
    addAddress(map, vmDevice.getAddress());
    map.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
    map.add(VdsProperties.nic_type, VmInterfaceType.forValue(nic.getType()).name());
    map.add(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (vmDevice.getBootOrder() > 0) {
        map.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
    }
    if (nic.isPortMirroring()) {
        map.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    }
    VmInfoBuilder.addNetworkFiltersToNic(map, getParameters().getVm().getvds_group_compatibility_version());
    return map;
}
#method_after
private XmlRpcStruct initNicStructure() {
    XmlRpcStruct map = new XmlRpcStruct();
    VmNetworkInterface nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    map.add(VdsProperties.Type, VmDeviceType.INTERFACE.getName());
    map.add(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
    map.add(VdsProperties.mac_addr, nic.getMacAddress());
    map.add(VdsProperties.network, StringUtils.defaultString(nic.getNetworkName()));
    boolean linkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getParameters().getVm().getVdsGroupCompatibilityVersion().getValue());
    if (linkingSupported) {
        map.add(VdsProperties.linkActive, String.valueOf(nic.isLinked()));
    }
    addAddress(map, vmDevice.getAddress());
    map.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
    map.add(VdsProperties.nic_type, VmInterfaceType.forValue(nic.getType()).name());
    map.add(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (vmDevice.getBootOrder() > 0) {
        map.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
    }
    if (nic.isPortMirroring()) {
        map.add(VdsProperties.portMirroring, nic.getNetworkName() == null ? Collections.<String>emptyList() : Collections.singletonList(nic.getNetworkName()));
    }
    VmInfoBuilder.addNetworkFiltersToNic(map, getParameters().getVm().getVdsGroupCompatibilityVersion());
    return map;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (activateDeactivateVmNicAllowed(getVm().getstatus())) {
        // HotPlug in the host needs to be called only if the Vm is UP
        if (hotPlugVmNicRequired(getVm().getstatus())) {
            setVdsId(getVm().getrun_on_vds().getValue());
            returnValue = canPerformHotPlug();
            if (returnValue && (getNetworkName() != null && !networkAttachedToVds(getNetworkName(), getVdsId()))) {
                addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
                returnValue = false;
            }
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        returnValue = false;
    }
    if (returnValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNicId(), getParameters().getVmId()));
        vmNetworkInterface = getVmNetworkInterfaceDao().get(getParameters().getNicId());
        if (vmDevice == null || vmNetworkInterface == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (activateDeactivateVmNicAllowed(getVm().getStatus())) {
        // HotPlug in the host needs to be called only if the Vm is UP
        if (hotPlugVmNicRequired(getVm().getStatus())) {
            setVdsId(getVm().getRunOnVds().getValue());
            returnValue = canPerformHotPlug();
            if (returnValue && (getNetworkName() != null && !networkAttachedToVds(getNetworkName(), getVdsId()))) {
                addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
                returnValue = false;
            }
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        returnValue = false;
    }
    if (returnValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNicId(), getParameters().getVmId()));
        vmNetworkInterface = getVmNetworkInterfaceDao().get(getParameters().getNicId());
        if (vmDevice == null || vmNetworkInterface == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        }
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceName", vmNetworkInterface.getName());
    AddCustomValue("InterfaceType", VmInterfaceType.forValue(vmNetworkInterface.getType()).getDescription());
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getstatus())) {
        runVdsCommand(getParameters().getAction().getCommandType(), new HotPlugUnplgNicVDSParameters(getVdsId(), getVm(), getVmNetworkInterfaceDao().get(getParameters().getNicId()), vmDevice));
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    VmDeviceUtils.updateBootOrderInVmDevice(getVm().getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceName", vmNetworkInterface.getName());
    AddCustomValue("InterfaceType", VmInterfaceType.forValue(vmNetworkInterface.getType()).getDescription());
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        runVdsCommand(getParameters().getAction().getCommandType(), new HotPlugUnplgNicVDSParameters(getVdsId(), getVm(), getVmNetworkInterfaceDao().get(getParameters().getNicId()), vmDevice));
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    VmDeviceUtils.updateBootOrderInVmDevice(getVm().getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
private boolean networkAttachedToVds(String networkName, Guid vdsId) {
    if (networkName != null) {
        List<VdsNetworkInterface> listOfInterfaces = getInterfaceDao().getAllInterfacesForVds(vdsId);
        for (VdsNetworkInterface vdsNetworkInterface : listOfInterfaces) {
            if (networkName.equals(vdsNetworkInterface.getNetworkName())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean networkAttachedToVds(String networkName, Guid vdsId) {
    List<VdsNetworkInterface> listOfInterfaces = getInterfaceDao().getAllInterfacesForVds(vdsId);
    for (VdsNetworkInterface vdsNetworkInterface : listOfInterfaces) {
        if (networkName.equals(vdsNetworkInterface.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // check that we are not removing the management network
    if (StringHelper.EqOp(getParameters().getNetwork().getname(), Config.<String>GetValue(ConfigValues.ManagementNetwork))) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", Config.<String>GetValue(ConfigValues.ManagementNetwork)));
        return false;
    }
    // check that there is no vm running with this network
    List<VmStatic> vms = DbFacade.getInstance().getVmStaticDao().getAllByGroupAndNetworkName(getParameters().getVdsGroupId(), getParameters().getNetwork().getname());
    if (vms.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_VM);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", getParameters().getNetwork().getname()));
        return false;
    }
    // check that no template is using this network
    List<VmTemplate> templates = DbFacade.getInstance().getVmTemplateDao().getAllForVdsGroup(getParameters().getVdsGroupId());
    for (VmTemplate tmpl : templates) {
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(tmpl.getId());
        if (getIfaceWithNetworkName(interfaces) != null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_TEMPLATE);
            return false;
        }
    }
    // check if network in use by vm
    String query = "Vms: cluster = " + getVdsGroup().getname();
    SearchParameters searchParams = new SearchParameters(query, SearchType.VM);
    searchParams.setMaxCount(Integer.MAX_VALUE);
    VdcQueryReturnValue tempVar = Backend.getInstance().runInternalQuery(VdcQueryType.Search, searchParams);
    SearchReturnValue ret = (SearchReturnValue) ((tempVar instanceof SearchReturnValue) ? tempVar : null);
    if (ret != null && ret.getSucceeded()) {
        List<IVdcQueryable> vmList = (List<IVdcQueryable>) ret.getReturnValue();
        for (IVdcQueryable vm_helper : vmList) {
            VM vm = (VM) vm_helper;
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId());
            VmNetworkInterface iface = getIfaceWithNetworkName(interfaces);
            if (iface != null) {
                addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
                return false;
            }
        }
    }
    if (getParameters().getNetwork().getname().equals(NetworkUtils.getEngineNetwork())) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.NETWORK_DEFAULT_UPDATE_NAME_INVALID.toString());
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", Config.<String>GetValue(ConfigValues.ManagementNetwork)));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // check that we are not removing the management network
    if (StringHelper.EqOp(getParameters().getNetwork().getname(), Config.<String>GetValue(ConfigValues.ManagementNetwork))) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", Config.<String>GetValue(ConfigValues.ManagementNetwork)));
        return false;
    }
    // check that there is no vm running with this network
    List<VmStatic> vms = DbFacade.getInstance().getVmStaticDao().getAllByGroupAndNetworkName(getParameters().getVdsGroupId(), getParameters().getNetwork().getname());
    if (vms.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_VM);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", getParameters().getNetwork().getname()));
        return false;
    }
    // check that no template is using this network
    List<VmTemplate> templates = DbFacade.getInstance().getVmTemplateDao().getAllForVdsGroup(getParameters().getVdsGroupId());
    for (VmTemplate tmpl : templates) {
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(tmpl.getId());
        if (networkUsedByAnInterface(interfaces)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_TEMPLATE);
            return false;
        }
    }
    // check if network in use by vm
    String query = "Vms: cluster = " + getVdsGroup().getname();
    SearchParameters searchParams = new SearchParameters(query, SearchType.VM);
    searchParams.setMaxCount(Integer.MAX_VALUE);
    VdcQueryReturnValue tempVar = Backend.getInstance().runInternalQuery(VdcQueryType.Search, searchParams);
    SearchReturnValue ret = (SearchReturnValue) ((tempVar instanceof SearchReturnValue) ? tempVar : null);
    if (ret != null && ret.getSucceeded()) {
        List<IVdcQueryable> vmList = (List<IVdcQueryable>) ret.getReturnValue();
        for (IVdcQueryable vm_helper : vmList) {
            VM vm = (VM) vm_helper;
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId());
            if (networkUsedByAnInterface(interfaces)) {
                addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
                return false;
            }
        }
    }
    if (getParameters().getNetwork().getname().equals(NetworkUtils.getEngineNetwork())) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.NETWORK_DEFAULT_UPDATE_NAME_INVALID.toString());
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", Config.<String>GetValue(ConfigValues.ManagementNetwork)));
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (ObjectIdentityChecker.CanUpdateField(vm, "vds_group_id", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
            // Check the destination cluster have all the networks that the VM use
            // Checks that if the destination Cluster doesn't support Network linking the VM doesn't have Nics with
            // unlinked Network ("no network" is allowed here, will be blocked in RunVm)
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
            StringBuilder missingNets = new StringBuilder();
            String clusterCompatibilityVersion = targetCluster.getcompatibility_version().getValue();
            for (VmNetworkInterface iface : interfaces) {
                VmNicValidator nicValidator = new VmNicValidator(iface, clusterCompatibilityVersion);
                if (!validate(nicValidator.linkedCorrectly())) {
                    return false;
                }
                String netName = iface.getNetworkName();
                if (netName != null) {
                    boolean exists = false;
                    for (Network net : networks) {
                        if (net.getname().equals(netName)) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        if (missingNets.length() > 0) {
                            missingNets.append(", ");
                        }
                        missingNets.append(netName);
                    }
                }
            }
            if (missingNets.length() > 0) {
                addCanDoActionMessage(VdcBllMessages.MOVE_VM_CLUSTER_MISSING_NETWORK);
                addCanDoActionMessage(String.format("$networks %1$s", missingNets.toString()));
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.CheckCpuSockets(vm.getStaticData().getnum_of_sockets(), vm.getStaticData().getcpu_per_socket(), clusterCompatibilityVersion, getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (ObjectIdentityChecker.CanUpdateField(vm, "vds_group_id", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
            String clusterCompatibilityVersion = targetCluster.getcompatibility_version().getValue();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNicsLinkedCorrectly(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.CheckCpuSockets(vm.getStaticData().getnum_of_sockets(), vm.getStaticData().getcpu_per_socket(), clusterCompatibilityVersion, getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public String getVmName() {
    if (mVmName == null && getVm() != null) {
        mVmName = getVm().getvm_name();
    }
    return mVmName;
}
#method_after
public String getVmName() {
    if (mVmName == null && getVm() != null) {
        mVmName = getVm().getVmName();
    }
    return mVmName;
}
#end_block

#method_before
protected VDS getVds() {
    if (mVds == null && (mVdsId != null || (getVm() != null && getVm().getrun_on_vds() != null))) {
        if (mVdsId == null) {
            mVdsId = new Guid(getVm().getrun_on_vds().toString());
        }
        try {
            mVds = getVdsDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.infoFormat("Failed to get vds {0}\n{1}", mVdsId, e.getMessage());
        }
    }
    return mVds;
}
#method_after
protected VDS getVds() {
    if (mVds == null && (mVdsId != null || (getVm() != null && getVm().getRunOnVds() != null))) {
        if (mVdsId == null) {
            mVdsId = new Guid(getVm().getRunOnVds().toString());
        }
        try {
            mVds = getVdsDAO().get(getVdsId());
        } catch (final RuntimeException e) {
            log.infoFormat("Failed to get vds {0}\n{1}", mVdsId, e.getMessage());
        }
    }
    return mVds;
}
#end_block

#method_before
public VmTemplate getVmTemplate() {
    if (mVmTemplate == null && (mVmTemplateId != null || getVm() != null)) {
        mVmTemplate = getVmTemplateDAO().get(mVmTemplateId != null ? getVmTemplateId() : getVm().getvmt_guid());
    }
    return mVmTemplate;
}
#method_after
public VmTemplate getVmTemplate() {
    if (mVmTemplate == null && (mVmTemplateId != null || getVm() != null)) {
        mVmTemplate = getVmTemplateDAO().get(mVmTemplateId != null ? getVmTemplateId() : getVm().getVmtGuid());
    }
    return mVmTemplate;
}
#end_block

#method_before
protected VDSGroup getVdsGroup() {
    if (mVdsGroup == null) {
        if (mVdsGroupId != null) {
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVds() != null) {
            mVdsGroupId = getVds().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVm() != null) {
            mVdsGroupId = getVm().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVmTemplate() != null) {
            mVdsGroupId = getVmTemplate().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        }
    }
    return mVdsGroup;
}
#method_after
protected VDSGroup getVdsGroup() {
    if (mVdsGroup == null) {
        if (mVdsGroupId != null) {
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVds() != null) {
            mVdsGroupId = getVds().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVm() != null) {
            mVdsGroupId = getVm().getVdsGroupId();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVmTemplate() != null) {
            mVdsGroupId = getVmTemplate().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        }
    }
    return mVdsGroup;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    DbFacade.getInstance().getVmNetworkInterfaceDao().save(getParameters().getInterface());
    // \\DbFacade.Instance.addInterfaceStatistics(AddVmTemplateInterfaceParameters.Interface.InterfaceStatistics);
    VmDeviceUtils.addNetworkInterfaceDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmTemplateId()), getParameters().getInterface().isActive());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNetworkInterfaceDao().save(getParameters().getInterface());
    VmDeviceUtils.addNetworkInterfaceDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmTemplateId()), getParameters().getInterface().isActive());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getParameters().getInterface().getVmId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_VM_CANNOT_BE_SET);
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getnum_of_monitors(), allInterfaces, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    boolean unlinkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVdsGroup().getcompatibility_version().getValue());
    if (!unlinkingSupported) {
        if (!getParameters().getInterface().isLinked()) {
            addCanDoActionMessage(VdcBllMessages.UNLINKING_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
            return false;
        }
        if (getParameters().getInterface().getNetworkName() == null) {
            addCanDoActionMessage(VdcBllMessages.NULL_NETWORK_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
            return false;
        }
    }
    if (getParameters().getInterface().getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getVmTemplate().getvds_group_id());
        if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getParameters().getInterface().getNetworkName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getParameters().getInterface().getVmId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_VM_CANNOT_BE_SET);
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getnum_of_monitors(), allInterfaces, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    String clusterCompatibilityVersion = getVdsGroup().getcompatibility_version().getValue();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.networkNameValid())) {
        return false;
    }
    if (getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id());
        if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getNetworkName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private ActivateDeactivateVmNicParameters createActivateDeactivateParameters(Guid nicId, PlugAction plugAction) {
    ActivateDeactivateVmNicParameters activateDeactivateVmNicParameters = new ActivateDeactivateVmNicParameters(nicId, plugAction);
    activateDeactivateVmNicParameters.setVmId(getParameters().getVmId());
    return activateDeactivateVmNicParameters;
}
#method_after
private ActivateDeactivateVmNicParameters createActivateDeactivateParameters(Guid nicId, PlugAction plugAction) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nicId, plugAction);
    parameters.setVmId(getParameters().getVmId());
    return parameters;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDao().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateNic(getParameters().getInterface().getId(), PlugAction.PLUG);
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    this.setVmName(getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateOrDeactivateNic(getParameters().getInterface().getId(), PlugAction.PLUG);
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
private void addInterfaceToDb(VmNetworkInterface vmNetworkInterface) {
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDao().save(vmNetworkInterface);
    getCompensationContext().snapshotNewEntity(vmNetworkInterface);
    dbFacade.getVmNetworkStatisticsDao().save(vmNetworkInterface.getStatistics());
    getCompensationContext().snapshotNewEntity(vmNetworkInterface.getStatistics());
}
#method_after
private void addInterfaceToDb(VmNetworkInterface vmNetworkInterface) {
    getVmNetworkInterfaceDao().save(vmNetworkInterface);
    getCompensationContext().snapshotNewEntity(vmNetworkInterface);
    getDbFacade().getVmNetworkStatisticsDao().save(vmNetworkInterface.getStatistics());
    getCompensationContext().snapshotNewEntity(vmNetworkInterface.getStatistics());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDao().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    boolean unlinkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!unlinkingSupported) {
        if (!getParameters().getInterface().isLinked()) {
            addCanDoActionMessage(VdcBllMessages.UNLINKING_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getParameters().getInterface().getNetworkName() == null) {
            addCanDoActionMessage(VdcBllMessages.NULL_NETWORK_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
    }
    if (getParameters().getInterface().getNetworkName() != null) {
        // check that the exists in current cluster
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vm.getvds_group_id());
        Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getParameters().getInterface().getNetworkName());
            }
        });
        if (interfaceNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!interfaceNetwork.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    String compatibilityVersion = getVm().getVdsGroupCompatibilityVersion().getValue();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), compatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.networkNameValid())) {
        return false;
    }
    if (getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = getNetworkDAO().getAllForCluster(vm.getvds_group_id());
        Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getNetworkName());
            }
        });
        if (interfaceNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!interfaceNetwork.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && StringUtils.isNotEmpty(getNetworkName()) && getVm() != null) {
        Network network = getNetworkDAO().getByNameAndCluster(getNetworkName(), getVm().getVdsGroupId());
        if (getParameters().getInterface().isPortMirroring()) {
            permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, ActionGroup.PORT_MIRRORING));
        } else {
            permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, getActionType().getActionGroup()));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected void initDeviceStructure() {
    super.initDeviceStructure();
    VmNetworkInterface nic = getParameters().getNic();
    if (nic.getNetworkName() != null) {
        deviceStruct.add(VdsProperties.network, nic.getNetworkName());
    } else {
        deviceStruct.add(VdsProperties.network, "");
    }
    deviceStruct.add(VdsProperties.linkActive, String.valueOf(nic.isLinked()));
    if (nic.isPortMirroring() && nic.getNetworkName() != null) {
        deviceStruct.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    } else {
        deviceStruct.add(VdsProperties.portMirroring, new ArrayList<String>());
    }
}
#method_after
protected XmlRpcStruct initDeviceStructure() {
    XmlRpcStruct deviceStruct = new XmlRpcStruct();
    deviceStruct.add(VdsProperties.DeviceType, getParameters().getVmDevice().getType());
    deviceStruct.add(VdsProperties.Alias, getParameters().getVmDevice().getAlias());
    VmNetworkInterface nic = getParameters().getNic();
    deviceStruct.add(VdsProperties.network, StringUtils.defaultString(nic.getNetworkName()));
    deviceStruct.add(VdsProperties.linkActive, String.valueOf(nic.isLinked()));
    deviceStruct.add(VdsProperties.portMirroring, nic.isPortMirroring() && nic.getNetworkName() != null ? Collections.singletonList(nic.getNetworkName()) : Collections.<String>emptyList());
    return deviceStruct;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(oldIface);
            DbFacade.getInstance().getVmNetworkInterfaceDao().update(getInterface());
            if (macAddressChanged) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            }
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(updateHost());
}
#method_after
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(oldIface);
            getVmNetworkInterfaceDao().update(getInterface());
            if (macAddressChanged) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            }
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(updateHost());
}
#end_block

#method_before
private boolean updateHost() {
    if (getRequiredVdsAction() != null) {
        switch(getRequiredVdsAction()) {
            case plug:
                {
                    return activateNic(getInterface().getId(), PlugAction.PLUG);
                }
            case unplug:
                {
                    return activateNic(getInterface().getId(), PlugAction.UNPLUG);
                }
            case update:
                {
                    runVdsCommand(VDSCommandType.UpdateVmInterface, new UpdateVmInterfaceVDSParameters(getVdsId(), getVm(), getVmNetworkInterfaceDao().get(getInterface().getId()), oldVmDevice));
                }
        }
    }
    return true;
}
#method_after
private boolean updateHost() {
    if (getVm().getStatus() == VMStatus.Up) {
        setVdsId(getVm().getRunOnVds().getValue());
    }
    if (getRequiredAction() != null) {
        switch(getRequiredAction()) {
            case PLUG:
                {
                    return activateOrDeactivateNic(getInterface().getId(), PlugAction.PLUG);
                }
            case UNPLUG:
                {
                    return activateOrDeactivateNic(getInterface().getId(), PlugAction.UNPLUG);
                }
            case UPDATE_VM_DEVICE:
                {
                    runVdsCommand(VDSCommandType.UpdateVmInterface, new VmNicDeviceVDSParameters(getVdsId(), getVm(), getVmNetworkInterfaceDao().get(getInterface().getId()), oldVmDevice));
                    break;
                }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getParameters().getVmId()));
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDao().get(getParameters().getVmId());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    if (getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    if (getRequiredVdsAction() == VdsAction.unplugPlug) {
        addCanDoActionMessage(VdcBllMessages.CANNOT_PERFOM_HOT_UPDATE);
        return false;
    }
    boolean linkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!linkingSupported) {
        if (!getInterface().isLinked()) {
            addCanDoActionMessage(VdcBllMessages.UNLINKING_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getInterface().getNetworkName() == null) {
            addCanDoActionMessage(VdcBllMessages.NULL_NETWORK_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getRequiredVdsAction() == VdsAction.update) {
            addCanDoActionMessage(VdcBllMessages.HOT_VM_INTERFACE_UPDATE_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
    } else {
        if (getRequiredVdsAction() == VdsAction.update) {
            if (getInterface().isPortMirroring()) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_PERFOM_HOT_UPDATE_WITH_PORT_MIRRORING);
                return false;
            }
        }
    }
    if (getInterface().getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vm.getvds_group_id());
        if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return n.getname().equals(getInterface().getNetworkName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    if (getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.networkNameValid()) || !validate(nicValidator.hotUpdatePossible())) {
        return false;
    }
    if (getInterface().getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = getNetworkDAO().getAllForCluster(vm.getvds_group_id());
        if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return n.getname().equals(getInterface().getNetworkName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getInterface() != null && StringUtils.isNotEmpty(getNetworkName()) && getVm() != null) {
        VmNetworkInterface iface = getVmNetworkInterfaceDao().get(getInterface().getId());
        if (iface != null) {
            Network network = getNetworkDAO().getByNameAndCluster(getNetworkName(), getVm().getVdsGroupId());
            if (getInterface().isPortMirroring() && (isNetworkChanged(iface) || !iface.isPortMirroring())) {
                permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, ActionGroup.PORT_MIRRORING));
            } else {
                // If the vNic's network is changed, the user should have permission for using the new network
                if (isNetworkChanged(iface)) {
                    permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, getActionType().getActionGroup()));
                }
            }
        }
    }
    return permissionList;
}
#end_block

#method_before
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).InnerText);
    iface.setMacAddress((node.SelectSingleNode("rasd:MACAddress", _xmlNS) != null) ? node.SelectSingleNode("rasd:MACAddress", _xmlNS).InnerText : "");
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).InnerText;
    if (StringUtils.isNotEmpty(networkName)) {
        iface.setNetworkName(networkName);
    } else {
        iface.setNetworkName(null);
    }
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    if (linkedNode != null) {
        iface.setLinked(Boolean.valueOf(linkedNode.InnerText));
    } else {
        iface.setLinked(true);
    }
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.InnerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#method_after
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).InnerText);
    iface.setMacAddress((node.SelectSingleNode("rasd:MACAddress", _xmlNS) != null) ? node.SelectSingleNode("rasd:MACAddress", _xmlNS).InnerText : "");
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).InnerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.InnerText));
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.InnerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#end_block

#method_before
private void initInterfaces(VM vm) {
    List<VmNetworkInterface> interfaceList = new ArrayList<VmNetworkInterface>();
    VmNetworkInterface vmInterface = new VmNetworkInterface();
    vmInterface.setStatistics(new VmNetworkStatistics());
    vmInterface.setId(Guid.NewGuid());
    vmInterface.setName("eth77");
    vmInterface.setNetworkName("blue");
    vmInterface.setLinked(false);
    vmInterface.setSpeed(1000);
    vmInterface.setType(3);
    vmInterface.setMacAddress("01:C0:81:21:71:17");
    VmNetworkInterface vmInterface2 = new VmNetworkInterface();
    vmInterface2.setStatistics(new VmNetworkStatistics());
    vmInterface2.setId(Guid.NewGuid());
    vmInterface2.setName("eth88");
    vmInterface2.setNetworkName(null);
    vmInterface2.setLinked(true);
    vmInterface2.setSpeed(1234);
    vmInterface2.setType(1);
    vmInterface2.setMacAddress("02:C1:92:22:25:28");
    interfaceList.add(vmInterface);
    interfaceList.add(vmInterface2);
    vm.setInterfaces(interfaceList);
}
#method_after
private void initInterfaces(VM vm) {
    VmNetworkInterface vmInterface = new VmNetworkInterface();
    vmInterface.setStatistics(new VmNetworkStatistics());
    vmInterface.setId(Guid.NewGuid());
    vmInterface.setName("eth77");
    vmInterface.setNetworkName("blue");
    vmInterface.setLinked(false);
    vmInterface.setSpeed(1000);
    vmInterface.setType(3);
    vmInterface.setMacAddress("01:C0:81:21:71:17");
    VmNetworkInterface vmInterface2 = new VmNetworkInterface();
    vmInterface2.setStatistics(new VmNetworkStatistics());
    vmInterface2.setId(Guid.NewGuid());
    vmInterface2.setName("eth88");
    vmInterface2.setNetworkName(null);
    vmInterface2.setLinked(true);
    vmInterface2.setSpeed(1234);
    vmInterface2.setType(1);
    vmInterface2.setMacAddress("02:C1:92:22:25:28");
    vm.setInterfaces(Arrays.asList(vmInterface, vmInterface2));
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setcpu_cores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setcpu_sockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setcpu_model(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setcpu_speed_mh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setphysical_mem_mb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setkvm_enabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setreserved_mem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setguest_overhead(guestOverhead != null ? guestOverhead : 0);
    vds.setcpu_flags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setsupported_cluster_levels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setsupported_engines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.getItem(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
}
#method_after
public static void updateVDSDynamicData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setcpu_cores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setcpu_sockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setcpu_model(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setcpu_speed_mh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setphysical_mem_mb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setkvm_enabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setreserved_mem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setguest_overhead(guestOverhead != null ? guestOverhead : 0);
    vds.setcpu_flags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setsupported_cluster_levels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setsupported_engines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.getItem(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
}
#end_block

#method_before
public static boolean hasCpuToRunVM(VDS vds, VM vm) {
    if (vds.getusage_cpu_percent() == null || vm.getUsageCpuPercent() == null) {
        return false;
    }
    // The predicted CPU is actually the CPU that the VM will take considering how many cores it has and now many
    // cores the host has. This is why we take both parameters into consideration.
    int predictedVmCpu = (vm.getUsageCpuPercent() * vm.getNumOfCpus()) / VdsSelector.geteffective_cpu_cores(vds);
    boolean result = vds.getusage_cpu_percent() + predictedVmCpu <= vds.gethigh_utilization();
    if (log.isDebugEnabled()) {
        log.debugFormat("Host {0} has {1}% CPU load; VM {2} is predicted to have {3}% CPU load; " + "High threshold is {4}%. Host is {5}suitable in terms of CPU.", vds.getvds_name(), vds.getusage_cpu_percent(), vm.getVmName(), predictedVmCpu, vds.gethigh_utilization(), (result ? "" : "not "));
    }
    return result;
}
#method_after
public static boolean hasCpuToRunVM(VDS vds, VM vm) {
    if (vds.getusage_cpu_percent() == null || vm.getUsageCpuPercent() == null) {
        return false;
    }
    // The predicted CPU is actually the CPU that the VM will take considering how many cores it has and now many
    // cores the host has. This is why we take both parameters into consideration.
    int predictedVmCpu = (vm.getUsageCpuPercent() * vm.getNumOfCpus()) / VdsSelector.getEffectiveCpuCores(vds);
    boolean result = vds.getusage_cpu_percent() + predictedVmCpu <= vds.gethigh_utilization();
    if (log.isDebugEnabled()) {
        log.debugFormat("Host {0} has {1}% CPU load; VM {2} is predicted to have {3}% CPU load; " + "High threshold is {4}%. Host is {5}suitable in terms of CPU.", vds.getvds_name(), vds.getusage_cpu_percent(), vm.getVmName(), predictedVmCpu, vds.gethigh_utilization(), (result ? "" : "not "));
    }
    return result;
}
#end_block

#method_before
private double calcDistributeMetric(VDS vds, VM vm) {
    int vcpu = Config.<Integer>GetValue(ConfigValues.VcpuConsumptionPercentage);
    int spmCpu = (vds.getspm_status() == VdsSpmStatus.None) ? 0 : Config.<Integer>GetValue(ConfigValues.SpmVCpuConsumption);
    int hostCores = VdsSelector.geteffective_cpu_cores(vds);
    double hostCpu = vds.getusage_cpu_percent();
    double pendingVcpus = vds.getpending_vcpus_count();
    return (hostCpu / vcpu) + (pendingVcpus + vm.getNumOfCpus() + spmCpu) / hostCores;
}
#method_after
private double calcDistributeMetric(VDS vds, VM vm) {
    int vcpu = Config.<Integer>GetValue(ConfigValues.VcpuConsumptionPercentage);
    int spmCpu = (vds.getspm_status() == VdsSpmStatus.None) ? 0 : Config.<Integer>GetValue(ConfigValues.SpmVCpuConsumption);
    int hostCores = VdsSelector.getEffectiveCpuCores(vds);
    double hostCpu = vds.getusage_cpu_percent();
    double pendingVcpus = vds.getpending_vcpus_count();
    return (hostCpu / vcpu) + (pendingVcpus + vm.getNumOfCpus() + spmCpu) / hostCores;
}
#end_block

#method_before
@Override
public boolean IsBetter(VDS x, VDS y, VM vm) {
    if (VdsSelector.geteffective_cpu_cores(x) == null || VdsSelector.geteffective_cpu_cores(y) == null || x.getusage_cpu_percent() == null || y.getusage_cpu_percent() == null || x.getpending_vcpus_count() == null || y.getpending_vcpus_count() == null) {
        return false;
    }
    return calcDistributeMetric(x, vm) > calcDistributeMetric(y, vm);
}
#method_after
@Override
public boolean IsBetter(VDS x, VDS y, VM vm) {
    if (VdsSelector.getEffectiveCpuCores(x) == null || VdsSelector.getEffectiveCpuCores(y) == null || x.getusage_cpu_percent() == null || y.getusage_cpu_percent() == null || x.getpending_vcpus_count() == null || y.getpending_vcpus_count() == null) {
        return false;
    }
    return calcDistributeMetric(x, vm) > calcDistributeMetric(y, vm);
}
#end_block

#method_before
@Override
protected void InitOverUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() > vmCountTemp * VdsSelector.geteffective_cpu_cores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o2.getvm_count() - o1.getvm_count();
        }
    });
    setOverUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#method_after
@Override
protected void InitOverUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() > vmCountTemp * VdsSelector.getEffectiveCpuCores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o2.getvm_count() - o1.getvm_count();
        }
    });
    setOverUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#end_block

#method_before
@Override
protected void InitUnderUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < vmCountTemp * VdsSelector.geteffective_cpu_cores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o1.getvm_count() - o2.getvm_count();
        }
    });
    setUnderUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#method_after
@Override
protected void InitUnderUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < vmCountTemp * VdsSelector.getEffectiveCpuCores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o1.getvm_count() - o2.getvm_count();
        }
    });
    setUnderUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#end_block

#method_before
@Override
protected void InitReadyToMigrationList() {
    int highVdsCount = 0;
    int lowVdsCount = 0;
    int afterThreasholdInPercent = Config.<Integer>GetValue(ConfigValues.UtilizationThresholdInPercent);
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int highVdsCountTemp = highVdsCount;
    final int lowVdsCountTemp = lowVdsCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < highVdsCountTemp * VdsSelector.geteffective_cpu_cores(p) && p.getvm_count() >= lowVdsCountTemp * VdsSelector.geteffective_cpu_cores(p);
        }
    });
    setReadyToMigrationServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#method_after
@Override
protected void InitReadyToMigrationList() {
    int highVdsCount = 0;
    int lowVdsCount = 0;
    int afterThreasholdInPercent = Config.<Integer>GetValue(ConfigValues.UtilizationThresholdInPercent);
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int highVdsCountTemp = highVdsCount;
    final int lowVdsCountTemp = lowVdsCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < highVdsCountTemp * VdsSelector.getEffectiveCpuCores(p) && p.getvm_count() >= lowVdsCountTemp * VdsSelector.getEffectiveCpuCores(p);
        }
    });
    setReadyToMigrationServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#end_block

#method_before
private int calculateCpuUsage(VDS o1) {
    return o1.getusage_cpu_percent() * VdsSelector.geteffective_cpu_cores(o1) / o1.getvds_strength();
}
#method_after
private int calculateCpuUsage(VDS o1) {
    return o1.getusage_cpu_percent() * VdsSelector.getEffectiveCpuCores(o1) / o1.getvds_strength();
}
#end_block

#method_before
private void UpdateProperties() {
    VDS vds = getEntity();
    setOS(vds.gethost_os());
    setKernelVersion(vds.getkernel_version());
    setKvmVersion(vds.getkvm_version());
    setLibvirtVersion(vds.getlibvirt_version());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getspice_version());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setActiveVms(vds.getvm_active());
    setCpuName(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuType(vds.getcpu_model());
    setNumberOfSockets(vds.getcpu_sockets());
    setCoresPerSocket((vds.getcpu_cores() != null && vds.getcpu_sockets() != null) ? vds.getcpu_cores() / vds.getcpu_sockets() : null);
    // vdsm may be accounting for hyperthreading already by doubling the core count
    setCpuHyperthreading(// $NON-NLS-1$
    vds.getvdsm_count_threads_as_cores() == null ? // $NON-NLS-1$
    "Unknown" : (// $NON-NLS-1$
    vds.getvdsm_count_threads_as_cores() ? // $NON-NLS-1$
    "Virtual (vdsm.conf setting)" : // $NON-NLS-1$ //$NON-NLS-2$
    (vds.getcpu_ht_enabled() ? "Enabled" : "Disabled")));
    setPhysicalMemory(vds.getphysical_mem_mb());
    setSwapTotal(vds.getswap_total());
    setSwapFree(vds.getswap_free());
    setSharedMemory(vds.getmem_shared_percent());
    setMemoryPageSharing(vds.getksm_state());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
}
#method_after
private void UpdateProperties() {
    VDS vds = getEntity();
    setOS(vds.gethost_os());
    setKernelVersion(vds.getkernel_version());
    setKvmVersion(vds.getkvm_version());
    setLibvirtVersion(vds.getlibvirt_version());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getspice_version());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setActiveVms(vds.getvm_active());
    setCpuName(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuType(vds.getcpu_model());
    setNumberOfSockets(vds.getcpu_sockets());
    setCoresPerSocket((vds.getcpu_cores() != null && vds.getcpu_sockets() != null) ? vds.getcpu_cores() / vds.getcpu_sockets() : null);
    if (vds.getvds_group_compatibility_version() != null && Version.v3_2.compareTo(vds.getvds_group_compatibility_version()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        // $NON-NLS-1$
        setThreadsPerCore("Unsupported");
    } else if (vds.getCpuThreads() == null || vds.getcpu_cores() == null) {
        // $NON-NLS-1$
        setThreadsPerCore("Unknown");
    } else {
        Integer threads = vds.getCpuThreads() / vds.getcpu_cores();
        // $NON-NLS-1$ //$NON-NLS-2$
        setThreadsPerCore(threads.toString() + (threads > 1 ? " (SMT Enabled)" : " (SMT Disabled)"));
    }
    setPhysicalMemory(vds.getphysical_mem_mb());
    setSwapTotal(vds.getswap_total());
    setSwapFree(vds.getswap_free());
    setSharedMemory(vds.getmem_shared_percent());
    setMemoryPageSharing(vds.getksm_state());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
}
#end_block

#method_before
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setEnableOvirtService(new EntityModel());
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    setEnableGlusterService(new EntityModel());
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCPUOvercommit(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#method_after
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#end_block

#method_before
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setEntity(false);
}
#method_after
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity((boolean) getEntity().getcount_threads_as_cores());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (storage_pool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity((boolean) getEntity().getCountThreadsAsCores());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (storage_pool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#end_block

#method_before
private void Version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = (Version) getVersion().getSelectedItem();
    } else {
        version = ((storage_pool) getDataCenter().getSelectedItem()).getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            ServerCpu oldSelectedCpu = (ServerCpu) clusterModel.getCPU().getSelectedItem();
            clusterModel.getCPU().setItems(cpus);
            clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.FirstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
            if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
                InitCPU();
            }
        }
    };
    AsyncDataProvider.GetCPUList(_asyncQuery, version);
    // CPU Overcommit is only available for clusters of version 3.2 or greater
    getVersionSupportsCPUOvercommit().setEntity(version.compareTo(Version.v3_2) >= 0);
}
#method_after
private void Version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = (Version) getVersion().getSelectedItem();
    } else {
        version = ((storage_pool) getDataCenter().getSelectedItem()).getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            ServerCpu oldSelectedCpu = (ServerCpu) clusterModel.getCPU().getSelectedItem();
            clusterModel.getCPU().setItems(cpus);
            clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.FirstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
            if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
                InitCPU();
            }
        }
    };
    AsyncDataProvider.GetCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
}
#end_block

#method_before
private void StoragePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    storage_pool selectedDataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.getstorage_pool_type() == StorageType.LOCALFS) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            clusterModel.getVersion().setItems(versions);
            if (!versions.contains(clusterModel.getVersion().getSelectedItem())) {
                if (versions.contains(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version())) {
                    clusterModel.getVersion().setSelectedItem(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version());
                } else {
                    clusterModel.getVersion().setSelectedItem(Linq.SelectHighestVersion(versions));
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.FirstOrDefault(versions, new Linq.VersionPredicate(((VDSGroup) clusterModel.getEntity()).getcompatibility_version())));
            }
        }
    };
    AsyncDataProvider.GetDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#method_after
private void StoragePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    storage_pool selectedDataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.getstorage_pool_type() == StorageType.LOCALFS) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            clusterModel.getVersion().setItems(versions);
            if (!versions.contains(clusterModel.getVersion().getSelectedItem())) {
                if (versions.contains(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version())) {
                    clusterModel.getVersion().setSelectedItem(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version());
                } else {
                    clusterModel.getVersion().setSelectedItem(Linq.SelectHighestVersion(versions));
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.FirstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            }
        }
    };
    AsyncDataProvider.GetDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#end_block

#method_before
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, parameters, aQuery);
}
#method_after
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, parameters, aQuery);
}
#end_block

#method_before
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    getAllFromExportDomainQueryParamenters.setGetAll(true);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static ArrayList<VmOsType> GetWindowsOsTypes() {
    if (windowsOsTypes != null) {
        return windowsOsTypes;
    }
    /**
     * ** TODO: remove once the gwt is using generic api instead of backend! ****
     */
    windowsOsTypes = new ArrayList<VmOsType>(Arrays.asList(new VmOsType[] { VmOsType.Windows2003, VmOsType.Windows2003x64, VmOsType.Windows2008, VmOsType.Windows2008R2x64, VmOsType.Windows2008x64, VmOsType.Windows7, VmOsType.Windows7x64, VmOsType.WindowsXP }));
    return windowsOsTypes;
/**
 * ***************************************************************************
 */
}
#method_after
public static ArrayList<VmOsType> GetWindowsOsTypes() {
    if (windowsOsTypes != null) {
        return windowsOsTypes;
    }
    /**
     * ** TODO: remove once the gwt is using generic api instead of backend! ****
     */
    windowsOsTypes = new ArrayList<VmOsType>();
    for (VmOsType type : VmOsType.values()) {
        if (type.isWindows()) {
            windowsOsTypes.add(type);
        }
    }
    return windowsOsTypes;
/**
 * ***************************************************************************
 */
}
#end_block

#method_before
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    model.getEnableOvirtService().setIsChangable(false);
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    model.getEnableGlusterService().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(model);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
            if (volumes.size() > 0) {
                clusterModel.getEnableGlusterService().setIsChangable(false);
            } else {
                clusterModel.getEnableGlusterService().setIsChangable(true);
            }
        }
    };
    AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
    AsyncQuery asyncQuery1 = new AsyncQuery();
    asyncQuery1.setModel(model);
    asyncQuery1.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<VM> vmList = (ArrayList<VM>) result;
            if (vmList.size() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
            } else {
                clusterModel.getEnableOvirtService().setIsChangable(true);
            }
        }
    };
    AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        // $NON-NLS-1$
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.Init(true);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getname());
    clusterModel.getName().setEntity(cluster.getname());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void OnSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuSmt", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        OnSaveConfirmCpuSmt();
    }
}
#method_after
private void OnSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        OnSaveConfirmCpuThreads();
    }
}
#end_block

#method_before
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setcount_threads_as_cores(((Boolean) model.getVersionSupportsCPUOvercommit().getEntity()) && ((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals((Boolean) model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(returnValue.getExceptionString());
                return;
            }
            Map<String, String> hostMap = (Map<String, String>) returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
public void postOnSaveInternalWithImport(VdcReturnValueBase returnValue) {
    MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    hostsModel.getClusterModel().setClusterId((Guid) returnValue.getActionReturnValue());
    addHosts(hostsModel);
}
#method_after
public void postOnSaveInternalWithImport(VdcReturnValueBase returnValue) {
    MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    if (returnValue != null && returnValue.getSucceeded()) {
        hostsModel.getClusterModel().setClusterId((Guid) returnValue.getActionReturnValue());
        addHosts(hostsModel);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuSmt")) {
        OnSaveConfirmCpuSmt();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        OnSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupRootPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuOvercommitPanelTitle.setText(constants.clusterPopupCpuOvercommitPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupRootPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
}
#end_block

#method_before
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
}
#method_after
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
}
#end_block

#method_before
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuOvercommitInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuOvercommitInfo()), resources);
}
#method_after
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCPUOvercommit().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuOvercommitPanel.setVisible((Boolean) object.getVersionSupportsCPUOvercommit().getEntity());
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
}
#end_block

#method_before
private void optimizationCustomFormatter(ClusterModel object) {
    if (object.getOptimizationCustom() != null && object.getOptimizationCustom().getEntity() != null) {
        // use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(messages.clusterPopupMemoryOptimizationCustomLabel(String.valueOf(object.getMemoryOverCommit())));
    }
}
#method_after
private void optimizationCustomFormatter(ClusterModel object) {
    if (object.getOptimizationCustom() != null && object.getOptimizationCustom().getEntity() != null) {
        // Use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(messages.clusterPopupMemoryOptimizationCustomLabel(String.valueOf(object.getMemoryOverCommit())));
    }
}
#end_block

#method_before
private void initialize(ApplicationResources resources, ApplicationTemplates templates) {
    dataCenterVersionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).getValue();
        }
    });
    clusterCpuNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    // Optimization options.
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    optimizationCustomEditor.setVisible(false);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", getConstants().clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuOvercommitInfo = new InfoIcon(templates.italicFixedWidth("600px", getConstants().clusterPopupCpuOvercommitInfo()), resources);
}
#method_after
private void initialize(ApplicationResources resources, ApplicationTemplates templates) {
    dataCenterVersionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).getValue();
        }
    });
    clusterCpuNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    // Optimization options.
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    optimizationCustomEditor.setVisible(false);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", getConstants().clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", getConstants().clusterPopupCpuThreadsInfo()), resources);
}
#end_block

#method_before
void localize() {
    generalTab.setLabel(getConstants().hostPopupGeneralTabLabel());
    dataCenterButton.setText(getConstants().editText());
    dataCenterNameEditor.setLabel(getConstants().nameLabel());
    dataCenterDescriptionEditor.setLabel(getConstants().descriptionLabel());
    dataCenterVersionEditor.setLabel(getConstants().dataCenterPopupVersionLabel());
    clusterButton.setText(getConstants().editText());
    clusterNameEditor.setLabel(getConstants().clusterPopupNameLabel());
    clusterDescriptionEditor.setLabel(getConstants().clusterPopupDescriptionLabel());
    clusterCpuNameEditor.setLabel(getConstants().clusterPopupCPULabel());
    storageButton.setText(getConstants().editText());
    storageNameEditor.setLabel(getConstants().storagePopupNameLabel());
    pathLabel.setText(getConstants().configureLocalStoragePopupPathLabel());
    optimizationTab.setLabel(getConstants().clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(getConstants().clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(getConstants().clusterPopupOptimizationNoneLabel());
    cpuOvercommitPanelTitle.setText(getConstants().clusterPopupCpuOvercommitPanelTitle());
    countThreadsAsCoresEditor.setLabel(getConstants().clusterPopupCountThreadsAsCoresLabel());
}
#method_after
void localize() {
    generalTab.setLabel(getConstants().hostPopupGeneralTabLabel());
    dataCenterButton.setText(getConstants().editText());
    dataCenterNameEditor.setLabel(getConstants().nameLabel());
    dataCenterDescriptionEditor.setLabel(getConstants().descriptionLabel());
    dataCenterVersionEditor.setLabel(getConstants().dataCenterPopupVersionLabel());
    clusterButton.setText(getConstants().editText());
    clusterNameEditor.setLabel(getConstants().clusterPopupNameLabel());
    clusterDescriptionEditor.setLabel(getConstants().clusterPopupDescriptionLabel());
    clusterCpuNameEditor.setLabel(getConstants().clusterPopupCPULabel());
    storageButton.setText(getConstants().editText());
    storageNameEditor.setLabel(getConstants().storagePopupNameLabel());
    pathLabel.setText(getConstants().configureLocalStoragePopupPathLabel());
    optimizationTab.setLabel(getConstants().clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(getConstants().clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(getConstants().clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(getConstants().clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(getConstants().clusterPopupCountThreadsAsCoresLabel());
}
#end_block

#method_before
@Override
public void edit(final ConfigureLocalStorageModel model) {
    Driver.driver.edit(model);
    dataCenterNameEditor.setEnabled(false);
    clusterNameEditor.setEnabled(false);
    storageNameEditor.setEnabled(false);
    optimizationForServerFormatter(model);
    optimizationForDesktopFormatter(model);
    optimizationCustomFormatter(model);
    model.getCluster().getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(model);
        }
    });
    model.getCluster().getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(model);
        }
    });
    model.getCluster().getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) model.getCluster().getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(model);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    model.getCluster().getVersionSupportsCPUOvercommit().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuOvercommitPanel.setVisible((Boolean) model.getCluster().getVersionSupportsCPUOvercommit().getEntity());
        }
    });
}
#method_after
@Override
public void edit(final ConfigureLocalStorageModel model) {
    Driver.driver.edit(model);
    dataCenterNameEditor.setEnabled(false);
    clusterNameEditor.setEnabled(false);
    storageNameEditor.setEnabled(false);
    optimizationForServerFormatter(model);
    optimizationForDesktopFormatter(model);
    optimizationCustomFormatter(model);
    model.getCluster().getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(model);
        }
    });
    model.getCluster().getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(model);
        }
    });
    model.getCluster().getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) model.getCluster().getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(model);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    model.getCluster().getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) model.getCluster().getVersionSupportsCpuThreads().getEntity());
        }
    });
}
#end_block

#method_before
private void optimizationCustomFormatter(ConfigureLocalStorageModel model) {
    if (model.getCluster() != null && model.getCluster().getOptimizationCustom() != null && model.getCluster().getOptimizationCustom().getEntity() != null) {
        // use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(getMessages().clusterPopupMemoryOptimizationCustomLabel(String.valueOf(model.getCluster().getMemoryOverCommit())));
    }
}
#method_after
private void optimizationCustomFormatter(ConfigureLocalStorageModel model) {
    if (model.getCluster() != null && model.getCluster().getOptimizationCustom() != null && model.getCluster().getOptimizationCustom().getEntity() != null) {
        // Use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(getMessages().clusterPopupMemoryOptimizationCustomLabel(String.valueOf(model.getCluster().getMemoryOverCommit())));
    }
}
#end_block

#method_before
@Test
public void testCanDoAction() {
    expectGetStoragePool(STORAGE_POOL_ID);
    expectGetStorageDomain(STORAGE_DOMAIN_ID, STORAGE_POOL_ID, StorageDomainType.Data, StorageType.NFS);
    expectGetVds(VDS_ID);
    expectGetIsoMap(STORAGE_DOMAIN_ID);
    expectBusinessEntitySnapshotDAO();
    RemoveStorageDomainCommand<RemoveStorageDomainParameters> cmd = createCommand(true);
    assertTrue(cmd.canDoAction());
    checkSucceeded(cmd, false);
    cmd.setActionMessageParameters();
    checkMessages(cmd, VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN, VdcBllMessages.VAR__ACTION__REMOVE);
}
#method_after
@Test
public void testCanDoAction() {
    expectGetStoragePool(STORAGE_POOL_ID);
    expectGetStorageDomain(STORAGE_DOMAIN_ID, STORAGE_POOL_ID, StorageDomainType.Data, StorageType.NFS);
    expectGetVds(VDS_ID);
    expectGetIsoMap(STORAGE_DOMAIN_ID);
    expectBusinessEntitySnapshotDAO();
    RemoveStorageDomainCommand<RemoveStorageDomainParameters> cmd = createCommand(true);
    assertTrue(cmd.canDoAction());
    checkSucceeded(cmd, false);
    assertEquals("Wrong number of messages", 0, cmd.getReturnValue().getCanDoActionMessages().size());
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    command.setActionMessageParameters();
    List<String> messages = command.getReturnValue().getCanDoActionMessages();
    assertEquals("Wrong number of messages", 3, messages.size());
    assertEquals("Wrong message", VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.name(), messages.get(0));
    assertEquals("Wrong message", VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN.name(), messages.get(1));
    assertEquals("Wrong message", VdcBllMessages.VAR__ACTION__REMOVE.name(), messages.get(2));
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    checkMessages(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
public void initQuotaList(ResourcesModel model) {
    List<QuotaPerUserUsageEntity> list = (List<QuotaPerUserUsageEntity>) model.getUsedQuotaPercentage().getEntity();
    QuotaPerUserUsageEntity aggregatedUsage = new QuotaPerUserUsageEntity(Guid.Empty, "", 0, 0, 0, 0, 0, 0);
    boolean unlimitedVcpu = false;
    boolean unlimitedMem = false;
    boolean unlimitedStorage = false;
    if (list != null) {
        cpusQuotasList.clear();
        memoryQuotasList.clear();
        storageQuotasList.clear();
        cpusQuotasList.setSpacing(7);
        memoryQuotasList.setSpacing(7);
        storageQuotasList.setSpacing(7);
        for (QuotaPerUserUsageEntity quotaPerUserUsageEntity : list) {
            unlimitedMem |= quotaPerUserUsageEntity.isUnlimitedMemory();
            unlimitedStorage |= quotaPerUserUsageEntity.isUnlimitedStorage();
            unlimitedVcpu |= quotaPerUserUsageEntity.isUnlimitedVcpu();
            aggregate(aggregatedUsage, quotaPerUserUsageEntity);
            addQuotaToVcpuQuotaList(quotaPerUserUsageEntity);
            addQuotaToMemoryQuotaList(quotaPerUserUsageEntity);
            addQuotaToStorageQuotaList(quotaPerUserUsageEntity);
        }
        if (unlimitedVcpu) {
            cpusProgressBar.setUnlimited(true);
        } else {
            cpusProgressBar.setValueA((int) aggregatedUsage.getOthersVcpuUsagePercentage());
            cpusProgressBar.setValueB((int) aggregatedUsage.getUserVcpuUsagePercentage());
            cpusProgressBar.setTitle(messages.quotaFreeCpus(aggregatedUsage.getFreeVcpu()));
        }
        if (unlimitedMem) {
            memoryProgressBar.setUnlimited(true);
        } else {
            memoryProgressBar.setValueA((int) aggregatedUsage.getOthersMemoryUsagePercentage());
            memoryProgressBar.setValueB((int) aggregatedUsage.getUserMemoryUsagePercentage());
            String freeMem = aggregatedUsage.getFreeMemory() > 4096 ? // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() + "MB";
            memoryProgressBar.setTitle(constants.freeMemory() + freeMem);
        }
        if (unlimitedStorage) {
            storageProgressBar.setUnlimited(true);
        } else {
            storageProgressBar.setValueA((int) aggregatedUsage.getOthersStorageUsagePercentage());
            storageProgressBar.setValueB((int) aggregatedUsage.getUserStorageUsagePercentage());
            String freeStorage = aggregatedUsage.getFreeStorage() == 0 ? // $NON-NLS-1$
            "0" : diskSizeRenderer.render(aggregatedUsage.getFreeStorage());
            storageProgressBar.setTitle(constants.freeStorage() + freeStorage);
        }
        // $NON-NLS-1$  //$NON-NLS-2$
        vcpuExpander.setTitleWhenCollapsed(constants.showQuotaDistribution() + " (" + list.size() + ")");
    }
}
#method_after
public void initQuotaList(ResourcesModel model) {
    List<QuotaUsagePerUser> list = (List<QuotaUsagePerUser>) model.getUsedQuotaPercentage().getEntity();
    QuotaUsagePerUser aggregatedUsage = new QuotaUsagePerUser(Guid.Empty, "", 0, 0, 0, 0, 0, 0);
    boolean unlimitedVcpu = false;
    boolean unlimitedMem = false;
    boolean unlimitedStorage = false;
    if (list != null) {
        cpusQuotasList.clear();
        memoryQuotasList.clear();
        storageQuotasList.clear();
        cpusQuotasList.setSpacing(7);
        memoryQuotasList.setSpacing(7);
        storageQuotasList.setSpacing(7);
        for (QuotaUsagePerUser quotaPerUserUsageEntity : list) {
            unlimitedMem |= quotaPerUserUsageEntity.isUnlimitedMemory();
            unlimitedStorage |= quotaPerUserUsageEntity.isUnlimitedStorage();
            unlimitedVcpu |= quotaPerUserUsageEntity.isUnlimitedVcpu();
            aggregate(aggregatedUsage, quotaPerUserUsageEntity);
            addQuotaToVcpuQuotaList(quotaPerUserUsageEntity);
            addQuotaToMemoryQuotaList(quotaPerUserUsageEntity);
            addQuotaToStorageQuotaList(quotaPerUserUsageEntity);
        }
        if (unlimitedVcpu) {
            cpusProgressBar.setUnlimited(true);
        } else {
            cpusProgressBar.setValueA((int) aggregatedUsage.getOthersVcpuUsagePercentage());
            cpusProgressBar.setValueB((int) aggregatedUsage.getUserVcpuUsagePercentage());
            cpusProgressBar.setTitle(messages.quotaFreeCpus(aggregatedUsage.getFreeVcpu()));
        }
        if (unlimitedMem) {
            memoryProgressBar.setUnlimited(true);
        } else {
            memoryProgressBar.setValueA((int) aggregatedUsage.getOthersMemoryUsagePercentage());
            memoryProgressBar.setValueB((int) aggregatedUsage.getUserMemoryUsagePercentage());
            String freeMem = aggregatedUsage.getFreeMemory() > 4096 ? // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() + "MB";
            memoryProgressBar.setTitle(constants.freeMemory() + freeMem);
        }
        if (unlimitedStorage) {
            storageProgressBar.setUnlimited(true);
        } else {
            storageProgressBar.setValueA((int) aggregatedUsage.getOthersStorageUsagePercentage());
            storageProgressBar.setValueB((int) aggregatedUsage.getUserStorageUsagePercentage());
            String freeStorage = aggregatedUsage.getFreeStorage() == 0 ? // $NON-NLS-1$
            "0" : diskSizeRenderer.render(aggregatedUsage.getFreeStorage());
            storageProgressBar.setTitle(constants.freeStorage() + freeStorage);
        }
        // $NON-NLS-1$  //$NON-NLS-2$
        vcpuExpander.setTitleWhenCollapsed(constants.showQuotaDistribution() + " (" + list.size() + ")");
    }
}
#end_block

#method_before
private void addQuotaToVcpuQuotaList(QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    QuotaProgressBar vcpuQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedVcpu()) {
        vcpuQuotaProgressBar.setUnlimited(true);
    } else {
        vcpuQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersVcpuUsagePercentage());
        vcpuQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserVcpuUsagePercentage());
        vcpuQuotaProgressBar.setTitle(messages.quotaFreeCpus(quotaPerUserUsageEntity.getFreeVcpu()));
        if (quotaPerUserUsageEntity.getVcpuTotalUsage() == 0) {
            vcpuQuotaProgressBar.setZeroValue();
        }
    }
    VerticalPanel verticalPanel = new VerticalPanel();
    Label quotaName = new Label();
    quotaName.setText(quotaPerUserUsageEntity.getQuotaName());
    verticalPanel.add(quotaName);
    verticalPanel.add(vcpuQuotaProgressBar);
    // $NON-NLS-1$
    verticalPanel.setWidth("100%");
    cpusQuotasList.add(verticalPanel);
}
#method_after
private void addQuotaToVcpuQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar vcpuQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedVcpu()) {
        vcpuQuotaProgressBar.setUnlimited(true);
    } else {
        vcpuQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersVcpuUsagePercentage());
        vcpuQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserVcpuUsagePercentage());
        vcpuQuotaProgressBar.setTitle(messages.quotaFreeCpus(quotaPerUserUsageEntity.getFreeVcpu()));
        if (quotaPerUserUsageEntity.getVcpuTotalUsage() == 0) {
            vcpuQuotaProgressBar.setZeroValue();
        }
    }
    addQuotaRow(cpusQuotasList, quotaPerUserUsageEntity.getQuotaName(), vcpuQuotaProgressBar);
}
#end_block

#method_before
private void addQuotaToMemoryQuotaList(QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    QuotaProgressBar memoryQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedMemory()) {
        memoryQuotaProgressBar.setUnlimited(true);
    } else {
        memoryQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersMemoryUsagePercentage());
        memoryQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserMemoryUsagePercentage());
        String freeMem = quotaPerUserUsageEntity.getFreeMemory() > 4096 ? // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() + "MB";
        memoryQuotaProgressBar.setTitle(constants.freeMemory() + freeMem);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            memoryQuotaProgressBar.setZeroValue();
        }
    }
    VerticalPanel verticalPanel = new VerticalPanel();
    Label quotaName = new Label();
    quotaName.setText(quotaPerUserUsageEntity.getQuotaName());
    verticalPanel.add(quotaName);
    verticalPanel.add(memoryQuotaProgressBar);
    // $NON-NLS-1$
    verticalPanel.setWidth("100%");
    memoryQuotasList.add(verticalPanel);
}
#method_after
private void addQuotaToMemoryQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar memoryQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedMemory()) {
        memoryQuotaProgressBar.setUnlimited(true);
    } else {
        memoryQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersMemoryUsagePercentage());
        memoryQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserMemoryUsagePercentage());
        String freeMem = quotaPerUserUsageEntity.getFreeMemory() > 4096 ? // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() + "MB";
        memoryQuotaProgressBar.setTitle(constants.freeMemory() + freeMem);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            memoryQuotaProgressBar.setZeroValue();
        }
    }
    addQuotaRow(memoryQuotasList, quotaPerUserUsageEntity.getQuotaName(), memoryQuotaProgressBar);
}
#end_block

#method_before
private void addQuotaToStorageQuotaList(QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    QuotaProgressBar storageQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedStorage()) {
        storageQuotaProgressBar.setUnlimited(true);
    } else {
        storageQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersStorageUsagePercentage());
        storageQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserStorageUsagePercentage());
        String freeStorage = quotaPerUserUsageEntity.getFreeStorage() == 0 ? // $NON-NLS-1$
        "0" : diskSizeRenderer.render(quotaPerUserUsageEntity.getFreeStorage());
        storageQuotaProgressBar.setTitle(constants.freeStorage() + freeStorage);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            storageQuotaProgressBar.setZeroValue();
        }
    }
    VerticalPanel verticalPanel = new VerticalPanel();
    Label quotaName = new Label();
    quotaName.setText(quotaPerUserUsageEntity.getQuotaName());
    verticalPanel.add(quotaName);
    verticalPanel.add(storageQuotaProgressBar);
    // $NON-NLS-1$
    verticalPanel.setWidth("100%");
    storageQuotasList.add(verticalPanel);
}
#method_after
private void addQuotaToStorageQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar storageQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedStorage()) {
        storageQuotaProgressBar.setUnlimited(true);
    } else {
        storageQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersStorageUsagePercentage());
        storageQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserStorageUsagePercentage());
        String freeStorage = quotaPerUserUsageEntity.getFreeStorage() == 0 ? // $NON-NLS-1$
        "0" : diskSizeRenderer.render(quotaPerUserUsageEntity.getFreeStorage());
        storageQuotaProgressBar.setTitle(constants.freeStorage() + freeStorage);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            storageQuotaProgressBar.setZeroValue();
        }
    }
    addQuotaRow(storageQuotasList, quotaPerUserUsageEntity.getQuotaName(), storageQuotaProgressBar);
}
#end_block

#method_before
private void aggregate(QuotaPerUserUsageEntity aggregatedUsage, QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    aggregatedUsage.setVcpuLimit(quotaPerUserUsageEntity.getVcpuLimit() + aggregatedUsage.getVcpuLimit());
    aggregatedUsage.setVcpuUsageForUser(quotaPerUserUsageEntity.getVcpuUsageForUser() + aggregatedUsage.getVcpuUsageForUser());
    aggregatedUsage.setVcpuTotalUsage(quotaPerUserUsageEntity.getVcpuTotalUsage() + aggregatedUsage.getVcpuTotalUsage());
    aggregatedUsage.setMemoryLimit(quotaPerUserUsageEntity.getMemoryLimit() + aggregatedUsage.getMemoryLimit());
    aggregatedUsage.setMemoryUsageForUser(quotaPerUserUsageEntity.getMemoryUsageForUser() + aggregatedUsage.getMemoryUsageForUser());
    aggregatedUsage.setMemoryTotalUsage(quotaPerUserUsageEntity.getMemoryTotalUsage() + aggregatedUsage.getMemoryTotalUsage());
    aggregatedUsage.setStorageLimit(quotaPerUserUsageEntity.getStorageLimit() + aggregatedUsage.getStorageLimit());
    aggregatedUsage.setStorageUsageForUser(quotaPerUserUsageEntity.getStorageUsageForUser() + aggregatedUsage.getStorageUsageForUser());
    aggregatedUsage.setStorageTotalUsage(quotaPerUserUsageEntity.getStorageTotalUsage() + aggregatedUsage.getStorageTotalUsage());
}
#method_after
private void aggregate(QuotaUsagePerUser aggregatedUsage, QuotaUsagePerUser quotaPerUserUsageEntity) {
    aggregatedUsage.setVcpuLimit(quotaPerUserUsageEntity.getVcpuLimit() + aggregatedUsage.getVcpuLimit());
    aggregatedUsage.setVcpuUsageForUser(quotaPerUserUsageEntity.getVcpuUsageForUser() + aggregatedUsage.getVcpuUsageForUser());
    aggregatedUsage.setVcpuTotalUsage(quotaPerUserUsageEntity.getVcpuTotalUsage() + aggregatedUsage.getVcpuTotalUsage());
    aggregatedUsage.setMemoryLimit(quotaPerUserUsageEntity.getMemoryLimit() + aggregatedUsage.getMemoryLimit());
    aggregatedUsage.setMemoryUsageForUser(quotaPerUserUsageEntity.getMemoryUsageForUser() + aggregatedUsage.getMemoryUsageForUser());
    aggregatedUsage.setMemoryTotalUsage(quotaPerUserUsageEntity.getMemoryTotalUsage() + aggregatedUsage.getMemoryTotalUsage());
    aggregatedUsage.setStorageLimit(quotaPerUserUsageEntity.getStorageLimit() + aggregatedUsage.getStorageLimit());
    aggregatedUsage.setStorageUsageForUser(quotaPerUserUsageEntity.getStorageUsageForUser() + aggregatedUsage.getStorageUsageForUser());
    aggregatedUsage.setStorageTotalUsage(quotaPerUserUsageEntity.getStorageTotalUsage() + aggregatedUsage.getStorageTotalUsage());
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            ResourcesModel resourcesModel = (ResourcesModel) model;
            ArrayList<VM> list = (ArrayList<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            // TODO: Insert dummy data regarding disks and snapshots.
            for (VM vm : list) {
            // vm.DiskList =
            // new[]
            // {
            // new DiskImage
            // {
            // internal_drive_mapping = "1",
            // SizeInGigabytes = 100,
            // ActualSize = 50,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage()
            // }
            // },
            // new DiskImage
            // {
            // internal_drive_mapping = "2",
            // SizeInGigabytes = 200,
            // ActualSize = 80,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage(),
            // new DiskImage()
            // }
            // }
            // };
            }
            // Update calculated properties.
            int runningVMs = 0;
            int definedCPUs = 0;
            int usedCPUs = 0;
            int definedMemory = 0;
            int usedMemory = 0;
            long totalDisksSize = 0;
            long totalSnapshotsSize = 0;
            int numOfSnapshots = 0;
            for (VM vm : list) {
                definedCPUs += vm.getNumOfCpus();
                definedMemory += vm.getVmMemSizeMb();
                if (vm.isStatusUp()) {
                    runningVMs++;
                    usedCPUs += vm.getNumOfCpus();
                    usedMemory += vm.getVmMemSizeMb();
                }
                if (vm.getDiskList() != null) {
                    for (DiskImage disk : vm.getDiskList()) {
                        totalDisksSize += disk.getSizeInGigabytes();
                        totalSnapshotsSize += (long) disk.getActualDiskWithSnapshotsSize();
                        numOfSnapshots += disk.getSnapshots().size();
                    }
                }
            }
            getDefinedVMs().setEntity(list.size());
            getRunningVMs().setEntity(runningVMs);
            getRunningVMsPercentage().setEntity(list.isEmpty() ? 0 : runningVMs * 100 / list.size());
            getDefinedCPUs().setEntity(definedCPUs);
            getUsedCPUs().setEntity(usedCPUs);
            getUsedCPUsPercentage().setEntity(usedCPUs * 100 / definedCPUs);
            getDefinedMemory().setEntity(SizeParser(definedMemory));
            getUsedMemory().setEntity(SizeParser(usedMemory));
            getUsedMemoryPercentage().setEntity(usedMemory * 100 / definedMemory);
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalDisksSize().setEntity(totalDisksSize >= 1 ? totalDisksSize + "GB" : "<1GB");
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalSnapshotsSize().setEntity(totalSnapshotsSize >= 1 ? totalSnapshotsSize + "GB" : "<1GB");
            getNumOfSnapshots().setEntity(numOfSnapshots);
            Collections.sort(list, COMPARATOR);
            resourcesModel.setItems(list);
            // async Query for quota
            AsyncQuery _asyncQueryForQuota = new AsyncQuery();
            _asyncQueryForQuota.setModel(this);
            GetQuotasByAdElementIdQueryParameters parameters = new GetQuotasByAdElementIdQueryParameters();
            // parameters.setAdElementId(new Guid(Frontend.getLoggedInUser().getGroupIds()));    //TODO
            parameters.setRefresh(getIsQueryFirstTime());
            parameters.setIncludeUsageData(true);
            parameters.setVms(list);
            Frontend.RunQuery(VdcQueryType.GetQuotasByAdElementId, parameters, new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model, Object ReturnValue) {
                    getUsedQuotaPercentage().setEntity(((VdcQueryReturnValue) ReturnValue).getReturnValue());
                }
            }));
        }
    };
    // Items property will contain list of VMs.
    GetUserVmsByUserIdAndGroupsParameters getUserVmsByUserIdAndGroupsParameters = new GetUserVmsByUserIdAndGroupsParameters(Frontend.getLoggedInUser().getUserId());
    getUserVmsByUserIdAndGroupsParameters.setIncludeDiskData(true);
    getUserVmsByUserIdAndGroupsParameters.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetUserVmsByUserIdAndGroups, getUserVmsByUserIdAndGroupsParameters, _asyncQuery);
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            ResourcesModel resourcesModel = (ResourcesModel) model;
            ArrayList<VM> list = (ArrayList<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            // TODO: Insert dummy data regarding disks and snapshots.
            for (VM vm : list) {
            // vm.DiskList =
            // new[]
            // {
            // new DiskImage
            // {
            // internal_drive_mapping = "1",
            // SizeInGigabytes = 100,
            // ActualSize = 50,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage()
            // }
            // },
            // new DiskImage
            // {
            // internal_drive_mapping = "2",
            // SizeInGigabytes = 200,
            // ActualSize = 80,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage(),
            // new DiskImage()
            // }
            // }
            // };
            }
            // Update calculated properties.
            int runningVMs = 0;
            int definedCPUs = 0;
            int usedCPUs = 0;
            int definedMemory = 0;
            int usedMemory = 0;
            long totalDisksSize = 0;
            long totalSnapshotsSize = 0;
            int numOfSnapshots = 0;
            for (VM vm : list) {
                definedCPUs += vm.getNumOfCpus();
                definedMemory += vm.getVmMemSizeMb();
                if (vm.isStatusUp()) {
                    runningVMs++;
                    usedCPUs += vm.getNumOfCpus();
                    usedMemory += vm.getVmMemSizeMb();
                }
                if (vm.getDiskList() != null) {
                    for (DiskImage disk : vm.getDiskList()) {
                        totalDisksSize += disk.getSizeInGigabytes();
                        totalSnapshotsSize += (long) disk.getActualDiskWithSnapshotsSize();
                        numOfSnapshots += disk.getSnapshots().size();
                    }
                }
            }
            getDefinedVMs().setEntity(list.size());
            getRunningVMs().setEntity(runningVMs);
            getRunningVMsPercentage().setEntity(list.isEmpty() ? 0 : runningVMs * 100 / list.size());
            getDefinedCPUs().setEntity(definedCPUs);
            getUsedCPUs().setEntity(usedCPUs);
            getUsedCPUsPercentage().setEntity(usedCPUs * 100 / definedCPUs);
            getDefinedMemory().setEntity(SizeParser(definedMemory));
            getUsedMemory().setEntity(SizeParser(usedMemory));
            getUsedMemoryPercentage().setEntity(usedMemory * 100 / definedMemory);
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalDisksSize().setEntity(totalDisksSize >= 1 ? totalDisksSize + "GB" : "<1GB");
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalSnapshotsSize().setEntity(totalSnapshotsSize >= 1 ? totalSnapshotsSize + "GB" : "<1GB");
            getNumOfSnapshots().setEntity(numOfSnapshots);
            Collections.sort(list, COMPARATOR);
            resourcesModel.setItems(list);
        }
    };
    // async Query for quota
    AsyncQuery _asyncQueryForQuota = new AsyncQuery();
    _asyncQueryForQuota.setModel(this);
    GetQuotasConsumptionForCurrentUserQueryParameters parameters = new GetQuotasConsumptionForCurrentUserQueryParameters();
    parameters.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetQuotasConsumptionForCurrentUser, parameters, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            getUsedQuotaPercentage().setEntity(((VdcQueryReturnValue) ReturnValue).getReturnValue());
        }
    }));
    // Items property will contain list of VMs.
    GetUserVmsByUserIdAndGroupsParameters getUserVmsByUserIdAndGroupsParameters = new GetUserVmsByUserIdAndGroupsParameters(Frontend.getLoggedInUser().getUserId());
    getUserVmsByUserIdAndGroupsParameters.setIncludeDiskData(true);
    getUserVmsByUserIdAndGroupsParameters.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetUserVmsByUserIdAndGroups, getUserVmsByUserIdAndGroupsParameters, _asyncQuery);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, true, true, true, false, true, true, disksList) && canDoSnapshot(getVm());
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && canDoSnapshot(getVm()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, true, true, true, false, true, true, disksList);
    }
    return result;
}
#end_block

#method_before
private boolean canDoSnapshot(VM vm) {
    // if version is 3.0 - live snapshot is not available, thus if vm is up snapshot is not possible so it needs to be
    // checked if it's up or not
    // if version is 3.1,  there is no need to check if vm is up since in any case snapshot is possible
    boolean canSnapshot = true;
    if (!isLiveSnapshotEnabled() && !ImagesHandler.isVmDown(vm)) {
        // if there is no live snapshot and the vm is up - snapshot is not possible
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_VERSION_DOESNT_SUPPORT_LIVE_SNAPSHOT);
        canSnapshot = false;
    }
    return canSnapshot;
}
#method_after
private boolean canDoSnapshot(VM vm) {
    // if live snapshot is enabled, there is no need to check if vm is up since in any case snapshot is possible
    if (!isLiveSnapshotEnabled() && !ImagesHandler.isVmDown(vm)) {
        // if there is no live snapshot and the vm is up - snapshot is not possible
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_VERSION_DOESNT_SUPPORT_LIVE_SNAPSHOT);
    }
    return true;
}
#end_block

#method_before
public static boolean setDiskAlias(BaseDisk disk, VM vm) {
    if (disk != null) {
        String vmName = "";
        int count = 1;
        if (vm != null) {
            vmName = vm.getVmName();
            count = vm.getDiskMapCount() + 1;
        }
        disk.setDiskAlias(getSuggestedDiskAlias(disk, vmName, count));
        return true;
    } else {
        log.errorFormat("Disk object is null");
        return false;
    }
}
#method_after
public static boolean setDiskAlias(BaseDisk disk, VM vm) {
    return setDiskAlias(disk, vm, nullSafeGetCount(vm));
}
#end_block

#method_before
public static boolean setDiskAlias(BaseDisk disk, VM vm) {
    if (disk != null) {
        String vmName = "";
        int count = 1;
        if (vm != null) {
            vmName = vm.getVmName();
            count = vm.getDiskMapCount() + 1;
        }
        disk.setDiskAlias(getSuggestedDiskAlias(disk, vmName, count));
        return true;
    } else {
        log.errorFormat("Disk object is null");
        return false;
    }
}
#method_after
public static boolean setDiskAlias(BaseDisk disk, VM vm, int count) {
    if (disk == null) {
        log.error("Disk object is null");
        return false;
    }
    String vmName = nullSafeGetVmName(vm);
    disk.setDiskAlias(getSuggestedDiskAlias(disk, vmName, count));
    return true;
}
#end_block

#method_before
public static boolean CheckImageConfiguration(storage_domain_static storageDomain, DiskImageBase diskInfo, List<String> messages) {
    boolean result = true;
    if ((diskInfo.getvolume_type() == VolumeType.Preallocated && diskInfo.getvolume_format() == VolumeFormat.COW) || ((storageDomain.getstorage_type() == StorageType.FCP || storageDomain.getstorage_type() == StorageType.ISCSI) && (diskInfo.getvolume_type() == VolumeType.Sparse && diskInfo.getvolume_format() == VolumeFormat.RAW)) || (diskInfo.getvolume_format() == VolumeFormat.Unassigned || diskInfo.getvolume_type() == VolumeType.Unassigned)) {
        // not supported
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED.toString());
    }
    return result;
}
#method_after
public static boolean CheckImageConfiguration(StorageDomainStatic storageDomain, DiskImageBase diskInfo, List<String> messages) {
    boolean result = true;
    if ((diskInfo.getvolume_type() == VolumeType.Preallocated && diskInfo.getvolume_format() == VolumeFormat.COW) || ((storageDomain.getstorage_type() == StorageType.FCP || storageDomain.getstorage_type() == StorageType.ISCSI) && (diskInfo.getvolume_type() == VolumeType.Sparse && diskInfo.getvolume_format() == VolumeFormat.RAW)) || (diskInfo.getvolume_format() == VolumeFormat.Unassigned || diskInfo.getvolume_type() == VolumeType.Unassigned)) {
        // not supported
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED.toString());
    }
    return result;
}
#end_block

#method_before
public static boolean CheckImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    boolean result = true;
    storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    for (Disk diskInfo : disksConfigList) {
        if (DiskStorageType.IMAGE == diskInfo.getDiskStorageType()) {
            result = CheckImageConfiguration(storageDomain, (DiskImage) diskInfo, messages);
        }
        if (!result)
            break;
    }
    return result;
}
#method_after
public static boolean CheckImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    boolean result = true;
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    for (Disk diskInfo : disksConfigList) {
        if (DiskStorageType.IMAGE == diskInfo.getDiskStorageType()) {
            result = CheckImageConfiguration(storageDomain, (DiskImage) diskInfo, messages);
        }
        if (!result)
            break;
    }
    return result;
}
#end_block

#method_before
public static boolean isStoragePoolValid(Guid storagePoolId) {
    boolean isValid = true;
    storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolId);
    if (pool == null || pool.getstatus() != StoragePoolStatus.Up) {
        isValid = false;
    }
    return isValid;
}
#method_after
public static boolean isStoragePoolValid(Guid storagePoolId) {
    storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolId);
    if (pool == null || pool.getstatus() != StoragePoolStatus.Up) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static void removeLunDisk(LunDisk lunDisk) {
    DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    DbFacade.getInstance().getDiskLunMapDao().remove(new DiskLunMapId(lunDisk.getId(), lun.getLUN_id()));
    DbFacade.getInstance().getBaseDiskDao().remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<storage_server_connections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
    if (!lun.getLunConnections().isEmpty()) {
        StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        StorageHelperDirector.getInstance().getItem(StorageType.FCP).removeLun(lun);
    }
}
#method_after
public static void removeLunDisk(LunDisk lunDisk) {
    DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    DbFacade.getInstance().getDiskLunMapDao().remove(new DiskLunMapId(lunDisk.getId(), lun.getLUN_id()));
    DbFacade.getInstance().getBaseDiskDao().remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<StorageServerConnections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
    if (!lun.getLunConnections().isEmpty()) {
        StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        StorageHelperDirector.getInstance().getItem(StorageType.FCP).removeLun(lun);
    }
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    // TODO
    hostCpuEditor.setLabel(constants.useHostCpu());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    hostCpuEditor.setLabel(constants.useHostCpu());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                highAvailabilityTab.setVisible((Boolean) vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if ((Boolean) vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesAvailable".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesTab.setVisible(vm.getIsCustomPropertiesAvailable());
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                disksAllocationPanel.setVisible(isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                storageAllocationPanel.setVisible(isProvisioningAvailable || isDisksAvailable);
                if (vm.getDisks() != null) {
                    for (DiskModel diskModel : vm.getDisks()) {
                        if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) diskModel.getDisk()).getimageStatus() == ImageStatus.ILLEGAL) {
                            generalWarningMessage.setText(constants.illegalDisksInVm());
                            return;
                        }
                    }
                }
            }
        }
    });
    // High Availability only avail in server mode
    highAvailabilityTab.setVisible(vm.getVmType().equals(VmType.Server));
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsLinux_Unassign_UnknownOS".equals(propName)) {
                // $NON-NLS-1$
                linuxBootOptionsPanel.setVisible(vm.getIsLinux_Unassign_UnknownOS());
            }
        }
    });
    // only avail for desktop mode
    isStatelessEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    numOfMonitorsEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    allowConsoleReconnectEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
    vm.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                highAvailabilityTab.setVisible((Boolean) vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if ((Boolean) vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                disksAllocationPanel.setVisible(isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                storageAllocationPanel.setVisible(isProvisioningAvailable || isDisksAvailable);
                if (vm.getDisks() != null) {
                    for (DiskModel diskModel : vm.getDisks()) {
                        if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) diskModel.getDisk()).getimageStatus() == ImageStatus.ILLEGAL) {
                            generalWarningMessage.setText(constants.illegalDisksInVm());
                            return;
                        }
                    }
                }
            }
        }
    });
    // High Availability only avail in server mode
    highAvailabilityTab.setVisible(vm.getVmType().equals(VmType.Server));
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsLinux_Unassign_UnknownOS".equals(propName)) {
                // $NON-NLS-1$
                linuxBootOptionsPanel.setVisible(vm.getIsLinux_Unassign_UnknownOS());
            }
        }
    });
    // only avail for desktop mode
    isStatelessEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    numOfMonitorsEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    allowConsoleReconnectEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
    vm.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = generalAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    runVMOnSpecificHostEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    dontMigrateVMEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = generalAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    runVMOnSpecificHostEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    dontMigrateVMEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getDontMigrateVM()) {
            DontMigrateVM_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#end_block

#method_before
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(DataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#method_after
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(DataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#method_after
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#end_block

#method_before
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (DataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || DataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid;
}
#method_after
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (AsyncDataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || AsyncDataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getdisplay_type() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (DataProvider.IsWindowsOsType(vm.getvm_os())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
private void Edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.setVmType(vm.getvm_type());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().editVmTitle(vm.getvm_type() == VmType.Server ? ConstantsManager.getInstance().getConstants().serverVmType() : ConstantsManager.getInstance().getConstants().desktopVmType()));
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    model.setHashName("edit_" + (vm.getvm_type() == VmType.Server ? "server" : "desktop"));
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.Initialize(this.getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void Edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.setVmType(vm.getVmType());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().editVmTitle(vm.getVmType() == VmType.Server ? ConstantsManager.getInstance().getConstants().serverVmType() : ConstantsManager.getInstance().getConstants().desktopVmType()));
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    model.setHashName("edit_" + (vm.getVmType() == VmType.Server ? "server" : "desktop"));
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.Initialize(this.getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> list = new ArrayList<String>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        list.add(a.getvm_name());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> list = new ArrayList<String>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        list.add(a.getVmName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected boolean entitiesSelectedOnDifferentDataCenters() {
    ArrayList<VM> vms = new ArrayList<VM>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        vms.add(a);
    }
    Map<NGuid, ArrayList<VM>> t = new HashMap<NGuid, ArrayList<VM>>();
    for (VM a : vms) {
        if (!t.containsKey(a.getstorage_pool_id())) {
            t.put(a.getstorage_pool_id(), new ArrayList<VM>());
        }
        ArrayList<VM> list = t.get(a.getstorage_pool_id());
        list.add(a);
    }
    return t.size() > 1;
}
#method_after
@Override
protected boolean entitiesSelectedOnDifferentDataCenters() {
    ArrayList<VM> vms = new ArrayList<VM>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        vms.add(a);
    }
    Map<NGuid, ArrayList<VM>> t = new HashMap<NGuid, ArrayList<VM>>();
    for (VM a : vms) {
        if (!t.containsKey(a.getStoragePoolId())) {
            t.put(a.getStoragePoolId(), new ArrayList<VM>());
        }
        ArrayList<VM> list = t.get(a.getStoragePoolId());
        list.add(a);
    }
    return t.size() > 1;
}
#end_block

#method_before
@Override
protected String extractNameFromEntity(VM entity) {
    return entity.getvm_name();
}
#method_after
@Override
protected String extractNameFromEntity(VM entity) {
    return entity.getVmName();
}
#end_block

#method_before
private void PostGetTemplatesNotPresentOnExportDomain(storage_pool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((storage_domains) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.GetAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getvmt_guid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getvmt_guid().equals(NGuid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getvmt_name())) {
                            templateDic.put(vm.getvmt_name(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getvmt_name()).add(vm.getvm_name());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    tempStr = "Template " + keyValuePair.getKey() + " (for ";
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        // $NON-NLS-1$
                        tempStr += tempList.get(i) + ", ";
                    }
                    // $NON-NLS-1$
                    tempStr += tempList.get(i) + ")";
                    missingTemplates.add(tempStr);
                }
                vmListModel.PostExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void PostGetTemplatesNotPresentOnExportDomain(storage_pool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((storage_domains) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.GetAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(NGuid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getVmName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    tempStr = "Template " + keyValuePair.getKey() + " (for ";
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        // $NON-NLS-1$
                        tempStr += tempList.get(i) + ", ";
                    }
                    // $NON-NLS-1$
                    tempStr += tempList.get(i) + ")";
                    missingTemplates.add(tempStr);
                }
                vmListModel.PostExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.getis_stateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getkernel_params());
    model.getKernel_path().setEntity(vm.getkernel_url());
    model.getInitrd_path().setEntity(vm.getinitrd_url());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getvds_group_compatibility_version()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getvds_group_compatibility_version()));
    model.setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(vm.getvm_os()) || vm.getvm_os() == VmOsType.Unassigned || vm.getvm_os() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(DataProvider.IsWindowsOsType(vm.getvm_os()));
    model.getIsVmFirstRun().setEntity(!vm.getis_initialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getvm_domain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void RunOnceUpdateDisplayProtocols(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    boolean isVncSelected = vm.getdefault_display_type() == DisplayType.vnc;
    model.getDisplayConsole_Vnc_IsSelected().setEntity(isVncSelected);
    model.getDisplayConsole_Spice_IsSelected().setEntity(!isVncSelected);
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(isVncSelected ? vncProtocol : qxlProtocol);
}
#method_after
private void RunOnceUpdateDisplayProtocols(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    boolean isVncSelected = vm.getDefaultDisplayType() == DisplayType.vnc;
    model.getDisplayConsole_Vnc_IsSelected().setEntity(isVncSelected);
    model.getDisplayConsole_Spice_IsSelected().setEntity(!isVncSelected);
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(isVncSelected ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
public void RunOnceUpdateFloppy(VM vm, ArrayList<String> images) {
    RunOnceModel model = (RunOnceModel) getWindow();
    if (DataProvider.IsWindowsOsType(vm.getvm_os())) {
        // Add a pseudo floppy disk image used for Windows' sysprep.
        if (!vm.getis_initialized()) {
            // $NON-NLS-1$
            images.add(0, "[sysprep]");
            model.getAttachFloppy().setEntity(true);
        } else {
            // $NON-NLS-1$
            images.add("[sysprep]");
        }
    }
    model.getFloppyImage().setItems(images);
    if (model.getFloppyImage().getIsChangable() && model.getFloppyImage().getSelectedItem() == null) {
        model.getFloppyImage().setSelectedItem(Linq.FirstOrDefault(images));
    }
}
#method_after
public void RunOnceUpdateFloppy(VM vm, ArrayList<String> images) {
    RunOnceModel model = (RunOnceModel) getWindow();
    if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
        // Add a pseudo floppy disk image used for Windows' sysprep.
        if (!vm.isInitialized()) {
            // $NON-NLS-1$
            images.add(0, "[sysprep]");
            model.getAttachFloppy().setEntity(true);
        } else {
            // $NON-NLS-1$
            images.add("[sysprep]");
        }
    }
    model.getFloppyImage().setItems(images);
    if (model.getFloppyImage().getIsChangable() && model.getFloppyImage().getSelectedItem() == null) {
        model.getFloppyImage().setSelectedItem(Linq.FirstOrDefault(images));
    }
}
#end_block

#method_before
private void RunOnceUpdateImages(VM vm) {
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model2, Object result) {
            VmListModel vmListModel2 = (VmListModel) model2;
            VM selectedVM = (VM) vmListModel2.getSelectedItem();
            ArrayList<String> images = (ArrayList<String>) result;
            vmListModel2.RunOnceUpdateFloppy(selectedVM, images);
        }
    };
    AsyncDataProvider.GetFloppyImageList(_asyncQuery2, vm.getstorage_pool_id());
    AsyncQuery getImageListQuery = new AsyncQuery();
    getImageListQuery.setModel(this);
    getImageListQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            VmListModel vmListModel1 = (VmListModel) model1;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel1.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            runOnceModel.getIsoImage().setItems(images);
            if (runOnceModel.getIsoImage().getIsChangable() && runOnceModel.getIsoImage().getSelectedItem() == null) {
                runOnceModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getImageListQuery, vm.getstorage_pool_id());
}
#method_after
private void RunOnceUpdateImages(VM vm) {
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model2, Object result) {
            VmListModel vmListModel2 = (VmListModel) model2;
            VM selectedVM = (VM) vmListModel2.getSelectedItem();
            ArrayList<String> images = (ArrayList<String>) result;
            vmListModel2.RunOnceUpdateFloppy(selectedVM, images);
        }
    };
    AsyncDataProvider.GetFloppyImageList(_asyncQuery2, vm.getStoragePoolId());
    AsyncQuery getImageListQuery = new AsyncQuery();
    getImageListQuery.setModel(this);
    getImageListQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            VmListModel vmListModel1 = (VmListModel) model1;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel1.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            runOnceModel.getIsoImage().setItems(images);
            if (runOnceModel.getIsoImage().getIsChangable() && runOnceModel.getIsoImage().getSelectedItem() == null) {
                runOnceModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getImageListQuery, vm.getStoragePoolId());
}
#end_block

#method_before
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getvm_type());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#method_after
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#end_block

#method_before
public void PostNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setvm_type(model.getVmType());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setvm_os((VmOsType) model.getOSType().getSelectedItem());
    tempVar.setnum_of_monitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setvm_domain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setvm_mem_size_mb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setvds_group_id(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    tempVar.settime_zone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    tempVar.setnum_of_sockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setcpu_per_socket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setis_auto_suspend(false);
    tempVar.setis_stateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setdefault_boot_sequence(model.getBootSequence());
    tempVar.setauto_startup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setiso_path(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setusb_policy(vm.getusb_policy());
    tempVar.setinitrd_url(vm.getinitrd_url());
    tempVar.setkernel_url(vm.getkernel_url());
    tempVar.setkernel_params(vm.getkernel_params());
    tempVar.setdedicated_vm_for_vds(vm.getdedicated_vm_for_vds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setdefault_display_type((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setpriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()));
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().StopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.Cancel();
            }
        }
    }, this);
}
#method_after
public void PostNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((VmOsType) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setAutoSuspend(false);
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()));
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().StopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.Cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void Migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>Cast(getSelectedItems()));
    AsyncDataProvider.GetUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.PostMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getvds_group_name());
}
#method_after
private void Migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>Cast(getSelectedItems()));
    AsyncDataProvider.GetUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.PostMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void PostMigrateGetUpHosts(ArrayList<VDS> hosts) {
    MigrateModel model = (MigrateModel) getWindow();
    NGuid run_on_vds = null;
    boolean allRunOnSameVds = true;
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        if (!a.getvds_group_id().equals(((VM) getSelectedItems().get(0)).getvds_group_id())) {
            model.setVmsOnSameCluster(false);
        }
        if (run_on_vds == null) {
            run_on_vds = a.getrun_on_vds().getValue();
        } else if (allRunOnSameVds && !run_on_vds.equals(a.getrun_on_vds().getValue())) {
            allRunOnSameVds = false;
        }
    }
    model.setIsHostSelAvailable(model.getVmsOnSameCluster() && hosts.size() > 0);
    if (model.getVmsOnSameCluster() && allRunOnSameVds) {
        VDS runOnSameVDS = null;
        for (VDS host : hosts) {
            if (host.getId().equals(run_on_vds)) {
                runOnSameVDS = host;
            }
        }
        hosts.remove(runOnSameVDS);
    }
    if (hosts.isEmpty()) {
        model.setIsHostSelAvailable(false);
        if (allRunOnSameVds) {
            model.setNoSelAvailable(true);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    } else {
        model.getHosts().setItems(hosts);
        model.getHosts().setSelectedItem(Linq.FirstOrDefault(hosts));
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnMigrate", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", this);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        model.getCommands().add(tempVar3);
    }
}
#method_after
private void PostMigrateGetUpHosts(ArrayList<VDS> hosts) {
    MigrateModel model = (MigrateModel) getWindow();
    NGuid run_on_vds = null;
    boolean allRunOnSameVds = true;
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        if (!a.getVdsGroupId().equals(((VM) getSelectedItems().get(0)).getVdsGroupId())) {
            model.setVmsOnSameCluster(false);
        }
        if (run_on_vds == null) {
            run_on_vds = a.getRunOnVds().getValue();
        } else if (allRunOnSameVds && !run_on_vds.equals(a.getRunOnVds().getValue())) {
            allRunOnSameVds = false;
        }
    }
    model.setIsHostSelAvailable(model.getVmsOnSameCluster() && hosts.size() > 0);
    if (model.getVmsOnSameCluster() && allRunOnSameVds) {
        VDS runOnSameVDS = null;
        for (VDS host : hosts) {
            if (host.getId().equals(run_on_vds)) {
                runOnSameVDS = host;
            }
        }
        hosts.remove(runOnSameVDS);
    }
    if (hosts.isEmpty()) {
        model.setIsHostSelAvailable(false);
        if (allRunOnSameVds) {
            model.setNoSelAvailable(true);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    } else {
        model.getHosts().setItems(hosts);
        model.getHosts().setSelectedItem(Linq.FirstOrDefault(hosts));
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnMigrate", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", this);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        model.getCommands().add(tempVar3);
    }
}
#end_block

#method_before
private void OnMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.StartProgress(null);
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getrun_on_vds().getValue().equals(((VDS) model.getHosts().getSelectedItem()).getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), ((VDS) model.getHosts().getSelectedItem()).getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    }
}
#method_after
private void OnMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.StartProgress(null);
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().getValue().equals(((VDS) model.getHosts().getSelectedItem()).getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), ((VDS) model.getHosts().getSelectedItem()).getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void Shutdown() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().shutdownVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("shut_down_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getvm_name());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnShutdown", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void Shutdown() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().shutdownVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("shut_down_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getVmName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnShutdown", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void stop() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("stop_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getvm_name());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnStop", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void stop() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("stop_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getVmName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnStop", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void Run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        // use sysprep iff the vm is not initialized and vm has Win OS
        boolean reinitialize = !a.getis_initialized() && DataProvider.IsWindowsOsType(a.getvm_os());
        RunVmParams tempVar = new RunVmParams(a.getId());
        tempVar.setReinitialize(reinitialize);
        list.add(tempVar);
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void Run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        // use sysprep iff the vm is not initialized and vm has Win OS
        boolean reinitialize = !a.isInitialized() && AsyncDataProvider.IsWindowsOsType(a.getVmOs());
        RunVmParams tempVar = new RunVmParams(a.getId());
        tempVar.setReinitialize(reinitialize);
        list.add(tempVar);
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void ChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = // $NON-NLS-1$
    new ArrayList<String>(Arrays.asList(new String[] { "No CDs" }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            if (images.size() > 0) {
                images.add(0, ConsoleModel.EjectLabel);
                _attachCdModel.getIsoImage().setItems(images);
            }
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getIrsImageListCallback, vm.getstorage_pool_id());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void ChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = // $NON-NLS-1$
    new ArrayList<String>(Arrays.asList(new String[] { "No CDs" }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            if (images.size() > 0) {
                images.add(0, ConsoleModel.EjectLabel);
                _attachCdModel.getIsoImage().setItems(images);
            }
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void RetrieveIsoImages() {
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Guid storagePoolId = vm.getstorage_pool_id();
    getIsoImages().clear();
    ChangeCDModel tempVar2 = new ChangeCDModel();
    tempVar2.setTitle(ConsoleModel.EjectLabel);
    ChangeCDModel ejectModel = tempVar2;
    ejectModel.getExecutedEvent().addListener(this);
    getIsoImages().add(ejectModel);
    ArrayList<String> list = new ArrayList<String>();
    ChangeCDModel tempVar4 = new ChangeCDModel();
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().noCDsTitle());
    getIsoImages().add(tempVar4);
}
#method_after
private void RetrieveIsoImages() {
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Guid storagePoolId = vm.getStoragePoolId();
    getIsoImages().clear();
    ChangeCDModel tempVar2 = new ChangeCDModel();
    tempVar2.setTitle(ConsoleModel.EjectLabel);
    ChangeCDModel ejectModel = tempVar2;
    ejectModel.getExecutedEvent().addListener(this);
    getIsoImages().add(ejectModel);
    ArrayList<String> list = new ArrayList<String>();
    ChangeCDModel tempVar4 = new ChangeCDModel();
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().noCDsTitle());
    getIsoImages().add(tempVar4);
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
protected Guid extractStoragePoolIdNullSafe(VM entity) {
    return entity.getstorage_pool_id();
}
#method_after
@Override
protected Guid extractStoragePoolIdNullSafe(VM entity) {
    return entity.getStoragePoolId();
}
#end_block

#method_before
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()));
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getDescription()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOs()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getVmName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.isInitialized()).addValue("is_auto_suspend", vm.isAutoSuspend()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setVmName(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setVmOs(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOs(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurUserName(rs.getString("guest_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestCurUserId(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setAutoSuspend(rs.getBoolean("is_auto_suspend"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setSelectionAlgorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    return entity;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + (is_initialized ? 1231 : 1237);
    result = prime * result + m_nDiskSize;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((vmt_guid == null) ? 0 : vmt_guid.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + (is_initialized ? 1231 : 1237);
    result = prime * result + m_nDiskSize;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((vmt_guid == null) ? 0 : vmt_guid.hashCode());
    result = prime * result + (useHostCpuFlags ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmStatic)) {
        return false;
    }
    VmStatic other = (VmStatic) obj;
    if (defaultDisplayType != other.defaultDisplayType) {
        return false;
    }
    if (is_initialized != other.is_initialized) {
        return false;
    }
    if (m_nDiskSize != other.m_nDiskSize) {
        return false;
    }
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    if (predefinedProperties == null) {
        if (other.predefinedProperties != null) {
            return false;
        }
    } else if (!predefinedProperties.equals(other.predefinedProperties)) {
        return false;
    }
    if (userDefinedProperties == null) {
        if (other.userDefinedProperties != null) {
            return false;
        }
    } else if (!userDefinedProperties.equals(other.userDefinedProperties)) {
        return false;
    }
    if (vmt_guid == null) {
        if (other.vmt_guid != null) {
            return false;
        }
    } else if (!vmt_guid.equals(other.vmt_guid)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmStatic)) {
        return false;
    }
    VmStatic other = (VmStatic) obj;
    if (defaultDisplayType != other.defaultDisplayType) {
        return false;
    }
    if (is_initialized != other.is_initialized) {
        return false;
    }
    if (m_nDiskSize != other.m_nDiskSize) {
        return false;
    }
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    if (predefinedProperties == null) {
        if (other.predefinedProperties != null) {
            return false;
        }
    } else if (!predefinedProperties.equals(other.predefinedProperties)) {
        return false;
    }
    if (userDefinedProperties == null) {
        if (other.userDefinedProperties != null) {
            return false;
        }
    } else if (!userDefinedProperties.equals(other.userDefinedProperties)) {
        return false;
    }
    if (vmt_guid == null) {
        if (other.vmt_guid != null) {
            return false;
        }
    } else if (!vmt_guid.equals(other.vmt_guid)) {
        return false;
    }
    if (useHostCpuFlags != other.useHostCpuFlags) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static void unlockVm(final VM vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm.getDynamicData(), vm.getstatus());
            UnLockVm(vm);
            compensationContext.stateChanged();
            return null;
        }
    });
}
#method_after
public static void unlockVm(final VM vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm.getDynamicData(), vm.getStatus());
            UnLockVm(vm);
            compensationContext.stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
public static void UnLockVm(VM vm) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
    vm.setstatus(VMStatus.Down);
}
#method_after
public static void UnLockVm(VM vm) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
    vm.setStatus(VMStatus.Down);
}
#end_block

#method_before
public static void UpdateVmGuestAgentVersion(final VM vm) {
    if (vm.getapp_list() != null) {
        final String[] parts = vm.getapp_list().split("[,]", -1);
        if (parts != null && parts.length != 0) {
            final String agentAppName = Config.<String>GetValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.<Map<String, String>>GetValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(ObjectUtils.toString(vm.getos().getOsType()).toLowerCase());
            for (final String part : parts) {
                if (StringUtils.containsIgnoreCase(part, agentAppName)) {
                    vm.setGuestAgentVersion(GetApplicationVersion(part, agentAppName));
                }
                if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                    vm.setSpiceDriverVersion(GetApplicationVersion(part, spiceDriverInGuest));
                }
            }
        }
    }
}
#method_after
public static void UpdateVmGuestAgentVersion(final VM vm) {
    if (vm.getAppList() != null) {
        final String[] parts = vm.getAppList().split("[,]", -1);
        if (parts != null && parts.length != 0) {
            final String agentAppName = Config.<String>GetValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.<Map<String, String>>GetValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(ObjectUtils.toString(vm.getOs().getOsType()).toLowerCase());
            for (final String part : parts) {
                if (StringUtils.containsIgnoreCase(part, agentAppName)) {
                    vm.setGuestAgentVersion(GetApplicationVersion(part, agentAppName));
                }
                if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                    vm.setSpiceDriverVersion(GetApplicationVersion(part, spiceDriverInGuest));
                }
            }
        }
    }
}
#end_block

#method_before
public String getUserDefinedProperties() {
    return mVmStatic.getUserDefinedProperties();
}
#method_after
public String getUserDefinedProperties() {
    return vmStatic.getUserDefinedProperties();
}
#end_block

#method_before
public void setUserDefinedProperties(String userDefinedProperties) {
    mVmStatic.setUserDefinedProperties(userDefinedProperties);
}
#method_after
public void setUserDefinedProperties(String userDefinedProperties) {
    vmStatic.setUserDefinedProperties(userDefinedProperties);
}
#end_block

#method_before
public String getPredefinedProperties() {
    return mVmStatic.getPredefinedProperties();
}
#method_after
public String getPredefinedProperties() {
    return vmStatic.getPredefinedProperties();
}
#end_block

#method_before
public String getCustomProperties() {
    return mVmStatic.getCustomProperties();
}
#method_after
public String getCustomProperties() {
    return vmStatic.getCustomProperties();
}
#end_block

#method_before
public void setCustomProperties(String customProperties) {
    mVmStatic.setCustomProperties(customProperties);
}
#method_after
public void setCustomProperties(String customProperties) {
    vmStatic.setCustomProperties(customProperties);
}
#end_block

#method_before
public void setPredefinedProperties(String predefinedProperties) {
    mVmStatic.setPredefinedProperties(predefinedProperties);
}
#method_after
public void setPredefinedProperties(String predefinedProperties) {
    vmStatic.setPredefinedProperties(predefinedProperties);
}
#end_block

#method_before
public VmPauseStatus getVmPauseStatus() {
    return this.mVmDynamic.getPauseStatus();
}
#method_after
public VmPauseStatus getVmPauseStatus() {
    return this.vmDynamic.getPauseStatus();
}
#end_block

#method_before
public void setVmPauseStatus(VmPauseStatus aPauseStatus) {
    this.mVmDynamic.setPauseStatus(aPauseStatus);
}
#method_after
public void setVmPauseStatus(VmPauseStatus aPauseStatus) {
    this.vmDynamic.setPauseStatus(aPauseStatus);
}
#end_block

#method_before
@Override
public Guid getId() {
    return this.mVmStatic.getId();
}
#method_after
@Override
public Guid getId() {
    return this.vmStatic.getId();
}
#end_block

#method_before
@Override
public void setId(Guid value) {
    this.mVmStatic.setId(value);
    this.mVmDynamic.setId(value);
    this.mVmStatistics.setId(value);
}
#method_after
@Override
public void setId(Guid value) {
    this.vmStatic.setId(value);
    this.vmDynamic.setId(value);
    this.vmStatistics.setId(value);
}
#end_block

#method_before
public Guid getQuotaId() {
    return this.mVmStatic.getQuotaId();
}
#method_after
public Guid getQuotaId() {
    return this.vmStatic.getQuotaId();
}
#end_block

#method_before
public void setQuotaId(Guid value) {
    this.mVmStatic.setQuotaId(value);
}
#method_after
public void setQuotaId(Guid value) {
    this.vmStatic.setQuotaId(value);
}
#end_block

#method_before
public String getQuotaName() {
    return this.mVmStatic.getQuotaName();
}
#method_after
public String getQuotaName() {
    return this.vmStatic.getQuotaName();
}
#end_block

#method_before
public void setQuotaName(String value) {
    this.mVmStatic.setQuotaName(value);
}
#method_after
public void setQuotaName(String value) {
    this.vmStatic.setQuotaName(value);
}
#end_block

#method_before
public boolean isQuotaDefault() {
    return this.mVmStatic.isQuotaDefault();
}
#method_after
public boolean isQuotaDefault() {
    return this.vmStatic.isQuotaDefault();
}
#end_block

#method_before
public void setIsQuotaDefault(boolean isQuotaDefault) {
    this.mVmStatic.setIsQuotaDefault(isQuotaDefault);
}
#method_after
public void setIsQuotaDefault(boolean isQuotaDefault) {
    this.vmStatic.setIsQuotaDefault(isQuotaDefault);
}
#end_block

#method_before
public QuotaEnforcementTypeEnum getQuotaEnforcementType() {
    return this.mVmStatic.getQuotaEnforcementType();
}
#method_after
public QuotaEnforcementTypeEnum getQuotaEnforcementType() {
    return this.vmStatic.getQuotaEnforcementType();
}
#end_block

#method_before
public void setQuotaEnforcementType(QuotaEnforcementTypeEnum quotaEnforcementType) {
    this.mVmStatic.setQuotaEnforcementType(quotaEnforcementType);
}
#method_after
public void setQuotaEnforcementType(QuotaEnforcementTypeEnum quotaEnforcementType) {
    this.vmStatic.setQuotaEnforcementType(quotaEnforcementType);
}
#end_block

#method_before
public boolean getAllowConsoleReconnect() {
    return this.mVmStatic.getAllowConsoleReconnect();
}
#method_after
public boolean getAllowConsoleReconnect() {
    return this.vmStatic.getAllowConsoleReconnect();
}
#end_block

#method_before
public void setAllowConsoleReconnect(boolean value) {
    this.mVmStatic.setAllowConsoleReconnect(value);
}
#method_after
public void setAllowConsoleReconnect(boolean value) {
    this.vmStatic.setAllowConsoleReconnect(value);
}
#end_block

#method_before
public boolean isSmartcardEnabled() {
    return mVmStatic.isSmartcardEnabled();
}
#method_after
public boolean isSmartcardEnabled() {
    return vmStatic.isSmartcardEnabled();
}
#end_block

#method_before
public void setSmartcardEnabled(boolean isSmartcardEnabled) {
    mVmStatic.setSmartcardEnabled(isSmartcardEnabled);
}
#method_after
public void setSmartcardEnabled(boolean isSmartcardEnabled) {
    vmStatic.setSmartcardEnabled(isSmartcardEnabled);
}
#end_block

#method_before
public void setDeleteProtected(boolean deleteProtected) {
    mVmStatic.setDeleteProtected(deleteProtected);
}
#method_after
public void setDeleteProtected(boolean deleteProtected) {
    vmStatic.setDeleteProtected(deleteProtected);
}
#end_block

#method_before
public boolean isDeleteProtected() {
    return mVmStatic.isDeleteProtected();
}
#method_after
public boolean isDeleteProtected() {
    return vmStatic.isDeleteProtected();
}
#end_block

#method_before
public Date getLastStartTime() {
    return this.mVmDynamic.getLastStartTime();
}
#method_after
public Date getLastStartTime() {
    return this.vmDynamic.getLastStartTime();
}
#end_block

#method_before
public void setLastStartTime(Date value) {
    this.mVmDynamic.setLastStartTime(value);
}
#method_after
public void setLastStartTime(Date value) {
    this.vmDynamic.setLastStartTime(value);
}
#end_block

#method_before
public NGuid getConsoleUserId() {
    return this.mVmDynamic.getConsoleUserId();
}
#method_after
public NGuid getConsoleUserId() {
    return this.vmDynamic.getConsoleUserId();
}
#end_block

#method_before
public void setConsoleUserId(NGuid value) {
    this.mVmDynamic.setConsoleUserId(value);
}
#method_after
public void setConsoleUserId(NGuid value) {
    this.vmDynamic.setConsoleUserId(value);
}
#end_block

#method_before
public NGuid getmigrating_to_vds() {
    return this.mVmDynamic.getmigrating_to_vds();
}
#method_after
public NGuid getmigrating_to_vds() {
    return this.vmDynamic.getmigrating_to_vds();
}
#end_block

#method_before
public VmExitStatus getExitStatus() {
    return this.mVmDynamic.getExitStatus();
}
#method_after
public VmExitStatus getExitStatus() {
    return this.vmDynamic.getExitStatus();
}
#end_block

#method_before
public void setExitStatus(VmExitStatus value) {
    this.mVmDynamic.setExitStatus(value);
}
#method_after
public void setExitStatus(VmExitStatus value) {
    this.vmDynamic.setExitStatus(value);
}
#end_block

#method_before
public String getExitMessage() {
    return this.mVmDynamic.getExitMessage();
}
#method_after
public String getExitMessage() {
    return this.vmDynamic.getExitMessage();
}
#end_block

#method_before
public void setExitMessage(String value) {
    this.mVmDynamic.setExitMessage(value);
}
#method_after
public void setExitMessage(String value) {
    this.vmDynamic.setExitMessage(value);
}
#end_block

#method_before
public String getHash() {
    return mVmDynamic.getHash();
}
#method_after
public String getHash() {
    return vmDynamic.getHash();
}
#end_block

#method_before
public void setHash(String hash) {
    mVmDynamic.setHash(hash);
}
#method_after
public void setHash(String hash) {
    vmDynamic.setHash(hash);
}
#end_block

#method_before
public Double getRoundedElapsedTime() {
    return this.mVmStatistics.getRoundedElapsedTime();
}
#method_after
public Double getRoundedElapsedTime() {
    return this.vmStatistics.getRoundedElapsedTime();
}
#end_block

#method_before
public void setRoundedElapsedTime(Double value) {
    this.mVmStatistics.setRoundedElapsedTime(value);
}
#method_after
public void setRoundedElapsedTime(Double value) {
    this.vmStatistics.setRoundedElapsedTime(value);
}
#end_block

#method_before
public MigrationSupport getMigrationSupport() {
    return this.mVmStatic.getMigrationSupport();
}
#method_after
public MigrationSupport getMigrationSupport() {
    return this.vmStatic.getMigrationSupport();
}
#end_block

#method_before
public void setMigrationSupport(MigrationSupport migrationSupport) {
    this.mVmStatic.setMigrationSupport(migrationSupport);
}
#method_after
public void setMigrationSupport(MigrationSupport migrationSupport) {
    this.vmStatic.setMigrationSupport(migrationSupport);
}
#end_block

#method_before
public void setExportDate(Date value) {
    this.mVmStatic.setExportDate(value);
}
#method_after
public void setExportDate(Date value) {
    this.vmStatic.setExportDate(value);
}
#end_block

#method_before
public Date getExportDate() {
    return this.mVmStatic.getExportDate();
}
#method_after
public Date getExportDate() {
    return this.vmStatic.getExportDate();
}
#end_block

#method_before
public List<VmNetworkInterface> getInterfaces() {
    return mVmStatic.getInterfaces();
}
#method_after
public List<VmNetworkInterface> getInterfaces() {
    return vmStatic.getInterfaces();
}
#end_block

#method_before
public void setInterfaces(List<VmNetworkInterface> value) {
    mVmStatic.setInterfaces(value);
}
#method_after
public void setInterfaces(List<VmNetworkInterface> value) {
    vmStatic.setInterfaces(value);
}
#end_block

#method_before
public ArrayList<DiskImage> getImages() {
    return mVmStatic.getImages();
}
#method_after
public ArrayList<DiskImage> getImages() {
    return vmStatic.getImages();
}
#end_block

#method_before
public void setImages(ArrayList<DiskImage> value) {
    mVmStatic.setImages(value);
}
#method_after
public void setImages(ArrayList<DiskImage> value) {
    vmStatic.setImages(value);
}
#end_block

#method_before
public void guestLogoutTimeTreatmentAfterDestroy() {
    if (getguest_last_login_time() != null && (getguest_last_logout_time() == null || getguest_last_login_time().compareTo(getguest_last_logout_time()) > 0)) {
        setguest_last_logout_time(new Date());
    }
}
#method_after
public void guestLogoutTimeTreatmentAfterDestroy() {
    if (getGuestLastLoginTime() != null && (getGuestLastLogoutTime() == null || getGuestLastLoginTime().compareTo(getGuestLastLogoutTime()) > 0)) {
        setGuestLastLogoutTime(new Date());
    }
}
#end_block

#method_before
public boolean isStatusUp() {
    return isStatusUp(getstatus());
}
#method_after
public boolean isStatusUp() {
    return isStatusUp(getStatus());
}
#end_block

#method_before
public boolean getIsFirstRun() {
    return mVmStatic.getIsFirstRun();
}
#method_after
public boolean getIsFirstRun() {
    return vmStatic.getIsFirstRun();
}
#end_block

#method_before
public double getDiskSize() {
    if (_diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                _diskSize += ((DiskImage) disk).getsize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return _diskSize;
}
#method_after
public double getDiskSize() {
    if (diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                diskSize += ((DiskImage) disk).getsize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return diskSize;
}
#end_block

#method_before
public void setDiskSize(double value) {
    _diskSize = value;
}
#method_after
public void setDiskSize(double value) {
    diskSize = value;
}
#end_block

#method_before
public VmDynamic getDynamicData() {
    return mVmDynamic;
}
#method_after
public VmDynamic getDynamicData() {
    return vmDynamic;
}
#end_block

#method_before
public void setDynamicData(VmDynamic value) {
    mVmDynamic = value;
}
#method_after
public void setDynamicData(VmDynamic value) {
    vmDynamic = value;
}
#end_block

#method_before
public VmStatic getStaticData() {
    return mVmStatic;
}
#method_after
public VmStatic getStaticData() {
    return vmStatic;
}
#end_block

#method_before
public void setStaticData(VmStatic value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic = value;
}
#method_after
public void setStaticData(final VmStatic value) {
    // TODO this null protection is here for historical reasons, it may not be needed anymore
    if (value == null) {
        vmStatic = new VmStatic();
    } else {
        vmStatic = value;
    }
}
#end_block

#method_before
public VmStatistics getStatisticsData() {
    return mVmStatistics;
}
#method_after
public VmStatistics getStatisticsData() {
    return vmStatistics;
}
#end_block

#method_before
public void setStatisticsData(VmStatistics value) {
    mVmStatistics = value;
}
#method_after
public void setStatisticsData(VmStatistics value) {
    vmStatistics = value;
}
#end_block

#method_before
public int getMigreatingToPort() {
    return mMigreatingToPort;
}
#method_after
public int getMigreatingToPort() {
    return migreatingToPort;
}
#end_block

#method_before
public void setMigreatingToPort(int value) {
    mMigreatingToPort = value;
}
#method_after
public void setMigreatingToPort(int value) {
    migreatingToPort = value;
}
#end_block

#method_before
public int getMigreatingFromPort() {
    return mMigreatingFromPort;
}
#method_after
public int getMigreatingFromPort() {
    return migreatingFromPort;
}
#end_block

#method_before
public void setMigreatingFromPort(int value) {
    mMigreatingFromPort = value;
}
#method_after
public void setMigreatingFromPort(int value) {
    migreatingFromPort = value;
}
#end_block

#method_before
public Map<Guid, Disk> getDiskMap() {
    return mDiskMap;
}
#method_after
public Map<Guid, Disk> getDiskMap() {
    return diskMap;
}
#end_block

#method_before
public void setDiskMap(Map<Guid, Disk> diskMap) {
    mDiskMap = diskMap;
}
#method_after
public void setDiskMap(Map<Guid, Disk> diskMap) {
    this.diskMap = diskMap;
}
#end_block

#method_before
public int getDiskMapCount() {
    return mDiskMap.size();
}
#method_after
public int getDiskMapCount() {
    return diskMap.size();
}
#end_block

#method_before
public int getMinAllocatedMem() {
    return mVmStatic.getMinAllocatedMem();
}
#method_after
public int getMinAllocatedMem() {
    return vmStatic.getMinAllocatedMem();
}
#end_block

#method_before
public void setMinAllocatedMem(int value) {
    mVmStatic.setMinAllocatedMem(value);
}
#method_after
public void setMinAllocatedMem(int value) {
    vmStatic.setMinAllocatedMem(value);
}
#end_block

#method_before
public String getCdPath() {
    return mCdPath;
}
#method_after
public String getCdPath() {
    return cdPath;
}
#end_block

#method_before
public void setCdPath(String value) {
    mCdPath = value;
}
#method_after
public void setCdPath(String value) {
    cdPath = value;
}
#end_block

#method_before
public String getFloppyPath() {
    return mFloppyPath;
}
#method_after
public String getFloppyPath() {
    return floppyPath;
}
#end_block

#method_before
public void setFloppyPath(String value) {
    mFloppyPath = value;
}
#method_after
public void setFloppyPath(String value) {
    floppyPath = value;
}
#end_block

#method_before
public void setRunAndPause(boolean value) {
    mRunAndPause = value;
}
#method_after
public void setRunAndPause(boolean value) {
    runAndPause = value;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setstatus(vm.getstatus());
    setrun_on_vds(vdsId);
    setrun_on_vds_name(vdsName);
    setdisplay(vm.getdisplay());
    setdisplay_secure_port(vm.getdisplay_secure_port());
    setvm_host(vm.getvm_host());
    setvm_ip(vm.getvm_ip());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setapp_list(vm.getapp_list());
    // }
    setguest_os(vm.getguest_os());
    setdisplay_type(vm.getdisplay_type());
    setdisplay_ip(vm.getdisplay_ip());
    setkvm_enable(vm.getkvm_enable());
    setacpi_enable(vm.getacpi_enable());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setutc_diff(vm.getutc_diff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setclient_ip(vm.getclient_ip());
    setVmPauseStatus(vm.getPauseStatus());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getstatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getdisplay());
    setDisplaySecurePort(vm.getdisplay_secure_port());
    setVmHost(vm.getvm_host());
    setVmIp(vm.getvm_ip());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getapp_list());
    // }
    setGuestOs(vm.getguest_os());
    setDisplayType(vm.getdisplay_type());
    setDisplayIp(vm.getdisplay_ip());
    setKvmEnable(vm.getkvm_enable());
    setAcpiEnable(vm.getacpi_enable());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getutc_diff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getclient_ip());
    setVmPauseStatus(vm.getPauseStatus());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setelapsed_time(vmStatistics.getelapsed_time());
    setusage_network_percent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setcpu_sys(vmStatistics.getcpu_sys());
    setcpu_user(vmStatistics.getcpu_user());
    if ((getcpu_sys() != null) && (getcpu_user() != null)) {
        Double percent = (getcpu_sys() + getcpu_user()) / new Double(vm.getnum_of_cpus());
        setusage_cpu_percent(percent.intValue());
        if (getusage_cpu_percent() != null && getusage_cpu_percent() > 100) {
            setusage_cpu_percent(100);
        }
    }
    // -------- memory --------------
    setusage_mem_percent(vmStatistics.getusage_mem_percent());
}
#method_after
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setElapsedTime(vmStatistics.getelapsed_time());
    setUsageNetworkPercent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setCpuSys(vmStatistics.getcpu_sys());
    setCpuUser(vmStatistics.getcpu_user());
    if ((getCpuSys() != null) && (getCpuUser() != null)) {
        Double percent = (getCpuSys() + getCpuUser()) / new Double(vm.getNumOfCpus());
        setUsageCpuPercent(percent.intValue());
        if (getUsageCpuPercent() != null && getUsageCpuPercent() > 100) {
            setUsageCpuPercent(100);
        }
    }
    // -------- memory --------------
    setUsageMemPercent(vmStatistics.getusage_mem_percent());
}
#end_block

#method_before
public String getVmPoolName() {
    return mVmPoolName;
}
#method_after
public String getVmPoolName() {
    return vmPoolName;
}
#end_block

#method_before
public void setVmPoolName(String value) {
    mVmPoolName = value;
}
#method_after
public void setVmPoolName(String value) {
    vmPoolName = value;
}
#end_block

#method_before
public NGuid getVmPoolId() {
    return mVmPoolId;
}
#method_after
public NGuid getVmPoolId() {
    return vmPoolId;
}
#end_block

#method_before
public void setVmPoolId(NGuid value) {
    mVmPoolId = value;
}
#method_after
public void setVmPoolId(NGuid value) {
    vmPoolId = value;
}
#end_block

#method_before
public Version getSpiceDriverVersion() {
    return privateSpiceDriverVersion;
}
#method_after
public Version getSpiceDriverVersion() {
    return spiceDriverVersion;
}
#end_block

#method_before
public void setSpiceDriverVersion(Version value) {
    privateSpiceDriverVersion = value;
}
#method_after
public void setSpiceDriverVersion(Version value) {
    spiceDriverVersion = value;
}
#end_block

#method_before
@Override
public ArrayList<String> getChangeablePropertiesList() {
    return _vmProperties;
}
#method_after
@Override
public ArrayList<String> getChangeablePropertiesList() {
    return vmProperties;
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskList() {
    return mVmStatic.getDiskList();
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    return vmStatic.getDiskList();
}
#end_block

#method_before
public Map<Guid, VmDevice> getManagedVmDeviceMap() {
    return mVmStatic.getManagedVmDeviceMap();
}
#method_after
public Map<Guid, VmDevice> getManagedVmDeviceMap() {
    return vmStatic.getManagedVmDeviceMap();
}
#end_block

#method_before
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    mVmStatic.setManagedDeviceMap(map);
}
#method_after
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    vmStatic.setManagedDeviceMap(map);
}
#end_block

#method_before
public List<VmDevice> getVmUnamagedDeviceList() {
    return mVmStatic.getUnmanagedDeviceList();
}
#method_after
public List<VmDevice> getVmUnamagedDeviceList() {
    return vmStatic.getUnmanagedDeviceList();
}
#end_block

#method_before
public void setUnmanagedDeviceList(List<VmDevice> list) {
    mVmStatic.setUnmanagedDeviceList(list);
}
#method_after
public void setUnmanagedDeviceList(List<VmDevice> list) {
    vmStatic.setUnmanagedDeviceList(list);
}
#end_block

#method_before
public void setRunOnce(boolean value) {
    isRunOnce = value;
}
#method_after
public void setRunOnce(boolean value) {
    runOnce = value;
}
#end_block

#method_before
public boolean isRunOnce() {
    return isRunOnce;
}
#method_after
public boolean isRunOnce() {
    return runOnce;
}
#end_block

#method_before
public boolean isUseHostCpuFlags() {
    return mVmStatic.isUseHostCpuFlags();
}
#method_after
public boolean isUseHostCpuFlags() {
    return vmStatic.isUseHostCpuFlags();
}
#end_block

#method_before
public void setUseHostCpuFlags(boolean useHostCpuFlags) {
    mVmStatic.setUseHostCpuFlags(useHostCpuFlags);
}
#method_after
public void setUseHostCpuFlags(boolean useHostCpuFlags) {
    vmStatic.setUseHostCpuFlags(useHostCpuFlags);
}
#end_block

#method_before
public String getCpuPinning() {
    return mVmStatic.getCpuPinning();
}
#method_after
public String getCpuPinning() {
    return vmStatic.getCpuPinning();
}
#end_block

#method_before
public void setCpuPinning(String cpuPinning) {
    mVmStatic.setCpuPinning(cpuPinning);
}
#method_after
public void setCpuPinning(String cpuPinning) {
    vmStatic.setCpuPinning(cpuPinning);
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getvm_name());
    createInfo.add(VdsProperties.mem_size_mb, vm.getvm_mem_size_mb());
    createInfo.add(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getnum_of_cpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getcpu_per_socket())));
    }
    final String compatibilityVersion = vm.getvds_group_compatibility_version().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getkvm_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getacpi_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.getRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.add(VdsProperties.cpuType, "hostPassthrough");
    } else {
        if (vm.getvds_group_cpu_flags_data() != null) {
            createInfo.add(VdsProperties.cpuType, vm.getvds_group_cpu_flags_data());
        }
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getnice_level())).toString());
    if (vm.getstatus() == VMStatus.Suspended && !StringUtils.isEmpty(vm.gethibernation_vol_handle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.gethibernation_vol_handle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getvm_os().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getdisplay_type() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.getTransparentHugePages() ? "true" : "false");
}
#method_after
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getVmName());
    createInfo.add(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.add(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getNumOfCpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.add(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.add(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getNiceLevel())).toString());
    if (vm.getStatus() == VMStatus.Suspended && !StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getVmOs().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#end_block

#method_before
protected void buildVmNetworkCluster() {
    // set Display network
    List<network_cluster> all = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(vm.getvds_group_id());
    network_cluster networkCluster = null;
    for (network_cluster tempNetworkCluster : all) {
        if (tempNetworkCluster.getis_display()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = DbFacade.getInstance().getNetworkDao().getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getnetwork_id())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.add(VdsProperties.displaynetwork, net.getname());
        }
    }
}
#method_after
protected void buildVmNetworkCluster() {
    // set Display network
    List<network_cluster> all = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(vm.getVdsGroupId());
    network_cluster networkCluster = null;
    for (network_cluster tempNetworkCluster : all) {
        if (tempNetworkCluster.getis_display()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = DbFacade.getInstance().getNetworkDao().getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getnetwork_id())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.add(VdsProperties.displaynetwork, net.getname());
        }
    }
}
#end_block

#method_before
protected void buildVmBootOptions() {
    // Boot Options
    if (!StringUtils.isEmpty(vm.getinitrd_url())) {
        createInfo.add(VdsProperties.InitrdUrl, vm.getinitrd_url());
    }
    if (!StringUtils.isEmpty(vm.getkernel_url())) {
        createInfo.add(VdsProperties.KernelUrl, vm.getkernel_url());
        if (!StringUtils.isEmpty(vm.getkernel_params())) {
            createInfo.add(VdsProperties.KernelParams, vm.getkernel_params());
        }
    }
}
#method_after
protected void buildVmBootOptions() {
    // Boot Options
    if (!StringUtils.isEmpty(vm.getInitrdUrl())) {
        createInfo.add(VdsProperties.InitrdUrl, vm.getInitrdUrl());
    }
    if (!StringUtils.isEmpty(vm.getKernelUrl())) {
        createInfo.add(VdsProperties.KernelUrl, vm.getKernelUrl());
        if (!StringUtils.isEmpty(vm.getKernelParams())) {
            createInfo.add(VdsProperties.KernelParams, vm.getKernelParams());
        }
    }
}
#end_block

#method_before
protected void buildVmTimeZone() {
    // send vm_dynamic.utc_diff if exist, if not send vm_static.time_zone
    if (vm.getutc_diff() != null) {
        createInfo.add(VdsProperties.utc_diff, vm.getutc_diff().toString());
    } else {
        // get vm timezone
        String timeZone = TimeZoneInfo.Local.getId();
        if (!StringUtils.isEmpty(vm.gettime_zone())) {
            timeZone = vm.gettime_zone();
        }
        int offset = 0;
        String javaZoneId = null;
        if (vm.getos().isWindows()) {
            // convert to java & calculate offset
            javaZoneId = WindowsJavaTimezoneMapping.windowsToJava.get(timeZone);
        } else {
            javaZoneId = timeZone;
        }
        if (javaZoneId != null) {
            offset = (TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000);
        }
        createInfo.add(VdsProperties.utc_diff, "" + offset);
    }
}
#method_after
protected void buildVmTimeZone() {
    // send vm_dynamic.utc_diff if exist, if not send vm_static.time_zone
    if (vm.getUtcDiff() != null) {
        createInfo.add(VdsProperties.utc_diff, vm.getUtcDiff().toString());
    } else {
        // get vm timezone
        String timeZone = TimeZoneInfo.Local.getId();
        if (!StringUtils.isEmpty(vm.getTimeZone())) {
            timeZone = vm.getTimeZone();
        }
        int offset = 0;
        String javaZoneId = null;
        if (vm.getOs().isWindows()) {
            // convert to java & calculate offset
            javaZoneId = WindowsJavaTimezoneMapping.windowsToJava.get(timeZone);
        } else {
            javaZoneId = timeZone;
        }
        if (javaZoneId != null) {
            offset = (TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000);
        }
        createInfo.add(VdsProperties.utc_diff, "" + offset);
    }
}
#end_block

#method_before
@Override
protected String getProgressText(T object) {
    Integer progressValue = getProgressValue(object);
    if (progressValue != null && progressValue >= 100) {
        // $NON-NLS-1$
        return "Exceeded";
    }
    if (progressValue != null && progressValue < 0) {
        // $NON-NLS-1$
        return "Unlimited";
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    return progressValue != null ? progressValue + "%" : "0%";
}
#method_after
@Override
protected String getProgressText(T object) {
    Integer progressValue = getProgressValue(object);
    if (progressValue != null && progressValue >= 100) {
        return getaApplicationConstants().exceeded();
    }
    if (progressValue != null && progressValue < 0) {
        return getaApplicationConstants().unlimited();
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    return progressValue != null ? progressValue + "%" : "0%";
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new QuotaDcStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    }, constants.nameQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.descriptionQuota(), // $NON-NLS-1$
    "120px");
    // getTable().addColumn(new TextColumnWithTooltip<Quota>() {
    // @Override
    // public String getValue(Quota object) {
    // return object.getStoragePoolName() == null ? "" : object.getStoragePoolName(); //$NON-NLS-1$
    // }
    // }, constants.dcQuota(), "150px"); //$NON-NLS-1$
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                // $NON-NLS-1$
                returnVal = "Unlimited";
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 MB";
            } else if (value <= 5120) {
                // $NON-NLS-1$
                returnVal = value + "MB";
            } else {
                // $NON-NLS-1$
                returnVal = decimalFormat.format((double) value / 1025) + "GB";
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                // $NON-NLS-1$
                returnVal = "Unlimited";
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                // $NON-NLS-1$
                returnVal = "Unlimited";
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 GB";
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveQuotaCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new QuotaDcStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    }, constants.nameQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.descriptionQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 MB";
            } else if (value <= 5 * 1024) {
                // $NON-NLS-1$
                returnVal = value + "MB";
            } else {
                // $NON-NLS-1$
                returnVal = decimalFormat.format((double) value / 1024) + "GB";
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 GB";
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveQuotaCommand();
        }
    });
}
#end_block

#method_before
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param, auditLogPair);
        boolean validVdsGroup = true;
        boolean validStorageDomain = true;
        if (validQuotaId) {
            // vds group id which is handled by this quota
            if (param instanceof QuotaVdsGroupConsumptionParameter) {
                validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
            }
            // storage domain id which is handled by this quota
            if (param instanceof QuotaStorageConsumptionParameter) {
                validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
            }
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
                    auditLogPair.setFirst(null);
                }
                return true;
            }
        }
    }
    return true;
}
#method_after
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param, auditLogPair);
        boolean validVdsGroup = true;
        boolean validStorageDomain = true;
        if (validQuotaId) {
            // vds group id which is handled by this quota
            if (param instanceof QuotaVdsGroupConsumptionParameter) {
                validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
            }
            // storage domain id which is handled by this quota
            if (param instanceof QuotaStorageConsumptionParameter) {
                validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
            }
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
                    auditLogPair.setFirst(null);
                }
            }
        }
    }
    parameters.getParameters().removeAll(corruptedParameters);
    corruptedParameters.clear();
    return true;
}
#end_block

#method_before
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#method_after
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        corruptedParameters.add(param);
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        corruptedParameters.add(param);
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#end_block

#method_before
public void updateUsage(List<Quota> quotaList) {
    lock.writeLock().lock();
    try {
        for (Quota quotaExternal : quotaList) {
            Quota quota = null;
            // look for the quota in the cache
            for (Map<Guid, Quota> quotaMap : storagePoolQuotaMap.values()) {
                quota = quotaMap.get(quotaExternal.getId());
                if (quota != null) {
                    break;
                }
            }
            // if quota not in cache look for it in DB and add it to cache
            if (quota == null) {
                quota = getQuotaDAO().getById(quotaExternal.getId());
                if (quota != null) {
                    if (!storagePoolQuotaMap.containsKey(quota.getStoragePoolId())) {
                        storagePoolQuotaMap.put(quota.getStoragePoolId(), new HashMap<Guid, Quota>());
                    }
                    storagePoolQuotaMap.get(quota.getStoragePoolId()).put(quota.getId(), quota);
                }
            }
            copyUsageData(quota, quotaExternal);
        }
    } finally {
        lock.writeLock().unlock();
    }
}
#method_after
public void updateUsage(List<Quota> quotaList) {
    List<Quota> needToCache = new ArrayList<Quota>();
    if (quotaList == null) {
        return;
    }
    lock.readLock().lock();
    try {
        for (Quota quotaExternal : quotaList) {
            // look for the quota in the cache
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(quotaExternal.getStoragePoolId());
            Quota quota = null;
            if (quotaMap != null) {
                quota = quotaMap.get(quotaExternal.getId());
            }
            // if quota not in cache look for it in DB and add it to cache
            if (quota == null) {
                needToCache.add(quotaExternal);
            } else {
                copyUsageData(quota, quotaExternal);
            }
        }
    } finally {
        lock.readLock().unlock();
    }
    // if some of the quota are not in cache and need to be cached
    if (!needToCache.isEmpty()) {
        lock.writeLock().lock();
        try {
            for (Quota quotaExternal : needToCache) {
                if (!storagePoolQuotaMap.containsKey(quotaExternal.getStoragePoolId())) {
                    storagePoolQuotaMap.put(quotaExternal.getStoragePoolId(), new HashMap<Guid, Quota>());
                }
                Quota quota = fetchQuotaFromCache(quotaExternal.getId(), quotaExternal.getStoragePoolId());
                if (quota != null) {
                    copyUsageData(quota, quotaExternal);
                }
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
}
#end_block

#method_before
private void countPersonalUsage(List<VM> vms, Map<Guid, QuotaPerUserUsageEntity> quotaPerUserUsageEntityMap) {
    for (VM vm : vms) {
        // if vm is running and have a quota
        if (vm.getStatus() != VMStatus.Down && vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.ImageIllegal && vm.getStatus() != VMStatus.ImageLocked && vm.getStatus() != VMStatus.PoweringDown && vm.getQuotaId() != null) {
            QuotaPerUserUsageEntity quotaPerUserUsageEntity = quotaPerUserUsageEntityMap.get(vm.getQuotaId());
            // add the vm cpu and mem to the user quota consumption
            if (quotaPerUserUsageEntity != null) {
                quotaPerUserUsageEntity.setMemoryUsageForUser(quotaPerUserUsageEntity.getMemoryUsageForUser() + vm.getMemSizeMb());
                quotaPerUserUsageEntity.setVcpuUsageForUser(quotaPerUserUsageEntity.getVcpuUsageForUser() + vm.getCpuPerSocket() * vm.getNumOfSockets());
            }
        }
        // for each image of each disk of the vm - if it has a quota
        for (DiskImage image : vm.getDiskList()) {
            QuotaPerUserUsageEntity quotaPerUserUsageEntity = quotaPerUserUsageEntityMap.get(image.getQuotaId());
            double imageSize = image.getImage().isActive() ? image.getSizeInGigabytes() : image.getActualSize();
            // add the disk size to the user storage consumption
            if (quotaPerUserUsageEntity != null) {
                quotaPerUserUsageEntity.setStorageUsageForUser(quotaPerUserUsageEntity.getStorageUsageForUser() + imageSize);
            }
        }
    }
}
#method_after
private void countPersonalUsage(List<VM> vms, Map<Guid, QuotaUsagePerUser> quotaPerUserUsageEntityMap) {
    if (vms != null) {
        for (VM vm : vms) {
            // if vm is running and have a quota
            if (vm.getStatus() != VMStatus.Down && vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.ImageIllegal && vm.getStatus() != VMStatus.ImageLocked && vm.getStatus() != VMStatus.PoweringDown && vm.getQuotaId() != null) {
                QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(vm.getQuotaId());
                // add the vm cpu and mem to the user quota consumption
                if (quotaUsagePerUser != null) {
                    quotaUsagePerUser.setMemoryUsageForUser(quotaUsagePerUser.getMemoryUsageForUser() + vm.getMemSizeMb());
                    quotaUsagePerUser.setVcpuUsageForUser(quotaUsagePerUser.getVcpuUsageForUser() + vm.getCpuPerSocket() * vm.getNumOfSockets());
                }
            }
            // for each image of each disk of the vm - if it has a quota
            for (DiskImage image : vm.getDiskList()) {
                QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(image.getQuotaId());
                double imageSize = image.getImage().isActive() ? image.getSizeInGigabytes() : image.getActualSize();
                // add the disk size to the user storage consumption
                if (quotaUsagePerUser != null) {
                    quotaUsagePerUser.setStorageUsageForUser(quotaUsagePerUser.getStorageUsageForUser() + imageSize);
                }
            }
        }
    }
}
#end_block

#method_before
private QuotaPerUserUsageEntity addQuotaEntry(Quota quota) {
    // if quota is not null (found in cache or DB) - add entry to quotaPerUserUsageEntityMap
    if (quota != null) {
        double storageLimit = 0;
        double storageUsage = 0;
        int cpuLimit = 0;
        int cpuUsage = 0;
        long memLimit = 0;
        long memUsage = 0;
        // calc storage
        if (quota.getGlobalQuotaStorage() != null) {
            storageLimit = quota.getGlobalQuotaStorage().getStorageSizeGB();
            storageUsage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage();
        } else {
            for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                storageLimit += quotaStorage.getStorageSizeGB();
                storageUsage += quotaStorage.getStorageSizeGBUsage();
            }
        }
        // calc cpu and mem
        if (quota.getGlobalQuotaVdsGroup() != null) {
            memLimit = quota.getGlobalQuotaVdsGroup().getMemSizeMB();
            memUsage = quota.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            cpuLimit = quota.getGlobalQuotaVdsGroup().getVirtualCpu();
            cpuUsage = quota.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
        } else {
            for (QuotaVdsGroup quotaVdsGroup : quota.getQuotaVdsGroups()) {
                memLimit += quotaVdsGroup.getMemSizeMB();
                memUsage += quotaVdsGroup.getMemSizeMBUsage();
                cpuLimit += quotaVdsGroup.getVirtualCpu();
                cpuUsage += quotaVdsGroup.getVirtualCpuUsage();
            }
        }
        return new QuotaPerUserUsageEntity(quota.getId(), quota.getQuotaName(), storageLimit, storageUsage, cpuLimit, cpuUsage, memLimit, memUsage);
    }
    return null;
}
#method_after
private QuotaUsagePerUser addQuotaEntry(Quota quota) {
    // if quota is not null (found in cache or DB) - add entry to quotaPerUserUsageEntityMap
    if (quota != null) {
        double storageLimit = 0;
        double storageUsage = 0;
        int cpuLimit = 0;
        int cpuUsage = 0;
        long memLimit = 0;
        long memUsage = 0;
        // calc storage
        if (quota.getGlobalQuotaStorage() != null) {
            storageLimit = quota.getGlobalQuotaStorage().getStorageSizeGB();
            storageUsage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage();
        } else {
            for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                storageLimit += quotaStorage.getStorageSizeGB();
                storageUsage += quotaStorage.getStorageSizeGBUsage();
            }
        }
        // calc cpu and mem
        if (quota.getGlobalQuotaVdsGroup() != null) {
            memLimit = quota.getGlobalQuotaVdsGroup().getMemSizeMB();
            memUsage = quota.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            cpuLimit = quota.getGlobalQuotaVdsGroup().getVirtualCpu();
            cpuUsage = quota.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
        } else {
            for (QuotaVdsGroup quotaVdsGroup : quota.getQuotaVdsGroups()) {
                memLimit += quotaVdsGroup.getMemSizeMB();
                memUsage += quotaVdsGroup.getMemSizeMBUsage();
                cpuLimit += quotaVdsGroup.getVirtualCpu();
                cpuUsage += quotaVdsGroup.getVirtualCpuUsage();
            }
        }
        return new QuotaUsagePerUser(quota.getId(), quota.getQuotaName(), storageLimit, storageUsage, cpuLimit, cpuUsage, memLimit, memUsage);
    }
    return null;
}
#end_block

#method_before
private ServiceInfo parseServiceInfo(Map<String, Object> volumeServiceInfo) {
    ServiceInfo serviceInfo = new ServiceInfo();
    if (volumeServiceInfo.containsKey(HOSTNAME)) {
        serviceInfo.setHostName((String) volumeServiceInfo.get(HOSTNAME));
    }
    if (volumeServiceInfo.containsKey(STATUS)) {
        String brickStatus = (String) volumeServiceInfo.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            serviceInfo.setStatus(GlusterStatus.UP);
            // parse the port and pid only if the brick is online.
            if (volumeServiceInfo.containsKey(PORT)) {
                serviceInfo.setPort(Integer.valueOf((String) volumeServiceInfo.get(PORT)));
            }
            if (volumeServiceInfo.containsKey(PID)) {
                serviceInfo.setPid(Integer.valueOf((String) volumeServiceInfo.get(PID)));
            }
        } else {
            serviceInfo.setStatus(GlusterStatus.DOWN);
        }
    }
    return serviceInfo;
}
#method_after
private ServiceInfo parseServiceInfo(Map<String, Object> volumeServiceInfo) {
    ServiceInfo serviceInfo = new ServiceInfo();
    if (volumeServiceInfo.containsKey(HOSTNAME)) {
        serviceInfo.setHostName((String) volumeServiceInfo.get(HOSTNAME));
    }
    if (volumeServiceInfo.containsKey(STATUS)) {
        String brickStatus = (String) volumeServiceInfo.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            serviceInfo.setStatus(GlusterStatus.UP);
            // parse the port and pid only if the brick is online.
            if (volumeServiceInfo.containsKey(PORT)) {
                serviceInfo.setPort(Integer.parseInt((String) volumeServiceInfo.get(PORT)));
            }
            if (volumeServiceInfo.containsKey(PID)) {
                serviceInfo.setPid(Integer.parseInt((String) volumeServiceInfo.get(PID)));
            }
        } else {
            serviceInfo.setStatus(GlusterStatus.DOWN);
        }
    }
    return serviceInfo;
}
#end_block

#method_before
private BrickProperties getBrickProperties(GlusterVolumeEntity volume, Map<String, Object> brick) {
    BrickProperties brickProperties = new BrickProperties();
    GlusterBrickEntity brickEntity = GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), (String) brick.get(BRICK));
    if (brickEntity != null) {
        brickProperties.setBrickId(brickEntity.getId());
    }
    if (brick.containsKey(PORT)) {
        brickProperties.setPort(Integer.valueOf((String) brick.get(PORT)));
    }
    if (brick.containsKey(PID)) {
        brickProperties.setPid(Integer.valueOf((String) brick.get(PID)));
    }
    if (brick.containsKey(STATUS)) {
        String brickStatus = (String) brick.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            brickProperties.setStatus(GlusterStatus.UP);
        } else {
            brickProperties.setStatus(GlusterStatus.DOWN);
        }
    }
    // Fetch the volume status detail
    if (brick.containsKey(DETAIL_SIZE_TOTAL)) {
        brickProperties.setTotalSize(Double.valueOf((String) brick.get(DETAIL_SIZE_TOTAL)));
    }
    if (brick.containsKey(DETAIL_SIZE_FREE)) {
        brickProperties.setFreeSize(Double.valueOf((String) brick.get(DETAIL_SIZE_FREE)));
    }
    if (brick.containsKey(DETAIL_DEVICE)) {
        brickProperties.setDevice((String) brick.get(DETAIL_DEVICE));
    }
    if (brick.containsKey(DETAIL_BLOCK_SIZE)) {
        brickProperties.setBlockSize(Integer.valueOf((String) brick.get(DETAIL_BLOCK_SIZE)));
    }
    if (brick.containsKey(DETAIL_MNT_OPTIONS)) {
        brickProperties.setMntOptions((String) brick.get(DETAIL_MNT_OPTIONS));
    }
    if (brick.containsKey(DETAIL_FS_NAME)) {
        brickProperties.setFsName((String) brick.get(DETAIL_FS_NAME));
    }
    return brickProperties;
}
#method_after
private BrickProperties getBrickProperties(GlusterVolumeEntity volume, Map<String, Object> brick) {
    BrickProperties brickProperties = new BrickProperties();
    GlusterBrickEntity brickEntity = GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), (String) brick.get(BRICK));
    if (brickEntity != null) {
        brickProperties.setBrickId(brickEntity.getId());
    }
    if (brick.containsKey(STATUS)) {
        String brickStatus = (String) brick.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            brickProperties.setStatus(GlusterStatus.UP);
            if (brick.containsKey(PORT)) {
                brickProperties.setPort(Integer.parseInt((String) brick.get(PORT)));
            }
            if (brick.containsKey(PID)) {
                brickProperties.setPid(Integer.parseInt((String) brick.get(PID)));
            }
        } else {
            brickProperties.setStatus(GlusterStatus.DOWN);
        }
    }
    // Fetch the volume status detail
    if (brick.containsKey(DETAIL_SIZE_TOTAL)) {
        brickProperties.setTotalSize(Double.valueOf((String) brick.get(DETAIL_SIZE_TOTAL)));
    }
    if (brick.containsKey(DETAIL_SIZE_FREE)) {
        brickProperties.setFreeSize(Double.valueOf((String) brick.get(DETAIL_SIZE_FREE)));
    }
    if (brick.containsKey(DETAIL_DEVICE)) {
        brickProperties.setDevice((String) brick.get(DETAIL_DEVICE));
    }
    if (brick.containsKey(DETAIL_BLOCK_SIZE)) {
        brickProperties.setBlockSize(Integer.valueOf((String) brick.get(DETAIL_BLOCK_SIZE)));
    }
    if (brick.containsKey(DETAIL_MNT_OPTIONS)) {
        brickProperties.setMntOptions((String) brick.get(DETAIL_MNT_OPTIONS));
    }
    if (brick.containsKey(DETAIL_FS_NAME)) {
        brickProperties.setFsName((String) brick.get(DETAIL_FS_NAME));
    }
    return brickProperties;
}
#end_block

#method_before
protected void updateConsoleModel(UserPortalItemModel item) {
    super.updateConsoleModel(item);
    if (item.getEntity() != null) {
        // Adjust item's default console for userportal 'Basic View'
        item.getDefaultConsole().setForceVmStatusUp(true);
    }
}
#method_after
@Override
protected void updateConsoleModel(UserPortalItemModel item) {
    super.updateConsoleModel(item);
    if (item.getEntity() != null) {
        // Adjust item's default console for userportal 'Basic View'
        item.getDefaultConsole().setForceVmStatusUp(true);
    }
}
#end_block

#method_before
private void Spice_MenuItemSelected(Object sender, SpiceMenuItemEventArgs e) {
    if (getEntity() != null) {
        // SpiceMenuCommandItem item = menu.Descendants()
        // .OfType<SpiceMenuCommandItem>()
        // .FirstOrDefault(a => a.Id == e.MenuItemId);
        SpiceMenuCommandItem item = null;
        for (SpiceMenuItem a : menu.Descendants()) {
            if (a.getClass() == SpiceMenuCommandItem.class && a.getId() == e.getMenuItemId()) {
                item = (SpiceMenuCommandItem) a;
                break;
            }
        }
        if (item != null) {
            if (StringHelper.stringsEqual(item.getCommandName(), CommandPlay)) {
                // use sysprep iff the vm is not initialized and vm has Win OS
                boolean reinitialize = !getEntity().isInitialized() && DataProvider.IsWindowsOsType(getEntity().getVmOs());
                RunVmParams tempVar = new RunVmParams(getEntity().getId());
                tempVar.setRunAsStateless(getEntity().isStateless());
                tempVar.setReinitialize(reinitialize);
                Frontend.RunMultipleAction(VdcActionType.RunVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { tempVar })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandSuspend)) {
                Frontend.RunMultipleAction(VdcActionType.HibernateVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new HibernateVmParameters(getEntity().getId()) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandStop)) {
                Frontend.RunMultipleAction(VdcActionType.ShutdownVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ShutdownVmParameters(getEntity().getId(), true) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandChangeCD)) {
                Frontend.RunMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(getEntity().getId(), // $NON-NLS-1$
                StringHelper.stringsEqual(item.getText(), EjectLabel) ? "" : item.getText()) })));
            }
        }
    }
}
#method_after
private void Spice_MenuItemSelected(Object sender, SpiceMenuItemEventArgs e) {
    if (getEntity() != null) {
        // SpiceMenuCommandItem item = menu.Descendants()
        // .OfType<SpiceMenuCommandItem>()
        // .FirstOrDefault(a => a.Id == e.MenuItemId);
        SpiceMenuCommandItem item = null;
        for (SpiceMenuItem a : menu.Descendants()) {
            if (a.getClass() == SpiceMenuCommandItem.class && a.getId() == e.getMenuItemId()) {
                item = (SpiceMenuCommandItem) a;
                break;
            }
        }
        if (item != null) {
            if (StringHelper.stringsEqual(item.getCommandName(), CommandPlay)) {
                // use sysprep iff the vm is not initialized and vm has Win OS
                boolean reinitialize = !getEntity().isInitialized() && AsyncDataProvider.IsWindowsOsType(getEntity().getVmOs());
                RunVmParams tempVar = new RunVmParams(getEntity().getId());
                tempVar.setRunAsStateless(getEntity().isStateless());
                tempVar.setReinitialize(reinitialize);
                Frontend.RunMultipleAction(VdcActionType.RunVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { tempVar })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandSuspend)) {
                Frontend.RunMultipleAction(VdcActionType.HibernateVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new HibernateVmParameters(getEntity().getId()) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandStop)) {
                Frontend.RunMultipleAction(VdcActionType.ShutdownVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ShutdownVmParameters(getEntity().getId(), true) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandChangeCD)) {
                Frontend.RunMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(getEntity().getId(), // $NON-NLS-1$
                StringHelper.stringsEqual(item.getText(), EjectLabel) ? "" : item.getText()) })));
            }
        }
    }
}
#end_block

#method_before
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : getEntity().getSpiceDriverVersion() != null ? false : true);
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#method_after
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : getEntity().getSpiceDriverVersion() != null ? false : true);
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#end_block

#method_before
@Override
public Boolean isRaiseErrorModalPanel(VdcQueryType queryType) {
    return false;
}
#method_after
@Override
public Boolean isRaiseErrorModalPanel(VdcActionType actionType, VdcFault fault) {
    return (actionType != VdcActionType.LoginUser) && !(actionType == VdcActionType.VmLogon && fault.getError() == VdcBllErrors.nonresp);
}
#end_block

#method_before
@Override
public void runActionExecutionFailed(VdcActionType action, VdcFault fault) {
    if (shouldRaiseErrorDialog(action, fault))
        errorPopupManager.show(messages.uiCommonRunActionExecutionFailed(EnumTranslator.createAndTranslate(action), fault.getMessage()));
}
#method_after
@Override
public void runActionExecutionFailed(VdcActionType action, VdcFault fault) {
    if (isRaiseErrorModalPanel(action, fault))
        errorPopupManager.show(messages.uiCommonRunActionExecutionFailed(EnumTranslator.createAndTranslate(action), fault.getMessage()));
}
#end_block

#method_before
@Override
public void runMultipleActionFailed(VdcActionType action, List<VdcReturnValueBase> returnValues, List<VdcFault> faults) {
    String actionStr = EnumTranslator.createAndTranslate(action);
    List<String> errors = new ArrayList<String>();
    for (VdcReturnValueBase v : returnValues) {
        if (shouldRaiseErrorDialog(action, v.getFault()))
            errors.add(messages.uiCommonRunActionFailed(v.getCanDoActionMessages().iterator().next()));
    }
    for (VdcFault fault : faults) {
        if (shouldRaiseErrorDialog(action, fault))
            errors.add(messages.uiCommonRunActionExecutionFailed(actionStr, fault.getMessage()));
    }
    errorPopupManager.show(ErrorMessageFormatter.formatErrorMessages(errors));
}
#method_after
@Override
public void runMultipleActionFailed(VdcActionType action, List<VdcReturnValueBase> returnValues, List<VdcFault> faults) {
    String actionStr = EnumTranslator.createAndTranslate(action);
    List<String> errors = new ArrayList<String>();
    for (VdcReturnValueBase v : returnValues) {
        if (isRaiseErrorModalPanel(action, v.getFault()))
            errors.add(messages.uiCommonRunActionFailed(v.getCanDoActionMessages().iterator().next()));
    }
    for (VdcFault fault : faults) {
        if (isRaiseErrorModalPanel(action, fault))
            errors.add(messages.uiCommonRunActionExecutionFailed(actionStr, fault.getMessage()));
    }
    errorPopupManager.show(ErrorMessageFormatter.formatErrorMessages(errors));
}
#end_block

#method_before
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setModel(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (DataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#method_after
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setModel(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#end_block

#method_before
protected void acquireLock(Guid clusterId) {
    getLockManager().acquireLockWait(getEngineLock(clusterId));
}
#method_after
protected void acquireLock(Guid clusterId) {
    lockManager.acquireLockWait(getEngineLock(clusterId));
}
#end_block

#method_before
protected void releaseLock(Guid clusterId) {
    getLockManager().releaseLock(getEngineLock(clusterId));
}
#method_after
protected void releaseLock(Guid clusterId) {
    lockManager.releaseLock(getEngineLock(clusterId));
}
#end_block

#method_before
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(DataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#method_after
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(DataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#method_after
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#end_block

#method_before
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (DataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || DataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#method_after
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (AsyncDataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || AsyncDataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
@Override
public void setMessage(String message) {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    messageLabel.getElement().setInnerHTML(message != null ? message.replace("\n", "<br/>") : "");
}
#method_after
@Override
public void setMessage(String message) {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    messageHTML.setHTML(SafeHtmlUtils.fromString(message != null ? message : "").asString().replace("\n", "<br>"));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (networkExists()) {
        getNetworkClusterDAO().update(getParameters().getNetworkCluster());
    } else {
        getNetworkClusterDAO().save(new network_cluster(getVdsGroupId(), getNetwork().getId(), NetworkStatus.Operational, false, getParameters().getNetworkCluster().isRequired()));
    }
    if (getNetwork().getCluster().getis_display()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetwork().getId());
    }
    SetNetworkStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (networkExists()) {
        getNetworkClusterDAO().update(getNetworkCluster());
    } else {
        getNetworkClusterDAO().save(new network_cluster(getVdsGroupId(), getNetwork().getId(), NetworkStatus.Operational, false, getNetworkCluster().isRequired()));
    }
    if (getNetwork().getCluster().getis_display()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetwork().getId());
    }
    SetNetworkStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#end_block

#method_before
private boolean logicalNetworkExists() {
    if (getNetworkDAO().get(getParameters().getNetworkCluster().getnetwork_id()) != null) {
        return true;
    }
    addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS);
    return false;
}
#method_after
private boolean logicalNetworkExists() {
    if (getNetworkDAO().get(getNetworkCluster().getnetwork_id()) != null) {
        return true;
    }
    addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS);
    return false;
}
#end_block

#method_before
private boolean networkExists() {
    List<network_cluster> networks = getNetworkClusterDAO().getAllForCluster(getVdsGroupId());
    for (network_cluster network_cluster : networks) {
        if (network_cluster.getnetwork_id().equals(getParameters().getNetworkCluster().getnetwork_id())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean networkExists() {
    List<network_cluster> networks = getNetworkClusterDAO().getAllForCluster(getVdsGroupId());
    for (network_cluster network_cluster : networks) {
        if (network_cluster.getnetwork_id().equals(getNetworkCluster().getnetwork_id())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (networkExists()) {
        return Collections.singletonList(new PermissionSubject(getParameters().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CONFIGURE_CLUSTER_NETWORK));
    } else {
        Guid networkId = getParameters().getNetwork() == null ? null : getParameters().getNetwork().getId();
        return Collections.singletonList(new PermissionSubject(networkId, VdcObjectType.Network, getActionType().getActionGroup()));
    }
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissions = new ArrayList<PermissionSubject>();
    Guid networkId = getNetworkCluster() == null ? null : getNetworkCluster().getnetwork_id();
    // require permissions on network
    permissions.add(new PermissionSubject(networkId, VdcObjectType.Network, getActionType().getActionGroup()));
    // require permissions on cluster the network is attached to
    if (networkExists()) {
        permissions.add(new PermissionSubject(getParameters().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CONFIGURE_CLUSTER_NETWORK));
    }
    return permissions;
}
#end_block

#method_before
private HttpRequest setUpRequestExpectations(String credentials, boolean valid, boolean preferHeader) {
    Scheme authorizer = control.createMock(Scheme.class);
    challenger.setScheme(authorizer);
    Current current = control.createMock(Current.class);
    challenger.setCurrent(current);
    HttpRequest request = control.createMock(HttpRequest.class);
    HttpHeaders headers = control.createMock(HttpHeaders.class);
    expect(request.getHttpHeaders()).andReturn(headers);
    List<String> authHeaders = new ArrayList<String>();
    if (preferHeader) {
        List<String> preferHeaders = new ArrayList<String>();
        preferHeaders.add(SessionUtils.PERSIST_FIELD_VALUE);
        expect(headers.getRequestHeader(SessionUtils.PREFER_HEADER_FIELD)).andReturn(preferHeaders);
    }
    if (credentials != null) {
        expect(headers.getRequestHeader(HttpHeaders.AUTHORIZATION)).andReturn(authHeaders);
        expect(headers.getRequestHeader(HttpHeaders.AUTHORIZATION)).andReturn(authHeaders);
        Principal principal = new Principal(USER, SECRET, DOMAIN);
        expect(authorizer.decode(headers)).andReturn(principal);
        authHeaders.add(credentials);
        if (valid) {
            current.set(principal);
            EasyMock.expectLastCall();
            current.set(challenger);
            EasyMock.expectLastCall();
        }
    }
    control.replay();
    return request;
}
#method_after
private HttpRequest setUpRequestExpectations(String credentials, boolean valid, boolean preferHeader) {
    Scheme authorizer = control.createMock(Scheme.class);
    challenger.setScheme(authorizer);
    Current current = control.createMock(Current.class);
    challenger.setCurrent(current);
    HttpRequest request = control.createMock(HttpRequest.class);
    HttpHeaders headers = control.createMock(HttpHeaders.class);
    expect(request.getHttpHeaders()).andReturn(headers);
    List<String> authHeaders = new ArrayList<String>();
    if (preferHeader) {
        List<String> preferHeaders = new ArrayList<String>();
        preferHeaders.add(SessionUtils.PERSIST_FIELD_VALUE);
        expect(headers.getRequestHeader(SessionUtils.PREFER_HEADER_FIELD)).andReturn(preferHeaders);
    }
    if (credentials != null) {
        expect(headers.getRequestHeader(HttpHeaders.AUTHORIZATION)).andReturn(authHeaders).anyTimes();
        Principal principal = new Principal(USER, SECRET, DOMAIN);
        expect(authorizer.decode(headers)).andReturn(principal);
        authHeaders.add(credentials);
        if (valid) {
            current.set(principal);
            EasyMock.expectLastCall();
            current.set(challenger);
            EasyMock.expectLastCall();
        }
    }
    control.replay();
    return request;
}
#end_block

#method_before
public static String GetSysPrep(VM vm, String hostName, String domain, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepXPPath));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey));
            break;
        case Windows2003:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003));
            break;
        case Windows2003x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003x64));
            break;
        case Windows2008:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008));
            break;
        case Windows2008x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008x64));
            break;
        case Windows2008R2x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8R2Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008R2));
            break;
        case Windows7:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7));
            break;
        case Windows7x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7x64));
            break;
        case Windows8:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8));
            break;
        case Windows8x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8x64));
            break;
        case Windows2012:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows2012Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows2012));
            break;
        case Windows2012x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows2012x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows2012x64));
            break;
        default:
            break;
    }
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>GetValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>GetValue(ConfigValues.OrganizationName));
    }
    return sysPrepContent;
}
#method_after
public static String GetSysPrep(VM vm, String hostName, String domain, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepXPPath));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey));
            break;
        case Windows2003:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003));
            break;
        case Windows2003x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003x64));
            break;
        case Windows2008:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008));
            break;
        case Windows2008x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008x64));
            break;
        case Windows2008R2x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8R2Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008R2));
            break;
        case Windows7:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7));
            break;
        case Windows7x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7x64));
            break;
        case Windows8:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8));
            break;
        case Windows8x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8x64));
            break;
        case Windows2012x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows2012x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows2012x64));
            break;
        default:
            break;
    }
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>GetValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>GetValue(ConfigValues.OrganizationName));
    }
    return sysPrepContent;
}
#end_block

#method_before
private static String getTimeZone(VM vm) {
    String timeZone;
    // Can be empty if the VM was imported.
    if (StringUtils.isEmpty(vm.gettime_zone())) {
        vm.settime_zone(TimeZoneInfo.Local.getId());
    }
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
        case Windows2003:
        case Windows2003x64:
            // send correct time zone as sysprep expect to get it (a wierd
            // number)
            timeZone = getTimezoneIndexByKey(vm.gettime_zone());
            break;
        case Windows2008:
        default:
            timeZone = vm.gettime_zone();
            break;
    }
    return timeZone;
}
#method_after
private static String getTimeZone(VM vm) {
    String timeZone;
    // Can be empty if the VM was imported.
    if (StringUtils.isEmpty(vm.getTimeZone())) {
        vm.setTimeZone(TimeZoneInfo.Local.getId());
    }
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
        case Windows2003:
        case Windows2003x64:
            // send correct time zone as sysprep expect to get it (a wierd
            // number)
            timeZone = getTimezoneIndexByKey(vm.getTimeZone());
            break;
        case Windows2008:
        default:
            timeZone = vm.getTimeZone();
            break;
    }
    return timeZone;
}
#end_block

#method_before
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (String s : EnumCompat.GetNames(VDSType.class)) {
        if (StringHelper.stringsEqual(s, VDSType.PowerClient.toString())) {
            if (showPowerclient) {
                ret.add(s);
            }
        } else {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (VDSType vdsType : VDSType.values()) {
        if (VDSType.PowerClient == vdsType) {
            if (showPowerclient) {
                ret.add(vdsType.name());
            }
        } else {
            ret.add(vdsType.name());
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EnumCompat.GetValues(EventNotificationEntity.class)) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>();
    for (VmInterfaceType item : EnumCompat.GetValues(VmInterfaceType.class)) {
        list.add(item);
    }
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        list.remove(VmInterfaceType.e1000);
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#method_after
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>(Arrays.asList(VmInterfaceType.values()));
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#end_block

#method_before
public static Iterable GetUsbPolicyList() {
    return EnumCompat.GetValues(UsbPolicy.class);
}
#method_after
public static Iterable GetUsbPolicyList() {
    return Arrays.asList(UsbPolicy.values());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getRunOnVds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getRunOnVds().toString());
    }
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getVmIp().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012:
            return OsType.WINDOWS_2012;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        case WINDOWS_2012X64:
            return VmOsType.Windows2012x64;
        default:
            return null;
    }
}
#end_block

#method_before
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getstatus() == VMStatus.Up || entity.getstatus() == VMStatus.PoweringUp || entity.getstatus() == VMStatus.WaitForLaunch || entity.getstatus() == VMStatus.PoweredDown || entity.getstatus() == VMStatus.RebootInProgress || entity.getstatus() == VMStatus.RestoringState;
}
#method_after
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getStatus() == VMStatus.Up || entity.getStatus() == VMStatus.PoweringUp || entity.getStatus() == VMStatus.WaitForLaunch || entity.getStatus() == VMStatus.PoweredDown || entity.getStatus() == VMStatus.RebootInProgress || entity.getStatus() == VMStatus.RestoringState;
}
#end_block

#method_before
@Override
public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
    final List<storage_server_connections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getstorage());
    final List<LUNs> lunsList = DbFacade.getInstance().getLunDao().getAllForVolumeGroup(storageDomain.getstorage());
    int numOfRemovedLuns = 0;
    for (LUNs lun : lunsList) {
        if (DbFacade.getInstance().getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) == null) {
            DbFacade.getInstance().getLunDao().remove(lun.getLUN_id());
            numOfRemovedLuns++;
        } else {
            DbFacade.getInstance().getLunDao().updateLUNsVolumeGroupId(lun.getLUN_id(), "");
        }
    }
    if (numOfRemovedLuns > 0) {
        for (storage_server_connections connection : FilterConnectionsUsedByOthers(list, storageDomain.getstorage())) {
            DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getid());
        }
    }
    return true;
}
#method_after
@Override
public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
    int numOfRemovedLuns = removeStorageDomainLuns(storageDomain);
    if (numOfRemovedLuns > 0) {
        List<storage_server_connections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getstorage());
        for (storage_server_connections connection : FilterConnectionsUsedByOthers(list, storageDomain.getstorage())) {
            DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getid());
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStorageDomainStatus(StorageDomainStatus.Locked, null);
    for (LUNs lun : getParameters().getLunsList()) {
        proceedLUNInDb(lun, getStorageDomain().getstorage_type(), getStorageDomain().getstorage());
    }
    if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId().getValue(), getStorageDomain().getId(), getParameters().getLunIds())).getSucceeded()) {
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    setStorageDomainStatus(StorageDomainStatus.Locked, null);
    for (LUNs lun : getParameters().getLunsList()) {
        proceedLUNInDb(lun, getStorageDomain().getstorage_type(), getStorageDomain().getstorage());
    }
    boolean supportForceExtendVG = Config.<Boolean>GetValue(ConfigValues.SupportForceExtendVG, getStoragePool().getcompatibility_version().toString());
    if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId().getValue(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce(), supportForceExtendVG)).getSucceeded()) {
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        setSucceeded(true);
    }
}
#end_block

#method_before
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().updateLUNsVolumeGroupId(lun.getLUN_id(), volumeGroupId);
    }
    for (storage_server_connections connection : lun.getLunConnections()) {
        List<storage_server_connections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.NewGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#method_after
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    if (getLunDao().get(lun.getLUN_id()) == null) {
        getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        getLunDao().updateLUNsVolumeGroupId(lun.getLUN_id(), volumeGroupId);
    }
    for (storage_server_connections connection : lun.getLunConnections()) {
        List<storage_server_connections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.NewGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#end_block

#method_before
@Override
public List<LUNs> getAllForVolumeGroup(String id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("volume_group_id", id);
    return getCallsHandler().executeReadList("GetLUNsByVolumeGroupId", MAPPER, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<LUNs> getAllForVolumeGroup(String id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("volume_group_id", id);
    return getCallsHandler().executeReadList("GetLUNsByVolumeGroupId", MAPPER, parameterSource);
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    return model;
}
#end_block

#method_before
@Before
public void setUp() {
    VmHandler.Init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.NewGuid());
    group.setcompatibility_version(Version.v3_0);
    vm.setvds_group_id(group.getId());
    vmStatic.setvds_group_id(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        protected VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(backendInternal).when(command).getBackend();
}
#method_after
@Before
public void setUp() {
    VmHandler.Init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.NewGuid());
    group.setcompatibility_version(Version.v3_0);
    vm.setVdsGroupId(group.getId());
    vmStatic.setvds_group_id(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        protected VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(backendInternal).when(command).getBackend();
}
#end_block

#method_before
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setvm_name("vm1");
    mockSameNameQuery(true);
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#method_after
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setVmName("vm1");
    mockSameNameQuery(true);
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    // check if display type was changed in given parameters
    if (vm.getdisplay_type() != vm.getdefault_display_type()) {
        if (vm.getdisplay_type() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // check if display type was changed in given parameters
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        if (vm.getDisplayType() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (vm.getHasAgent()) {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getvds_group_compatibility_version());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (vm.getHasAgent()) {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getVdsGroupCompatibilityVersion());
                    // Doual Mode: in this case we have to insert 2 interfaces with the same entries except nicModel
                    XmlRpcStruct rtl8139Struct = new XmlRpcStruct();
                    addNetworkInterfaceProperties(rtl8139Struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getVdsGroupCompatibilityVersion());
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getVdsGroupCompatibilityVersion());
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getVdsGroupCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmSoundDevices() {
    if (vm.getVmType() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                String deviceId = (String) struct.getItem(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.getKeys().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                String deviceId = (String) struct.getItem(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.getKeys().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    // vnc,qxl
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    createInfo.add(VdsProperties.num_of_monitors, String.valueOf(vm.getnum_of_monitors()));
}
#method_after
@Override
protected void buildVmVideoCards() {
    // vnc,qxl
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    createInfo.add(VdsProperties.num_of_monitors, String.valueOf(vm.getNumOfMonitors()));
}
#end_block

#method_before
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        createInfo.add(VdsProperties.soundDevice, getSoundDevice(vm.getStaticData(), vm.getvds_group_compatibility_version()));
    }
}
#method_after
@Override
protected void buildVmSoundDevices() {
    if (vm.getVmType() == VmType.Desktop) {
        createInfo.add(VdsProperties.soundDevice, getSoundDevice(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion()));
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // get device list for the VM
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    String bootSeqInDB = VmDeviceCommonUtils.getBootSequence(devices).toString().toLowerCase();
    String bootSeqInBE = vm.getboot_sequence().toString().toLowerCase();
    // TODO : find another way to distinguish run vs. run-once
    if (bootSeqInBE.equals(bootSeqInDB))
        createInfo.add(VdsProperties.Boot, bootSeqInDB);
    else
        // run once
        createInfo.add(VdsProperties.Boot, bootSeqInBE);
}
#method_after
@Override
protected void buildVmBootSequence() {
    // get device list for the VM
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    String bootSeqInDB = VmDeviceCommonUtils.getBootSequence(devices).toString().toLowerCase();
    String bootSeqInBE = vm.getBootSequence().toString().toLowerCase();
    // TODO : find another way to distinguish run vs. run-once
    if (bootSeqInBE.equals(bootSeqInDB))
        createInfo.add(VdsProperties.Boot, bootSeqInDB);
    else
        // run once
        createInfo.add(VdsProperties.Boot, bootSeqInBE);
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.GetTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            PostInitTemplate();
        }
    }, getModel().getHash()), vm.getvmt_guid());
}
#method_after
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.GetTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            PostInitTemplate();
        }
    }, getModel().getHash()), vm.getVmtGuid());
}
#end_block

#method_before
@Override
public void Initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.Initialize(systemTreeSelectedItem);
    AsyncDataProvider.GetDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                storage_pool dataCenter = (storage_pool) returnValue;
                ArrayList<storage_pool> list = new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dataCenter }));
                model.SetDataCenter(model, list);
                model.getDataCenter().setIsChangable(false);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getvds_group_id());
                tempVar.setname(currentVm.getvds_group_name());
                tempVar.setcompatibility_version(currentVm.getvds_group_compatibility_version());
                tempVar.setstorage_pool_id(currentVm.getstorage_pool_id());
                VDSGroup cluster = tempVar;
                model.getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { cluster })));
                model.getCluster().setSelectedItem(cluster);
                behavior.InitTemplate();
                behavior.InitCdImage();
            }
        }
    }, getModel().getHash()), vm.getstorage_pool_id());
}
#method_after
@Override
public void Initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.Initialize(systemTreeSelectedItem);
    AsyncDataProvider.GetDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                storage_pool dataCenter = (storage_pool) returnValue;
                ArrayList<storage_pool> list = new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dataCenter }));
                model.SetDataCenter(model, list);
                model.getDataCenter().setIsChangable(false);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getVdsGroupId());
                tempVar.setname(currentVm.getVdsGroupName());
                tempVar.setcompatibility_version(currentVm.getVdsGroupCompatibilityVersion());
                tempVar.setStoragePoolId(currentVm.getStoragePoolId());
                VDSGroup cluster = tempVar;
                model.getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { cluster })));
                model.getCluster().setSelectedItem(cluster);
                behavior.InitTemplate();
                behavior.InitCdImage();
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void DataCenter_SelectedItemChanged() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    getModel().setIsHostAvailable(dataCenter.getstorage_pool_type() != StorageType.LOCALFS);
    AsyncDataProvider.GetClusterList(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) array[0];
            UnitVmModel model = (UnitVmModel) array[1];
            VM vm = ((ExistingVmModelBehavior) array[0]).vm;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            model.SetClusters(model, clusters, vm.getvds_group_id().getValue());
            behavior.InitTemplate();
            behavior.InitCdImage();
        }
    }, getModel().getHash()), dataCenter.getId());
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
}
#method_after
@Override
public void DataCenter_SelectedItemChanged() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    getModel().setIsHostAvailable(dataCenter.getstorage_pool_type() != StorageType.LOCALFS);
    AsyncDataProvider.GetClusterList(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) array[0];
            UnitVmModel model = (UnitVmModel) array[1];
            VM vm = ((ExistingVmModelBehavior) array[0]).vm;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            model.SetClusters(model, clusters, vm.getVdsGroupId().getValue());
            behavior.InitTemplate();
            behavior.InitCdImage();
        }
    }, getModel().getHash()), dataCenter.getId());
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
}
#end_block

#method_before
@Override
public void Template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getvm_name());
    getModel().getDescription().setEntity(vm.getvm_description());
    getModel().getMemSize().setEntity(vm.getvm_mem_size_mb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getvm_os());
    getModel().getDomain().setSelectedItem(vm.getvm_domain());
    getModel().getUsbPolicy().setSelectedItem(vm.getusb_policy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getnum_of_monitors());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getdefault_boot_sequence());
    getModel().getIsHighlyAvailable().setEntity(vm.getauto_startup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getnum_of_cpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isStatusUp());
    getModel().getIsStateless().setEntity(vm.getis_stateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getNumOfSockets().setSelectedItem(vm.getnum_of_sockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isStatusUp());
    getModel().getKernel_parameters().setEntity(vm.getkernel_params());
    getModel().getKernel_path().setEntity(vm.getkernel_url());
    getModel().getInitrd_path().setEntity(vm.getinitrd_url());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    if (vm.getis_initialized()) {
        getModel().getTimeZone().setIsChangable(false);
        getModel().getTimeZone().getChangeProhibitionReasons().add(// $NON-NLS-1$
        "Time Zone cannot be change since the Virtual Machine was booted at the first time.");
    }
    updateTimeZone(vm.gettime_zone());
    // Update domain list
    UpdateDomain();
    updateHostPinning(vm.getMigrationSupport());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getvmt_guid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getdefault_display_type()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(vm.getpriority());
}
#method_after
@Override
public void Template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getVmName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOs());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isStatusUp());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isStatusUp());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    if (vm.isInitialized()) {
        getModel().getTimeZone().setIsChangable(false);
        getModel().getTimeZone().getChangeProhibitionReasons().add(// $NON-NLS-1$
        "Time Zone cannot be change since the Virtual Machine was booted at the first time.");
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    UpdateDomain();
    updateHostPinning(vm.getMigrationSupport());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(vm.getPriority());
}
#end_block

#method_before
@Override
protected void ChangeDefualtHost() {
    super.ChangeDefualtHost();
    doChangeDefautlHost(vm.getdedicated_vm_for_vds());
}
#method_after
@Override
protected void ChangeDefualtHost() {
    super.ChangeDefualtHost();
    doChangeDefautlHost(vm.getDedicatedVmForVds());
}
#end_block

#method_before
@Override
public void UpdateMinAllocatedMemory() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    if ((Integer) getModel().getMemSize().getEntity() < vm.getvm_mem_size_mb()) {
        double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
        getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#method_after
@Override
public void UpdateMinAllocatedMemory() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    if ((Integer) getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
        getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#end_block

#method_before
public void InitCdImage() {
    getModel().getCdImage().setSelectedItem(vm.getiso_path());
    boolean hasCd = !StringHelper.isNullOrEmpty(vm.getiso_path());
    getModel().getCdImage().setIsChangable(hasCd);
    getModel().getCdAttached().setEntity(hasCd);
    UpdateCdImage();
}
#method_after
public void InitCdImage() {
    getModel().getCdImage().setSelectedItem(vm.getIsoPath());
    boolean hasCd = !StringHelper.isNullOrEmpty(vm.getIsoPath());
    getModel().getCdImage().setIsChangable(hasCd);
    getModel().getCdAttached().setEntity(hasCd);
    UpdateCdImage();
}
#end_block

#method_before
@Override
public void Template_SelectedItemChanged() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(template.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(template.getdomain());
        getModel().getMemSize().setEntity(template.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(template.getusb_policy());
        getModel().setBootSequence(template.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(template.getauto_startup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getdedicated_vm_for_vds());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        if (getModel().getVmType() == VmType.Desktop) {
            getModel().getIsStateless().setEntity(template.getis_stateless());
            getModel().getAllowConsoleReconnect().setEntity(template.getAllowConsoleReconnect());
        }
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(template.gettime_zone())) {
            updateTimeZone(template.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(template.getvds_group_id()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == template.getdefault_display_type()) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getkernel_url());
        getModel().getKernel_parameters().setEntity(template.getkernel_params());
        getModel().getInitrd_path().setEntity(template.getinitrd_url());
        if (!template.getId().equals(NGuid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        InitPriority(template.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#method_after
@Override
public void Template_SelectedItemChanged() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(template.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(template.getdomain());
        getModel().getMemSize().setEntity(template.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(template.getusb_policy());
        getModel().setBootSequence(template.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(template.getauto_startup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getdedicated_vm_for_vds());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        if (getModel().getVmType() == VmType.Desktop) {
            getModel().getIsStateless().setEntity(template.getis_stateless());
            getModel().getAllowConsoleReconnect().setEntity(template.getAllowConsoleReconnect());
        }
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(template.gettime_zone())) {
            updateTimeZone(template.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == template.getdefault_display_type()) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getkernel_url());
        getModel().getKernel_parameters().setEntity(template.getkernel_params());
        getModel().getInitrd_path().setEntity(template.getinitrd_url());
        if (!template.getId().equals(NGuid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        InitPriority(template.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(vmBase.getdomain());
        getModel().getMemSize().setEntity(vmBase.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(vmBase.getusb_policy());
        getModel().setBootSequence(vmBase.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.getauto_startup());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(vmBase.gettime_zone())) {
            updateTimeZone(vmBase.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(vmBase.getvds_group_id()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getkernel_url());
        getModel().getKernel_parameters().setEntity(vmBase.getkernel_params());
        getModel().getInitrd_path().setEntity(vmBase.getinitrd_url());
        getModel().setIsDisksAvailable(true);
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        InitPriority(vmBase.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(vmBase.getdomain());
        getModel().getMemSize().setEntity(vmBase.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(vmBase.getusb_policy());
        getModel().setBootSequence(vmBase.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.getauto_startup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(vmBase.gettime_zone())) {
            updateTimeZone(vmBase.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(vmBase.getvds_group_id()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getkernel_url());
        getModel().getKernel_parameters().setEntity(vmBase.getkernel_params());
        getModel().getInitrd_path().setEntity(vmBase.getinitrd_url());
        getModel().setIsDisksAvailable(true);
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        InitPriority(vmBase.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#end_block

#method_before
public boolean canRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator, VmPropertiesUtils vmPropsUtils) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else if (!(validationErrors = vmPropsUtils.validateVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData())).isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<Disk> vmDisks = getPluggedDisks(vm);
        if (boot_sequence == BootSequence.C && vmDisks.size() == 0) {
            String messageStr = !vmDisks.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmDisks.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    if (retValue && !performImageChecksForRunningVm(vm, message, runParams, vmDisks)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) getBackend().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDao().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                message.add(VdcBllMessages.VAR__HOST_STATUS__UP.toString());
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && isVmInPreview(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        if (retValue && isStatelessVm && !hasSpaceForSnapthosts(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.name());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.canFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public boolean canRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator, VmPropertiesUtils vmPropsUtils) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else if (!(validationErrors = vmPropsUtils.validateVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData())).isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getDefaultBootSequence();
        Guid storagePoolId = vm.getStoragePoolId();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<Disk> vmDisks = getPluggedDisks(vm);
        if (boot_sequence == BootSequence.C && vmDisks.size() == 0) {
            String messageStr = !vmDisks.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmDisks.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    if (retValue && !performImageChecksForRunningVm(vm, message, runParams, vmDisks)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.isAutoStartup() && !validateIsoPath(findActiveISODomain(vm.getStoragePoolId()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) getBackend().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getStatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                        } else if (vm.getStatus() == VMStatus.Paused && vm.getRunOnVds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDao().get(new Guid(vm.getRunOnVds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                message.add(VdcBllMessages.VAR__HOST_STATUS__UP.toString());
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && isVmInPreview(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.isAutoStartup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        if (retValue && isStatelessVm && !hasSpaceForSnapthosts(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.name());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.canFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean performImageChecksForRunningVm(VM vm, List<String> message, RunVmParams runParams, List<Disk> vmDisks) {
    return ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmDisks);
}
#method_after
protected boolean performImageChecksForRunningVm(VM vm, List<String> message, RunVmParams runParams, List<Disk> vmDisks) {
    return ImagesHandler.PerformImagesChecks(vm, message, vm.getStoragePoolId(), Guid.Empty, !vm.isAutoStartup(), true, false, false, false, false, !vm.isAutoStartup() || !runParams.getIsInternal() && vm.isAutoStartup(), !vm.isAutoStartup() || !runParams.getIsInternal() && vm.isAutoStartup(), vmDisks);
}
#end_block

#method_before
public boolean shouldVmRunAsStateless(RunVmParams param, VM vm) {
    if (param.getRunAsStateless() != null) {
        return param.getRunAsStateless();
    }
    return vm.getis_stateless();
}
#method_after
public boolean shouldVmRunAsStateless(RunVmParams param, VM vm) {
    if (param.getRunAsStateless() != null) {
        return param.getRunAsStateless();
    }
    return vm.isStateless();
}
#end_block

#method_before
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (String s : EnumCompat.GetNames(VDSType.class)) {
        if (StringHelper.stringsEqual(s, VDSType.PowerClient.toString())) {
            if (showPowerclient) {
                ret.add(s);
            }
        } else {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (VDSType vdsType : VDSType.values()) {
        if (VDSType.PowerClient == vdsType) {
            if (showPowerclient) {
                ret.add(vdsType.name());
            }
        } else {
            ret.add(vdsType.name());
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EnumCompat.GetValues(EventNotificationEntity.class)) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>();
    for (VmInterfaceType item : EnumCompat.GetValues(VmInterfaceType.class)) {
        list.add(item);
    }
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        list.remove(VmInterfaceType.e1000);
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#method_after
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>(Arrays.asList(VmInterfaceType.values()));
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#end_block

#method_before
public static Iterable GetUsbPolicyList() {
    return EnumCompat.GetValues(UsbPolicy.class);
}
#method_after
public static Iterable GetUsbPolicyList() {
    return Arrays.asList(UsbPolicy.values());
}
#end_block

#method_before
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    } else {
        return super.getVmId();
    }
}
#method_after
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    }
    return super.getVmId();
}
#end_block

#method_before
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    } else {
        return super.getVm();
    }
}
#method_after
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    }
    return super.getVm();
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setvm_name(getParameters().getVm().getvm_name());
    getVm().setstorage_pool_id(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setVmName(getParameters().getVm().getVmName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#end_block

#method_before
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                // Iterate over all the VM images (active image and snapshots)
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        // a match with the image from the VM.
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                                // Validate the configuration of the image got from the parameters.
                                retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                                break;
                            }
                        }
                    } else {
                        // If no copy collapse sent, validate each image configuration (snapshot or active image).
                        retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                    }
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#method_after
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            }
            domainsMap.put(destGuid, storageDomain);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                // Iterate over all the VM images (active image and snapshots)
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        // a match with the image from the VM.
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                                // Validate the configuration of the image got from the parameters.
                                retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                                break;
                            }
                        }
                    } else {
                        // If no copy collapse sent, validate each image configuration (snapshot or active image).
                        retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                    }
                    if (!retVal) {
                        break;
                    }
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    // we put the source domain id in order that copy will
                    // work properly.
                    // we fix it to DestDomainId in
                    // MoveOrCopyAllImageGroups();
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !templateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        VmHandler.updateImportedVmUsbPolicy(vm.getStaticData());
        retVal = VmHandler.isUsbPolicyLegal(vm.getusb_policy(), vm.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
private boolean canDoAction_afterCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (retVal) {
        if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, canDoActionMessages);
                    if (!retVal) {
                        break;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !templateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    // Check that the USB policy is legal
    if (retVal) {
        VmHandler.updateImportedVmUsbPolicy(vm.getStaticData());
        retVal = VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = validateMacAddress(getVm().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getvmt_guid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getvmt_guid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#method_after
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getVmtGuid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getVmtGuid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getvm_name())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#method_after
private boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getVmName())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#end_block

#method_before
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getmem_size_mb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(getVm().getvds_group_id());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(getVm().getVdsGroupId());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getVdsGroupId()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getvm_name());
}
#method_after
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getVmName());
}
#end_block

#method_before
protected boolean updateVmInSpm() {
    return VmCommand.updateVmInSpm(getVm().getstorage_pool_id(), new ArrayList<VM>(Arrays.asList(new VM[] { getVm() })));
}
#method_after
protected boolean updateVmInSpm() {
    return VmCommand.updateVmInSpm(getVm().getStoragePoolId(), new ArrayList<VM>(Arrays.asList(new VM[] { getVm() })));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getvds_group_id(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (ObjectIdentityChecker.CanUpdateField(vm, "vds_group_id", vm.getstatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getstorage_pool_id().equals(vm.getstorage_pool_id())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
            // Check the destination cluster have all the networks that the VM use
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
            StringBuilder missingNets = new StringBuilder();
            for (VmNetworkInterface iface : interfaces) {
                String netName = iface.getNetworkName();
                if (isNotEmpty(netName)) {
                    boolean exists = false;
                    for (Network net : networks) {
                        if (net.getname().equals(netName)) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        if (missingNets.length() > 0) {
                            missingNets.append(", ");
                        }
                        missingNets.append(netName);
                    }
                }
            }
            if (missingNets.length() > 0) {
                addCanDoActionMessage(VdcBllMessages.MOVE_VM_CLUSTER_MISSING_NETWORK);
                addCanDoActionMessage(String.format("$networks %1$s", missingNets.toString()));
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.CheckCpuSockets(vm.getStaticData().getnum_of_sockets(), vm.getStaticData().getcpu_per_socket(), targetCluster.getcompatibility_version().getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getusb_policy(), vm.getos(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (ObjectIdentityChecker.CanUpdateField(vm, "vds_group_id", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
            // Check the destination cluster have all the networks that the VM use
            List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
            StringBuilder missingNets = new StringBuilder();
            for (VmNetworkInterface iface : interfaces) {
                String netName = iface.getNetworkName();
                if (isNotEmpty(netName)) {
                    boolean exists = false;
                    for (Network net : networks) {
                        if (net.getname().equals(netName)) {
                            exists = true;
                            break;
                        }
                    }
                    if (!exists) {
                        if (missingNets.length() > 0) {
                            missingNets.append(", ");
                        }
                        missingNets.append(netName);
                    }
                }
            }
            if (missingNets.length() > 0) {
                addCanDoActionMessage(VdcBllMessages.MOVE_VM_CLUSTER_MISSING_NETWORK);
                addCanDoActionMessage(String.format("$networks %1$s", missingNets.toString()));
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.CheckCpuSockets(vm.getStaticData().getnum_of_sockets(), vm.getStaticData().getcpu_per_socket(), targetCluster.getcompatibility_version().getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getvds_group_id().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    for (final VmNetworkInterface iface : interfaces) {
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return iface.getNetworkName().equals(n.getname());
            }
        });
        // interface connection
        if (net == null) {
            iface.setNetworkName(null);
            DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
        }
    }
    if (vm.getdedicated_vm_for_vds() != null) {
        vm.setdedicated_vm_for_vds(null);
        dedicatedHostWasCleared = true;
    }
    vm.setvds_group_id(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // check that the cluster are not the same
    VM vm = getVm();
    if (vm.getVdsGroupId().equals(getParameters().getClusterId())) {
        setSucceeded(true);
        return;
    }
    // update vm interfaces
    List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getClusterId());
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    for (final VmNetworkInterface iface : interfaces) {
        Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return iface.getNetworkName().equals(n.getname());
            }
        });
        // interface connection
        if (net == null) {
            iface.setNetworkName(null);
            DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
        }
    }
    if (vm.getDedicatedVmForVds() != null) {
        vm.setDedicatedVmForVds(null);
        dedicatedHostWasCleared = true;
    }
    vm.setVdsGroupId(getParameters().getClusterId());
    DbFacade.getInstance().getVmStaticDao().update(vm.getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
protected ImportVmParameters createParameters() {
    final VM v = createVM();
    v.setvm_name("testVm");
    final ImportVmParameters p = new ImportVmParameters(v, Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid());
    return p;
}
#method_after
protected ImportVmParameters createParameters() {
    final VM v = createVM();
    v.setVmName("testVm");
    final ImportVmParameters p = new ImportVmParameters(v, Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid(), Guid.NewGuid());
    return p;
}
#end_block

#method_before
private void checkVmName(boolean isImportAsNewEntity, String name) {
    ImportVmParameters parameters = createParameters();
    parameters.getVm().setvm_name(name);
    parameters.setImportAsNewEntity(isImportAsNewEntity);
    ImportVmCommand command = spy(new ImportVmCommand(parameters));
    Set<ConstraintViolation<ImportVmParameters>> validate = ValidationUtils.getValidator().validate(parameters, command.getValidationGroups().toArray(new Class<?>[0]));
    Assert.isTrue(validate.isEmpty() == !isImportAsNewEntity);
}
#method_after
private void checkVmName(boolean isImportAsNewEntity, String name) {
    ImportVmParameters parameters = createParameters();
    parameters.getVm().setVmName(name);
    parameters.setImportAsNewEntity(isImportAsNewEntity);
    ImportVmCommand command = spy(new ImportVmCommand(parameters));
    Set<ConstraintViolation<ImportVmParameters>> validate = ValidationUtils.getValidator().validate(parameters, command.getValidationGroups().toArray(new Class<?>[0]));
    Assert.isTrue(validate.isEmpty() == !isImportAsNewEntity);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getstorage_pool_id(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getstorage_pool_id(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#end_block

#method_before
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getstorage_pool_id());
        }
    }
    return super.getStoragePoolId();
}
#method_after
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getStoragePoolId());
        }
    }
    return super.getStoragePoolId();
}
#end_block

#method_before
public static boolean updateVmInSpm(Guid storagePoolId, List<VM> vmsList, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>(vmsList.size());
    OvfManager ovfManager = new OvfManager();
    for (VM vm : vmsList) {
        ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
        VmHandler.updateDisksFromDb(vm);
        if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
            vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
        }
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isAllowSnapshot()) {
                DiskImage diskImage = (DiskImage) disk;
                AllVmImages.addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
            }
        }
        if (StringUtils.isEmpty(vm.getvmt_name())) {
            VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getvmt_guid());
            vm.setvmt_name(t.getname());
        }
        String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
        vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

            @Override
            public Guid eval(Disk a) {
                return a.getId();
            }
        })));
    }
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
public static boolean updateVmInSpm(Guid storagePoolId, List<VM> vmsList, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>(vmsList.size());
    OvfManager ovfManager = new OvfManager();
    for (VM vm : vmsList) {
        ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
        VmHandler.updateDisksFromDb(vm);
        if (vm.getInterfaces() == null || vm.getInterfaces().isEmpty()) {
            vm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
        }
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isAllowSnapshot()) {
                DiskImage diskImage = (DiskImage) disk;
                AllVmImages.addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
            }
        }
        if (StringUtils.isEmpty(vm.getVmtName())) {
            VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getVmtGuid());
            vm.setVmtName(t.getname());
        }
        String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
        vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, LinqUtils.foreach(vm.getDiskMap().values(), new Function<Disk, Guid>() {

            @Override
            public Guid eval(Disk a) {
                return a.getId();
            }
        })));
    }
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected void endActionOnVmConfiguration() {
    if (getVm() != null) {
        if (getVm().getstatus() == VMStatus.ImageLocked) {
            VmHandler.unlockVm(getVm(), getCompensationContext());
        }
        updateVmInSpm(getVm().getstorage_pool_id(), Arrays.asList(getVm()));
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
}
#method_after
protected void endActionOnVmConfiguration() {
    if (getVm() != null) {
        if (getVm().getStatus() == VMStatus.ImageLocked) {
            VmHandler.unlockVm(getVm(), getCompensationContext());
        }
        updateVmInSpm(getVm().getStoragePoolId(), Arrays.asList(getVm()));
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
}
#end_block

#method_before
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().getHibernationVolHandle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getvm_name();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getvm_os().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#method_after
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getVmName();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getVmOs().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#end_block

#method_before
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getos().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getOs().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getstorage_pool_id() != null ? getVdsGroup().getstorage_pool_id().getValue() : Guid.Empty);
    }
}
#method_after
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId().getValue() : Guid.Empty);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getVmName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getvds_group_id()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getstatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getstorage_ids().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getstorage_ids().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getstorage_ids().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getstorage_ids().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            getParameters().getImagesParameters().add(tempVar);
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    if (getVm() != null) {
        removeVmInSpm(getVm().getstorage_pool_id(), getVmId());
    }
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    if (getVm() != null) {
        removeVmInSpm(getVm().getStoragePoolId(), getVmId());
    }
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getvm_name())) {
        return Collections.singletonMap(getParameters().getVm().getvm_name(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getVmName())) {
        return Collections.singletonMap(getParameters().getVm().getVmName(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#end_block

#method_before
private void glusterHostRemove() {
    if (isGlusterEnabled() && clusterHasMultipleHosts() && !hasVolumeOnServer()) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostRemove, new GlusterHostRemoveVDSParameters(upServer.getId(), getVds().gethost_name(), getParameters().isForceAction()));
        setSucceeded(returnValue.getSucceeded());
        if (!getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            errorType = AuditLogType.GLUSTER_HOST_REMOVE_FAILED;
            return;
        }
    }
}
#method_after
private void glusterHostRemove() {
    if (isGlusterEnabled() && clusterHasMultipleHosts() && !hasVolumeOnServer()) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(upServer.getId(), getVds().gethost_name(), getParameters().isForceAction()));
        setSucceeded(returnValue.getSucceeded());
        if (!getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
            return;
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    GlusterServerParameters parameters = createParameters();
    command = spy(new RemoveVdsCommand<GlusterServerParameters>(parameters));
    clusterUtils = mock(ClusterUtils.class);
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    doReturn(glusterBrickDao).when(command).getGlusterBrickDao();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsGroup).when(vdsGroupDao).get(Mockito.any(Guid.class));
    doReturn(clusterUtils).when(command).getClusterUtils();
    when(clusterUtils.getUpServer(CLUSTER_ID)).thenReturn(getVds(VDSStatus.Up));
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    command = spy(new RemoveVdsCommand<RemoveVdsParameters>(new RemoveVdsParameters(Guid.NewGuid(), false)));
    clusterUtils = mock(ClusterUtils.class);
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vmStaticDAO).when(command).getVmStaticDAO();
    doReturn(storagePoolDAO).when(command).getStoragePoolDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    doReturn(glusterBrickDao).when(command).getGlusterBrickDao();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsGroup).when(vdsGroupDao).get(Mockito.any(Guid.class));
    doReturn(clusterUtils).when(command).getClusterUtils();
    when(clusterUtils.getUpServer(CLUSTER_ID)).thenReturn(getVds(VDSStatus.Up));
}
#end_block

#method_before
@Test
public void isCpuPinningValid() {
    Assert.assertTrue("null value must be accepted", VmManagementCommandBase.isCpuPinningValid(null));
    Assert.assertTrue("empty string must be accepted", VmManagementCommandBase.isCpuPinningValid(""));
    Assert.assertFalse(VmManagementCommandBase.isCpuPinningValid("intentionally invalid"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3,^2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^5,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^1,^2,^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8,9-12"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,^3,9-12,^10"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0_1#1"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-2_1#1-2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#1-4,^3"));
    // validate vcpus over 9
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3"));
}
#method_after
@Test
public void isCpuPinningValid() {
    Assert.assertTrue("null value must be accepted", VmManagementCommandBase.isCpuPinningValid(null));
    Assert.assertTrue("empty string must be accepted", VmManagementCommandBase.isCpuPinningValid(""));
    Assert.assertFalse(VmManagementCommandBase.isCpuPinningValid("intentionally invalid"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3,^2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^5,^6,^7"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^1,^2,^3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8,9-12"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,^3,9-12,^10"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0_1#1"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-2_1#1-2"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#2,3"));
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#1-4,^3"));
    // validate vcpus over 9
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3"));
    // negative tests
    Assert.assertFalse("random wrong text", VmManagementCommandBase.isCpuPinningValid("lorem ipsum"));
    Assert.assertFalse("no cpu id specified, should not pass", VmManagementCommandBase.isCpuPinningValid("0"));
    Assert.assertFalse("letter instead of vcpu ID", VmManagementCommandBase.isCpuPinningValid("A#1"));
    Assert.assertFalse("letter instead of cpu ID", VmManagementCommandBase.isCpuPinningValid("0#B"));
    Assert.assertFalse("A separating _ while only one vcpu pinning", VmManagementCommandBase.isCpuPinningValid("0#1_"));
    Assert.assertFalse("Trailing _", VmManagementCommandBase.isCpuPinningValid("0#1_1#2_"));
    Assert.assertFalse("Too many separators", VmManagementCommandBase.isCpuPinningValid("0#1__1#2"));
    Assert.assertFalse("trailing junk", VmManagementCommandBase.isCpuPinningValid("0#1_1#2..."));
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isPreventDeletion(), transform.isPreventDeletion());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setis_stateless(model.isStateless());
    }
    if (model.isSetPreventDeletion()) {
        entity.setPreventDeletion(model.isPreventDeletion());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                entity.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        entity.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    if (model.isSetUsb() && model.getUsb().isSetEnabled()) {
        entity.setusb_policy(model.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setname(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setis_stateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                entity.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        entity.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        entity.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    if (model.isSetUsb() && model.getUsb().isSetEnabled()) {
        entity.setusb_policy(model.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setvm_name(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setis_stateless(model.isStateless());
    }
    if (model.isSetPreventDeletion()) {
        staticVm.setPreventDeletion(model.isPreventDeletion());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                staticVm.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setvm_name(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(new Guid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setdescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setauto_startup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setpriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setis_stateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setvm_type(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setorigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setmem_size_mb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setcpu_per_socket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setnum_of_sockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            OsType osType = OsType.fromValue(model.getOs().getType());
            if (osType != null) {
                staticVm.setos(VmMapper.map(osType, null));
            }
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setkernel_url(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setkernel_params(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        staticVm.setdomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(model.getTimezone()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getname());
    model.setDescription(entity.getdescription());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    model.setStateless(entity.getis_stateless());
    model.setPreventDeletion(entity.getPreventDeletion());
    if (entity.getvm_type() != null) {
        model.setType(VmMapper.map(entity.getvm_type(), null));
    }
    if (entity.getorigin() != null) {
        model.setOrigin(VmMapper.map(entity.getorigin(), null));
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
    }
    if (entity.getos() != null || entity.getdefault_boot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getos() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getdefault_boot_sequence() != null) {
            for (Boot boot : VmMapper.map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getdefault_display_type(), null));
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    if (entity.getcreation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getcreation_date(), null));
    }
    if (entity.getdomain() != null && !entity.getdomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getdomain());
        model.setDomain(domain);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    return model;
}
#method_after
@Mapping(from = VmTemplate.class, to = Template.class)
public static Template map(VmTemplate entity, Template incoming) {
    Template model = incoming != null ? incoming : new Template();
    model.setId(entity.getId().toString());
    model.setName(entity.getname());
    model.setDescription(entity.getdescription());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    model.setStateless(entity.getis_stateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    if (entity.getvm_type() != null) {
        model.setType(VmMapper.map(entity.getvm_type(), null));
    }
    if (entity.getorigin() != null) {
        model.setOrigin(VmMapper.map(entity.getorigin(), null));
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
    }
    if (entity.getos() != null || entity.getdefault_boot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getos() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getdefault_boot_sequence() != null) {
            for (Boot boot : VmMapper.map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    model.setCpu(new CPU());
    model.getCpu().setTopology(topology);
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        model.getDisplay().setType(VmMapper.map(entity.getdefault_display_type(), null));
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    if (entity.getcreation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getcreation_date(), null));
    }
    if (entity.getdomain() != null && !entity.getdomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getdomain());
        model.setDomain(domain);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    return model;
}
#end_block

#method_before
@Override
protected void verify(Template model, Template transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.isSetOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertNotNull(model.getDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isPreventDeletion(), transform.isPreventDeletion());
}
#method_after
@Override
protected void verify(Template model, Template transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.isSetOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertNotNull(model.getDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setPreventDeletion(entity.getPreventDeletion());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetPreventDeletion()) {
        staticVm.setPreventDeletion(vm.isPreventDeletion());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setPreventDeletion(entity.getPreventDeletion());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("prevent_deletion", vm.getPreventDeletion()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning());
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("domain", vm.getdomain()).addValue("creation_date", vm.getcreation_date()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning());
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().getPreventDeletion()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
public static void Init() {
    mUpdateVmTemplate = new ObjectIdentityChecker(VmTemplateHandler.class);
    BlankVmTemplateId = new Guid("00000000-0000-0000-0000-000000000000");
    mUpdateVmTemplate.AddPermittedFields(new String[] { "name", "description", "domain", "os", "osType", "is_auto_suspend", "interfaces", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "vds_group_id", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "time_zone", "diskMap", "default_boot_sequence", "iso_path", "diskImageMap", "default_display_type", "priority", "auto_startup", "is_stateless", "initrd_url", "kernel_url", "kernel_params", "images", "interfaces", "quotaId", "quotaName", "quotaEnforcementType", "migrationSupport", "dedicated_vm_for_vds", "smartcardEnabled", "preventDeletion" });
}
#method_after
public static void Init() {
    mUpdateVmTemplate = new ObjectIdentityChecker(VmTemplateHandler.class);
    BlankVmTemplateId = new Guid("00000000-0000-0000-0000-000000000000");
    mUpdateVmTemplate.AddPermittedFields(new String[] { "name", "description", "domain", "os", "osType", "is_auto_suspend", "interfaces", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "vds_group_id", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "time_zone", "diskMap", "default_boot_sequence", "iso_path", "diskImageMap", "default_display_type", "priority", "auto_startup", "is_stateless", "initrd_url", "kernel_url", "kernel_params", "images", "interfaces", "quotaId", "quotaName", "quotaEnforcementType", "migrationSupport", "dedicated_vm_for_vds", "smartcardEnabled", "deleteProtected" });
}
#end_block

#method_before
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(vmBase.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("PreventDeletion");
    _writer.WriteRaw(String.valueOf(vmBase.getPreventDeletion()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(vmBase.getinitrd_url())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_url())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_params())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getkernel_params());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getvm_type().getValue()));
    _writer.WriteEndElement();
}
#method_after
protected void writeGeneralData() {
    _writer.WriteStartElement("Description");
    _writer.WriteRaw(vmBase.getdescription());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Domain");
    _writer.WriteRaw(vmBase.getdomain());
    _writer.WriteEndElement();
    _writer.WriteStartElement("CreationDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(vmBase.getcreation_date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("ExportDate");
    _writer.WriteRaw(OvfParser.LocalDateToUtcDateString(new Date()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsAutoSuspend");
    _writer.WriteRaw(String.valueOf(vmBase.getis_auto_suspend()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("DeleteProtected");
    _writer.WriteRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsSmartcardEnabled");
    _writer.WriteRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TimeZone");
    _writer.WriteRaw(vmBase.gettime_zone());
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_boot_sequence");
    _writer.WriteRaw(String.valueOf(vmBase.getdefault_boot_sequence().getValue()));
    _writer.WriteEndElement();
    if (!StringHelper.isNullOrEmpty(vmBase.getinitrd_url())) {
        _writer.WriteStartElement("initrd_url");
        _writer.WriteRaw(vmBase.getinitrd_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_url())) {
        _writer.WriteStartElement("kernel_url");
        _writer.WriteRaw(vmBase.getkernel_url());
        _writer.WriteEndElement();
    }
    if (!StringHelper.isNullOrEmpty(vmBase.getkernel_params())) {
        _writer.WriteStartElement("kernel_params");
        _writer.WriteRaw(vmBase.getkernel_params());
        _writer.WriteEndElement();
    }
    _writer.WriteStartElement("VmType");
    _writer.WriteRaw(String.valueOf(vmBase.getvm_type().getValue()));
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
public void BuildNetwork() {
}
#method_after
@Override
public void BuildNetwork() {
// No implementation - networks aren't read from the OVF.
}
#end_block

#method_before
@Override
public void BuildDisk() {
    XmlNodeList list = _document.SelectNodes("//*/Section/Disk");
    for (XmlNode node : list) {
        final Guid guid = new Guid(node.Attributes.get("ovf:diskId").getValue());
        DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getImageId().equals(guid);
            }
        });
        if (node.Attributes.get("ovf:vm_snapshot_id") != null) {
            image.setvm_snapshot_id(new Guid(node.Attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:size").getValue())) {
            image.setsize(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:size").getValue())));
        }
        if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:actual_size").getValue())) {
            image.setactual_size(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:actual_size").getValue())));
        }
        if (node.Attributes.get("ovf:volume-format") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:volume-format").getValue())) {
                image.setvolume_format(VolumeFormat.valueOf(node.Attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setvolume_format(VolumeFormat.Unassigned);
            }
        } else {
            image.setvolume_format(VolumeFormat.Unassigned);
        }
        if (node.Attributes.get("ovf:volume-type") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:volume-type").getValue())) {
                image.setvolume_type(VolumeType.valueOf(node.Attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setvolume_type(VolumeType.Unassigned);
            }
        } else {
            image.setvolume_type(VolumeType.Unassigned);
        }
        if (node.Attributes.get("ovf:disk-interface") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:disk-interface").getValue())) {
                image.setDiskInterface(DiskInterface.valueOf(node.Attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            image.setDiskInterface(DiskInterface.IDE);
        }
        if (node.Attributes.get("ovf:boot") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:boot").getValue())) {
                image.setBoot(Boolean.parseBoolean(node.Attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.Attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.Attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-alias") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.Attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-description") != null) {
            if (!StringHelper.isNullOrEmpty(node.Attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.Attributes.get("ovf:disk-description").getValue()));
            }
        }
    }
}
#method_after
@Override
public void BuildDisk() {
    XmlNodeList list = _document.SelectNodes("//*/Section/Disk");
    for (XmlNode node : list) {
        final Guid guid = new Guid(node.Attributes.get("ovf:diskId").getValue());
        DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

            @Override
            public boolean eval(DiskImage diskImage) {
                return diskImage.getImageId().equals(guid);
            }
        });
        if (node.Attributes.get("ovf:vm_snapshot_id") != null) {
            image.setvm_snapshot_id(new Guid(node.Attributes.get("ovf:vm_snapshot_id").getValue()));
        }
        if (!StringUtils.isEmpty(node.Attributes.get("ovf:size").getValue())) {
            image.setsize(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:size").getValue())));
        }
        if (!StringUtils.isEmpty(node.Attributes.get("ovf:actual_size").getValue())) {
            image.setactual_size(GigabyteToBytes(Long.parseLong(node.Attributes.get("ovf:actual_size").getValue())));
        }
        if (node.Attributes.get("ovf:volume-format") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:volume-format").getValue())) {
                image.setvolume_format(VolumeFormat.valueOf(node.Attributes.get("ovf:volume-format").getValue()));
            } else {
                image.setvolume_format(VolumeFormat.Unassigned);
            }
        } else {
            image.setvolume_format(VolumeFormat.Unassigned);
        }
        if (node.Attributes.get("ovf:volume-type") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:volume-type").getValue())) {
                image.setvolume_type(VolumeType.valueOf(node.Attributes.get("ovf:volume-type").getValue()));
            } else {
                image.setvolume_type(VolumeType.Unassigned);
            }
        } else {
            image.setvolume_type(VolumeType.Unassigned);
        }
        if (node.Attributes.get("ovf:disk-interface") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:disk-interface").getValue())) {
                image.setDiskInterface(DiskInterface.valueOf(node.Attributes.get("ovf:disk-interface").getValue()));
            }
        } else {
            image.setDiskInterface(DiskInterface.IDE);
        }
        if (node.Attributes.get("ovf:boot") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:boot").getValue())) {
                image.setBoot(Boolean.parseBoolean(node.Attributes.get("ovf:boot").getValue()));
            }
        }
        if (node.Attributes.get("ovf:wipe-after-delete") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:wipe-after-delete").getValue())) {
                image.setWipeAfterDelete(Boolean.parseBoolean(node.Attributes.get("ovf:wipe-after-delete").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-alias") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:disk-alias").getValue())) {
                image.setDiskAlias(String.valueOf(node.Attributes.get("ovf:disk-alias").getValue()));
            }
        }
        if (node.Attributes.get("ovf:disk-description") != null) {
            if (!StringUtils.isEmpty(node.Attributes.get("ovf:disk-description").getValue())) {
                image.setDiskDescription(String.valueOf(node.Attributes.get("ovf:disk-description").getValue()));
            }
        }
    }
}
#end_block

#method_before
public void readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringHelper.isNullOrEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText));
    } else {
        int resourceType = getResourceType(node, vmDevice, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceType.getoVirtDevice(resourceType).getName());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (isManaged) {
        vmBase.getManagedVmDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
}
#method_after
public void readVmDevice(XmlNode node, VmBase vmBase, Guid deviceId, boolean isManaged) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText)) {
        vmDevice.setAddress(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ADDRESS, _xmlNS).InnerText));
    } else {
        vmDevice.setAddress("");
    }
    if (node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText)) {
        vmDevice.setAlias(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_ALIAS, _xmlNS).InnerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = node.SelectSingleNode(OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.InnerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText)) {
        vmDevice.setType(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_TYPE, _xmlNS).InnerText));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceType.getoVirtDevice(resourceType).getName());
    }
    if (node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText)) {
        vmDevice.setDevice(String.valueOf(node.SelectSingleNode(OvfProperties.VMD_DEVICE, _xmlNS).InnerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText)) {
        vmDevice.setBootOrder(Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_BOOT_ORDER, _xmlNS).InnerText));
    } else {
        vmDevice.setBootOrder(0);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_PLUGGED, _xmlNS).InnerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(node.SelectSingleNode(OvfProperties.VMD_IS_READONLY, _xmlNS).InnerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (isManaged) {
        vmBase.getManagedVmDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    } else {
        vmBase.getUnmanagedDeviceList().add(vmDevice);
    }
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if (StringHelper.EqOp(value, "ovf:OperatingSystemSection_Type")) {
            ReadOsSection(section);
        } else if (StringHelper.EqOp(value, "ovf:VirtualHardwareSection_Type")) {
            ReadHardwareSection(section);
        } else if (StringUtils.equals(value, "ovf:SnapshotsSection_Type")) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("PreventDeletion");
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if ("ovf:OperatingSystemSection_Type".equals(value)) {
            ReadOsSection(section);
        } else if ("ovf:VirtualHardwareSection_Type".equals(value)) {
            ReadHardwareSection(section);
        } else if ("ovf:SnapshotsSection_Type".equals(value)) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#end_block

#method_before
protected void readSnapshotsSection(XmlNode section) {
}
#method_after
protected void readSnapshotsSection(@SuppressWarnings("unused") XmlNode section) {
// The snapshot section only has meaning for VMs, and is overridden in OvfVmReader.
}
#end_block

#method_before
private void buildImageReference() {
    XmlNodeList list = _document.SelectNodes("//*/File", _xmlNS);
    for (XmlNode node : list) {
        DiskImage image = new DiskImage();
        image.setImageId(new Guid(node.Attributes.get("ovf:id").getValue()));
        image.setimage_group_id(OvfParser.GetImageGrupIdFromImageFile(node.Attributes.get("ovf:href").getValue()));
        // Default values:
        image.setactive(true);
        image.setimageStatus(ImageStatus.OK);
        image.setdescription(node.Attributes.get("ovf:description").getValue());
        _images.add(image);
    }
}
#method_after
private void buildImageReference() {
    XmlNodeList list = _document.SelectNodes("//*/File", _xmlNS);
    for (XmlNode node : list) {
        DiskImage image = new DiskImage();
        image.setImageId(new Guid(node.Attributes.get("ovf:id").getValue()));
        image.setId(OvfParser.GetImageGrupIdFromImageFile(node.Attributes.get("ovf:href").getValue()));
        // Default values:
        image.setactive(true);
        image.setimageStatus(ImageStatus.OK);
        image.setdescription(node.Attributes.get("ovf:description").getValue());
        _images.add(image);
    }
}
#end_block

#method_before
private int getResourceType(XmlNode node, VmDevice vmDevice, String resource) {
    if (node.SelectSingleNode(resource, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(resource, _xmlNS).InnerText)) {
        return Integer.valueOf(node.SelectSingleNode(resource, _xmlNS).InnerText);
    }
    return -1;
}
#method_after
private int getResourceType(XmlNode node, String resource) {
    if (node.SelectSingleNode(resource, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(resource, _xmlNS).InnerText)) {
        return Integer.valueOf(node.SelectSingleNode(resource, _xmlNS).InnerText);
    }
    return -1;
}
#end_block

#method_before
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, vmDevice, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, vmDevice, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.valueOf(OvfHardware.Monitor) == resourceType) {
            // get number of monitors from VirtualQuantity in OVF
            if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringHelper.isNullOrEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText)) {
                int virtualQuantity = Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText);
                if (virtualQuantity > 1) {
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                } else {
                    vmDevice.setDevice(VmDeviceType.CIRRUS.getName());
                }
            } else {
                // default to spice if quantity not found
                vmDevice.setDevice(VmDeviceType.QXL.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.valueOf(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-3 as the VmInterfaceType enum
        boolean isKnownType = false;
        for (VmInterfaceType vmInterfaceType : VmInterfaceType.values()) {
            if ((Integer.valueOf(vmInterfaceType.getValue()) == resourceSubType)) {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
                isKnownType = true;
                break;
            }
        }
        if (!isKnownType) {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#method_after
private void setDeviceByResource(XmlNode node, VmDevice vmDevice) {
    int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
    int resourceSubType = getResourceType(node, OvfProperties.VMD_SUB_RESOURCE_TYPE);
    if (resourceSubType == -1) {
        // we need special handling for Monitor to define it as vnc or spice
        if (Integer.valueOf(OvfHardware.Monitor) == resourceType) {
            // get number of monitors from VirtualQuantity in OVF
            if (node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS) != null && !StringUtils.isEmpty(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText)) {
                int virtualQuantity = Integer.valueOf(node.SelectSingleNode(OvfProperties.VMD_VIRTUAL_QUANTITY, _xmlNS).InnerText);
                if (virtualQuantity > 1) {
                    vmDevice.setDevice(VmDeviceType.QXL.getName());
                } else {
                    vmDevice.setDevice(VmDeviceType.CIRRUS.getName());
                }
            } else {
                // default to spice if quantity not found
                vmDevice.setDevice(VmDeviceType.QXL.getName());
            }
        } else {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    } else if (Integer.valueOf(OvfHardware.Network) == resourceType) {
        // handle interfaces with different sub types : we have 0-3 as the VmInterfaceType enum
        boolean isKnownType = false;
        for (VmInterfaceType vmInterfaceType : VmInterfaceType.values()) {
            if ((Integer.valueOf(vmInterfaceType.getValue()) == resourceSubType)) {
                vmDevice.setDevice(VmDeviceType.BRIDGE.getName());
                isKnownType = true;
                break;
            }
        }
        if (!isKnownType) {
            vmDevice.setDevice(VmDeviceType.getoVirtDevice(resourceType).getName());
        }
    }
}
#end_block

#method_before
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", "smartcardEnabled", "preventDeletion", // images list is relational entity - ignore value changes
    "images", // interfaces is relational entity - ignore value changes
    "interfaces" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#method_after
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", "smartcardEnabled", "deleteProtected", // images list is relational entity - ignore value changes
    "images", // interfaces is relational entity - ignore value changes
    "interfaces" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#end_block

#method_before
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("prevent_deletion", vm.getPreventDeletion()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()));
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setPreventDeletion(rs.getBoolean("prevent_deletion"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    return entity;
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setPreventDeletion(rs.getBoolean("prevent_deletion"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("prevent_deletion", template.getPreventDeletion()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (preventDeletion != other.preventDeletion) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (deleteProtected != other.deleteProtected) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#end_block

#method_before
@UiChild(tagname = "tab")
public void addTab(final DialogTab tab) {
    tabContainer.add(tab);
    tab.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchTab(tab);
        }
    });
    tab.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            // if space key was pressed
            if (32 == event.getNativeKeyCode()) {
                switchTab(tab);
            }
        }
    });
    // Switch to first tab automatically
    if (tabContainer.getWidgetCount() == 1) {
        switchTab(tab);
    }
}
#method_after
@UiChild(tagname = "tab")
public void addTab(final DialogTab tab) {
    tabContainer.add(tab);
    tab.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            switchTab(tab);
        }
    });
    tab.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            if (SPACE_KEY_CODE == event.getNativeKeyCode()) {
                switchTab(tab);
            }
        }
    });
    // Switch to first tab automatically
    if (tabContainer.getWidgetCount() == 1) {
        switchTab(tab);
    }
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    int nbWidgets = footerButtonPanel.getWidgetCount();
    for (int i = nbWidgets - 1; i >= 0; --i) {
        Widget iWidget = footerButtonPanel.getWidget(i);
        if (iWidget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) iWidget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    int nbWidgets = footerButtonPanel.getWidgetCount();
    for (int i = nbWidgets - 1; i >= 0; --i) {
        Widget iWidget = footerButtonPanel.getWidget(i);
        if (iWidget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) iWidget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    // default behavior, should be overridden by subclasses
    return startTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    // default behavior, should be overridden by subclasses
    return nextTabIndex;
}
#end_block

#method_before
@Override
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    isTemplatePublicEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    isTemplatePublicEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    diskAliasEditor.setTabIndex(nextTabIndex++);
    storageListEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    diskAliasEditor.setTabIndex(nextTabIndex++);
    storageListEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    int nbWidgetsInDiskListPanel = diskListPanel.getWidgetCount();
    for (int i = 0; i < nbWidgetsInDiskListPanel; ++i) {
        Widget widget = diskListPanel.getWidget(i);
        if (widget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) widget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    int nbWidgetsInDiskListPanel = diskListPanel.getWidgetCount();
    for (int i = 0; i < nbWidgetsInDiskListPanel; ++i) {
        Widget widget = diskListPanel.getWidget(i);
        if (widget instanceof FocusableComponentsContainer)
            nextTabIndex = ((FocusableComponentsContainer) widget).setTabIndexes(nextTabIndex);
    }
    return nextTabIndex;
}
#end_block

#method_before
public int setTabIndexes(int startTabIndex) {
    int nextTabIndex = startTabIndex;
    button.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
public int setTabIndexes(int nextTabIndex) {
    button.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.VDS_APPROVE;
    } else {
        return super.getAuditLogTypeValue();
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (!getSucceeded()) {
        if (_failureLogTypeValue == AuditLogType.VDS_INSTALL_FAILED) {
            AddCustomValue("FailedInstallMessage", getErrorMessage(_failureMessage));
        }
        return _failureLogTypeValue;
    } else {
        return AuditLogType.VDS_APPROVE;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade {0} host {0}, {1}", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade {0}, host {0}, {1}: success", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsBootstrap installer = null;
        try {
            T parameters = getParameters();
            installer = new VdsBootstrap(getVds());
            if (getVds().getvds_type() == VDSType.VDS) {
                installer.setUser("root");
                installer.setPassword(parameters.getRootPassword());
                installer.setFirewall(parameters.getOverrideFirewall());
            } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
                log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
                if (parameters.getOverrideFirewall()) {
                    log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                }
                installer.setUser("root");
                installer.useDefaultKeyPair();
            }
            log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation {0}", Thread.currentThread().getName());
            setSucceeded(true);
        } catch (Exception e) {
            setSucceeded(false);
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getvds_name());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getvds_type()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case PowerClient:
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getvds_type()));
            }
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getvds_name(), getVds().getvds_type().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#end_block

#method_before
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // if runAsStateless
    if (getVm().getis_stateless()) {
        for (DiskImage image : getVm().getDiskList()) {
            if (image.getQuotaId() != null) {
                list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, image.getstorage_ids().get(0), image.getActualSize()));
            }
        }
    }
    return list;
}
#method_after
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (!getVm().getis_stateless()) {
        return list;
    }
    // if runAsStateless
    for (DiskImage image : getVm().getDiskList()) {
        if (image.getQuotaId() != null) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVm().getstatus() != VMStatus.Down) {
        log.error("Cannot remove VM snapshot. Vm is not Down");
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // No need for locking, VDSM tasks, and all that jazz.
    if (!hasImages()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
            getCompensationContext().snapshotEntityStatus(snapshot, snapshot.getStatus());
            getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
    getParameters().setEntityId(getVmId());
    for (final DiskImage source : getSourceImages()) {
        // The following line is ok because we have tested in the
        // candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(source.getImageId()).get(0);
        ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(source.getImageId(), getVmId());
        tempVar.setDestinationImageId(dest.getImageId());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setParentParameters(getParameters());
        tempVar.setParentCommand(getActionType());
        ImagesContainterParametersBase p = tempVar;
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.RemoveSnapshotSingleDisk, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getParameters().getImagesParameters().add(p);
        if (vdcReturnValue != null && vdcReturnValue.getInternalTaskIdList() != null) {
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        }
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId().getValue(), source.getQuotaId());
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId().getValue(), dest.getQuotaId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getVm().getstatus() != VMStatus.Down) {
        log.error("Cannot remove VM snapshot. Vm is not Down");
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // No need for locking, VDSM tasks, and all that jazz.
    if (!hasImages()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
        setSucceeded(true);
        return;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
            getCompensationContext().snapshotEntityStatus(snapshot, snapshot.getStatus());
            getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.LOCKED);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
    getParameters().setEntityId(getVmId());
    for (final DiskImage source : getSourceImages()) {
        // The following line is ok because we have tested in the
        // candoaction that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        DiskImage dest = getDiskImageDao().getAllSnapshotsForParent(source.getImageId()).get(0);
        ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(source.getImageId(), getVmId());
        tempVar.setDestinationImageId(dest.getImageId());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setParentParameters(getParameters());
        tempVar.setParentCommand(getActionType());
        ImagesContainterParametersBase p = tempVar;
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.RemoveSnapshotSingleDisk, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        getParameters().getImagesParameters().add(p);
        if (vdcReturnValue != null && vdcReturnValue.getInternalTaskIdList() != null) {
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<Guid>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        quotasToRemoveFromCache.add(dest.getQuotaId());
        QuotaManager.getInstance().removeQuotaFromCache(getStoragePoolId().getValue(), quotasToRemoveFromCache);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void quotaDependencyTest() {
    for (VdcActionType vdcActionType : VdcActionType.values()) {
        if (vdcActionType.getQuotaDependency() != VdcActionType.QuotaDependency.NONE) {
            Class commandClass = CommandsFactory.getCommandClass(vdcActionType.name());
            // if command is deprecated or internal - skip it
            if (commandClass.getAnnotation(Deprecated.class) != null || commandClass.getAnnotation(InternalCommandAttribute.class) != null) {
                continue;
            }
            switch(vdcActionType.getQuotaDependency()) {
                case VDS_GROUP:
                    assertCommandIsQuotaVdsDependent(commandClass);
                    break;
                case STORAGE:
                    assertCommandIsQuotaStorageDependent(commandClass);
                    break;
                case BOTH:
                    assertCommandIsQuotaVdsDependent(commandClass);
                    assertCommandIsQuotaStorageDependent(commandClass);
                    break;
                default:
                    break;
            }
        }
    }
}
#method_after
@Theory
public void quotaDependencyTest(VdcActionType vdcActionType) {
    if (vdcActionType.getQuotaDependency() != VdcActionType.QuotaDependency.NONE) {
        Class commandClass = CommandsFactory.getCommandClass(vdcActionType.name());
        // if command is deprecated or internal - skip it
        if (commandClass.getAnnotation(Deprecated.class) != null || commandClass.getAnnotation(InternalCommandAttribute.class) != null) {
            return;
        }
        switch(vdcActionType.getQuotaDependency()) {
            case VDS_GROUP:
                assertCommandIsQuotaVdsDependent(commandClass);
                break;
            case STORAGE:
                assertCommandIsQuotaStorageDependent(commandClass);
                break;
            case BOTH:
                assertCommandIsQuotaVdsDependent(commandClass);
                assertCommandIsQuotaStorageDependent(commandClass);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
private boolean isImplementingRecursive(Class commandClass, Class interfaceClass) {
    if (Arrays.asList(commandClass.getInterfaces()).contains(interfaceClass)) {
        return true;
    } else {
        return commandClass.getSuperclass() != CommandBase.class && isImplementingRecursive(commandClass.getSuperclass(), interfaceClass);
    }
}
#method_after
private boolean isImplementingRecursive(Class commandClass, Class interfaceClass) {
    if (Arrays.asList(commandClass.getInterfaces()).contains(interfaceClass)) {
        return true;
    } else {
        return !commandClass.getSuperclass().equals(CommandBase.class) && isImplementingRecursive(commandClass.getSuperclass(), interfaceClass);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageIsNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain(canDoActionMessages) && validateDestStorage(canDoActionMessages) && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration(canDoActionMessages) && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#method_after
@Override
protected boolean canDoAction() {
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain(canDoActionMessages) && validateDestStorage(canDoActionMessages) && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration(canDoActionMessages) && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    List<storage_domains> storageDomains = getStorageDomainDAO().getAllForStorageDomain(getParameters().getSourceDomainId().getValue());
    String sourceSDName = StringUtils.EMPTY;
    if (storageDomains.size() > 0) {
        sourceSDName = storageDomains.get(0).getstorage_name();
    }
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("sourcesd", sourceSDName);
        jobProperties.put("targetsd", getStorageDomainName());
        jobProperties.put("action", getParameters().getOperation().getAction());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    List<storage_domains> storageDomains = getStorageDomainDAO().getAllForStorageDomain(getParameters().getSourceDomainId().getValue());
    String sourceSDName = StringUtils.EMPTY;
    if (storageDomains.size() > 0) {
        sourceSDName = storageDomains.get(0).getstorage_name();
    }
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("sourcesd", sourceSDName);
        jobProperties.put("targetsd", getStorageDomainName());
        if (ImageOperation.Move == getParameters().getOperation()) {
            jobProperties.put("action", "Moving");
        } else {
            jobProperties.put("action", "Copying");
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public void storagePoolUpEvent(storage_pool storagePool, boolean isNewSpm) {
    if (isNewSpm) {
        AsyncTaskManager.getInstance().StopStoragePoolTasks(storagePool);
    }
    {
        AsyncTaskManager.getInstance().AddStoragePoolExistingTasks(storagePool);
    }
}
#method_after
@Override
public void storagePoolUpEvent(storage_pool storagePool, boolean isNewSpm) {
    if (isNewSpm) {
        AsyncTaskManager.getInstance().StopStoragePoolTasks(storagePool);
    } else {
        AsyncTaskManager.getInstance().AddStoragePoolExistingTasks(storagePool);
    }
}
#end_block

#method_before
@Override
public void runFailedAutoStartVM(Guid vmId) {
    // We will reuse this because we can generate more than one event:
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    // Alert that the virtual machine failed:
    AuditLogDirector.log(event, AuditLogType.HA_VM_FAILED);
    log.infoFormat("Restart of the Highly Available VM was initiated due to failure. VM Name:{0}, VM Id:{1}", event.getVmName(), vmId);
    // Try to start it again:
    final VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(vmId), ExecutionHandler.createInternalJobContext());
    // Alert if the restart fails:
    if (!result.getSucceeded()) {
        AuditLogDirector.log(event, AuditLogType.HA_VM_RESTART_FAILED);
    }
}
#method_after
@Override
public void runFailedAutoStartVM(Guid vmId) {
    // We will reuse this because we can generate more than one event:
    final AuditLogableBase event = new AuditLogableBase();
    event.setVmId(vmId);
    // Alert that the virtual machine failed:
    AuditLogDirector.log(event, AuditLogType.HA_VM_FAILED);
    log.infoFormat("Failed to start Highly Available VM. Attempting to restart. VM Name: {0}, VM Id:{1}", event.getVmName(), vmId);
    // Try to start it again:
    final VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(vmId), ExecutionHandler.createInternalJobContext());
    // Alert if the restart fails:
    if (!result.getSucceeded()) {
        AuditLogDirector.log(event, AuditLogType.HA_VM_RESTART_FAILED);
    }
}
#end_block

#method_before
@Override
public void rerun(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        command.rerun();
    }
}
#method_after
@Override
public void rerun(Guid vmId) {
    final IVdsAsyncCommand command = Backend.getInstance().getResourceManager().GetAsyncCommandForVm(vmId);
    if (command != null) {
        // The command will be invoked in a different VDS in its rerun method, so we're calling
        // its rerun method from a new thread so that it won't be executed within our current VDSM lock
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                command.rerun();
            }
        });
    }
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_HOST_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static String ComposeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    return sb.toString();
}
#method_after
private static String ComposeObjectId(AuditLogableBase logable, AuditLogType logType) {
    final char DELIMITER = ',';
    StringBuilder sb = new StringBuilder();
    sb.append("type=");
    sb.append(logType);
    sb.append(DELIMITER);
    sb.append("sd=");
    sb.append(logable.getStorageDomainId() == null ? "" : logable.getStorageDomainId().toString());
    sb.append(DELIMITER);
    sb.append("dc=");
    sb.append(logable.getStoragePoolId() == null ? "" : logable.getStoragePoolId().toString());
    sb.append(DELIMITER);
    sb.append("user=");
    sb.append(logable.getUserId() == null ? "" : logable.getUserId().toString());
    sb.append(DELIMITER);
    sb.append("cluster=");
    sb.append(logable.getVdsGroupId().toString());
    sb.append(DELIMITER);
    sb.append("vds=");
    sb.append(logable.getVdsId().toString());
    sb.append(DELIMITER);
    sb.append("vm=");
    sb.append(logable.getVmId().equals(Guid.Empty) ? "" : logable.getVmId().toString());
    sb.append(DELIMITER);
    sb.append("template=");
    sb.append(logable.getVmTemplateId().equals(Guid.Empty) ? "" : logable.getVmTemplateId().toString());
    sb.append(DELIMITER);
    sb.append("customId=");
    sb.append(logable.getCustomId() == null ? "" : logable.getCustomId().toString());
    sb.append(DELIMITER);
    return sb.toString();
}
#end_block

#method_before
@Test
public void testExecuteQueryCommnad() {
    when(getQueryParameters().getServer()).thenReturn(serverName);
    doReturn(fingerPrint).when(getQuery()).getServerFingerprint(serverName);
    getQuery().executeQueryCommand();
    String serverFingerprint = (String) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(serverFingerprint);
    assertEquals(fingerPrint, serverFingerprint);
}
#method_after
@Test
public void testExecuteQueryCommnad() throws IOException {
    when(getQueryParameters().getServer()).thenReturn(serverName);
    doReturn(fingerPrint).when(mockEngineSSHDialog).getHostFingerprint();
    getQuery().executeQueryCommand();
    String serverFingerprint = (String) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(serverFingerprint);
    assertEquals(fingerPrint, serverFingerprint);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    VDSReturnValue returnValue = getBackendInstance().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(getClusterUtils().getUpServer(getParameters().getClusterId()).getId()));
    Map<String, String> glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    getQueryReturnValue().setReturnValue(glusterServers);
}
#method_after
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<String, String>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getBackendInstance().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#end_block

#method_before
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    SSHClient client = null;
    try {
        long timeout = Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000;
        client = new SSHClient();
        client.setHardTimeout(timeout);
        client.setSoftTimeout(timeout);
        client.setHost(serverName, 22);
        client.connect();
        PublicKey serverKey = client.getServerKey();
        if (serverKey == null) {
            throw new Exception("No server key");
        }
        fingerPrint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
    return fingerPrint;
}
#method_after
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    EngineSSHDialog dialog = getEngineSSHDialog();
    try {
        dialog.setHost(serverName);
        dialog.connect();
        fingerPrint = dialog.getHostFingerprint();
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        dialog.disconnect();
    }
    return fingerPrint;
}
#end_block

#method_before
private void setupMock() throws Exception {
    vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    clusterUtils = mock(ClusterUtils.class);
    vdsDaoMock = mock(VdsDAO.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getBackendInstance();
    doReturn(clusterUtils).when(getQuery()).getClusterUtils();
    doReturn(getVds(VDSStatus.Up)).when(clusterUtils).getUpServer(CLUSTER_ID);
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(serversList).when(vdsDaoMock).getAllForVdsGroup(CLUSTER_ID);
    doReturn(serverKeyFingerprint).when(getQuery()).getServerFingerprint("test_server3");
}
#method_after
private void setupMock() throws Exception {
    vdsBrokerFrontend = mock(VDSBrokerFrontend.class);
    clusterUtils = mock(ClusterUtils.class);
    vdsDaoMock = mock(VdsDAO.class);
    doReturn(vdsBrokerFrontend).when(getQuery()).getBackendInstance();
    doReturn(clusterUtils).when(getQuery()).getClusterUtils();
    doReturn(getVds(VDSStatus.Up)).when(clusterUtils).getUpServer(CLUSTER_ID);
    VDSReturnValue returnValue = getVDSReturnValue();
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GlusterServersList), any(VDSParametersBase.class))).thenReturn(returnValue);
    doReturn(params.getClusterId()).when(getQueryParameters()).getClusterId();
    doReturn(true).when(getQueryParameters()).isServerKeyFingerprintRequired();
    doReturn(vdsDaoMock).when(clusterUtils).getVdsDao();
    doReturn(serversList).when(vdsDaoMock).getAllForVdsGroup(CLUSTER_ID);
    mockEngineSSHDialog = mock(EngineSSHDialog.class);
    doNothing().when(mockEngineSSHDialog).connect();
    doNothing().when(mockEngineSSHDialog).authenticate();
    doReturn(mockEngineSSHDialog).when(getQuery()).getEngineSSHDialog();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testExecuteQueryCommand() {
    getQuery().executeQueryCommand();
    Map<String, String> servers = (Map<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(servers);
    assertEquals(getAddedServers(), servers);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testExecuteQueryCommand() throws IOException {
    doReturn(serverKeyFingerprint).when(mockEngineSSHDialog).getHostFingerprint();
    getQuery().executeQueryCommand();
    Map<String, String> servers = (Map<String, String>) getQuery().getQueryReturnValue().getReturnValue();
    assertNotNull(servers);
    assertEquals(getAddedServers(), servers);
}
#end_block

#method_before
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    SSHClient client = null;
    try {
        long timeout = Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000;
        client = new SSHClient();
        client.setHardTimeout(timeout);
        client.setSoftTimeout(timeout);
        client.setHost(serverName, 22);
        client.connect();
        PublicKey serverKey = client.getServerKey();
        if (serverKey == null) {
            throw new Exception("No server key");
        }
        fingerPrint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
    return fingerPrint;
}
#method_after
public String getServerFingerprint(String serverName) {
    String fingerPrint = null;
    EngineSSHDialog dialog = getEngineSSHDialog();
    try {
        dialog.setHost(serverName);
        dialog.connect();
        fingerPrint = dialog.getHostFingerprint();
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of host {0} with message: {1}", serverName, ExceptionUtils.getMessage(e));
    } finally {
        dialog.disconnect();
    }
    return fingerPrint;
}
#end_block

#method_before
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long hardTimeout, long softTimeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d, %7$d)", server, user, userPassword, keyStore, keyStorePassword, hardTimeout, softTimeout));
    boolean ret = false;
    try {
        _openSession(server, hardTimeout, softTimeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("PKCS12");
                ks.load(in, keyStorePassword.toCharArray());
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getServerKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.client.getDisplayHost(), fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s", this.client.getDisplayHost());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#method_after
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long hardTimeout, long softTimeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d, %7$d)", server, user, userPassword, keyStore, keyStorePassword, hardTimeout, softTimeout));
    boolean ret = false;
    try {
        _openSession(server, hardTimeout, softTimeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("PKCS12");
                ks.load(in, keyStorePassword.toCharArray());
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getHostKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.client.getDisplayHost(), fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s", this.client.getDisplayHost());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#end_block

#method_before
@Before
public void setup() throws IOException {
    assumeTrue(SystemUtils.IS_OS_UNIX);
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    hostKstore = System.getProperty("ssh-test-p12", "src/test/resources/key.p12");
    hostKstorePassword = System.getProperty("ssh-test-p12-password", "NoSoup4U");
    host = System.getProperty("ssh-host");
    if (host == null) {
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        try {
            KeyStore ks = KeyStore.getInstance("PKCS12");
            ks.load(new FileInputStream(hostKstore), hostKstorePassword.toCharArray());
            sshd.setUser(user, password, ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey());
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
    }
}
#method_after
@Before
public void setup() throws IOException {
    assumeTrue(SystemUtils.IS_OS_UNIX);
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    hostKstore = System.getProperty("ssh-test-p12", "src/test/resources/key.p12");
    hostKstorePassword = System.getProperty("ssh-test-p12-password", "NoSoup4U");
    hostKstoreAlias = System.getProperty("ssh-test-p12-alias", "1");
    host = System.getProperty("ssh-host");
    if (host == null) {
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        try {
            KeyStore ks = KeyStore.getInstance("PKCS12");
            ks.load(new FileInputStream(hostKstore), hostKstorePassword.toCharArray());
            sshd.setUser(user, password, ks.getCertificate(hostKstoreAlias).getPublicKey());
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade {0} host {0}, {1}", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade {0}, host {0}, {1}: success", Thread.currentThread().getName(), getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        T parameters = getParameters();
        VdsInstaller vdsInstaller = null;
        if (getVds().getvds_type() == VDSType.VDS) {
            vdsInstaller = new VdsInstaller(getVds(), parameters.getRootPassword(), parameters.getOverrideFirewall(), parameters.isRebootAfterInstallation());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (parameters.getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            vdsInstaller = new OVirtInstaller(getVds());
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        boolean installResult = false;
        try {
            installResult = vdsInstaller.Install();
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
        }
        setSucceeded(installResult);
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (getSucceeded()) {
            if (vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            switch(getVds().getvds_type()) {
                case VDS:
                    if (getParameters().isRebootAfterInstallation()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case oVirtNode:
                    if (getParameters().getIsReinstallOrUpgrade()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case PowerClient:
                    setHostStatus(VDSStatus.NonResponsive);
                    break;
            }
        } else {
            _failureMessage = getErrorMessage(vdsInstaller.getErrorMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
            setHostStatus(VDSStatus.InstallFailed);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        T parameters = getParameters();
        VdsInstaller vdsInstaller = null;
        if (getVds().getvds_type() == VDSType.VDS) {
            vdsInstaller = new VdsInstaller(getVds(), parameters.getRootPassword(), parameters.getOverrideFirewall(), parameters.isRebootAfterInstallation());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (parameters.getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            vdsInstaller = new OVirtInstaller(getVds());
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        boolean installResult = false;
        try {
            installResult = vdsInstaller.Install();
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
        }
        setSucceeded(installResult);
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (getSucceeded()) {
            if (vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            switch(getVds().getvds_type()) {
                case VDS:
                    if (getParameters().isRebootAfterInstallation()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case oVirtNode:
                    if (getParameters().getIsReinstallOrUpgrade()) {
                        setHostStatus(VDSStatus.Reboot);
                        RunSleepOnReboot();
                    } else {
                        setHostStatus(VDSStatus.NonResponsive);
                    }
                    break;
                case PowerClient:
                    setHostStatus(VDSStatus.NonResponsive);
                    break;
            }
        } else {
            _failureMessage = getErrorMessage(vdsInstaller.getErrorMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
            setHostStatus(VDSStatus.InstallFailed);
        }
    }
}
#end_block

#method_before
public void connect() throws Exception {
    log.debug(String.format("connect enter (%1$s:%2$s, %3$d, %4$d)", _host, _port, _hardTimeout, _softTimeout));
    try {
        if (_client != null) {
            throw new IOException("Already connected");
        }
        _client = _getSSHClient();
        _client.setHardTimeout(_hardTimeout);
        _client.setSoftTimeout(_softTimeout);
        _client.setHost(_host, _port);
        log.debug("connecting");
        _client.connect();
    } catch (Exception e) {
        log.debug(String.format("Could not connect to host %1$s", _client.getDisplayHost()), e);
        throw e;
    }
}
#method_after
public void connect() throws Exception {
    if (log.isDebugEnabled()) {
        log.debug(String.format("connect enter (%1$s:%2$s, %3$d, %4$d)", _host, _port, _hardTimeout, _softTimeout));
    }
    try {
        if (_client != null) {
            throw new IOException("Already connected");
        }
        _client = _getSSHClient();
        _client.setHardTimeout(_hardTimeout);
        _client.setSoftTimeout(_softTimeout);
        _client.setHost(_host, _port);
        log.debug("connecting");
        _client.connect();
    } catch (Exception e) {
        log.debug(String.format("Could not connect to host %1$s", _client.getDisplayHost()), e);
        throw e;
    }
}
#end_block

#method_before
public boolean postOldXmlFormat(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = postOldXmlFormat(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = _postOldXmlFormat(message);
            } catch (RuntimeException e) {
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {1}, Exception: {2}", message, e.toString());
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#method_after
public boolean postOldXmlFormat(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = postOldXmlFormat(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = _internalPostOldXmlFormat(message);
            } catch (RuntimeException e) {
                error = true;
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {0}", message, e);
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#end_block

#method_before
@Override
public void stop() {
    if (_thread != null) {
        _thread.interrupt();
        while (true) {
            try {
                _thread.join();
                break;
            } catch (InterruptedException e) {
            }
        }
        _thread = null;
    }
}
#method_after
@Override
public void stop() {
    if (_thread != null) {
        /*
             * We cannot just interrupt the thread as the
             * implementation of jboss connection pooling
             * drops the connection when interrupted.
             * As we may have log events pending to be written
             * to database, we wait for some time for thread
             * complete before interrupting.
             */
        try {
            _thread.join(THREAD_JOIN_TIMEOUT);
        } catch (InterruptedException e) {
            log.error("interrupted", e);
        }
        if (_thread.isAlive()) {
            _thread.interrupt();
            while (true) {
                try {
                    _thread.join();
                    break;
                } catch (InterruptedException e) {
                }
            }
        }
        _thread = null;
    }
}
#end_block

#method_before
public void useDefaultKeyPair() throws KeyStoreException {
    String alias = Config.<String>GetValue(ConfigValues.CertAlias);
    String p12 = Config.<String>GetValue(ConfigValues.keystoreUrl);
    String password = Config.<String>GetValue(ConfigValues.keystorePass);
    KeyStore.PrivateKeyEntry entry;
    InputStream in = null;
    try {
        in = new FileInputStream(p12);
        KeyStore ks = KeyStore.getInstance("PKCS12");
        ks.load(in, password.toCharArray());
        entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(password.toCharArray()));
    } catch (Exception e) {
        throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", p12, alias), e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close key store", e);
            }
        }
    }
    if (entry == null) {
        throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", p12, alias));
    }
    setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
}
#method_after
public void useDefaultKeyPair() throws KeyStoreException {
    final String alias = Config.<String>GetValue(ConfigValues.CertAlias);
    final String p12 = Config.<String>GetValue(ConfigValues.keystoreUrl);
    final char[] password = Config.<String>GetValue(ConfigValues.keystorePass).toCharArray();
    KeyStore.PrivateKeyEntry entry;
    InputStream in = null;
    try {
        in = new FileInputStream(p12);
        KeyStore ks = KeyStore.getInstance("PKCS12");
        ks.load(in, password);
        entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(password));
    } catch (Exception e) {
        throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", p12, alias), e);
    } finally {
        Arrays.fill(password, '*');
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close key store", e);
            }
        }
    }
    if (entry == null) {
        throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", p12, alias));
    }
    setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(getActionType());
        tempVar.setParentParameters(getParameters());
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (statelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(getActionType());
        tempVar.setParentParameters(getParameters());
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        p.setSnapshotType(SnapshotType.STATELESS);
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? (getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds())) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    setVdsId(getVdsSelector().getVdsToRunOn());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    setVdsId(getVdsSelector().getVdsToRunOn(false));
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    setIsVmRunningStateless();
    rollbackQuota();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.endWithFailure();
    }
}
#method_after
@Override
protected void endWithFailure() {
    setIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcReturnValueBase vdcReturnValue = getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
    // we are not running the VM, of course,
    // since we couldn't create a snpashot.
    } else {
        super.endWithFailure();
    }
}
#end_block

#method_before
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    boolean isValid = checkIsValid && ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
    if (checkIsValid && !isValid) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
    }
    List<DiskImage> images = getImages(vm, diskImageList);
    if (returnValue && checkImagesLocked) {
        returnValue = checkImagesLocked(vm, messages, images);
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && isValid) {
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#method_after
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    ;
    if (checkIsValid) {
        storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolId);
        if (pool == null || pool.getstatus() != StoragePoolStatus.Up) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
        }
    }
    List<DiskImage> images = getImages(vm, diskImageList);
    if (returnValue && checkImagesLocked) {
        returnValue = checkImagesLocked(vm, messages, images);
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && checkIsValid) {
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#end_block

#method_before
private static boolean checkImagesLocked(VM vm, List<String> messages, List<DiskImage> images) {
    boolean returnValue = true;
    List<String> lockedDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : images) {
        if (diskImage.getimageStatus() == ImageStatus.LOCKED) {
            lockedDisksAliases.add(diskImage.getDiskAlias());
            returnValue = false;
        }
    }
    addDiskLockedMessage(lockedDisksAliases, messages);
    if (returnValue && vm.getstatus() == VMStatus.ImageLocked) {
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED.toString());
        returnValue = false;
    }
    return returnValue;
}
#method_after
private static boolean checkImagesLocked(VM vm, List<String> messages, List<DiskImage> images) {
    boolean returnValue = true;
    List<String> lockedDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : images) {
        if (diskImage.getimageStatus() == ImageStatus.LOCKED) {
            lockedDisksAliases.add(diskImage.getDiskAlias());
            returnValue = false;
        }
    }
    if (lockedDisksAliases.size() > 0) {
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED.toString());
        ListUtils.nullSafeAdd(messages, String.format("$%1$s %2$s", "diskAliases", StringUtils.join(lockedDisksAliases, ", ")));
    }
    if (returnValue && vm.getstatus() == VMStatus.ImageLocked) {
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED.toString());
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), 0, 0));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // The cases must be persistent with the create_functions_sp
    if (getVm().getstatus() == VMStatus.Down || getVm().getstatus() == VMStatus.Suspended || getVm().getstatus() == VMStatus.ImageIllegal || getVm().getstatus() == VMStatus.ImageLocked || getVm().getstatus() == VMStatus.PoweringDown) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
    } else {
        if (getParameters().getVmStaticData().getQuotaId() != null && !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getvmt_cpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), getParameters().getVmStaticData().getcpu_per_socket() * getParameters().getVmStaticData().getnum_of_sockets(), getParameters().getVmStaticData().getmem_size_mb()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // if not runAsStateless
    if (!getParameters().getRunAsStateless()) {
        for (DiskImage image : getVm().getDiskList()) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // if runAsStateless
    if (Boolean.TRUE.equals(getParameters().getRunAsStateless())) {
        for (DiskImage image : getVm().getDiskList()) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#end_block

#method_before
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVm().getvds_group_id(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
    return list;
}
#method_after
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (getVm().getQuotaId() != null && !Guid.Empty.equals(getVm().getQuotaId()) && (getVm().getstatus() == VMStatus.Up || getVm().getstatus() == VMStatus.Paused || getVm().getstatus() == VMStatus.PoweringUp || getVm().getstatus() == VMStatus.RebootInProgress)) {
        list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVm().getvds_group_id(), getVm().getcpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
    }
    return list;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        if (disk.getQuotaId() != null) {
            list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        if (disk.getQuotaId() != null && !Guid.Empty.equals(disk.getQuotaId())) {
            list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
private void rollbackQuota(Guid storagePoolId, List<Guid> quotaList) {
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePoolId)) {
            return;
        }
        synchronized (storagePoolQuotaMap.get(storagePoolId)) {
            Map<Guid, Quota> map = storagePoolQuotaMap.get(storagePoolId);
            for (Guid quotaId : quotaList) {
                map.remove(quotaId);
            }
        }
    } finally {
        lock.writeLock().unlock();
    }
}
#method_after
public void rollbackQuota(Guid storagePoolId, List<Guid> quotaList) {
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePoolId)) {
            return;
        }
        synchronized (storagePoolQuotaMap.get(storagePoolId)) {
            Map<Guid, Quota> map = storagePoolQuotaMap.get(storagePoolId);
            for (Guid quotaId : quotaList) {
                map.remove(quotaId);
            }
        }
    } finally {
        lock.writeLock().unlock();
    }
}
#end_block

#method_before
public boolean consume(QuotaConsumptionParametersWrapper parameters) throws InvalidQuotaParametersException {
    Pair<AuditLogType, AuditLogableBase> auditLogPair = new Pair<AuditLogType, AuditLogableBase>();
    auditLogPair.setSecond(parameters.getAuditLogable());
    storage_pool storagePool = parameters.getAuditLogable().getStoragePool();
    if (storagePool == null) {
        throw new InvalidQuotaParametersException("Null storage pool passed to QuotaManager");
    }
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.put(storagePool.getId(), new HashMap<Guid, Quota>());
        }
    } finally {
        lock.writeLock().unlock();
    }
    lock.readLock().lock();
    try {
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (!validateAndCompleteParameters(parameters, auditLogPair)) {
                throw new InvalidQuotaParametersException();
            }
            return internalConsumeAndReleaseHandler(parameters, auditLogPair);
        }
    } finally {
        lock.readLock().unlock();
        getQuotaManagerAuditLogger().auditLog(auditLogPair.getFirst(), auditLogPair.getSecond());
    }
}
#method_after
public boolean consume(QuotaConsumptionParametersWrapper parameters) throws InvalidQuotaParametersException {
    Pair<AuditLogType, AuditLogableBase> auditLogPair = new Pair<AuditLogType, AuditLogableBase>();
    auditLogPair.setSecond(parameters.getAuditLogable());
    storage_pool storagePool = parameters.getAuditLogable().getStoragePool();
    if (storagePool == null) {
        throw new InvalidQuotaParametersException("Null storage pool passed to QuotaManager");
    }
    lock.writeLock().lock();
    try {
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.put(storagePool.getId(), new HashMap<Guid, Quota>());
        }
    } finally {
        lock.writeLock().unlock();
    }
    lock.readLock().lock();
    try {
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            return validateAndCompleteParameters(parameters, auditLogPair) && (parameters.getStoragePool().getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED || internalConsumeAndReleaseHandler(parameters, auditLogPair));
        }
    } finally {
        lock.readLock().unlock();
        getQuotaManagerAuditLogger().auditLog(auditLogPair.getFirst(), auditLogPair.getSecond());
    }
}
#end_block

#method_before
private boolean internalConsumeAndReleaseHandler(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    boolean result = validateAndSetStorageQuotaHelper(parameters, auditLogPair);
    if (result) {
        result = validateAndSetClusterQuota(parameters, auditLogPair);
        if (result) {
            return true;
        } else {
            QuotaConsumptionParametersWrapper revertedParams = revertParametersQuantities(parameters);
            validateAndSetStorageQuotaHelper(revertedParams, auditLogPair);
            validateAndSetClusterQuota(parameters, auditLogPair);
        }
    } else {
        // roll back storage request
        QuotaConsumptionParametersWrapper revertedParams = revertParametersQuantities(parameters);
        validateAndSetStorageQuotaHelper(revertedParams, auditLogPair);
    }
    return result;
}
#method_after
private boolean internalConsumeAndReleaseHandler(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) {
    boolean result = validateAndSetStorageQuotaHelper(parameters, auditLogPair);
    if (result) {
        result = validateAndSetClusterQuota(parameters, auditLogPair);
        if (result) {
            return true;
        } else {
            QuotaConsumptionParametersWrapper revertedParams = revertParametersQuantities(parameters);
            validateAndSetStorageQuotaHelper(revertedParams, auditLogPair);
        }
    }
    return result;
}
#end_block

#method_before
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param);
        // In case this param is a QuotaVdsConsumptionParameter - check that it has a valid
        // vds group id which is handled by this quota
        boolean validVdsGroup = true;
        if (param instanceof QuotaVdsGroupConsumptionParameter) {
            validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
        }
        // In case this param is a QuotaStorageConsumptionParameter - check that it has a valid
        // storage domain id which is handled by this quota
        boolean validStorageDomain = true;
        if (param instanceof QuotaStorageConsumptionParameter) {
            validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // otherwise write to auditLog and return true
                auditLogPair.setFirst(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE);
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                return true;
            }
        }
    }
    return true;
}
#method_after
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param, auditLogPair);
        boolean validVdsGroup = true;
        boolean validStorageDomain = true;
        if (validQuotaId) {
            // vds group id which is handled by this quota
            if (param instanceof QuotaVdsGroupConsumptionParameter) {
                validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
            }
            // storage domain id which is handled by this quota
            if (param instanceof QuotaStorageConsumptionParameter) {
                validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
            }
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
                    auditLogPair.setFirst(null);
                }
                return true;
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#method_after
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (imageTemplates != null) {
        for (DiskImage disk : imageTemplates) {
            if (disk.getQuotaId() != null) {
                list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
            }
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (imageTemplates != null) {
        for (DiskImage disk : imageTemplates) {
            if (disk.getQuotaId() != null && !Guid.Empty.equals(disk.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(disk.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, disk.getstorage_ids().get(0), (double) disk.getSizeInGigabytes()));
            }
        }
    }
    return list;
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollBackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected final void internalCompensate() {
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endWithFailure();
        revertPreviousHandlers();
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollBackQuota();
}
#method_after
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endWithFailure();
        revertPreviousHandlers();
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#end_block

#method_before
protected void endWithFailure() {
    setSucceeded(true);
}
#method_after
protected void endWithFailure() {
    setSucceeded(true);
    rollbackQuota();
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
            }
        }
    }
}
#end_block

#method_before
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollBackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#method_after
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // TODO: need to be fixed. sp id should be available
    setStoragePoolId(getImagesList().get(0).getstorage_pool_id());
    for (DiskImage image : getImagesList()) {
        if (!image.getImage().isActive()) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // TODO: need to be fixed. sp id should be available
    setStoragePoolId(getImagesList().get(0).getstorage_pool_id());
    for (DiskImage image : getImagesList()) {
        if (!image.getImage().isActive() && image.getQuotaId() != null && !Guid.Empty.equals(image.getQuotaId())) {
            list.add(new QuotaStorageConsumptionParameter(image.getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, image.getstorage_ids().get(0), image.getActualSize()));
        }
    }
    return list;
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    // If user want to update the disk to be shareable then update the vm snapshot id to be null.
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        diskImage.setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) _oldDisk;
        DiskImage newDiskImage = (DiskImage) getParameters().getDiskInfo();
        list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
        oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
        newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) _oldDisk;
        DiskImage newDiskImage = (DiskImage) getParameters().getDiskInfo();
        if (oldDiskImage.getQuotaId() == null || !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
            if (oldDiskImage.getQuotaId() != null && !Guid.Empty.equals(oldDiskImage.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
                oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
            }
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? (getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds())) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (getParameters() != null && getParameters().getIsInternal()) {
                return getSucceeded() ? AuditLogType.VDS_INITIATED_RUN_VM : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getdedicated_vm_for_vds() != null && !getVm().getrun_on_vds().equals(getVm().getdedicated_vm_for_vds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : AuditLogType.USER_RUN_VM : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return _isVmRunningStateless ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {1}", fRes ? "Success" : "Failed");
    return fRes;
}
#method_after
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {0}", fRes ? "Success" : "Failed");
    return fRes;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else if (!validateHostUniqueNameAndAddress(getParameters().getVdsStaticData())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#end_block

#method_before
private boolean canConnect(VDS vds) {
    boolean returnValue = true;
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (vds.getvds_type() == VDSType.VDS && Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        SSHClient sshclient = null;
        try {
            Long timeout = TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.ConnectToServerTimeoutInSeconds));
            sshclient = getSSHClient();
            sshclient.setHardTimeout(timeout);
            sshclient.setSoftTimeout(timeout);
            sshclient.setHost(vds.gethost_name());
            sshclient.setUser("root");
            sshclient.setPassword(getParameters().getRootPassword());
            sshclient.connect();
            sshclient.authenticate();
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getvds_name(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
            returnValue = false;
        } finally {
            if (sshclient != null) {
                sshclient.disconnect();
            }
        }
    }
    return returnValue;
}
#method_after
private boolean canConnect(VDS vds) {
    boolean returnValue = true;
    // execute the connectivity and id uniqueness validation for VDS type hosts
    if (vds.getvds_type() == VDSType.VDS && Config.<Boolean>GetValue(ConfigValues.InstallVds)) {
        SSHClient sshclient = null;
        try {
            Long timeout = TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.ConnectToServerTimeoutInSeconds));
            sshclient = getSSHClient();
            sshclient.setHardTimeout(timeout);
            sshclient.setSoftTimeout(timeout);
            sshclient.setHost(vds.gethost_name());
            sshclient.setUser(USER_NAME);
            sshclient.setPassword(getParameters().getRootPassword());
            sshclient.connect();
            sshclient.authenticate();
        } catch (Exception e) {
            log.errorFormat("Failed to establish session with host {0}", vds.getvds_name(), e);
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_CONNECT_TO_SERVER);
            returnValue = false;
        } finally {
            if (sshclient != null) {
                sshclient.disconnect();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private void mockSSHClient() {
    try {
        doNothing().when(sshclient).connect();
        doNothing().when(sshclient).authenticate();
    } catch (Exception e) {
    }
}
#method_after
private void mockSSHClient() {
    try {
        doNothing().when(sshclient).connect();
        doNothing().when(sshclient).authenticate();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {1}", fRes ? "Success" : "Failed");
    return fRes;
}
#method_after
private boolean runBootstrapCommand(boolean doFinal) {
    boolean fRes = false;
    String command = _bootstrapCommand.replace("{RunFlag}", doFinal ? "True" : "False");
    if (!doFinal) {
        serverInstallationTime = DateTime.getUtcNow().toString("yyyy-MM-ddTHH:mm:ss");
    } else {
        if (!_rebootAfterInstallation) {
            command = command.replace(" -b ", " ");
        }
    }
    // NOTICE: the time is also used as ticket for registration
    // time will be correct only at !doFinal
    command = command.replace("{utc_time}", serverInstallationTime);
    log.infoFormat("Installation of {0}. Sending SSH Command {1} < {2}. (Stage: {3})", _serverName, command, s_bootstrapPackage.getFileNoUse(), getCurrentInstallStage());
    InputStream in = null;
    try {
        in = new FileInputStream(s_bootstrapPackage.getFile());
        fRes = _wrapper.executeCommand(command, in);
    } catch (Exception e) {
        log.error("Error during executing bootstrap", e);
    } finally {
        if (in != null) {
            try {
                in.close();
            } catch (IOException e) {
                log.error("Cannot close bootstrap file", e);
            }
        }
    }
    log.infoFormat("Script ended, result is {0}", fRes ? "Success" : "Failed");
    return fRes;
}
#end_block

#method_before
public static String SignCertificateRequest(String request, String label) throws FileNotFoundException, UnsupportedEncodingException, IOException {
    File pkicertdir = new File(Config.resolveCABasePath(), "certs");
    File pkireqdir = new File(Config.resolveCABasePath(), "requests");
    String reqFileName = String.format("%1$sreq.pem", label);
    String certFileName = String.format("%1$scert.pem", label);
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(pkireqdir, reqFileName));
        os.write(request.getBytes("UTF-8"));
    } finally {
        if (os == null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().SignCertificateRequest(reqFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, certFileName)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(pkicertdir, certFileName).getPath());
}
#method_after
public static String SignCertificateRequest(String request, String label) throws IOException {
    File pkicertdir = new File(Config.resolveCABasePath(), "certs");
    File pkireqdir = new File(Config.resolveCABasePath(), "requests");
    String reqFileName = String.format("%1$sreq.pem", label);
    String certFileName = String.format("%1$scert.pem", label);
    OutputStream os = null;
    try {
        os = new FileOutputStream(new File(pkireqdir, reqFileName));
        os.write(request.getBytes("UTF-8"));
    } finally {
        if (os != null) {
            try {
                os.close();
            } catch (IOException e) {
                log.error("error during close", e);
            }
        }
    }
    if (!new OpenSslCAWrapper().SignCertificateRequest(reqFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, certFileName)) {
        throw new RuntimeException("Certificate enrollment failed");
    }
    return FileUtil.readAllText(new File(pkicertdir, certFileName).getPath());
}
#end_block

#method_before
public boolean AddMessage(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = AddMessage(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = parseMessage(message);
            } catch (RuntimeException e) {
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {1}, Exception: {2}", message, e.toString());
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#method_after
public boolean AddMessage(String message) {
    boolean error = false;
    if (StringUtils.isEmpty(message)) {
        return error;
    }
    String[] msgs = message.split("[\\n]", -1);
    if (msgs.length > 1) {
        for (String msg : msgs) {
            error = AddMessage(msg) || error;
        }
        return error;
    }
    if (StringUtils.isNotEmpty(message)) {
        if (message.charAt(0) == '<') {
            try {
                error = parseMessage(message);
            } catch (RuntimeException e) {
                error = true;
                log.errorFormat("Installation of Host. Received illegal XML from Host. Message: {0}", message, e);
            }
        } else {
            log.info("VDS message: " + message);
        }
    }
    return error;
}
#end_block

#method_before
private boolean parseMessage(String message) {
    boolean error = false;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(message);
    XmlNode node = doc.ChildNodes[0];
    if (node != null) {
        StringBuilder sb = new StringBuilder();
        // check status
        AuditLogType logType;
        if (node.Attributes.get("status") == null) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else if (node.Attributes.get("status").getValue().equals("OK")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS;
        } else if (node.Attributes.get("status").getValue().equals("WARN")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else {
            error = true;
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR;
        }
        if ((node.Attributes.get("component") != null) && (StringUtils.isNotEmpty(node.Attributes.get("component").getValue()))) {
            sb.append("Step: " + node.Attributes.get("component").getValue());
        }
        if ((node.Attributes.get("message") != null) && (StringUtils.isNotEmpty(node.Attributes.get("message").getValue()))) {
            sb.append("; ");
            sb.append("Details: " + node.Attributes.get("message").getValue());
            sb.append(" ");
        }
        if ((node.Attributes.get("result") != null) && (StringUtils.isNotEmpty(node.Attributes.get("result").getValue()))) {
            sb.append(" (" + node.Attributes.get("result").getValue() + ")");
        }
        AuditLogableBase logable = new AuditLogableBase(_vdsId);
        logable.AddCustomValue("Message", StringUtils.stripEnd(sb.toString(), " "));
        AuditLogDirector.log(logable, logType);
        return error;
    }
    return error;
}
#method_after
private boolean parseMessage(String message) {
    boolean error = false;
    XmlDocument doc = new XmlDocument();
    doc.LoadXml(message);
    XmlNode node = doc.ChildNodes[0];
    if (node != null) {
        StringBuilder sb = new StringBuilder();
        // check status
        AuditLogType logType;
        if (node.Attributes.get("status") == null) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else if (node.Attributes.get("status").getValue().equals("OK")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS;
        } else if (node.Attributes.get("status").getValue().equals("WARN")) {
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING;
        } else {
            error = true;
            logType = AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR;
        }
        if ((node.Attributes.get("component") != null) && (StringUtils.isNotEmpty(node.Attributes.get("component").getValue()))) {
            sb.append("Step: " + node.Attributes.get("component").getValue());
        }
        if ((node.Attributes.get("message") != null) && (StringUtils.isNotEmpty(node.Attributes.get("message").getValue()))) {
            sb.append("; ");
            sb.append("Details: " + node.Attributes.get("message").getValue());
            sb.append(" ");
        }
        if ((node.Attributes.get("result") != null) && (StringUtils.isNotEmpty(node.Attributes.get("result").getValue()))) {
            sb.append(" (" + node.Attributes.get("result").getValue() + ")");
        }
        AuditLogableBase logable = new AuditLogableBase(_vdsId);
        logable.AddCustomValue("Message", StringUtils.stripEnd(sb.toString(), " "));
        AuditLogDirector.log(logable, logType);
    }
    return error;
}
#end_block

#method_before
@Override
public void rerun() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        // set the _isRerun flag to false before calling executeAction to that we'll know if
        // there is another rerun attempt within the method
        _isRerun = false;
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            log();
            failedToRunVm();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
        log();
    }
}
#method_after
@Override
public void rerun() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        // set the _isRerun flag to false before calling executeAction so that we'll know if
        // there is another rerun attempt within the method
        _isRerun = false;
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            log();
            failedToRunVm();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
        log();
    }
}
#end_block

#method_before
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode(), getParameters().getMasterVm().isSmartcardEnabled()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(((CreateImageTemplateParameters) getParameters().getImagesParameters().get(0)).getVmId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        // disks regardless if there was a failure during the initializtion of it.
        if (getSnapshotDao().get(((ImagesActionsParametersBase) getParameters().getImagesParameters().get(0)).getVmSnapshotId()) != null) {
            restoreVmConfigFromSnapshot();
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // if there are no images we can should restore the config now so it'll be executed within the transaction.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    getParameters().getImagesParameters().add(p);
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // the update is being executed in the same transaction so we can restore the vm config and end the command.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, VmTemplate vmTemplate, Guid storagePoolId, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else {
        boolean isValid = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
        if (isValid) {
            if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
                returnValue = false;
            }
        } else {
            if (reasons != null) {
                reasons.add(VdcBllMessages.IMAGE_REPOSITORY_NOT_FOUND.toString());
            }
            returnValue = false;
        }
    }
    return returnValue;
}
#method_after
public static boolean VerifyAddVm(List<String> reasons, int nicsCount, int vmPriority) {
    boolean returnValue = true;
    if (MacPoolManager.getInstance().getavailableMacsCount() < nicsCount) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES.toString());
        }
        returnValue = false;
    } else if (!VmTemplateCommand.IsVmPriorityValueLegal(vmPriority, reasons)) {
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
@Override
public void save(tags tag) {
    Guid id = tag.gettag_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        tag.settag_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", tag.getdescription()).addValue("tag_id", id).addValue("tag_name", tag.gettag_name()).addValue("parent_id", tag.getparent_id()).addValue("readonly", tag.getIsReadonly()).addValue("type", tag.gettype());
    getCallsHandler().executeModification("Inserttags", parameterSource);
}
#method_after
@Override
public void save(tags tag) {
    Guid id = tag.gettag_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        tag.settag_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", tag.getdescription()).addValue("tag_id", tag.gettag_id()).addValue("tag_name", tag.gettag_name()).addValue("parent_id", tag.getparent_id()).addValue("readonly", tag.getIsReadonly()).addValue("type", tag.gettype());
    getCallsHandler().executeModification("Inserttags", parameterSource);
}
#end_block

#method_before
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getdescription()).addValue("name", group.getname()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getcpu_name()).addValue("selection_algorithm", group.getselection_algorithm()).addValue("high_utilization", group.gethigh_utilization()).addValue("low_utilization", group.getlow_utilization()).addValue("cpu_over_commit_duration_minutes", group.getcpu_over_commit_duration_minutes()).addValue("hypervisor_type", group.gethypervisor_type()).addValue("storage_pool_id", group.getstorage_pool_id()).addValue("max_vds_memory_over_commit", group.getmax_vds_memory_over_commit()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getcompatibility_version()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService());
    return parameterSource;
}
#method_after
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getdescription()).addValue("name", group.getname()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getcpu_name()).addValue("selection_algorithm", group.getselection_algorithm()).addValue("high_utilization", group.gethigh_utilization()).addValue("low_utilization", group.getlow_utilization()).addValue("cpu_over_commit_duration_minutes", group.getcpu_over_commit_duration_minutes()).addValue("storage_pool_id", group.getstorage_pool_id()).addValue("max_vds_memory_over_commit", group.getmax_vds_memory_over_commit()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getcompatibility_version()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService());
    return parameterSource;
}
#end_block

#method_before
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setdescription(rs.getString("description"));
    entity.setname(rs.getString("name"));
    entity.setId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setcpu_name(rs.getString("cpu_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.sethigh_utilization(rs.getInt("high_utilization"));
    entity.setlow_utilization(rs.getInt("low_utilization"));
    entity.setcpu_over_commit_duration_minutes(rs.getInt("cpu_over_commit_duration_minutes"));
    entity.sethypervisor_type(HypervisorType.forValue(rs.getInt("hypervisor_type")));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    return entity;
}
#method_after
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setdescription(rs.getString("description"));
    entity.setname(rs.getString("name"));
    entity.setId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setcpu_name(rs.getString("cpu_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.sethigh_utilization(rs.getInt("high_utilization"));
    entity.setlow_utilization(rs.getInt("low_utilization"));
    entity.setcpu_over_commit_duration_minutes(rs.getInt("cpu_over_commit_duration_minutes"));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setmax_vds_memory_over_commit(rs.getInt("max_vds_memory_over_commit"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setcompatibility_version(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    return entity;
}
#end_block

#method_before
@Override
public void save(vm_pools pool) {
    Guid id = pool.getvm_pool_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        pool.setvm_pool_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getvm_pool_description()).addValue("vm_pool_id", id).addValue("vm_pool_name", pool.getvm_pool_name()).addValue("vm_pool_type", pool.getvm_pool_type()).addValue("parameters", pool.getparameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getvds_group_id());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#method_after
@Override
public void save(vm_pools pool) {
    Guid id = pool.getvm_pool_id();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.NewGuid();
        pool.setvm_pool_id(id);
    }
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_pool_description", pool.getvm_pool_description()).addValue("vm_pool_id", pool.getvm_pool_id()).addValue("vm_pool_name", pool.getvm_pool_name()).addValue("vm_pool_type", pool.getvm_pool_type()).addValue("parameters", pool.getparameters()).addValue("prestarted_vms", pool.getPrestartedVms()).addValue("vds_group_id", pool.getvds_group_id());
    getCallsHandler().executeModification("InsertVm_pools", parameterSource);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getmStatus();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return result.getStatus();
}
#end_block

#method_before
private List<BrickProfileDetails> prepareBrickProfileDetails(GlusterVolumeEntity volume, Object[] brickProfileDetails) {
    List<BrickProfileDetails> brickProfileDetailsList = new ArrayList<BrickProfileDetails>();
    for (Object brickProfileObj : brickProfileDetails) {
        BrickProfileDetails brickProfileDetail = new BrickProfileDetails();
        Map<String, Object> brickProfile = (Map<String, Object>) brickProfileObj;
        brickProfileDetail.setBrickId(getBrickId(volume.getBricks(), (String) brickProfile.get(BRICK)));
        List<StatsInfo> statsInfo = new ArrayList<StatsInfo>();
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(CUMULATIVE_STATS), CUMULATIVE_STATS));
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(INTERVAL_STATS), INTERVAL_STATS));
        brickProfileDetail.setStatsInfo(statsInfo);
        brickProfileDetailsList.add(brickProfileDetail);
    }
    return brickProfileDetailsList;
}
#method_after
private List<BrickProfileDetails> prepareBrickProfileDetails(GlusterVolumeEntity volume, Object[] brickProfileDetails) {
    List<BrickProfileDetails> brickProfileDetailsList = new ArrayList<BrickProfileDetails>();
    for (Object brickProfileObj : brickProfileDetails) {
        BrickProfileDetails brickProfileDetail = new BrickProfileDetails();
        Map<String, Object> brickProfile = (Map<String, Object>) brickProfileObj;
        GlusterBrickEntity brick = GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), (String) brickProfile.get(BRICK));
        if (brick != null) {
            brickProfileDetail.setBrickId(brick.getId());
        }
        List<StatsInfo> statsInfo = new ArrayList<StatsInfo>();
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(CUMULATIVE_STATS), CUMULATIVE_STATS));
        statsInfo.add(getStatInfo((Map<String, Object>) brickProfile.get(INTERVAL_STATS), INTERVAL_STATS));
        brickProfileDetail.setStatsInfo(statsInfo);
        brickProfileDetailsList.add(brickProfileDetail);
    }
    return brickProfileDetailsList;
}
#end_block

#method_before
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterHostRemoveFailed:
        case GlusterAddHostFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterVolumeProfileInfoFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void ProceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case GlusterHostRemoveFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.ProceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new ClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    setClusterServiceModel(new ClusterServiceModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(getClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void UpdateDetailsAvailability() {
    super.UpdateDetailsAvailability();
    for (EntityModel detailModel : getDetailModels()) {
        if (detailModel instanceof ClusterServiceModel) {
            detailModel.setIsAvailable(((VDSGroup) getSelectedItem()).supportsGlusterService());
        }
    }
}
#method_after
@Override
protected void UpdateDetailsAvailability() {
    super.UpdateDetailsAvailability();
    getClusterServiceModel().setIsAvailable(((VDSGroup) getSelectedItem()).supportsGlusterService());
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<Network, ClusterListModel, ClusterNetworkListModel> getClusterNetworkListProvider(ClientGinjector ginjector, final Provider<ClusterNetworkPopupPresenterWidget> popupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider) {
    return new SearchableDetailTabModelProvider<Network, ClusterListModel, ClusterNetworkListModel>(ginjector, ClusterListModel.class, ClusterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewNetworkCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<Network, ClusterListModel, ClusterNetworkListModel> getClusterNetworkListProvider(ClientGinjector ginjector, final Provider<NewClusterNetworkPopupPresenterWidget> popupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider) {
    return new SearchableDetailTabModelProvider<Network, ClusterListModel, ClusterNetworkListModel>(ginjector, ClusterListModel.class, ClusterNetworkListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewNetworkCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNetworkPopupPresenterWidget.class, ClusterNetworkPopupPresenterWidget.ViewDef.class, ClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
}
#end_block

#method_before
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), REMOTE_LOCATION, getLdapProviderType(parser));
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), null, parser.hasArg(Arguments.provider.name()) ? getLdapProviderType(parser) : null);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase());
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#method_after
private void runCommand(CLIParser parser) throws ManageDomainsResult {
    String action = parser.getArg(Arguments.action.name());
    ActionType actionType;
    try {
        actionType = ActionType.valueOf(action);
    } catch (IllegalArgumentException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
    if (actionType.equals(ActionType.add)) {
        addDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), getLdapProviderType(parser));
    } else if (actionType.equals(ActionType.edit)) {
        editDomain(parser.getArg(Arguments.domain.name()).toLowerCase(), parser.getArg(Arguments.user.name()), getPasswordInput(parser), null, parser.hasArg(Arguments.provider.name()) ? getLdapProviderType(parser) : null);
    } else if (actionType.equals(ActionType.delete)) {
        deleteDomain(parser.getArg(Arguments.domain.name()).toLowerCase());
    } else if (actionType.equals(ActionType.validate)) {
        validate();
    } else if (actionType.equals(ActionType.list)) {
        getConfiguration();
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
    }
}
#end_block

#method_before
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#method_after
private String getPasswordInput(CLIParser parser) throws ManageDomainsResult {
    String pass = null;
    if (parser.hasArg(Arguments.passwordFile.name())) {
        try {
            String passwordFile = parser.getArg(Arguments.passwordFile.name());
            pass = readPasswordFile(passwordFile);
        } catch (Exception e) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.FAILURE_READING_PASSWORD_FILE, e.getMessage());
        }
        if (pass == null) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.EMPTY_PASSWORD_FILE);
        }
    } else if (parser.hasArg(Arguments.interactive.name())) {
        pass = readPasswordInteractively();
    }
    validatePassword(pass);
    return pass;
}
#end_block

#method_before
public void addDomain(String domainName, String userName, String password, String mode, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, true, false);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    printSuccessMessage(domainName, "added");
}
#method_after
public void addDomain(String domainName, String userName, String password, LdapProviderType ldapProviderType) throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, true, false);
    handleAddPermissions(domainName, adUserNameEntry, adUserIdEntry);
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
private void validate(CLIParser parser) throws ManageDomainsResult {
    if (parser.hasArg(Arguments.propertiesFile.name())) {
        if (parser.hasArg(Arguments.action.name())) {
            String action = parser.getArg(Arguments.action.name());
            ActionType actionType;
            try {
                actionType = ActionType.valueOf(action);
            } catch (IllegalArgumentException ex) {
                throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
            }
            if (actionType.equals(ActionType.add)) {
                requireArgs(parser, Arguments.domain, Arguments.user, Arguments.provider);
                requireAtLeastOneArg(parser, Arguments.passwordFile, Arguments.interactive);
                checkInvalidArgs(parser, Arguments.location);
            } else if (actionType.equals(ActionType.edit)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser, Arguments.location);
            } else if (actionType.equals(ActionType.delete)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser, Arguments.location);
            } else if (actionType.equals(ActionType.validate)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive, Arguments.location);
            } else if (actionType.equals(ActionType.list)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive, Arguments.location);
            }
        } else {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ACTION_IS_NOT_SPECIFIED);
        }
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.PROPERTIES_FILE_IS_NOT_SPECIFIED);
    }
    if (parser.getArgs().size() > Arguments.values().length) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.TOO_MANY_ARGUMENTS);
    }
}
#method_after
private void validate(CLIParser parser) throws ManageDomainsResult {
    if (parser.hasArg(Arguments.propertiesFile.name())) {
        if (parser.hasArg(Arguments.action.name())) {
            String action = parser.getArg(Arguments.action.name());
            ActionType actionType;
            try {
                actionType = ActionType.valueOf(action);
            } catch (IllegalArgumentException ex) {
                throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
            }
            if (actionType.equals(ActionType.add)) {
                requireArgs(parser, Arguments.domain, Arguments.user, Arguments.provider);
                requireAtLeastOneArg(parser, Arguments.passwordFile, Arguments.interactive);
                checkInvalidArgs(parser);
            } else if (actionType.equals(ActionType.edit)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser);
            } else if (actionType.equals(ActionType.delete)) {
                requireArgs(parser, Arguments.domain);
                checkInvalidArgs(parser);
            } else if (actionType.equals(ActionType.validate)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            } else if (actionType.equals(ActionType.list)) {
                checkInvalidArgs(parser, Arguments.domain, Arguments.user, Arguments.passwordFile, Arguments.interactive);
            }
        } else {
            throw new ManageDomainsResult(ManageDomainsResultEnum.ACTION_IS_NOT_SPECIFIED);
        }
    } else {
        throw new ManageDomainsResult(ManageDomainsResultEnum.PROPERTIES_FILE_IS_NOT_SPECIFIED);
    }
    if (parser.getArgs().size() > Arguments.values().length) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.TOO_MANY_ARGUMENTS);
    }
}
#end_block

#method_before
private void checkInvalidArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arg.name());
        }
    }
}
#method_after
private void checkInvalidArgs(CLIParser parser, Arguments... args) throws ManageDomainsResult {
    for (Arguments arg : args) {
        if (parser.hasArg(arg.name())) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arg.name());
        }
    }
    // check if the user has provided undefined arguments
    Set<String> arguments = new TreeSet<String>(parser.getArgs());
    for (Arguments arg : Arguments.values()) {
        arguments.remove(arg.name().toLowerCase());
    }
    if (arguments.size() > 0) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ARGUMENT_FOR_COMMAND, arguments.toString().replaceAll("\\[", "").replaceAll("\\]", ""));
    }
}
#end_block

#method_before
protected void createObjects() {
    existingDistVol = volumeDao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = volumeDao.getById(EXISTING_VOL_REPL_ID);
    existingServer1Static = vdsStaticDao.get(SERVER_ID_1);
    existingServer1 = vdsDao.get(SERVER_ID_1.getValue());
    existingServer2 = vdsDao.get(SERVER_ID_2.getValue());
}
#method_after
@Before
public void createObjects() {
    existingServer1 = createServer(SERVER_ID_1, SERVER_NAME_1);
    existingServer2 = createServer(SERVER_ID_2, SERVER_NAME_2);
    existingServers.add(existingServer1);
    existingServers.add(existingServer2);
    existingServers.add(createServer(SERVER_ID_3, SERVER_NAME_3));
    createCluster();
    existingDistVol = createDistVol(DIST_VOL_NAME, EXISTING_VOL_DIST_ID);
    existingReplVol = createReplVol();
}
#end_block

#method_before
private void setupMocks() {
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doReturn(volumeDao).when(glusterManager).getVolumeDao();
    doReturn(brickDao).when(glusterManager).getBrickDao();
    doReturn(optionDao).when(glusterManager).getOptionDao();
    doReturn(vdsDao).when(glusterManager).getVdsDao();
    doReturn(vdsStatisticsDao).when(glusterManager).getVdsStatisticsDao();
    doReturn(vdsStaticDao).when(glusterManager).getVdsStaticDao();
    doReturn(vdsDynamicDao).when(glusterManager).getVdsDynamicDAO();
    doReturn(clusterDao).when(glusterManager).getClusterDao();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(serversListCommand).when(glusterManager).createServersListCommand(any(VDS.class));
    doReturn(volumesListCommand).when(glusterManager).createVolumesListCommand(any(VDS.class));
    doNothing().when(glusterManager).logVolumeMessage(any(GlusterVolumeEntity.class), any(AuditLogType.class));
    doReturn(getFetchedServersList()).when(serversListCommand).ExecuteWithReturnValue();
    doReturn(getFetchedVolumesList()).when(volumesListCommand).ExecuteWithReturnValue();
}
#method_after
private void setupMocks() throws Exception {
    glusterManager = Mockito.spy(GlusterManager.getInstance());
    mockTransactionManager();
    mockDaos();
    doReturn(clusterUtils).when(glusterManager).getClusterUtils();
    doReturn(existingServer1).when(clusterUtils).getUpServer(any(Guid.class));
    doNothing().when(glusterManager).logAuditMessage(any(Guid.class), any(GlusterVolumeEntity.class), any(VDS.class), any(AuditLogType.class), any(String.class), any(String.class));
    doReturn(getFetchedServersList()).when(glusterManager).fetchServers(any(VDS.class));
    doReturn(getFetchedVolumesList()).when(glusterManager).fetchVolumes(any(VDS.class));
    doReturn(getVolumeAdvancedDetails(existingDistVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingDistVol.getName());
    doReturn(getVolumeAdvancedDetails(existingReplVol)).when(glusterManager).getVolumeAdvancedDetails(existingServer1, CLUSTER_ID, existingReplVol.getName());
    doReturn(new VDSReturnValue()).when(glusterManager).runVdsCommand(eq(VDSCommandType.RemoveVds), argThat(isRemovedServer()));
}
#end_block

#method_before
private Map<String, GlusterVolumeEntity> getFetchedVolumesList() {
    Map<String, GlusterVolumeEntity> volumes = new HashMap<String, GlusterVolumeEntity>();
    // add all existing volumes except one
    List<GlusterVolumeEntity> existingVolumes = volumeDao.getByClusterId(CLUSTER_ID);
    for (GlusterVolumeEntity existingVolume : existingVolumes) {
        // do not return the distributed volume to test volume deletion
        if (!existingVolume.getId().equals(EXISTING_VOL_DIST_ID)) {
            if (existingVolume.getId().equals(EXISTING_VOL_REPL_ID)) {
                // test volume option changes
                // remove
                existingVolume.removeOption(OPTION_AUTH_ALLOW);
                // add
                existingVolume.setOption(OPTION_AUTH_REJECT, AUTH_REJECT_IP);
                // change
                existingVolume.setOption(OPTION_NFS_DISABLE, OPTION_VALUE_ON);
                // test brick changes
                replaceBrick(GlusterCoreUtil.findBrick(existingVolume.getBricks(), SERVER_ID_1, REPL_BRICK_R2D1), SERVER_ID_1, REPL_BRICK_R2D1_NEW);
                replaceBrick(GlusterCoreUtil.findBrick(existingVolume.getBricks(), SERVER_ID_1, REPL_BRICK_R2D2), SERVER_ID_1, REPL_BRICK_R2D2_NEW);
            }
            volumes.put(existingVolume.getName(), existingVolume);
        }
    }
    // add a new volume
    newVolume = getNewVolume();
    volumes.put(newVolume.getName(), newVolume);
    return volumes;
}
#method_after
private Map<String, GlusterVolumeEntity> getFetchedVolumesList() {
    Map<String, GlusterVolumeEntity> volumes = new HashMap<String, GlusterVolumeEntity>();
    GlusterVolumeEntity fetchedReplVol = createReplVol();
    // option removed
    fetchedReplVol.removeOption(OPTION_AUTH_ALLOW);
    // added
    fetchedReplVol.setOption(OPTION_AUTH_REJECT, AUTH_REJECT_IP);
    // changed
    fetchedReplVol.setOption(OPTION_NFS_DISABLE, OPTION_VALUE_ON);
    // brick changes
    removedBrickIds.add(GlusterCoreUtil.findBrick(existingReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R1D1).getId());
    removedBrickIds.add(GlusterCoreUtil.findBrick(existingReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R2D1).getId());
    GlusterBrickEntity brickToReplace = GlusterCoreUtil.findBrick(fetchedReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R1D1);
    replaceBrick(brickToReplace, SERVER_ID_1, REPL_BRICK_R1D1_NEW);
    brickToReplace = GlusterCoreUtil.findBrick(fetchedReplVol.getBricks(), SERVER_ID_1, REPL_BRICK_R2D1);
    replaceBrick(brickToReplace, SERVER_ID_1, REPL_BRICK_R2D1_NEW);
    volumes.put(fetchedReplVol.getName(), fetchedReplVol);
    // add a new volume
    newVolume = getNewVolume();
    volumes.put(newVolume.getName(), newVolume);
    return volumes;
}
#end_block

#method_before
private void replaceBrick(GlusterBrickEntity brick, Guid newServerId, String newBrickDir) {
    brick.setId(Guid.NewGuid());
    brick.setServerId(newServerId);
    brick.setBrickDirectory(newBrickDir);
}
#method_after
private void replaceBrick(GlusterBrickEntity brick, Guid newServerId, String newBrickDir) {
    brick.setId(Guid.NewGuid());
    brick.setServerId(newServerId);
    brick.setBrickDirectory(newBrickDir);
    addedBrickIds.add(brick.getId());
}
#end_block

#method_before
private Set<GlusterServerInfo> getFetchedServersList() {
    Set<GlusterServerInfo> servers = new HashSet<GlusterServerInfo>();
    List<VDS> existingServers = vdsDao.getAllForVdsGroup(CLUSTER_ID);
    for (VDS existingServer : existingServers) {
        if (!existingServer.getId().equals(SERVER_ID_2)) {
            servers.add(new GlusterServerInfo(existingServer.getId(), existingServer.gethost_name(), PeerStatus.CONNECTED));
        }
    }
    return servers;
}
#method_after
private Set<GlusterServerInfo> getFetchedServersList() {
    Set<GlusterServerInfo> servers = new HashSet<GlusterServerInfo>();
    servers.add(new GlusterServerInfo(SERVER_ID_1, SERVER_NAME_1, PeerStatus.CONNECTED));
    servers.add(new GlusterServerInfo(SERVER_ID_2, SERVER_NAME_2, PeerStatus.CONNECTED));
    return servers;
}
#end_block

#method_before
private GlusterVolumeEntity getNewVolume() {
    Guid volumeId = Guid.NewGuid();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setName(NEW_VOL_NAME);
    volume.setClusterId(CLUSTER_ID);
    volume.setId(volumeId);
    volume.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volume.addTransportType(TransportType.TCP);
    volume.setReplicaCount(0);
    volume.setStripeCount(0);
    volume.setStatus(GlusterStatus.UP);
    volume.setOption("auth.allow", "*");
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    volume.addAccessProtocol(AccessProtocol.NFS);
    GlusterBrickEntity brick = new GlusterBrickEntity(volumeId, existingServer1Static, "/export/testVol1", GlusterStatus.UP);
    brick.setBrickOrder(0);
    volume.addBrick(brick);
    return volume;
}
#method_after
private GlusterVolumeEntity getNewVolume() {
    Guid volumeId = Guid.NewGuid();
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setName(NEW_VOL_NAME);
    volume.setClusterId(CLUSTER_ID);
    volume.setId(volumeId);
    volume.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volume.addTransportType(TransportType.TCP);
    volume.setReplicaCount(0);
    volume.setStripeCount(0);
    volume.setStatus(GlusterStatus.UP);
    volume.setOption("auth.allow", "*");
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    volume.addAccessProtocol(AccessProtocol.NFS);
    GlusterBrickEntity brick = new GlusterBrickEntity(volumeId, existingServer1.getStaticData(), "/export/testVol1", GlusterStatus.UP);
    brick.setBrickOrder(0);
    volume.addBrick(brick);
    return volume;
}
#end_block

#method_before
public void enableCifs() {
    accessProtocols.add(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_CIFS_DISABLE, GlusterConstants.OFF);
}
#method_after
public void enableCifs() {
    accessProtocols.add(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.ON);
}
#end_block

#method_before
public void disableCifs() {
    accessProtocols.remove(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_CIFS_DISABLE, GlusterConstants.ON);
}
#method_after
public void disableCifs() {
    accessProtocols.remove(AccessProtocol.CIFS);
    setOption(GlusterConstants.OPTION_USER_CIFS, GlusterConstants.OFF);
}
#end_block

#method_before
public boolean isCifsEnabled() {
    String cifsEnabled = getOptionValue(GlusterConstants.OPTION_CIFS_DISABLE);
    return (cifsEnabled == null || cifsEnabled.equalsIgnoreCase(GlusterConstants.OFF));
}
#method_after
public boolean isCifsEnabled() {
    String cifsEnabled = getOptionValue(GlusterConstants.OPTION_USER_CIFS);
    return (cifsEnabled == null || cifsEnabled.equalsIgnoreCase(GlusterConstants.ON));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) obj;
    if (!(clusterId.equals(volume.getClusterId()))) {
        return false;
    }
    if (!(name.equals(volume.getName()) && volumeType == volume.getVolumeType() && status == volume.getStatus() && GlusterCoreUtil.objectsEqual(replicaCount, volume.getReplicaCount()) && GlusterCoreUtil.objectsEqual(stripeCount, volume.getStripeCount()))) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(getOptions(), volume.getOptions())) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(accessProtocols, volume.getAccessProtocols())) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(transportTypes, volume.getTransportTypes())) {
        return false;
    }
    if (!GlusterCoreUtil.listsEqual(bricks, volume.getBricks())) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) obj;
    if (!(clusterId.equals(volume.getClusterId()))) {
        return false;
    }
    if (!(name.equals(volume.getName()) && volumeType == volume.getVolumeType() && status == volume.getStatus() && ObjectUtils.objectsEqual(replicaCount, volume.getReplicaCount()) && ObjectUtils.objectsEqual(stripeCount, volume.getStripeCount()))) {
        return false;
    }
    if (!ListUtils.listsEqual(getOptions(), volume.getOptions())) {
        return false;
    }
    if (!ListUtils.listsEqual(accessProtocols, volume.getAccessProtocols())) {
        return false;
    }
    if (!ListUtils.listsEqual(transportTypes, volume.getTransportTypes())) {
        return false;
    }
    if (!ListUtils.listsEqual(bricks, volume.getBricks())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void insertVolumeEntity(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("InsertGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#method_after
private void insertVolumeEntity(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("InsertGlusterVolume", createFullParametersMapper(volume));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (getId().equals(brick.getId()) && GlusterCoreUtil.objectsEqual(volumeId, brick.getVolumeId()) && GlusterCoreUtil.objectsEqual(serverId, brick.getServerId()) && GlusterCoreUtil.objectsEqual(brickDirectory, brick.getBrickDirectory()) && GlusterCoreUtil.objectsEqual(brickOrder, brick.getBrickOrder()) && status == brick.getStatus());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity brick = (GlusterBrickEntity) obj;
    return (getId().equals(brick.getId()) && (ObjectUtils.objectsEqual(volumeId, brick.getVolumeId())) && (ObjectUtils.objectsEqual(serverId, brick.getServerId())) && (ObjectUtils.objectsEqual(brickDirectory, brick.getBrickDirectory())) && (ObjectUtils.objectsEqual(brickOrder, brick.getBrickOrder())) && status == brick.getStatus());
}
#end_block

#method_before
public Guid getId() {
    return getId(true);
}
#method_after
@Override
public Guid getId() {
    return getId(true);
}
#end_block

#method_before
public void setId(Guid id) {
    this.id = id;
}
#method_after
@Override
public void setId(Guid id) {
    this.id = id;
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    log.infoFormat("GlusterManager: {0}", new Date());
}
#method_after
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDAO());
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDAO());
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = prepareDAO(dbFacade.getVdsGroupDAO());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDAO().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
    newGroup.setVirtService(true);
    newGroup.setGlusterService(false);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    VdsDAO vdsDAO = prepareDAO(dbFacade.getVdsDao());
    existingVds = vdsDAO.get(FixturesTool.VDS_RHEL6_NFS_SPM);
    StoragePoolDAO storagePoolDAO = prepareDAO(dbFacade.getStoragePoolDao());
    storagePool = storagePoolDAO.get(FixturesTool.STORAGE_POOL_RHEL6_ISCSI_OTHER);
    dao = prepareDAO(dbFacade.getVdsGroupDao());
    existingVdsGroup = dao.get(existingVds.getvds_group_id());
    groupWithNoRunningVms = dbFacade.getVdsGroupDao().get(FixturesTool.VDS_GROUP_NO_RUNNING_VMS);
    newGroup = new VDSGroup();
    newGroup.setname("New VDS Group");
    newGroup.setcompatibility_version(new Version("3.0"));
    newGroup.setVirtService(true);
    newGroup.setGlusterService(false);
}
#end_block

#method_before
public void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(this, "refreshLightWeightData", new Class[0], new Object[0], GLUSTER_REFRESH_RATE_LIGHT, GLUSTER_REFRESH_RATE_LIGHT, TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(this, "refreshHeavyWeightData", new Class[0], new Object[0], GLUSTER_REFRESH_RATE_HEAVY, GLUSTER_REFRESH_RATE_HEAVY, TimeUnit.SECONDS);
}
#method_after
public void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(this, "refreshLightWeightData", new Class[0], new Object[0], getGlusterRefreshRateLight(), getGlusterRefreshRateLight(), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(this, "refreshHeavyWeightData", new Class[0], new Object[0], getGlusterRefreshRateHeavy(), getGlusterRefreshRateHeavy(), TimeUnit.SECONDS);
}
#end_block

#method_before
private boolean glusterModeSupported() {
    VdcQueryReturnValue result = Backend.getInstance().RunPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ApplicationMode, Config.DefaultConfigurationVersion));
    if (result.getSucceeded()) {
        Integer appMode = (Integer) result.getReturnValue();
        return ((appMode & ApplicationMode.GlusterOnly.getValue()) > 0);
    } else {
        log.errorFormat("Couldn't fetch configuration value ApplicationMode. " + "Aborting initialization of GlusterManager! Error: {0}", result.getExceptionString());
        return false;
    }
}
#method_after
private boolean glusterModeSupported() {
    Integer appMode = Config.<Integer>GetValue(ConfigValues.ApplicationMode);
    return ((appMode & ApplicationMode.GlusterOnly.getValue()) > 0);
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.info("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            log.debugFormat("Refreshing Gluter Data for cluster {0}", cluster.getname());
            refreshClusterData(cluster);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("refreshLightWeightData")
public void refreshLightWeightData() {
    log.debug("Refreshing Gluster Data [lightweight]");
    List<VDSGroup> clusters = getClusterDao().getAll();
    for (VDSGroup cluster : clusters) {
        if (cluster.supportsGlusterService()) {
            try {
                refreshClusterData(cluster);
            } catch (Exception e) {
                log.errorFormat("Error while refreshing Gluster lightweight data of cluster {0}!", cluster.getname(), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void refreshClusterData(VDSGroup cluster) {
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.warnFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    refreshServerData(cluster, upServer);
    refreshVolumeData(cluster, upServer);
}
#method_after
private void refreshClusterData(VDSGroup cluster) {
    log.debugFormat("Refreshing Gluster lightweight Data for cluster {0}", cluster.getname());
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    VDS upServer = getClusterUtils().getUpServer(cluster.getId());
    if (upServer == null) {
        log.debugFormat("No server UP in cluster {0}. Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    refreshServerData(cluster, upServer, existingServers);
    refreshVolumeData(cluster, upServer, existingServers);
}
#end_block

#method_before
private void refreshServerData(VDSGroup cluster, VDS upServer) {
    if (cluster.supportsVirtService()) {
        // running VMs
        return;
    }
    List<VDS> existingServers = getVdsDao().getAllForVdsGroup(cluster.getId());
    Set<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
    if (fetchedServers != null) {
        removeDetachedServers(existingServers, fetchedServers);
    }
}
#method_after
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debugFormat("As cluster {0} supports virt service as well, it's servers will not be synced with glusterfs", cluster.getname());
        return;
    }
    Set<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
    if (fetchedServers != null) {
        removeDetachedServers(existingServers, fetchedServers);
    }
}
#end_block

#method_before
private void removeDetachedServers(List<VDS> existingServers, Set<GlusterServerInfo> fetchedServers) {
    for (VDS server : existingServers) {
        if (!findServer(server, fetchedServers)) {
            RemoveVdsStatisticsFromDb(server);
            RemoveVdsDynamicFromDb(server);
            RemoveVdsStaticFromDb(server);
            // remove the server from resource manager
            ResourceManager.getInstance().RemoveVds(server.getId());
        }
    }
}
#method_after
private void removeDetachedServers(List<VDS> existingServers, Set<GlusterServerInfo> fetchedServers) {
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getstatus()) && serverDetached(server, fetchedServers)) {
            log.debugFormat("Server {0} has been removed directly using the gluster CLI. Removing it from engine as well.", server.getvds_name());
            logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
            try {
                removeServerFromDb(server);
            } catch (Exception e) {
                log.errorFormat("Error while removing server {0} from database!", server.getvds_name(), e);
                continue;
            }
            // remove the server from resource manager
            runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
        }
    }
}
#end_block

#method_before
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<String>();
    for (VdsNetworkInterface iface : vds.getInterfaces()) {
        vdsIps.add(iface.getAddress());
    }
    return vdsIps;
}
#method_after
private List<String> getVdsIps(VDS vds) {
    List<String> vdsIps = new ArrayList<String>();
    for (VdsNetworkInterface iface : getInterfaceDao().getAllInterfacesForVds(vds.getId())) {
        if (iface.getAddress() != null) {
            vdsIps.add(iface.getAddress());
        }
    }
    return vdsIps;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Set<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    Set<GlusterServerInfo> fetchedServers;
    GlusterServersListVDSCommand<VdsIdVDSCommandParametersBase> serversListCommand = createServersListCommand(upServer);
    fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.gethost_name()) || server.getHostnameOrIp().equals(upServer.getManagmentIp())) {
            // Find a different UP server, and get servers list from it
            upServer = getNewUpServer(existingServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
        }
    }
    return fetchedServers;
}
#method_after
private Set<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Create a copy of the existing servers as the fetchServer method can potentially remove elements from it
    List<VDS> tempServers = new ArrayList<VDS>(existingServers);
    Set<GlusterServerInfo> fetchedServers = fetchServers(upServer, tempServers);
    if (fetchedServers == null) {
        log.errorFormat("gluster peer status command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
        return null;
    }
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.gethost_name()) || getVdsIps(upServer).contains(server.getHostnameOrIp())) {
            // Find a different UP server, and get servers list from it
            tempServers.remove(upServer);
            upServer = getNewUpServer(tempServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = fetchServers(upServer, tempServers);
            if (fetchedServers == null) {
                log.warnFormat("The only UP server in cluster {0} (or the only one on which gluster peer status " + "command is working) seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
        }
    }
    return fetchedServers;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private Set<GlusterServerInfo> fetchServers(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    Set<GlusterServerInfo> fetchedServers;
    GlusterServersListVDSCommand<VdsIdVDSCommandParametersBase> serversListCommand = createServersListCommand(upServer);
    fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
    if (fetchedServers.size() == 1 && existingServers.size() > 2) {
        // It's possible that the server we are using to get list of servers itself has been removed from the
        // cluster, and hence is returning a single server (itself)
        GlusterServerInfo server = fetchedServers.iterator().next();
        if (server.getHostnameOrIp().equals(upServer.gethost_name()) || server.getHostnameOrIp().equals(upServer.getManagmentIp())) {
            // Find a different UP server, and get servers list from it
            upServer = getNewUpServer(existingServers, upServer);
            if (upServer == null) {
                log.warnFormat("The only UP server in cluster {0} seems to have been removed from it using gluster CLI. " + "Can't refresh it's data at this point.", cluster.getname());
                return null;
            }
            fetchedServers = (Set<GlusterServerInfo>) serversListCommand.ExecuteWithReturnValue();
        }
    }
    return fetchedServers;
}
#method_after
private Set<GlusterServerInfo> fetchServers(VDS upServer, List<VDS> existingServers) {
    Set<GlusterServerInfo> fetchedServers = null;
    while (fetchedServers == null && !existingServers.isEmpty()) {
        fetchedServers = fetchServers(upServer);
        if (fetchedServers == null) {
            logServerMessage(upServer, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
            // Couldn't fetch servers from the up server. Mark it as non-operational
            setNonOperational(upServer);
            existingServers.remove(upServer);
            upServer = getNewUpServer(existingServers, upServer);
        }
    }
    return fetchedServers;
}
#end_block

#method_before
private void refreshVolumeData(VDSGroup cluster, VDS upServer) {
    GlusterVolumesListVDSCommand<GlusterVolumesListVDSParameters> volumesListCommand = createVolumesListCommand(upServer);
    @SuppressWarnings("unchecked")
    Map<String, GlusterVolumeEntity> volumesMap = (Map<String, GlusterVolumeEntity>) volumesListCommand.ExecuteWithReturnValue();
    updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    removeDeletedVolumes(cluster.getId(), volumesMap);
}
#method_after
private void refreshVolumeData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    // Pass a copy of the existing servers as the fetchVolumes method can potentially remove elements from it
    Map<String, GlusterVolumeEntity> volumesMap = fetchVolumes(upServer, new ArrayList<VDS>(existingServers));
    if (volumesMap == null) {
        log.errorFormat("gluster volume info command failed on all servers of the cluster {0}." + "Can't refresh it's data at this point.", cluster.getname());
        return;
    }
    updateExistingAndNewVolumes(cluster.getId(), volumesMap);
    removeDeletedVolumes(cluster.getId(), volumesMap);
}
#end_block

#method_before
private void removeDeletedVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getName())) {
            log.debugFormat("Volume {0} has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            getVolumeDao().remove(volume.getId());
            logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
}
#method_after
private void removeDeletedVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterVolumeEntity volume : getVolumeDao().getByClusterId(clusterId)) {
        if (!volumesMap.containsKey(volume.getName())) {
            idsToRemove.add(volume.getId());
            log.debugFormat("Volume {0} has been removed directly using the gluster CLI. Removing it from engine as well.", volume.getName());
            logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI);
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getVolumeDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing volumes from database!", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    for (Entry<String, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debugFormat("Analyzing volume {0}", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getByName(clusterId, volume.getName());
        if (existingVolume == null) {
            log.infoFormat("Volume {0} Not present in engine. Creating the same.", volume.getName());
            createVolume(volume);
        } else {
            log.debugFormat("Volume {0} exists in engine. Checking if it needs to be updated.", existingVolume.getName());
            updateVolume(existingVolume, volume);
        }
    }
}
#method_after
private void updateExistingAndNewVolumes(Guid clusterId, Map<String, GlusterVolumeEntity> volumesMap) {
    for (Entry<String, GlusterVolumeEntity> entry : volumesMap.entrySet()) {
        GlusterVolumeEntity volume = entry.getValue();
        log.debugFormat("Analyzing volume {0}", volume.getName());
        GlusterVolumeEntity existingVolume = getVolumeDao().getByName(clusterId, volume.getName());
        if (existingVolume == null) {
            try {
                createVolume(volume);
            } catch (Exception e) {
                log.errorFormat("Could not save volume {0} in database!", volume.getName(), e);
                continue;
            }
        } else {
            try {
                log.debugFormat("Volume {0} exists in engine. Checking if it needs to be updated.", existingVolume.getName());
                updateVolume(existingVolume, volume);
            } catch (Exception e) {
                log.errorFormat("Error while updating Volume {0}!", volume.getName(), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void createVolume(final GlusterVolumeEntity volume) {
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getServerId() == null) {
            log.warnFormat("Volume {0} contains brick(s) from unknown hosts. Hence will not add it to engine at this point.", volume.getName());
            return;
        }
    }
    log.debugFormat("Volume {0} has been created directly using the gluster CLI. Creating it in engine as well.", volume.getName());
    getVolumeDao().save(volume);
    logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI);
}
#method_after
private void createVolume(final GlusterVolumeEntity volume) {
    if (volume.getBricks() == null) {
        log.warnFormat("Bricks of volume {0} were not fetched. " + "Hence will not add it to engine at this point.", volume.getName());
        return;
    }
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getServerId() == null) {
            log.warnFormat("Volume {0} contains brick(s) from unknown hosts. " + "Hence will not add it to engine at this point.", volume.getName());
            return;
        }
    }
    logVolumeMessage(volume, AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI);
    log.debugFormat("Volume {0} has been created directly using the gluster CLI. Creating it in engine as well.", volume.getName());
    getVolumeDao().save(volume);
}
#end_block

#method_before
@SuppressWarnings("serial")
protected void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    AuditLogDirector.log(new AuditLogableBase() {

        @Override
        protected GlusterVolumeEntity getGlusterVolume() {
            return volume;
        }

        @Override
        public AuditLogType getAuditLogTypeValue() {
            return logType;
        }
    });
}
#method_after
private void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    logAuditMessage(volume.getClusterId(), volume, null, logType, null, null);
}
#end_block

#method_before
private void updateTransportTypes(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    Set<TransportType> existingTransportTypes = existingVolume.getTransportTypes();
    Set<TransportType> fetchedTransportTypes = fetchedVolume.getTransportTypes();
    if (GlusterCoreUtil.listsEqual(existingTransportTypes, fetchedTransportTypes)) {
        // transport types not changed. return without updating DB.
        return;
    }
    Collection<TransportType> addedTransportTypes = GlusterCoreUtil.getAddedElements(existingTransportTypes, fetchedTransportTypes);
    if (!addedTransportTypes.isEmpty()) {
        log.infoFormat("Adding transport type(s) {0} to volume {1}", addedTransportTypes, existingVolume.getName());
        getVolumeDao().addTransportTypes(existingVolume.getId(), addedTransportTypes);
    }
    Collection<TransportType> removedTransportTypes = GlusterCoreUtil.getAddedElements(fetchedTransportTypes, existingTransportTypes);
    if (!removedTransportTypes.isEmpty()) {
        log.infoFormat("Removing transport type(s) {0} from volume {1}", removedTransportTypes, existingVolume.getName());
        getVolumeDao().removeTransportTypes(existingVolume.getId(), removedTransportTypes);
    }
}
#method_after
private void updateTransportTypes(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    Set<TransportType> existingTransportTypes = existingVolume.getTransportTypes();
    Set<TransportType> fetchedTransportTypes = fetchedVolume.getTransportTypes();
    if (ListUtils.listsEqual(existingTransportTypes, fetchedTransportTypes)) {
        // transport types not changed. return without updating DB.
        return;
    }
    Collection<TransportType> addedTransportTypes = ListUtils.getAddedElements(existingTransportTypes, fetchedTransportTypes);
    if (!addedTransportTypes.isEmpty()) {
        log.infoFormat("Adding transport type(s) {0} to volume {1}", addedTransportTypes, existingVolume.getName());
        getVolumeDao().addTransportTypes(existingVolume.getId(), addedTransportTypes);
    }
    Collection<TransportType> removedTransportTypes = ListUtils.getAddedElements(fetchedTransportTypes, existingTransportTypes);
    if (!removedTransportTypes.isEmpty()) {
        log.infoFormat("Removing transport type(s) {0} from volume {1}", removedTransportTypes, existingVolume.getName());
        getVolumeDao().removeTransportTypes(existingVolume.getId(), removedTransportTypes);
    }
}
#end_block

#method_before
private void updateBricks(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    List<GlusterBrickEntity> fetchedBricks = fetchedVolume.getBricks();
    removeDeletedBricks(existingVolume, fetchedBricks);
    updateExistingAndNewBricks(existingVolume, fetchedBricks);
}
#method_after
private void updateBricks(GlusterVolumeEntity existingVolume, GlusterVolumeEntity fetchedVolume) {
    List<GlusterBrickEntity> fetchedBricks = fetchedVolume.getBricks();
    if (fetchedBricks == null) {
        log.warnFormat("Bricks of volume {0} were not fetched. " + "Hence will not try to update them in engine at this point.", fetchedVolume.getName());
        return;
    }
    removeDeletedBricks(existingVolume, fetchedBricks);
    updateExistingAndNewBricks(existingVolume, fetchedBricks);
}
#end_block

#method_before
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            log.infoFormat("Brick {0} removed from volume {1} from CLI. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            getBrickDao().removeBrick(existingBrick.getId());
            logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI);
        }
    }
}
#method_after
private void removeDeletedBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterBrickEntity existingBrick : existingVolume.getBricks()) {
        if (!GlusterCoreUtil.containsBrick(fetchedBricks, existingBrick)) {
            idsToRemove.add(existingBrick.getId());
            log.infoFormat("Brick {0} removed from volume {1} from CLI. Removing it from engine DB as well.", existingBrick.getQualifiedName(), existingVolume.getName());
            logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, ENTITY_BRICK, existingBrick.getQualifiedName());
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getBrickDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing bricks from database!", e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.infoFormat("New brick {0} added to volume {1} from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI);
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (existingBrick.getBrickOrder() != fetchedBrick.getBrickOrder()) {
                log.infoFormat("Brick order for brick {0} changed from {1} to {2} because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
        }
    }
}
#method_after
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.infoFormat("New brick {0} added to volume {1} from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, ENTITY_BRICK, fetchedBrick.getQualifiedName());
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (existingBrick.getBrickOrder() != fetchedBrick.getBrickOrder()) {
                log.infoFormat("Brick order for brick {0} changed from {1} to {2} because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
        }
    }
}
#end_block

#method_before
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    for (GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            log.infoFormat("Option {0} unset on volume {1} from CLI. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            getOptionDao().removeVolumeOption(existingOption.getId());
            logVolumeMessage(fetchedVolume, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI);
        }
    }
}
#method_after
private void removeDeletedOptions(GlusterVolumeEntity fetchedVolume, Collection<GlusterVolumeOptionEntity> existingOptions) {
    List<Guid> idsToRemove = new ArrayList<Guid>();
    for (GlusterVolumeOptionEntity existingOption : existingOptions) {
        if (fetchedVolume.getOption(existingOption.getKey()) == null) {
            idsToRemove.add(existingOption.getId());
            log.infoFormat("Option {0} unset on volume {1} from CLI. Removing it from engine DB as well.", existingOption.getKey(), fetchedVolume.getName());
            logAuditMessage(fetchedVolume.getClusterId(), fetchedVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, ENTITY_OPTION, existingOption.getKey());
        }
    }
    if (!idsToRemove.isEmpty()) {
        try {
            getOptionDao().removeAll(idsToRemove);
        } catch (Exception e) {
            log.errorFormat("Error while removing options of volume {0} from database!", fetchedVolume.getName(), e);
        }
    }
}
#end_block

#method_before
private void updateExistingAndNewOptions(GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    for (GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            log.infoFormat("New option {0}={1} set on volume {2} from gluster CLI. Updating engine DB accordingly.", fetchedOption.getKey(), fetchedOption.getValue(), existingVolume.getName());
            getOptionDao().save(fetchedOption);
            logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI);
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            log.infoFormat("Value of option {0} changed from {1} to {2} from CLI. Updating engine DB accordingly.", existingOption.getKey(), existingOption.getValue(), fetchedOption.getValue());
            getOptionDao().updateVolumeOption(existingOption.getId(), fetchedOption.getValue());
            logVolumeMessage(existingVolume, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI);
        }
    }
}
#method_after
private void updateExistingAndNewOptions(GlusterVolumeEntity existingVolume, Collection<GlusterVolumeOptionEntity> fetchedOptions) {
    for (GlusterVolumeOptionEntity fetchedOption : fetchedOptions) {
        GlusterVolumeOptionEntity existingOption = existingVolume.getOption(fetchedOption.getKey());
        if (existingOption == null) {
            logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, ENTITY_OPTION, fetchedOption.toString());
            log.infoFormat("New option {0}={1} set on volume {2} from gluster CLI. Updating engine DB accordingly.", fetchedOption.getKey(), fetchedOption.getValue(), existingVolume.getName());
            try {
                getOptionDao().save(fetchedOption);
            } catch (Exception e) {
                log.errorFormat("Could not save option {0} of volume {1) to database!", fetchedOption, existingVolume.getName(), e);
                continue;
            }
        } else if (!existingOption.getValue().equals(fetchedOption.getValue())) {
            logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, ENTITY_OPTION, fetchedOption.toString());
            log.infoFormat("Value of option {0} of volume {1} changed from {2} to {3} from CLI. Updating engine DB accordingly.", existingOption.getKey(), existingVolume.getName(), existingOption.getValue(), fetchedOption.getValue());
            try {
                getOptionDao().updateVolumeOption(existingOption.getId(), fetchedOption.getValue());
            } catch (Exception e) {
                log.errorFormat("Error while updating option {0} of volume {1} in database!", fetchedOption, existingVolume.getName(), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
// TODO: Fetch and update brick statuses
}
#method_after
@OnTimerMethodAnnotation("refreshHeavyWeightData")
public void refreshHeavyWeightData() {
    log.debug("Refreshing Gluster Data [heavyweight]");
    for (VDSGroup cluster : getClusterDao().getAll()) {
        try {
            refreshClusterHeavyWeightData(cluster);
        } catch (Exception e) {
            log.errorFormat("Error while refreshing Gluster heavyweight data of cluster {0}!", cluster.getname(), e);
            continue;
        }
    }
}
#end_block

#method_before
protected VdsStatisticsDAO getVdsStatisticsDao() {
    return DbFacade.getInstance().getVdsStatisticsDAO();
}
#method_after
protected VdsStatisticsDAO getVdsStatisticsDao() {
    return DbFacade.getInstance().getVdsStatisticsDao();
}
#end_block

#method_before
protected VdsStaticDAO getVdsStaticDao() {
    return DbFacade.getInstance().getVdsStaticDAO();
}
#method_after
protected VdsStaticDAO getVdsStaticDao() {
    return DbFacade.getInstance().getVdsStaticDao();
}
#end_block

#method_before
protected VdsGroupDAO getClusterDao() {
    return DbFacade.getInstance().getVdsGroupDAO();
}
#method_after
protected VdsGroupDAO getClusterDao() {
    return DbFacade.getInstance().getVdsGroupDao();
}
#end_block

#method_before
protected VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDAO();
}
#method_after
protected VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDao();
}
#end_block

#method_before
private List<GlusterBrickEntity> getBricks(Guid volumeId, Object[] brickList) throws Exception {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    int brickOrder = 0;
    for (Object brick : brickList) {
        bricks.add(getBrick(clusterId, volumeId, (String) brick, brickOrder++));
    }
    return bricks;
}
#method_after
private List<GlusterBrickEntity> getBricks(Guid volumeId, Object[] brickList) throws Exception {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    int brickOrder = 0;
    try {
        for (Object brick : brickList) {
            bricks.add(getBrick(clusterId, volumeId, (String) brick, brickOrder++));
        }
    } catch (Exception e) {
        // We do not want the command to fail if bricks for one of the volumes could not be fetched. Hence log the
        // exception and return null. The client should have special handling if bricks list of any of the volumes
        // is null.
        log.errorFormat("Error while populating bricks of volume {0}.", volumeId, e);
        return null;
    }
    return bricks;
}
#end_block

#method_before
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, String brickInfo, int brickOrder) {
    String[] brickParts = brickInfo.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickInfo + "]");
    }
    String hostnameOrIp = brickParts[0];
    String brickDir = brickParts[1];
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setVolumeId(volumeId);
    brick.setBrickOrder(brickOrder);
    brick.setBrickDirectory(brickDir);
    VDS server = getServer(clusterId, hostnameOrIp);
    if (server == null) {
        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, clusterId);
    } else {
        brick.setServerId(server.getId());
    }
    return brick;
}
#method_after
private GlusterBrickEntity getBrick(Guid clusterId, Guid volumeId, String brickInfo, int brickOrder) {
    String[] brickParts = brickInfo.split(":", -1);
    if (brickParts.length != 2) {
        throw new RuntimeException("Invalid brick representation [" + brickInfo + "]");
    }
    String hostnameOrIp = brickParts[0];
    String brickDir = brickParts[1];
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setVolumeId(volumeId);
    brick.setBrickOrder(brickOrder);
    brick.setBrickDirectory(brickDir);
    VDS server = getServer(clusterId, hostnameOrIp);
    if (server == null) {
        log.warnFormat("Could not find server {0} in cluster {1}", hostnameOrIp, clusterId);
    } else {
        brick.setServerId(server.getId());
        brick.setServerName(server.gethost_name());
    }
    return brick;
}
#end_block

#method_before
private VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDAO();
}
#method_after
private VdsDAO getVdsDao() {
    return DbFacade.getInstance().getVdsDao();
}
#end_block

#method_before
private VDS getServer(Guid clusterId, String hostnameOrIp) {
    List<VDS> servers = getVdsDao().getAllWithIpAddress(hostnameOrIp);
    if (servers.size() > 0) {
        return getServerOfCluster(clusterId, servers);
    }
    servers = getVdsDao().getAllForHostname(hostnameOrIp);
    if (servers.size() > 0) {
        return getServerOfCluster(clusterId, servers);
    }
    return null;
}
#method_after
private VDS getServer(Guid clusterId, String hostnameOrIp) {
    List<VDS> servers = getVdsDao().getAllForHostname(hostnameOrIp);
    if (servers.size() > 0) {
        return getServerOfCluster(clusterId, servers);
    }
    List<VdsNetworkInterface> ifaces = getInterfaceDao().getAllInterfacesWithIpAddress(clusterId, hostnameOrIp);
    if (ifaces.size() == 1) {
        for (VdsNetworkInterface iface : ifaces) {
            VDS server = getVdsDao().get(iface.getVdsId());
            if (server.getvds_group_id().equals(clusterId)) {
                return server;
            }
        }
    } else if (ifaces.size() > 1) {
        // manager doesn't try to update/add bricks belonging to such servers
        throw new RuntimeException(String.format("There are multiple servers in DB having same IP address %1$s! " + "Cannot arrive at correct server id for bricks related to this ip address in cluster %2$s", hostnameOrIp, clusterId));
    }
    return null;
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterBrickDao();
    server = dbFacade.getVdsStaticDAO().get(SERVER_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterBrickDao();
    server = dbFacade.getVdsStaticDao().get(SERVER_ID);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterVolumeDao();
    server = dbFacade.getVdsStaticDAO().get(SERVER_ID);
    existingDistVol = dao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = dao.getById(EXISTING_VOL_REPL_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getGlusterVolumeDao();
    server = dbFacade.getVdsStaticDao().get(SERVER_ID);
    existingDistVol = dao.getById(EXISTING_VOL_DIST_ID);
    existingReplVol = dao.getById(EXISTING_VOL_REPL_ID);
}
#end_block

#method_before
@Test
public void testContainsBrick() {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    bricks.add(brick1);
    bricks.add(brick2);
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick1));
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick2));
    assertFalse(GlusterCoreUtil.containsBrick(bricks, brick3));
}
#method_after
public void testContainsBrick() {
    List<GlusterBrickEntity> bricks = new ArrayList<GlusterBrickEntity>();
    bricks.add(brick1);
    bricks.add(brick2);
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick1));
    assertTrue(GlusterCoreUtil.containsBrick(bricks, brick2));
    assertFalse(GlusterCoreUtil.containsBrick(bricks, brick3));
}
#end_block

#method_before
private GlusterBrickEntity createBrick(Guid serverId, String serverName, String brickDir) {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setServerId(serverId);
    brick.setServerName(serverName);
    brick.setBrickDirectory(brickDir);
    return brick;
}
#method_after
private GlusterBrickEntity createBrick(Guid serverId, String serverName, String brickDir) {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(Guid.NewGuid());
    brick.setServerId(serverId);
    brick.setServerName(serverName);
    brick.setBrickDirectory(brickDir);
    return brick;
}
#end_block

#method_before
private List<GlusterMempool> prepareMemPool(Map<String, Object> memPool) {
    List<GlusterMempool> memPoolList = new ArrayList<GlusterMempool>();
    for (int i = 0; i < memPool.size(); i++) {
        GlusterMempool glusterMemoryPool = new GlusterMempool();
        glusterMemoryPool.setName((String) memPool.get(MEMORY_NAME));
        glusterMemoryPool.setHotCount(Integer.valueOf((String) memPool.get(MEMORY_HOTCOUNT)));
        glusterMemoryPool.setColdCount(Integer.valueOf((String) memPool.get(MEMORY_COLDCOUNT)));
        glusterMemoryPool.setPadddedSize(Integer.valueOf((String) memPool.get(MEMORY_PADDDEDSIZEOF)));
        glusterMemoryPool.setAllocCount(Integer.valueOf((String) memPool.get(MEMORY_ALLOCCOUNT)));
        glusterMemoryPool.setMaxAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXALLOC)));
        glusterMemoryPool.setPoolMisses(Integer.valueOf((String) memPool.get(MEMORY_POOLMISSES)));
        glusterMemoryPool.setMaxStdAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXSTDALLOC)));
        memPoolList.add(glusterMemoryPool);
    }
    return memPoolList;
}
#method_after
private List<Mempool> prepareMemPool(Object[] memoryPool) {
    List<Mempool> memPoolList = new ArrayList<Mempool>();
    for (Object memPoolObj : memoryPool) {
        Mempool glusterMemoryPool = new Mempool();
        Map<String, Object> memPool = (Map<String, Object>) memPoolObj;
        glusterMemoryPool.setName((String) memPool.get(MEMORY_NAME));
        glusterMemoryPool.setHotCount(Integer.valueOf((String) memPool.get(MEMORY_HOTCOUNT)));
        glusterMemoryPool.setColdCount(Integer.valueOf((String) memPool.get(MEMORY_COLDCOUNT)));
        glusterMemoryPool.setPadddedSize(Integer.valueOf((String) memPool.get(MEMORY_PADDDEDSIZEOF)));
        glusterMemoryPool.setAllocCount(Integer.valueOf((String) memPool.get(MEMORY_ALLOCCOUNT)));
        glusterMemoryPool.setMaxAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXALLOC)));
        glusterMemoryPool.setPoolMisses(Integer.valueOf((String) memPool.get(MEMORY_POOLMISSES)));
        glusterMemoryPool.setMaxStdAlloc(Integer.valueOf((String) memPool.get(MEMORY_MAXSTDALLOC)));
        memPoolList.add(glusterMemoryPool);
    }
    return memPoolList;
}
#end_block

#method_before
private GlusterMallInfo prepareMallInfo(Map<String, Object> mallInfo) {
    GlusterMallInfo glusterMallInfo = new GlusterMallInfo();
    glusterMallInfo.setArena(Integer.valueOf((String) mallInfo.get(MEMORY_ARENA)));
    glusterMallInfo.setOrdblks(Integer.valueOf((String) mallInfo.get(MEMORY_ORDBLKS)));
    glusterMallInfo.setSmblks(Integer.valueOf((String) mallInfo.get(MEMORY_SMBLKS)));
    glusterMallInfo.setHblks(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKS)));
    glusterMallInfo.setHblkhd(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKHD)));
    glusterMallInfo.setUsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_USMBLKS)));
    glusterMallInfo.setFsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_FSMBLKS)));
    glusterMallInfo.setUordblks(Integer.valueOf((String) mallInfo.get(MEMORY_UORDBLKS)));
    glusterMallInfo.setFordblks(Integer.valueOf((String) mallInfo.get(MEMORY_FORDBLKS)));
    glusterMallInfo.setKeepcost(Integer.valueOf((String) mallInfo.get(MEMORY_KEEPCOST)));
    return glusterMallInfo;
}
#method_after
private MallInfo prepareMallInfo(Map<String, Object> mallInfo) {
    MallInfo glusterMallInfo = new MallInfo();
    glusterMallInfo.setArena(Integer.valueOf((String) mallInfo.get(MEMORY_ARENA)));
    glusterMallInfo.setOrdblks(Integer.valueOf((String) mallInfo.get(MEMORY_ORDBLKS)));
    glusterMallInfo.setSmblks(Integer.valueOf((String) mallInfo.get(MEMORY_SMBLKS)));
    glusterMallInfo.setHblks(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKS)));
    glusterMallInfo.setHblkhd(Integer.valueOf((String) mallInfo.get(MEMORY_HBLKHD)));
    glusterMallInfo.setUsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_USMBLKS)));
    glusterMallInfo.setFsmblks(Integer.valueOf((String) mallInfo.get(MEMORY_FSMBLKS)));
    glusterMallInfo.setUordblks(Integer.valueOf((String) mallInfo.get(MEMORY_UORDBLKS)));
    glusterMallInfo.setFordblks(Integer.valueOf((String) mallInfo.get(MEMORY_FORDBLKS)));
    glusterMallInfo.setKeepcost(Integer.valueOf((String) mallInfo.get(MEMORY_KEEPCOST)));
    return glusterMallInfo;
}
#end_block

#method_before
private List<GlusterClientInfo> prepareClientInfo(Map<String, Object> clientsStatus) {
    List<GlusterClientInfo> clientInfoList = new ArrayList<GlusterClientInfo>();
    for (int i = 0; i < clientsStatus.size(); i++) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        String hostName = (String) clientsStatus.get(CLIENTS_HOST_NAME);
        String[] hostNameArr = hostName.split(":", -1);
        clientInfo.setHostname(hostNameArr[0]);
        clientInfo.setClientPort(Integer.valueOf(hostNameArr[1]));
        clientInfo.setBytesRead(Integer.valueOf((String) clientsStatus.get(CLIENTS_BYTES_READ)));
        clientInfo.setBytesWrite(Integer.valueOf((String) clientsStatus.get(CLIENTS_BYTES_WRITE)));
        clientInfoList.add(clientInfo);
    }
    return clientInfoList;
}
#method_after
private List<GlusterClientInfo> prepareClientInfo(Object[] clientsStatus) {
    List<GlusterClientInfo> clientInfoList = new ArrayList<GlusterClientInfo>();
    for (Object clientStatusObj : clientsStatus) {
        GlusterClientInfo clientInfo = new GlusterClientInfo();
        Map<String, Object> client = (Map<String, Object>) clientStatusObj;
        String hostName = (String) client.get(CLIENTS_HOST_NAME);
        String[] hostNameArr = hostName.split(":", -1);
        clientInfo.setHostname(hostNameArr[0]);
        clientInfo.setClientPort(Integer.valueOf(hostNameArr[1]));
        clientInfo.setBytesRead(Integer.valueOf((String) client.get(CLIENTS_BYTES_READ)));
        clientInfo.setBytesWritten(Integer.valueOf((String) client.get(CLIENTS_BYTES_WRITE)));
        clientInfoList.add(clientInfo);
    }
    return clientInfoList;
}
#end_block

#method_before
public Integer getClientPort() {
    return clientPort;
}
#method_after
public int getClientPort() {
    return clientPort;
}
#end_block

#method_before
public void setClientPort(Integer clientPort) {
    this.clientPort = clientPort;
}
#method_after
public void setClientPort(int clientPort) {
    this.clientPort = clientPort;
}
#end_block

#method_before
public Integer getBytesRead() {
    return bytesRead;
}
#method_after
public int getBytesRead() {
    return bytesRead;
}
#end_block

#method_before
public void setBytesRead(Integer bytesRead) {
    this.bytesRead = bytesRead;
}
#method_after
public void setBytesRead(int bytesRead) {
    this.bytesRead = bytesRead;
}
#end_block

#method_before
public Integer getPort() {
    return port;
}
#method_after
public int getPort() {
    return port;
}
#end_block

#method_before
public void setPort(Integer port) {
    this.port = port;
}
#method_after
public void setPort(int port) {
    this.port = port;
}
#end_block

#method_before
public Integer getPid() {
    return pid;
}
#method_after
public int getPid() {
    return pid;
}
#end_block

#method_before
public void setPid(Integer pid) {
    this.pid = pid;
}
#method_after
public void setPid(int pid) {
    this.pid = pid;
}
#end_block

#method_before
public Double getTotalSize() {
    return totalSize;
}
#method_after
public double getTotalSize() {
    return totalSize;
}
#end_block

#method_before
public void setTotalSize(Double totalSize) {
    this.totalSize = totalSize;
}
#method_after
public void setTotalSize(double totalSize) {
    this.totalSize = totalSize;
}
#end_block

#method_before
public Double getFreeSize() {
    return freeSize;
}
#method_after
public double getFreeSize() {
    return freeSize;
}
#end_block

#method_before
public void setFreeSize(Double freeSize) {
    this.freeSize = freeSize;
}
#method_after
public void setFreeSize(double freeSize) {
    this.freeSize = freeSize;
}
#end_block

#method_before
public Integer getBlockSize() {
    return blockSize;
}
#method_after
public int getBlockSize() {
    return blockSize;
}
#end_block

#method_before
public void setBlockSize(Integer blockSize) {
    this.blockSize = blockSize;
}
#method_after
public void setBlockSize(int blockSize) {
    this.blockSize = blockSize;
}
#end_block

#method_before
public boolean Validate() {
    LongIntegerValidation longInterValidation = new LongIntegerValidation(1, Long.MAX_VALUE);
    getSpecificMemValue().setIsValid(true);
    getSpecificCpuValue().setIsValid(true);
    if ((Boolean) getSpecificMem().getEntity()) {
        getSpecificMemValue().ValidateEntity(new IValidation[] { longInterValidation, new NotEmptyValidation() });
    }
    if ((Boolean) getSpecificCpu().getEntity()) {
        getSpecificCpuValue().ValidateEntity(new IValidation[] { longInterValidation, new NotEmptyValidation() });
    }
    return getSpecificMemValue().getIsValid() && getSpecificCpuValue().getIsValid();
}
#method_after
public boolean Validate() {
    IntegerValidation intValidation = new IntegerValidation();
    intValidation.setMinimum(1);
    getSpecificMemValue().setIsValid(true);
    getSpecificCpuValue().setIsValid(true);
    if ((Boolean) getSpecificMem().getEntity()) {
        getSpecificMemValue().ValidateEntity(new IValidation[] { intValidation, new NotEmptyValidation() });
    }
    if ((Boolean) getSpecificCpu().getEntity()) {
        getSpecificCpuValue().ValidateEntity(new IValidation[] { intValidation, new NotEmptyValidation() });
    }
    return getSpecificMemValue().getIsValid() && getSpecificCpuValue().getIsValid();
}
#end_block

#method_before
protected String addToAuditLogErrorMessage(String connection, String errorCode, List<storage_server_connections> connections, LUNs lun) {
    AuditLogableBase logable = new AuditLogableBase();
    String connectionField = getConnectionDescription(connections, connection) + (lun == null ? "" : " (LUN " + lun.getLUN_id() + ")");
    logable.AddCustomValue("Connection", connectionField);
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    String translatedError = getTranslatedStorageError(errorCode);
    logable.AddCustomValue("ErrorCode", translatedError);
    AuditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_ERROR);
    return connectionField;
}
#method_after
protected String addToAuditLogErrorMessage(String connection, String errorCode, List<storage_server_connections> connections, LUNs lun) {
    AuditLogableBase logable = new AuditLogableBase();
    String connectionField = getConnectionDescription(connections, connection) + (lun == null ? "" : " (LUN " + lun.getLUN_id() + ")");
    logable.AddCustomValue("Connection", connectionField);
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    String translatedError = getTranslatedStorageError(errorCode);
    logable.AddCustomValue("ErrorMessage", translatedError);
    AuditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_ERROR);
    return connectionField;
}
#end_block

#method_before
private void prepareMocks(StartGlusterVolumeProfileCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getGlusterVolume(stoppedVolumeId)).when(volumeDao).getById(stoppedVolumeId);
    doReturn(getGlusterVolume(startedVolumeId)).when(volumeDao).getById(startedVolumeId);
    doReturn(null).when(volumeDao).getById(null);
}
#method_after
private void prepareMocks(StartGlusterVolumeProfileCommand command) {
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getGlusterVolume(STOPPED_VOLUME_ID)).when(volumeDao).getById(STOPPED_VOLUME_ID);
    doReturn(getGlusterVolume(STARTED_VOLUME_ID)).when(volumeDao).getById(STARTED_VOLUME_ID);
    doReturn(null).when(volumeDao).getById(null);
}
#end_block

#method_before
private GlusterVolumeEntity getGlusterVolume(Guid volumeId) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volumeEntity.setStatus((volumeId.equals(startedVolumeId)) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volumeEntity.setClusterId(CLUSTER_ID);
    return volumeEntity;
}
#method_after
private GlusterVolumeEntity getGlusterVolume(Guid volumeId) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(volumeId);
    volumeEntity.setName("test-vol");
    volumeEntity.addAccessProtocol(AccessProtocol.GLUSTER);
    volumeEntity.addTransportType(TransportType.TCP);
    volumeEntity.setVolumeType(GlusterVolumeType.DISTRIBUTE);
    volumeEntity.setStatus((volumeId.equals(STARTED_VOLUME_ID)) ? GlusterStatus.UP : GlusterStatus.DOWN);
    volumeEntity.setClusterId(CLUSTER_ID);
    return volumeEntity;
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnStoppedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(stoppedVolumeId)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionSucceedsOnStoppedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(STOPPED_VOLUME_ID)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnStartedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(startedVolumeId)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionSucceedsOnStartedVolume() {
    cmd = spy(new StartGlusterVolumeProfileCommand(new GlusterVolumeParameters(STARTED_VOLUME_ID)));
    prepareMocks(cmd);
    assertTrue(cmd.canDoAction());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__START_VOLUME_PROFILE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__START_PROFILE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolumeProfile, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartGlusterVolumeProfile, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, returnValue.getVdsError().getMessage());
    }
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initQuotaSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DELETE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DELETE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.QUOTA_STORAGE_RESIZE_LOWER_THEN_CONSUMPTION, AuditLogSeverity.WARNING);
}
#method_after
private static void initQuotaSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DELETE_QUOTA, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DELETE_QUOTA, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_VDS_GROUP_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_GRACE_LIMIT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_LIMIT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXCEEDED_QUOTA_STORAGE_THRESHOLD, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.QUOTA_STORAGE_RESIZE_LOWER_THEN_CONSUMPTION, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private void UpdateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getnet_config_dirty() == null ? false : getEntity().getnet_config_dirty()));
    // Check manual fence alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getvm_active() == null ? 0 : getEntity().getvm_active()) > 0 || getEntity().getspm_status() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getstatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getstatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else // available oVirt ISOs that are returned by the backend's GetoVirtISOs query.
    if (getEntity().getvds_type() == VDSType.oVirtNode && isEntityChanged) {
        AsyncDataProvider.GetoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    hostGeneralModel.setHasUpgradeAlert(true);
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(vds.getstatus() != VDSStatus.Up && vds.getstatus() != VDSStatus.Installing && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.Reboot && vds.getstatus() != VDSStatus.PendingApproval);
                    if (!hostGeneralModel.getInstallCommand().getIsExecutionAllowed()) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().switchToMaintenanceModeToEnableUpgradeReason());
                    }
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#method_after
private void UpdateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getnet_config_dirty() == null ? false : getEntity().getnet_config_dirty()));
    // Check manual fence alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getvm_active() == null ? 0 : getEntity().getvm_active()) > 0 || getEntity().getspm_status() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getstatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getstatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getstatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else // available oVirt ISOs that are returned by the backend's GetoVirtISOs query.
    if (getEntity().getvds_type() == VDSType.oVirtNode && isEntityChanged) {
        AsyncDataProvider.GetoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    hostGeneralModel.setHasUpgradeAlert(true);
                    boolean executionAllowed = vds.getstatus() != VDSStatus.Up && vds.getstatus() != VDSStatus.Installing && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.Reboot && vds.getstatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(executionAllowed);
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    if (returnValue && (vm != null && vm.getstatus() == VMStatus.ImageLocked)) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_ARE_LOCKED);
    } else {
        // if user sent drive check that its not in use
        returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
        if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfImageDiskCanBeAdded(vm);
        }
        if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfLunDiskCanBeAdded();
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    // if user sent drive check that its not in use
    returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
    if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfImageDiskCanBeAdded(vm);
    }
    if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfLunDiskCanBeAdded();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, false, false, false, true, false, false, true, Collections.emptyList());
}
#method_after
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, true, false, false, true, false, false, true, null);
}
#end_block

#method_before
public Pair<T, K> getPair() {
    return pair == null ? new Pair<T, K>(null, null) : pair;
}
#method_after
private Pair<T, K> getPair() {
    if (pair == null) {
        pair = new Pair<T, K>(null, null);
    }
    return pair;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    PairQueryable other = (PairQueryable) obj;
    if (getPair() == null) {
        if (other.getPair() != null)
            return false;
    } else if (!getPair().equals(other.getPair()))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof PairQueryable)) {
        return false;
    }
    PairQueryable other = (PairQueryable) obj;
    if (getPair() == null) {
        if (other.getPair() != null) {
            return false;
        }
    } else if (!getPair().equals(other.getPair())) {
        return false;
    }
    return true;
}
#end_block

#method_before
/* Overridden CommandBase Methods */
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    return Arrays.<SPMAsyncTaskHandler>asList(new CreateImagePlaceholderTaskHandler(this), new VmMigrationDiskStartTaskHandler(this), new VmMigrationDiskCompleteTaskHandler(this));
}
#method_after
/* Overridden CommandBase Methods */
@Override
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    return Arrays.<SPMAsyncTaskHandler>asList(new LiveSnapshotTaskHandler(this), new CreateImagePlaceholderTaskHandler(this), new VmReplicateDiskStartTaskHandler(this), new VmReplicateDiskFinishTaskHandler(this));
}
#end_block

#method_before
@Override
protected T getParameters() {
    return super.getParameters();
}
#method_after
/* Overridden stubs declared as public in order to implement ITaskHandlerCommand */
@Override
public T getParameters() {
    return super.getParameters();
}
#end_block

#method_before
@Override
protected Guid createTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTask(asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#method_after
@Override
public Guid createTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, VdcObjectType entityType, Guid... entityIds) {
    return super.createTask(asyncTaskCreationInfo, parentCommand, entityType, entityIds);
}
#end_block

#method_before
@Override
protected VDSCommandType getVDSCommandType() {
    return VDSCommandType.SyncImageGroup;
}
#method_after
@Override
protected VDSCommandType getVDSCommandType() {
    return VDSCommandType.CloneImageGroupStructure;
}
#end_block

#method_before
@Override
public AsyncTaskType getTaskType() {
    return AsyncTaskType.syncImage;
}
#method_after
@Override
public AsyncTaskType getTaskType() {
    return AsyncTaskType.cloneImageStructure;
}
#end_block

#method_before
@Override
protected VDSParametersBase getVDSParameters() {
    return new SyncImageGroupVDSCommandParameters(getStoragePoolID(), getEnclosingCommand().getParameters().getSourceDomainId().getValue(), getImageGroupID(), getStorageDomainID(), SyncOptions.PREPARE | SyncOptions.MIRROR_EXTEND_START);
}
#method_after
@Override
protected VDSParametersBase getVDSParameters() {
    return new TargetDomainImageGroupVDSCommandParameters(getEnclosingCommand().getParameters().getStoragePoolId().getValue(), getEnclosingCommand().getParameters().getSourceStorageDomainId(), getEnclosingCommand().getParameters().getImageGroupID(), getEnclosingCommand().getParameters().getTargetStorageDomainId());
}
#end_block

#method_before
@Override
protected VdcObjectType getTaskObjectType() {
    return VdcObjectType.Disk;
}
#method_after
@Override
protected VdcObjectType getTaskObjectType() {
    return VdcObjectType.VM;
}
#end_block

#method_before
@Override
protected Guid[] getTaskObjects() {
    return new Guid[] { getEnclosingCommand().getDiskImage().getId() };
}
#method_after
@Override
protected Guid[] getTaskObjects() {
    return new Guid[] { getEnclosingCommand().getParameters().getVmId() };
}
#end_block

#method_before
@Override
protected VDSCommandType getRevertVDSCommandType() {
    return VDSCommandType.DeleteImageGroup;
}
#method_after
@Override
protected VDSCommandType getRevertVDSCommandType() {
    // VDSM handles the failed cloneImageGroupStructure, so no action required here.
    return null;
}
#end_block

#method_before
@Override
public AsyncTaskType getRevertTaskType() {
    return AsyncTaskType.deleteImage;
}
#method_after
@Override
public AsyncTaskType getRevertTaskType() {
    // VDSM handles the failed cloneImageGroupStructure, so no action required here.
    return null;
}
#end_block

#method_before
@Override
protected VDSParametersBase getRevertVDSParameters() {
    return new DeleteImageGroupVDSCommandParameters(getStoragePoolID(), getStorageDomainID(), getImageGroupID(), false, false, getEnclosingCommand().getStoragePool().getcompatibility_version().getValue());
}
#method_after
@Override
protected VDSParametersBase getRevertVDSParameters() {
    // VDSM handles the failed cloneImageGroupStructure, so no action required here.
    return null;
}
#end_block

#method_before
private static Class<CommandBase<? extends VdcActionParametersBase>> getCommandClass(String name, String suffix) {
    // try the cache first
    String key = name + suffix;
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = commandsCache.get(key);
    if (clazz != null) {
        return clazz;
    }
    for (String commandPackage : COMMAND_PACKAGES) {
        String className = String.format(CLASS_NAME_FORMAT, commandPackage, name, suffix);
        Class<CommandBase<?>> type = loadClass(className);
        if (type != null) {
            // update cache
            Class<CommandBase<?>> cachedType = commandsCache.putIfAbsent(key, type);
            return cachedType == null ? type : cachedType;
        }
    }
    // nothing found
    log.warn("Unable to find class for action: " + key);
    return null;
}
#method_after
public static Class<CommandBase<? extends VdcActionParametersBase>> getCommandClass(String name) {
    return getCommandClass(name, CommandSuffix);
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    getBroker().diskReplicateFinsih(getParameters().getVmId().toString(), getSrcDiskXmlRpc(), getDstDiskXmlRpc());
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    getBroker().diskReplicateFinish(getParameters().getVmId().toString(), getSrcDiskXmlRpc(), getDstDiskXmlRpc());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    storage_pool_iso_map domainPoolMap = TransactionSupport.executeInNewTransaction(new TransactionMethod<storage_pool_iso_map>() {

        @Override
        public storage_pool_iso_map runInTransaction() {
            storage_pool_iso_map domainPoolMap = new storage_pool_iso_map(getRecoveryStoragePoolParametersData().getNewMasterDomainId(), getRecoveryStoragePoolParametersData().getStoragePoolId(), StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
            return domainPoolMap;
        }
    });
    getStoragePool().setstatus(StoragePoolStatus.Problematic);
    try {
        if (StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
            super.executeCommand();
        } else {
            getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
        }
    } finally {
        if (!reconstructOpsSucceeded) {
            getCompensationContext().snapshotNewEntity(domainPoolMap);
            getCompensationContext().stateChanged();
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    storage_pool_iso_map domainPoolMap = TransactionSupport.executeInNewTransaction(new TransactionMethod<storage_pool_iso_map>() {

        @Override
        public storage_pool_iso_map runInTransaction() {
            storage_pool_iso_map domainPoolMap = new storage_pool_iso_map(getRecoveryStoragePoolParametersData().getNewMasterDomainId(), getRecoveryStoragePoolParametersData().getStoragePoolId(), StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
            return domainPoolMap;
        }
    });
    getStoragePool().setstatus(StoragePoolStatus.Problematic);
    try {
        if (StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToDomainByVdsId(getNewMaster(false), getVds().getId())) {
            super.executeCommand();
        } else {
            getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
        }
    } finally {
        if (!reconstructOpSucceeded) {
            getStoragePoolIsoMapDAO().remove(new StoragePoolIsoMapId(getRecoveryStoragePoolParametersData().getNewMasterDomainId(), getRecoveryStoragePoolParametersData().getStoragePoolId()));
        }
    }
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpsSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpsSucceeded);
        if (!_isLastMaster && reconstructOpsSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpsSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                if (returnValue.getSucceeded()) {
                    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } else {
                    log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((imagesParameters == null) ? 0 : imagesParameters.hashCode());
    result = prime * result + (shouldbelogged ? 1231 : 1237);
    result = prime * result + (int) (taskStartTime ^ (taskStartTime >>> 32));
    result = prime * result + ((transctionOption == null) ? 0 : transctionOption.hashCode());
    result = prime * result + ((entityId == null) ? 0 : entityId.hashCode());
    result = prime * result + ((httpSessionId == null) ? 0 : httpSessionId.hashCode());
    result = prime * result + (multipleAction ? 1231 : 1237);
    result = prime * result + ((parametersCurrentUser == null) ? 0 : parametersCurrentUser.hashCode());
    result = prime * result + ((parentCommand == null) ? 0 : parentCommand.hashCode());
    result = prime * result + ((taskIds == null) ? 0 : taskIds.hashCode());
    result = prime * result + ((correlationId == null) ? 0 : correlationId.hashCode());
    result = prime * result + executionIndex;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((imagesParameters == null) ? 0 : imagesParameters.hashCode());
    result = prime * result + (shouldbelogged ? 1231 : 1237);
    result = prime * result + ((transctionOption == null) ? 0 : transctionOption.hashCode());
    result = prime * result + ((entityId == null) ? 0 : entityId.hashCode());
    result = prime * result + ((httpSessionId == null) ? 0 : httpSessionId.hashCode());
    result = prime * result + (multipleAction ? 1231 : 1237);
    result = prime * result + ((parametersCurrentUser == null) ? 0 : parametersCurrentUser.hashCode());
    result = prime * result + ((parentCommand == null) ? 0 : parentCommand.hashCode());
    result = prime * result + ((taskIds == null) ? 0 : taskIds.hashCode());
    result = prime * result + ((correlationId == null) ? 0 : correlationId.hashCode());
    result = prime * result + executionIndex;
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdcActionParametersBase other = (VdcActionParametersBase) obj;
    if (imagesParameters == null) {
        if (other.imagesParameters != null)
            return false;
    } else if (!imagesParameters.equals(other.imagesParameters))
        return false;
    if (shouldbelogged != other.shouldbelogged)
        return false;
    if (taskStartTime != other.taskStartTime)
        return false;
    if (transctionOption != other.transctionOption)
        return false;
    if (entityId == null) {
        if (other.entityId != null)
            return false;
    } else if (!entityId.equals(other.entityId))
        return false;
    if (httpSessionId == null) {
        if (other.httpSessionId != null)
            return false;
    } else if (!httpSessionId.equals(other.httpSessionId))
        return false;
    if (multipleAction != other.multipleAction)
        return false;
    if (parametersCurrentUser == null) {
        if (other.parametersCurrentUser != null)
            return false;
    } else if (!parametersCurrentUser.equals(other.parametersCurrentUser))
        return false;
    if (parentCommand != other.parentCommand)
        return false;
    if (taskIds == null) {
        if (other.taskIds != null)
            return false;
    } else if (!taskIds.equals(other.taskIds))
        return false;
    if (correlationId == null) {
        if (other.correlationId != null)
            return false;
    } else if (!correlationId.equals(other.correlationId))
        return false;
    if (executionIndex != other.executionIndex)
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VdcActionParametersBase other = (VdcActionParametersBase) obj;
    if (imagesParameters == null) {
        if (other.imagesParameters != null)
            return false;
    } else if (!imagesParameters.equals(other.imagesParameters))
        return false;
    if (shouldbelogged != other.shouldbelogged)
        return false;
    if (transctionOption != other.transctionOption)
        return false;
    if (entityId == null) {
        if (other.entityId != null)
            return false;
    } else if (!entityId.equals(other.entityId))
        return false;
    if (httpSessionId == null) {
        if (other.httpSessionId != null)
            return false;
    } else if (!httpSessionId.equals(other.httpSessionId))
        return false;
    if (multipleAction != other.multipleAction)
        return false;
    if (parametersCurrentUser == null) {
        if (other.parametersCurrentUser != null)
            return false;
    } else if (!parametersCurrentUser.equals(other.parametersCurrentUser))
        return false;
    if (parentCommand != other.parentCommand)
        return false;
    if (taskIds == null) {
        if (other.taskIds != null)
            return false;
    } else if (!taskIds.equals(other.taskIds))
        return false;
    if (correlationId == null) {
        if (other.correlationId != null)
            return false;
    } else if (!correlationId.equals(other.correlationId))
        return false;
    if (executionIndex != other.executionIndex)
        return false;
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
// Do nothing
}
#method_after
@Override
protected void executeCommand() {
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void testHandlersInEndSuccessful() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getReturnValue().setSucceeded(true);
    command.endActionInTransactionScope();
    verify(handler1).endSuccessfully();
    verify(handler2).beforeTask();
    verifyNoMoreInteractions(handler1, handler2);
}
#method_after
@Test
public void testHandlersInEndSuccessful() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getReturnValue().setSucceeded(true);
    command.endActionInTransactionScope();
    verify(handler1).endSuccessfully();
    verify(handler2).execute();
    verifyNoMoreInteractions(handler1, handler2);
}
#end_block

#method_before
@Test
public void testHandlersInEndWithFailure() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getParameters().setTaskGroupSuccess(false);
    command.getParameters().setExecutionIndex(1);
    command.getReturnValue().setSucceeded(false);
    command.endActionInTransactionScope();
    verify(handler2).endWithFailure();
    verify(handler1).compensate();
    verifyNoMoreInteractions(handler2, handler1);
}
#method_after
@Test
public void testHandlersInEndWithFailure() {
    SPMAsyncTaskHandler handler1 = mock(SPMAsyncTaskHandler.class);
    SPMAsyncTaskHandler handler2 = mock(SPMAsyncTaskHandler.class);
    CommandBase<VdcActionParametersBase> command = spy(new CommandBaseDummy(new VdcActionParametersBase()));
    when(command.getTaskHandlers()).thenReturn(Arrays.<SPMAsyncTaskHandler>asList(handler1, handler2));
    command.getParameters().setTaskGroupSuccess(false);
    command.getParameters().setExecutionIndex(1);
    command.getReturnValue().setSucceeded(false);
    command.endActionInTransactionScope();
    verify(handler2).endWithFailure();
    verify(handler1).compensate();
    verify(handler1).getRevertTaskType();
    verifyNoMoreInteractions(handler2, handler1);
}
#end_block

#method_before
protected List<? extends SPMAsyncTaskHandler> initTaskHandlers() {
    return Collections.singletonList(new CompleteCommandSPMAsyncTaskHandler(this));
}
#method_after
protected List<SPMAsyncTaskHandler> initTaskHandlers() {
    return null;
}
#end_block

#method_before
protected BusinessEntitySnapshotDAO getBusinessEntitySnapshotDAO() {
    return DbFacade.getInstance().getBusinessEntitySnapshotDAO();
}
#method_after
protected BusinessEntitySnapshotDAO getBusinessEntitySnapshotDAO() {
    return DbFacade.getInstance().getBusinessEntitySnapshotDao();
}
#end_block

#method_before
protected void compensate() {
    getCurrentTaskHandler().compensate();
}
#method_after
protected void compensate() {
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().compensate();
        revertPreviousHandlers();
    } else {
        internalCompensate();
    }
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            InternalEndSuccessfully();
        } else {
            InternalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected VdcActionParametersBase getParametersForTask(VdcActionType parentCommandType, VdcActionParametersBase parameters) {
    // will be stored in the DB for thr task is the one creating the command
    if (parentCommandType == VdcActionType.Unknown) {
        return parameters;
    }
    VdcActionParametersBase parentParameters = parameters.getParentParameters();
    if (parentParameters == null) {
        String msg = "No parameters exist for " + parentCommandType;
        log.error(msg);
        throw new VdcBLLException(VdcBllErrors.NO_PARAMETERS_FOR_TASK, msg);
    }
    // The parent parameters are the ones that are kept for the task.
    // In order to make sure that in case of rollback-by-command, the ROLLBACK
    // flow will be called, the execution reason of the child command is set
    // to the one of the parent command (if its REGULAR_FLOW, the execution
    // reason of the parent command remains REGULAR_FLOW).
    parentParameters.setExecutionReason(parameters.getExecutionReason());
    return parentParameters;
}
#method_after
protected VdcActionParametersBase getParametersForTask(VdcActionType parentCommandType, VdcActionParametersBase parameters) {
    // If there is no parent command, the command that its type
    // will be stored in the DB for thr task is the one creating the command
    VdcActionParametersBase parentParameters = parameters.getParentParameters();
    if (parentCommandType == VdcActionType.Unknown || parentParameters == null) {
        return parameters;
    }
    // The parent parameters are the ones that are kept for the task.
    // In order to make sure that in case of rollback-by-command, the ROLLBACK
    // flow will be called, the execution reason of the child command is set
    // to the one of the parent command (if its REGULAR_FLOW, the execution
    // reason of the parent command remains REGULAR_FLOW).
    parentParameters.setExecutionReason(parameters.getExecutionReason());
    return parentParameters;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName()).append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append("Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
private void executeActionInTransactionScope() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(CommandBase.this);
    }
    // rollback the transaction.
    if (!ExecuteWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#method_after
private void executeActionInTransactionScope() {
    if (TransactionSupport.current() != null) {
        TransactionSupport.registerRollbackHandler(CommandBase.this);
    }
    // rollback the transaction.
    if (!executeWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#end_block

#method_before
public VdcReturnValueBase getReturnValue() {
    if (_returnValue == null) {
        _returnValue = CreateReturnValue();
    }
    return _returnValue;
}
#method_after
public VdcReturnValueBase getReturnValue() {
    if (_returnValue == null) {
        _returnValue = createReturnValue();
    }
    return _returnValue;
}
#end_block

#method_before
protected void startPollingAsyncTasks(Collection<Guid> taskIds) {
    for (Guid taskID : taskIds) {
        getAsyncTaskManager().StartPollingTask(taskID);
    }
}
#method_after
protected void startPollingAsyncTasks() {
    startPollingAsyncTasks(getReturnValue().getTaskIdList());
}
#end_block

#method_before
protected List<SPMAsyncTaskHandler> getTaskHandlers() {
    return Collections.unmodifiableList(taskHandlers);
}
#method_after
protected List<SPMAsyncTaskHandler> getTaskHandlers() {
    return taskHandlers;
}
#end_block

#method_before
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        return returnValue;
    }
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            {
                // used mainly for safe upgrade and proper handling of left async tasks and compensation.
                if (Config.<Boolean>GetValue(ConfigValues.EngineMaintenanceMode)) {
                    return getErrorReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
                }
                // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
                boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
                returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
                if (returnValue != null) {
                    return returnValue;
                }
                CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
                command.setInternalExecution(runAsInternal);
                command.setContext(context);
                ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
                returnValue = command.executeAction();
                returnValue.setCorrelationId(parameters.getCorrelationId());
                returnValue.setJobId(command.getJobId());
                return returnValue;
            }
    }
}
#method_after
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
            boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
            returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
            if (returnValue != null) {
                return returnValue;
            }
            CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
            command.setInternalExecution(runAsInternal);
            command.setContext(context);
            ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
            returnValue = command.executeAction();
            returnValue.setCorrelationId(parameters.getCorrelationId());
            returnValue.setJobId(command.getJobId());
            return returnValue;
    }
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    if (EngineWorkingMode.MAINTENANCE == Config.<EngineWorkingMode>GetValue(ConfigValues.EngineMode)) {
        Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
        if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass) {
    return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass);
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isRunOnlyIfAllCanDoPass) {
    VdcReturnValueBase returnValue = notAllowToRunAction(actionType);
    if (returnValue != null) {
        ArrayList<VdcReturnValueBase> list = new ArrayList<VdcReturnValueBase>();
        list.add(returnValue);
        return list;
    } else {
        return runMultipleActionsImpl(actionType, parameters, false, isRunOnlyIfAllCanDoPass);
    }
}
#end_block

#method_before
private static VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#method_after
private VdcReturnValueBase NotAutorizedError() {
    return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode) {
                    return runQueryImpl(actionType, parameters, false);
                }
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
        case ValidateSession:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion || configParameters.getConfigValue() == ConfigurationValues.ApplicationMode) {
                return runQueryImpl(actionType, parameters, false);
            }
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
        default:
            return getErrorQueryReturnValue(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
    }
}
#end_block

#method_before
private VDSExceptionBase createException() {
    VDSExceptionBase outEx;
    final String errorMessage = String.format("Failed to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage);
    outEx = createDefaultConcreteException(errorMessage);
    return outEx;
}
#method_after
private VDSExceptionBase createException() {
    final String errorMessage = String.format("Failed to %1$s, error = %2$s", getCommandName(), getReturnStatus().mMessage);
    return createDefaultConcreteException(errorMessage);
}
#end_block

#method_before
@Override
protected VDSExceptionBase createDefaultConcreteException(String errorMessage) {
    VDSExceptionBase outEx = new IrsOperationFailedNoFailoverException(errorMessage);
    return outEx;
}
#method_after
@Override
protected VDSExceptionBase createDefaultConcreteException(String errorMessage) {
    return new IrsOperationFailedNoFailoverException(errorMessage);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    if (returnValue && (vm != null && vm.getstatus() == VMStatus.ImageLocked)) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED);
    } else {
        // if user sent drive check that its not in use
        returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
        if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfImageDiskCanBeAdded(vm);
        }
        if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
            returnValue = checkIfLunDiskCanBeAdded();
        }
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = isVmExist() && acquireLockInternal();
    VM vm = getVm();
    // if user sent drive check that its not in use
    returnValue = returnValue && (vm == null || isDiskCanBeAddedToVm(getParameters().getDiskInfo()));
    if (returnValue && DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfImageDiskCanBeAdded(vm);
    }
    if (returnValue && DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        returnValue = checkIfLunDiskCanBeAdded();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, false, false, false, true, false, false, true, Collections.emptyList());
}
#method_after
protected boolean performImagesChecks(VM vm) {
    return ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getStorageDomainId().getValue(), false, true, false, false, true, false, false, true, null);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS spmVds = LinqUtils.first(LinqUtils.filter(getAllRunningVdssInPool(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            return vds.getspm_status() == VdsSpmStatus.SPM;
        }
    }));
    final List<LUNs> luns = getHostLuns(spmVds);
    final Map<String, LUNs> lunsMap = new HashMap<String, LUNs>();
    for (LUNs lun : luns) {
        lunsMap.put(lun.getLUN_id(), lun);
    }
    final List<LUNs> processedLunsList = new ArrayList<LUNs>();
    for (String lunId : getParameters().getLunIds()) {
        LUNs lun = lunsMap.get(lunId);
        if (lun == null) {
            // fail
            ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(spmVds);
            ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedLun(getDbFacade().getLunDao().get(lunId));
            return;
        }
        lun.setvolume_group_id(getStorageDomain().getstorage());
        processedLunsList.add(lun);
    }
    // connect all vds in pool (except spm) to lun and getDeviceList
    Pair<Boolean, Map<String, List<Guid>>> result = ConnectVdsToLun(processedLunsList);
    if (result.getFirst()) {
        getReturnValue().setActionReturnValue(processedLunsList);
        setCommandShouldBeLogged(false);
        setSucceeded(true);
    } else {
        // disconnect all hosts if connection is not in use by other luns
        Map<String, List<Guid>> processed = result.getSecond();
        for (String lunId : processed.keySet()) {
            for (Guid vdsId : processed.get(lunId)) {
                LUNs lun = lunsMap.get(lunId);
                StorageHelperDirector.getInstance().getItem(getStoragePool().getstorage_pool_type()).DisconnectStorageFromLunByVdsId(getStorageDomain(), vdsId, lun);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VDS spmVds = LinqUtils.first(LinqUtils.filter(getAllRunningVdssInPool(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            return vds.getspm_status() == VdsSpmStatus.SPM;
        }
    }));
    final List<LUNs> luns = getHostLuns(spmVds);
    final Map<String, LUNs> lunsMap = new HashMap<String, LUNs>();
    for (LUNs lun : luns) {
        lunsMap.put(lun.getLUN_id(), lun);
    }
    final List<LUNs> processedLunsList = new ArrayList<LUNs>();
    for (String lunId : getParameters().getLunIds()) {
        LUNs lun = lunsMap.get(lunId);
        if (lun == null) {
            // fail
            final ConnectAllHostsToLunCommandReturnValue result = getResult();
            result.setFailedVds(spmVds);
            result.setFailedLun(getDbFacade().getLunDao().get(lunId));
            return;
        }
        lun.setvolume_group_id(getStorageDomain().getstorage());
        processedLunsList.add(lun);
    }
    // connect all vds in pool (except spm) to lun and getDeviceList
    Pair<Boolean, Map<String, List<Guid>>> result = ConnectVdsToLun(processedLunsList);
    if (result.getFirst()) {
        getReturnValue().setActionReturnValue(processedLunsList);
        setCommandShouldBeLogged(false);
        setSucceeded(true);
    } else {
        // disconnect all hosts if connection is not in use by other luns
        Map<String, List<Guid>> processed = result.getSecond();
        for (String lunId : processed.keySet()) {
            for (Guid vdsId : processed.get(lunId)) {
                LUNs lun = lunsMap.get(lunId);
                StorageHelperDirector.getInstance().getItem(getStoragePool().getstorage_pool_type()).DisconnectStorageFromLunByVdsId(getStorageDomain(), vdsId, lun);
            }
        }
    }
}
#end_block

#method_before
private Pair<Boolean, Map<String, List<Guid>>> ConnectVdsToLun(List<LUNs> luns) {
    Map<String, List<Guid>> resultMap = new HashMap<String, List<Guid>>();
    for (VDS vds : getAllRunningVdssInPool()) {
        // try to connect vds to luns and getDeviceList in order to refresh them
        for (LUNs lun : luns) {
            if (!connectStorageToLunByVdsId(vds, lun)) {
                log.errorFormat("Could not connect host {0} to lun {1}", vds.getvds_name(), lun.getLUN_id());
                setVds(vds);
                ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(vds);
                ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedLun(lun);
                return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
            } else {
                List<Guid> hosts = resultMap.get(lun.getLUN_id());
                if (hosts == null) {
                    hosts = new ArrayList<Guid>();
                    resultMap.put(lun.getLUN_id(), hosts);
                }
                hosts.add(vds.getId());
            }
        }
        // Refresh all connected luns to host
        if (!Config.<Boolean>GetValue(ConfigValues.SupportGetDevicesVisibility, vds.getvds_group_compatibility_version().getValue())) {
            Set<String> hostsLunsIds = new HashSet<String>();
            List<LUNs> hostLuns = getHostLuns(vds);
            for (LUNs lun : hostLuns) {
                hostsLunsIds.add(lun.getLUN_id());
            }
            for (LUNs lun : luns) {
                if (!hostsLunsIds.contains(lun.getLUN_id())) {
                    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
                }
            }
        } else if (!validateConnectedLuns(vds, getParameters().getLunIds())) {
            return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
        }
    }
    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.TRUE, resultMap);
}
#method_after
private Pair<Boolean, Map<String, List<Guid>>> ConnectVdsToLun(List<LUNs> luns) {
    Map<String, List<Guid>> resultMap = new HashMap<String, List<Guid>>();
    for (VDS vds : getAllRunningVdssInPool()) {
        // try to connect vds to luns and getDeviceList in order to refresh them
        for (LUNs lun : luns) {
            if (!connectStorageToLunByVdsId(vds, lun)) {
                log.errorFormat("Could not connect host {0} to lun {1}", vds.getvds_name(), lun.getLUN_id());
                setVds(vds);
                final ConnectAllHostsToLunCommandReturnValue result = getResult();
                result.setFailedVds(vds);
                result.setFailedLun(lun);
                return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
            } else {
                List<Guid> hosts = resultMap.get(lun.getLUN_id());
                if (hosts == null) {
                    hosts = new ArrayList<Guid>();
                    resultMap.put(lun.getLUN_id(), hosts);
                }
                hosts.add(vds.getId());
            }
        }
        // Refresh all connected luns to host
        if (!Config.<Boolean>GetValue(ConfigValues.SupportGetDevicesVisibility, vds.getvds_group_compatibility_version().getValue())) {
            Set<String> hostsLunsIds = new HashSet<String>();
            List<LUNs> hostLuns = getHostLuns(vds);
            for (LUNs lun : hostLuns) {
                hostsLunsIds.add(lun.getLUN_id());
            }
            for (LUNs lun : luns) {
                if (!hostsLunsIds.contains(lun.getLUN_id())) {
                    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
                }
            }
        } else if (!validateConnectedLuns(vds, getParameters().getLunIds())) {
            return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.FALSE, resultMap);
        }
    }
    return new Pair<Boolean, Map<String, List<Guid>>>(Boolean.TRUE, resultMap);
}
#end_block

#method_before
private boolean connectStorageToLunByVdsId(VDS vds, LUNs lun) {
    try {
        return StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToLunByVdsId(getStorageDomain(), vds.getId(), lun, Guid.Empty);
    } catch (VdcBLLException e) {
        ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(vds);
        ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedLun(lun);
        throw e;
    }
}
#method_after
private boolean connectStorageToLunByVdsId(VDS vds, LUNs lun) {
    try {
        return StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).ConnectStorageToLunByVdsId(getStorageDomain(), vds.getId(), lun, Guid.Empty);
    } catch (VdcBLLException e) {
        final ConnectAllHostsToLunCommandReturnValue result = getResult();
        result.setFailedVds(vds);
        result.setFailedLun(lun);
        throw e;
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<LUNs> getHostLuns(VDS vds) {
    try {
        return (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, new GetDeviceListVDSCommandParameters(vds.getId(), getStorageDomain().getstorage_type())).getReturnValue();
    } catch (VdcBLLException e) {
        ((ConnectAllHostsToLunCommandReturnValue) getReturnValue()).setFailedVds(vds);
        throw e;
    }
}
#method_after
@SuppressWarnings("unchecked")
private List<LUNs> getHostLuns(VDS vds) {
    try {
        return (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, new GetDeviceListVDSCommandParameters(vds.getId(), getStorageDomain().getstorage_type())).getReturnValue();
    } catch (VdcBLLException e) {
        getResult().setFailedVds(vds);
        throw e;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map domain : domains) {
        if (domain.getstatus() == null || domain.getstatus() == StorageDomainStatus.Unknown) {
            domain.setstatus(StorageDomainStatus.Active);
        } else if (domain.getstatus() == StorageDomainStatus.Maintenance) {
            domain.setstatus(StorageDomainStatus.InActive);
        } else if (domain.getstatus() == StorageDomainStatus.Locked) {
            throw new VdcBLLException(VdcBllErrors.CANT_RECONSTRUCT_WHEN_A_DOMAIN_IN_POOL_IS_LOCKED, "Cannot reconstruct master domain when a domain in the " + "pool is locked.");
        }
    }
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        boolean commandSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.UpdateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        boolean commandSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(commandSucceeded);
        if (!_isLastMaster && commandSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(commandSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDAO().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.gethost_name(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getstatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#method_after
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.gethost_name(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getstatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    try {
        for (VDS vds : getAllRunningVdssInPool()) {
            try {
                VDSReturnValue returnValue = null;
                // refresh command shouldn't be executed for the reconstruct initiating host
                if (!_isLastMaster && commandSucceeded && !getVds().equals(vds)) {
                    returnValue = executeRefreshStoragePoolCommand(vds);
                    if (!returnValue.getSucceeded()) {
                        log.errorFormat("Post reconstruct actions (refreshPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                    }
                }
                // connect to the storage pool.
                if (returnValue == null || returnValue.getSucceeded()) {
                    returnValue = executeConnectStoragePoolCommand(vds);
                    if (!returnValue.getSucceeded()) {
                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                    }
                }
                // only if we deactivate the storage domain we want to disconnect from it.
                if (getParameters().isInactive()) {
                    StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                }
            } catch (Exception e) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
            }
        }
    } catch (Exception ex) {
        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
private boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    if (lun.getLunType() == StorageType.UNKNOWN) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        return false;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (storage_server_connections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setParentCommand(VdcActionType.AddDisk);
    parameters.setEntityId(getParameters().getEntityId());
    parameters.setStoragePoolId(getStorageDomain().getstorage_pool_id().getValue());
    getParameters().getImagesParameters().add(parameters);
    parameters.setParentParameters(getParameters());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getstatus() == VMStatus.Down, false));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setParentCommand(VdcActionType.AddDisk);
    parameters.setEntityId(getParameters().getEntityId());
    parameters.setStoragePoolId(getStorageDomain().getstorage_pool_id().getValue());
    getParameters().getImagesParameters().add(parameters);
    parameters.setParentParameters(getParameters());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, null, getVm().getstatus() == VMStatus.Down, false));
        getCompensationContext().stateChanged();
    }
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(getExecutionContext(), getLock()));
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(getDeviceSubResource(disk.getId()).get()).build();
    } else {
        return super.add(disk);
    }
}
#method_after
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(lookupEntity(asGuid(disk.getId()))).build();
    } else {
        validateParameters(disk, "format", "interface");
        if (!disk.isSetLunStorage() || disk.getLunStorage().getLogicalUnits().isEmpty()) {
            // lun-disk does not
            // require
            // size
            validateParameters(disk, "provisionedSize|size");
        }
        return performCreation(addAction, getAddParameters(map(disk), disk), getEntityIdResolver(disk.getName()));
    }
}
#end_block

#method_before
@Test
public void testAddDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpEntityQueryExpectations(VdcQueryType.GetAllDisksByVmId, GetAllDisksByVmIdParameters.class, new String[] { "VmId" }, new Object[] { PARENT_ID }, asList(getEntity(0)));
    setUpCreationExpectations(VdcActionType.AddDisk, AddDiskParameters.class, new String[] { "VmId", "StorageDomainId" }, new Object[] { PARENT_ID, GUIDS[2] }, true, true, GUIDS[0], asList(GUIDS[3]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetAllDisksByVmId, GetAllDisksByVmIdParameters.class, new String[] { "VmId" }, new Object[] { PARENT_ID }, asList(getEntity(0)));
    Disk model = getModel(0);
    model.setSize(1024 * 1024L);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Disk);
    verifyModel((Disk) response.getEntity(), 0);
    assertNull(((Disk) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddDisk() throws Exception {
    testAddDiskImpl(getModel(0));
}
#end_block

#method_before
@Test
public void testAddIncompleteParameters() throws Exception {
    Disk model = new Disk();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Disk", "add", "provisionedSize|size", "format", "interface");
    }
}
#method_after
@Test
public void testAddIncompleteParameters() throws Exception {
    Disk model = new Disk();
    model.setName(NAMES[0]);
    setUriInfo(setUpBasicUriExpectations());
    control.replay();
    try {
        collection.add(model);
        fail("expected WebApplicationException on incomplete parameters");
    } catch (WebApplicationException wae) {
        verifyIncompleteException(wae, "Disk", "add", "format", "interface");
    }
}
#end_block

#method_before
public static QuotaDAO getQuotaDAO() {
    return DbFacade.getInstance().getQuotaDao();
}
#method_after
protected QuotaDAO getQuotaDAO() {
    return DbFacade.getInstance().getQuotaDao();
}
#end_block

#method_before
private boolean validateAndSetStorageQuotaHelper(storage_pool storagePool, List<StorageQuotaValidationParameter> parameters, ArrayList<String> canDoActionMessages, boolean isIncrease) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    lock.readLock().lock();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (parameters.isEmpty() || parameters.get(0).getQuotaId() == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(parameters.get(0).getQuotaId());
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        for (StorageQuotaValidationParameter param : parameters) {
            if (param.getQuotaId() == null || param.getStorageDomainId() == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (storagePoolQuotaMap.get(storagePool.getId()) == null) {
                return false;
            }
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            Map<Guid, Map<Guid, Double>> desiredStorageSizeQuotaMap = new HashMap<Guid, Map<Guid, Double>>();
            Map<Guid, Double> newUsedGlobalStorageSize = new HashMap<Guid, Double>();
            Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize = new HashMap<Guid, Map<Guid, Double>>();
            for (StorageQuotaValidationParameter param : parameters) {
                Quota quota;
                if (!quotaMap.containsKey(param.getQuotaId())) {
                    quota = getQuotaDAO().getById(param.getQuotaId());
                    if (quota == null) {
                        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                        return false;
                    }
                    quotaMap.put(quota.getId(), quota);
                } else {
                    quota = quotaMap.get(param.getQuotaId());
                }
                if (!desiredStorageSizeQuotaMap.containsKey(quota.getId())) {
                    desiredStorageSizeQuotaMap.put(quota.getId(), new HashMap<Guid, Double>());
                }
                Map<Guid, Double> quotaStorageMap = desiredStorageSizeQuotaMap.get(quota.getId());
                if (!quotaStorageMap.containsKey(param.getStorageDomainId())) {
                    quotaStorageMap.put(param.getStorageDomainId(), 0.0);
                }
                quotaStorageMap.put(param.getStorageDomainId(), quotaStorageMap.get(param.getStorageDomainId()) + param.getSize());
            }
            for (Guid quotaId : desiredStorageSizeQuotaMap.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                if (quota.getGlobalQuotaStorage() != null) {
                    // global storage quota
                    if (quota.getGlobalQuotaStorage().getStorageSizeGB() != UNLIMITED) {
                        double sum = 0.0;
                        for (Double size : desiredStorageSizeQuotaMap.get(quotaId).values()) {
                            sum += size;
                        }
                        double storageUsagePercentage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage() / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        double storageRequestPercentage = sum / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quota.getGlobalQuotaStorage().getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                            return false;
                        }
                        newUsedGlobalStorageSize.put(quotaId, sum + quota.getGlobalQuotaStorage().getStorageSizeGBUsage());
                    }
                } else {
                    newUsedSpecificStorageSize.put(quotaId, new HashMap<Guid, Double>());
                    for (Guid storageId : desiredStorageSizeQuotaMap.get(quotaId).keySet()) {
                        boolean hasStorageId = false;
                        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                            if (quotaStorage.getStorageId().equals(storageId)) {
                                hasStorageId = true;
                                if (quotaStorage.getStorageSizeGB() != UNLIMITED) {
                                    double storageUsagePercentage = quotaStorage.getStorageSizeGBUsage() / quotaStorage.getStorageSizeGB() * 100;
                                    double storageRequestPercentage = desiredStorageSizeQuotaMap.get(quotaId).get(storageId) / quotaStorage.getStorageSizeGB() * 100;
                                    if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quotaStorage.getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                                        return false;
                                    }
                                    newUsedSpecificStorageSize.get(quotaId).put(storageId, quotaStorage.getStorageSizeGBUsage() + desiredStorageSizeQuotaMap.get(quotaId).get(storageId));
                                    break;
                                }
                            }
                        }
                        if (!hasStorageId) {
                            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN.toString());
                            return false;
                        }
                    }
                }
            }
            // cache new storage size.
            for (Guid quotaId : newUsedGlobalStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                double value = newUsedGlobalStorageSize.get(quotaId);
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                    quotaMap.remove(quotaId);
                    continue;
                }
                quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
            }
            for (Guid quotaId : newUsedSpecificStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                    if (newUsedSpecificStorageSize.get(quotaId).containsKey(quotaStorage.getStorageId())) {
                        double value = newUsedSpecificStorageSize.get(quotaId).get(quotaStorage.getStorageId());
                        if (value < 0) {
                            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                            quotaMap.remove(quotaId);
                            continue;
                        }
                        quotaStorage.setStorageSizeGBUsage(value);
                    }
                }
            }
        }
        return true;
    } finally {
        lock.readLock().unlock();
        if (logPair.getFirst() != null) {
            AuditLogDirector.log(logPair.getSecond(), logPair.getFirst());
        }
    }
}
#method_after
private boolean validateAndSetStorageQuotaHelper(storage_pool storagePool, List<StorageQuotaValidationParameter> parameters, ArrayList<String> canDoActionMessages, boolean isIncrease) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    lock.readLock().lock();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (parameters.isEmpty() || parameters.get(0).getQuotaId() == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(parameters.get(0).getQuotaId());
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        for (StorageQuotaValidationParameter param : parameters) {
            if (param.getQuotaId() == null || Guid.Empty.equals(param.getQuotaId()) || param.getStorageDomainId() == null) {
                if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT.equals(storagePool.getQuotaEnforcementType())) {
                    canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                    return false;
                } else {
                    logPair.setFirst(AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE);
                    logPair.setSecond(new AuditLogableBase());
                    return true;
                }
            }
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (storagePoolQuotaMap.get(storagePool.getId()) == null) {
                return false;
            }
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            Map<Guid, Map<Guid, Double>> desiredStorageSizeQuotaMap = new HashMap<Guid, Map<Guid, Double>>();
            Map<Guid, Double> newUsedGlobalStorageSize = new HashMap<Guid, Double>();
            Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize = new HashMap<Guid, Map<Guid, Double>>();
            for (StorageQuotaValidationParameter param : parameters) {
                Quota quota;
                if (!quotaMap.containsKey(param.getQuotaId())) {
                    quota = getQuotaDAO().getById(param.getQuotaId());
                    if (quota == null) {
                        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                        return false;
                    }
                    quotaMap.put(quota.getId(), quota);
                } else {
                    quota = quotaMap.get(param.getQuotaId());
                }
                if (!desiredStorageSizeQuotaMap.containsKey(quota.getId())) {
                    desiredStorageSizeQuotaMap.put(quota.getId(), new HashMap<Guid, Double>());
                }
                Map<Guid, Double> quotaStorageMap = desiredStorageSizeQuotaMap.get(quota.getId());
                if (!quotaStorageMap.containsKey(param.getStorageDomainId())) {
                    quotaStorageMap.put(param.getStorageDomainId(), 0.0);
                }
                quotaStorageMap.put(param.getStorageDomainId(), quotaStorageMap.get(param.getStorageDomainId()) + param.getSize());
            }
            for (Guid quotaId : desiredStorageSizeQuotaMap.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                if (quota.getGlobalQuotaStorage() != null) {
                    // global storage quota
                    if (quota.getGlobalQuotaStorage().getStorageSizeGB() != UNLIMITED) {
                        double sum = 0.0;
                        for (Double size : desiredStorageSizeQuotaMap.get(quotaId).values()) {
                            sum += size;
                        }
                        double storageUsagePercentage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage() / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        double storageRequestPercentage = sum / quota.getGlobalQuotaStorage().getStorageSizeGB() * 100;
                        if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quota.getGlobalQuotaStorage().getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                            return false;
                        }
                        newUsedGlobalStorageSize.put(quotaId, sum + quota.getGlobalQuotaStorage().getStorageSizeGBUsage());
                    }
                } else {
                    newUsedSpecificStorageSize.put(quotaId, new HashMap<Guid, Double>());
                    for (Guid storageId : desiredStorageSizeQuotaMap.get(quotaId).keySet()) {
                        boolean hasStorageId = false;
                        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                            if (quotaStorage.getStorageId().equals(storageId)) {
                                hasStorageId = true;
                                if (quotaStorage.getStorageSizeGB() != UNLIMITED) {
                                    double storageUsagePercentage = quotaStorage.getStorageSizeGBUsage() / quotaStorage.getStorageSizeGB() * 100;
                                    double storageRequestPercentage = desiredStorageSizeQuotaMap.get(quotaId).get(storageId) / quotaStorage.getStorageSizeGB() * 100;
                                    if (!checkQuotaStorageLimits(storagePool.getQuotaEnforcementType(), quota, quotaStorage.getStorageSizeGB(), storageUsagePercentage, storageRequestPercentage, canDoActionMessages, logPair)) {
                                        return false;
                                    }
                                    newUsedSpecificStorageSize.get(quotaId).put(storageId, quotaStorage.getStorageSizeGBUsage() + desiredStorageSizeQuotaMap.get(quotaId).get(storageId));
                                    break;
                                }
                            }
                        }
                        if (!hasStorageId) {
                            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_NO_QUOTA_SET_FOR_DOMAIN.toString());
                            return false;
                        }
                    }
                }
            }
            // cache new storage size.
            for (Guid quotaId : newUsedGlobalStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                double value = newUsedGlobalStorageSize.get(quotaId);
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                    quotaMap.remove(quotaId);
                    continue;
                }
                quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
            }
            for (Guid quotaId : newUsedSpecificStorageSize.keySet()) {
                Quota quota = quotaMap.get(quotaId);
                for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                    if (newUsedSpecificStorageSize.get(quotaId).containsKey(quotaStorage.getStorageId())) {
                        double value = newUsedSpecificStorageSize.get(quotaId).get(quotaStorage.getStorageId());
                        if (value < 0) {
                            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaId);
                            quotaMap.remove(quotaId);
                            continue;
                        }
                        quotaStorage.setStorageSizeGBUsage(value);
                    }
                }
            }
        }
        return true;
    } finally {
        lock.readLock().unlock();
        auditLog(logPair);
    }
}
#end_block

#method_before
public boolean validateQuotaForStoragePool(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, ArrayList<String> canDoActionMessages) {
    lock.readLock().lock();
    try {
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (vdsGroupId == null || vdsGroupId.equals(Guid.Empty) || quotaId == null) {
            canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
            return false;
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            if (quotaMap == null) {
                return false;
            }
            Quota quota = null;
            if (!quotaMap.containsKey(quotaId)) {
                quota = getQuotaDAO().getById(quotaId);
                if (quota == null) {
                    canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
                    log.errorFormat("The quota id {0} is not found in backend and DB.", quotaId.toString());
                    return false;
                }
                quotaMap.put(quota.getId(), quota);
            } else {
                quota = quotaMap.get(quotaId);
            }
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                return true;
            } else {
                boolean hasVdsGroup = false;
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        hasVdsGroup = true;
                        break;
                    }
                }
                if (hasVdsGroup) {
                    return true;
                }
            }
        }
        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    } finally {
        lock.readLock().unlock();
    }
}
#method_after
public boolean validateQuotaForStoragePool(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, ArrayList<String> canDoActionMessages) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    lock.readLock().lock();
    try {
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (vdsGroupId == null || Guid.Empty.equals(vdsGroupId) || quotaId == null || Guid.Empty.equals(quotaId)) {
            if (QuotaEnforcementTypeEnum.HARD_ENFORCEMENT.equals(storagePool.getQuotaEnforcementType())) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            } else {
                logPair.setFirst(AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
                logPair.setSecond(new AuditLogableBase());
                return true;
            }
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(storagePool.getId());
            if (quotaMap == null) {
                return false;
            }
            Quota quota = null;
            if (!quotaMap.containsKey(quotaId)) {
                quota = getQuotaDAO().getById(quotaId);
                if (quota == null) {
                    canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
                    log.errorFormat("The quota id {0} is not found in backend and DB.", quotaId.toString());
                    return false;
                }
                quotaMap.put(quota.getId(), quota);
            } else {
                quota = quotaMap.get(quotaId);
            }
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                return true;
            } else {
                boolean hasVdsGroup = false;
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        hasVdsGroup = true;
                        break;
                    }
                }
                if (hasVdsGroup) {
                    return true;
                }
            }
        }
        canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        return false;
    } finally {
        lock.readLock().unlock();
        if (logPair.getFirst() != null) {
            AuditLogDirector.log(logPair.getSecond(), logPair.getFirst());
        }
    }
}
#end_block

#method_before
public boolean validateAndSetClusterQuota(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, int vcpu, long mem, ArrayList<String> canDoActionMessages) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (quotaId == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(quotaId);
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (!validateQuotaForStoragePool(storagePool, vdsGroupId, quotaId, canDoActionMessages)) {
                return false;
            }
            Quota quota = storagePoolQuotaMap.get(storagePool.getId()).get(quotaId);
            if (quota == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            QuotaVdsGroup quotaVdsGroup = null;
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                quotaVdsGroup = quota.getGlobalQuotaVdsGroup();
            } else {
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        quotaVdsGroup = vdsGroup;
                        break;
                    }
                }
            }
            if (quotaVdsGroup == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            boolean success = checkQuotaClusterLimits(storagePool.getQuotaEnforcementType(), quota, quotaVdsGroup, mem, vcpu, canDoActionMessages, logPair);
            if (!success) {
                return false;
            }
        }
        return true;
    } finally {
        if (logPair.getFirst() != null) {
            AuditLogDirector.log(logPair.getSecond(), logPair.getFirst());
        }
    }
}
#method_after
public boolean validateAndSetClusterQuota(storage_pool storagePool, Guid vdsGroupId, Guid quotaId, int vcpu, long mem, ArrayList<String> canDoActionMessages) {
    Pair<AuditLogType, AuditLogableBase> logPair = new Pair<AuditLogType, AuditLogableBase>();
    try {
        if (storagePool == null) {
            log.debug("Null storage pool was passed to 'QuotaManager.validateAndSetStorageQuota()'");
            if (quotaId == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            storagePool = extractStoragePoolFromQuota(quotaId);
        }
        if (QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            return true;
        }
        if (!storagePoolQuotaMap.containsKey(storagePool.getId())) {
            storagePoolQuotaMap.putIfAbsent(storagePool.getId(), new HashMap<Guid, Quota>());
        }
        synchronized (storagePoolQuotaMap.get(storagePool.getId())) {
            if (!validateQuotaForStoragePool(storagePool, vdsGroupId, quotaId, canDoActionMessages)) {
                return false;
            }
            Quota quota = storagePoolQuotaMap.get(storagePool.getId()).get(quotaId);
            if (quota == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            QuotaVdsGroup quotaVdsGroup = null;
            if (quota.getGlobalQuotaVdsGroup() != null) {
                // global cluster quota
                quotaVdsGroup = quota.getGlobalQuotaVdsGroup();
            } else {
                for (QuotaVdsGroup vdsGroup : quota.getQuotaVdsGroups()) {
                    if (vdsGroup.getVdsGroupId().equals(vdsGroupId)) {
                        quotaVdsGroup = vdsGroup;
                        break;
                    }
                }
            }
            if (quotaVdsGroup == null) {
                canDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
                return false;
            }
            boolean success = checkQuotaClusterLimits(storagePool.getQuotaEnforcementType(), quota, quotaVdsGroup, mem, vcpu, canDoActionMessages, logPair);
            if (!success) {
                return false;
            }
        }
        return true;
    } finally {
        auditLog(logPair);
    }
}
#end_block

#method_before
protected void connectAllHostToPoolAndDomain(final storage_domains masterDomain) {
    final List<VDS> vdsList = getAllRunningVdssInPool();
    final storage_pool storagePool = getStoragePool();
    SyncronizeNumberOfAsyncOperations sync = new SyncronizeNumberOfAsyncOperations(vdsList.size(), null, new ActivateDeactivateSingleAsyncOperationFactory() {

        @Override
        public ISingleAsyncOperation CreateSingleAsyncOperation() {
            return new ConntectVDSToPoolAndDomains((ArrayList<VDS>) vdsList, masterDomain, storagePool);
        }

        @Override
        public void Initialize(ArrayList parameters) {
        // no need to initilalize params
        }
    });
    sync.Execute();
}
#method_after
protected void connectAllHostToPoolAndDomain(final storage_domains masterDomain) {
    final List<VDS> vdsList = getAllRunningVdssInPool();
    final storage_pool storagePool = getStoragePool();
    SyncronizeNumberOfAsyncOperations sync = new SyncronizeNumberOfAsyncOperations(vdsList.size(), null, new ActivateDeactivateSingleAsyncOperationFactory() {

        @Override
        public ISingleAsyncOperation createSingleAsyncOperation() {
            return new ConntectVDSToPoolAndDomains((ArrayList<VDS>) vdsList, masterDomain, storagePool);
        }

        @Override
        public void initialize(ArrayList parameters) {
        // no need to initilalize params
        }
    });
    sync.Execute();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    VdsSpmIdParameters vdsSpmIdParameters = new VdsSpmIdParameters();
    vdsSpmIdParameters.setCompensationEnabled(true);
    vdsSpmIdParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    vdsSpmIdParameters.setVdsId(getVds().getId());
    if (targetStoragePool != null && (getSourceCluster().getstorage_pool_id() == null || !targetStoragePool.getId().equals(getSourceCluster().getstorage_pool_id().getValue()))) {
        vdsSpmIdParameters.setStoragePoolId(targetStoragePool.getId());
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, vdsSpmIdParameters, new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    if (getSourceCluster().getstorage_pool_id() != null && (targetStoragePool == null || !getSourceCluster().getstorage_pool_id().getValue().equals(targetStoragePool.getId()))) {
        vdsSpmIdParameters.setStoragePoolId(getSourceCluster().getstorage_pool_id().getValue());
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, vdsSpmIdParameters, new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (targetStoragePool != null && (getSourceCluster().getstorage_pool_id() == null || !targetStoragePool.getId().equals(getSourceCluster().getstorage_pool_id().getValue()))) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    if (getSourceCluster().getstorage_pool_id() != null && (targetStoragePool == null || !getSourceCluster().getstorage_pool_id().getValue().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getstorage_pool_id().getValue());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // according to shaharf the first id is 1
    int selectedId = 1;
    List<Integer> map = LinqUtils.foreach(vds_spm_id_mapList, new Function<vds_spm_id_map, Integer>() {

        @Override
        public Integer eval(vds_spm_id_map vds_spm_id_map) {
            return vds_spm_id_map.getvds_spm_id();
        }
    });
    Collections.sort(map);
    for (int id : map) {
        if (selectedId == id) {
            selectedId++;
        } else {
            break;
        }
    }
    vds_spm_id_map newMap = new vds_spm_id_map(getVds().getstorage_pool_id(), getVdsId(), selectedId);
    DbFacade.getInstance().getVdsSpmIdMapDao().save(newMap);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(newMap);
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // according to shaharf the first id is 1
    int selectedId = 1;
    List<Integer> list = LinqUtils.foreach(vds_spm_id_mapList, new Function<vds_spm_id_map, Integer>() {

        @Override
        public Integer eval(vds_spm_id_map vds_spm_id_map) {
            return vds_spm_id_map.getvds_spm_id();
        }
    });
    Collections.sort(list);
    for (int id : list) {
        if (selectedId == id) {
            selectedId++;
        } else {
            break;
        }
    }
    vds_spm_id_map newMap = new vds_spm_id_map(getVds().getstorage_pool_id(), getVdsId(), selectedId);
    DbFacade.getInstance().getVdsSpmIdMapDao().save(newMap);
    if (getParameters().isCompensationEnabled()) {
        getCompensationContext().snapshotNewEntity(newMap);
        getCompensationContext().stateChanged();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void removeByVdsAndStoragePool(Guid vdsId, Guid storagePoolId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", vdsId).addValue("storage_pool_id", storagePoolId);
    getCallsHandler().executeModification("Deletevds_spm_id_map", parameterSource);
}
#method_after
@Override
public void removeByVdsAndStoragePool(Guid vdsId, Guid storagePoolId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", vdsId).addValue("storage_pool_id", storagePoolId);
    getCallsHandler().executeModification("DeleteByPoolvds_spm_id_map", parameterSource);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    VDSGroup oldGroup = getVdsGroupDAO().get(getParameters().getVdsGroup().getId());
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()) || oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null) {
        for (VdsStatic vds : getVdsStaticDAO().getAllForVdsGroup(oldGroup.getId())) {
            VdsSpmIdParameters parameters = new VdsSpmIdParameters(vds.getId(), getVdsGroup().getstorage_pool_id().getValue());
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
            parameters.setStoragePoolId(oldGroup.getstorage_pool_id().getValue());
            if (oldGroup.getstorage_pool_id() != null) {
                VdcReturnValueBase removeVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.RemoveVdsSpmId, parameters);
                if (!removeVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getname(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getname(), managementNetwork)) {
                    getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getId(), net.getId(), NetworkStatus.Operational, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) || (oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null)) {
        VdsActionParameters parameters = new VdsActionParameters();
        for (VDS vds : allForVdsGroup) {
            parameters.setVdsId(vds.getId());
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
        if (oldGroup.getstorage_pool_id() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getstorage_pool_id().getValue());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getname(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getname(), managementNetwork)) {
                    getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getId(), net.getId(), NetworkStatus.Operational, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings("null")
@Override
protected boolean canDoAction() {
    boolean result = super.canDoAction();
    boolean hasVms = false;
    getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VAR__ACTION__UPDATE.toString());
    VDSGroup oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    // check that if name was changed, it was done to the same cluster
    VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
    if (oldGroup != null && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && getVdsStaticDAO().getAllForVdsGroup(getVdsGroup().getId()).size() > 0) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result) {
        SearchParameters p = new SearchParameters(MessageFormat.format(StorageHandlingCommandBase.UpVdssInCluster, oldGroup.getname()), SearchType.VDS);
        p.setMaxCount(Integer.MAX_VALUE);
        @SuppressWarnings("unchecked")
        Iterable<VDS> clusterUpVdss = (Iterable<VDS>) getBackend().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
        for (VDS vds : clusterUpVdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS.toString());
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS.toString());
                result = false;
                break;
            }
        }
    }
    if (result && (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()))) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    if (result) {
        SearchParameters searchParams = new SearchParameters("vms: cluster = " + oldGroup.getname(), SearchType.VM);
        searchParams.setMaxCount(Integer.MAX_VALUE);
        @SuppressWarnings("unchecked")
        List<VM> vmList = (List<VM>) getBackend().runInternalQuery(VdcQueryType.Search, searchParams).getReturnValue();
        if (vmList.size() > 0) {
            hasVms = true;
        }
        int notDownVms = 0;
        int suspendedVms = 0;
        for (VM vm : vmList) {
            // the vm cluster id is the same as the cluster.id
            if (!vm.getvds_group_id().equals(oldGroup.getId())) {
                continue;
            }
            VMStatus vmStatus = vm.getstatus();
            if (vmStatus == VMStatus.Suspended) {
                suspendedVms++;
            }
            if (vmStatus != VMStatus.Down) {
                notDownVms++;
            }
        }
        boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
        if (result && !sameCpuNames) {
            if (suspendedVms > 0) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                result = false;
            } else if (notDownVms > 0) {
                int compareResult = compareCpuLevels(oldGroup);
                if (compareResult < 0) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                    result = false;
                } else if (compareResult > 0) {
                    // Upgrade of CPU in same compability level is allowed if there
                    // are running VMs - but we should warn they
                    // cannot not be hibernated
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                    AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                }
            }
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        if (oldGroup.getstorage_pool_id() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getstatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            SearchParameters searchParams = new SearchParameters("vms: cluster = " + oldGroup.getname(), SearchType.VM);
            searchParams.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmList = (List<VM>) getBackend().runInternalQuery(VdcQueryType.Search, searchParams).getReturnValue();
            boolean notDownVms = false;
            boolean suspendedVms = false;
            for (VM vm : vmList) {
                // the vm cluster id is the same as the cluster.id
                if (!vm.getvds_group_id().equals(oldGroup.getId())) {
                    continue;
                } else {
                    hasVms = true;
                }
                if (vm.getstatus() == VMStatus.Suspended) {
                    suspendedVms = true;
                } else if (vm.getstatus() != VMStatus.Down) {
                    notDownVms = true;
                }
            }
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getstorage_pool_id() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getstorage_pool_id().getValue());
        if (oldGroup.getstorage_pool_id() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getstorage_pool_id().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    boolean isValid = checkIsValid && ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
    if (checkIsValid && !isValid) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
    }
    if (returnValue && checkImagesLocked) {
        List<String> lockedDisksAliases = new ArrayList<String>();
        if (vm.getstatus() == VMStatus.ImageLocked) {
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.toString());
            returnValue = false;
        } else if (diskImageList != null) {
            for (Object object : diskImageList) {
                Disk disk = (Disk) object;
                if (DiskStorageType.IMAGE == disk.getDiskStorageType() && ((DiskImage) disk).getimageStatus() == ImageStatus.LOCKED) {
                    lockedDisksAliases.add(disk.getDiskAlias());
                    returnValue = false;
                }
            }
            if (lockedDisksAliases.size() > 0) {
                ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_IMAGES_ARE_LOCKED.toString());
                messages.add(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(lockedDisksAliases, ", ")));
            }
        }
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && isValid) {
        List<DiskImage> images = getImages(vm, diskImageList);
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#method_after
public static boolean PerformImagesChecks(VM vm, List<String> messages, Guid storagePoolId, Guid storageDomainId, boolean diskSpaceCheck, boolean checkImagesLocked, boolean checkImagesIllegal, boolean checkImagesExist, boolean checkVmInPreview, boolean checkVmIsDown, boolean checkStorageDomain, boolean checkIsValid, Collection diskImageList) {
    boolean returnValue = true;
    boolean isValid = checkIsValid && ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(storagePoolId)).getReturnValue()).booleanValue();
    if (checkIsValid && !isValid) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND.toString());
    }
    if (returnValue && checkImagesLocked) {
        List<String> lockedDisksAliases = new ArrayList<String>();
        if (diskImageList != null) {
            for (Object object : diskImageList) {
                Disk disk = (Disk) object;
                if (DiskStorageType.IMAGE == disk.getDiskStorageType() && ((DiskImage) disk).getimageStatus() == ImageStatus.LOCKED) {
                    lockedDisksAliases.add(disk.getDiskAlias());
                    returnValue = false;
                }
            }
            if (lockedDisksAliases.size() > 0) {
                ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_ARE_LOCKED.toString());
                messages.add(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(lockedDisksAliases, ", ")));
            }
        }
        if (returnValue && vm.getstatus() == VMStatus.ImageLocked) {
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_LOCKED.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkVmIsDown && vm.getstatus() != VMStatus.Down) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString());
    }
    if (returnValue && checkVmInPreview && isVmInPreview(vm.getId())) {
        returnValue = false;
        ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString());
    }
    if (returnValue && isValid) {
        List<DiskImage> images = getImages(vm, diskImageList);
        if (images.size() > 0) {
            returnValue = returnValue && checkDiskImages(messages, storagePoolId, storageDomainId, diskSpaceCheck, checkImagesIllegal, checkImagesExist, checkStorageDomain, vm, images);
        } else if (checkImagesExist) {
            returnValue = false;
            ListUtils.nullSafeAdd(messages, VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS.toString());
        }
    }
    return returnValue;
}
#end_block

#method_before
private void selectedKeyChanged() {
    String key = (String) getSelectedKey().getEntity();
    List<GlusterVolumeOptionInfo> options = (List<GlusterVolumeOptionInfo>) getKeyList().getItems();
    GlusterVolumeOptionInfo selectedOption = null;
    for (GlusterVolumeOptionInfo option : options) {
        if (option.getKey().equals(key.trim())) {
            selectedOption = option;
            break;
        }
    }
    if (selectedOption != null) {
        if (// $NON-NLS-1$
        selectedOption.getDescription().equals("(null)")) {
            getDescription().setEntity(null);
        } else {
            getDescription().setEntity(selectedOption.getDescription());
        }
        if (getIsNew()) {
            if (// $NON-NLS-1$
            selectedOption.getDefaultValue().equals("(null)")) {
                getValue().setEntity(null);
            } else {
                getValue().setEntity(selectedOption.getDefaultValue());
            }
        }
    } else if (getIsNew()) {
        getDescription().setEntity(null);
        getValue().setEntity(null);
    }
}
#method_after
private void selectedKeyChanged() {
    String key = (String) getSelectedKey().getEntity();
    List<GlusterVolumeOptionInfo> options = (List<GlusterVolumeOptionInfo>) getKeyList().getItems();
    GlusterVolumeOptionInfo selectedOption = null;
    for (GlusterVolumeOptionInfo option : options) {
        if (option.getKey().equals(key.trim())) {
            selectedOption = option;
            break;
        }
    }
    if (selectedOption != null) {
        if (selectedOption.getDescription() == null || selectedOption.getDescription().equals(NULL_CONST)) {
            getDescription().setEntity(null);
        } else {
            getDescription().setEntity(selectedOption.getDescription());
        }
        if (getIsNew()) {
            if (selectedOption.getDefaultValue() == null || selectedOption.getDefaultValue().equals(NULL_CONST)) {
                getValue().setEntity(null);
            } else {
                getValue().setEntity(selectedOption.getDefaultValue());
            }
        }
    } else if (getIsNew()) {
        getDescription().setEntity(null);
        getValue().setEntity(null);
    }
}
#end_block

#method_before
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<roles>) source : new ArrayList<roles>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
    mUpdateVmsStatic.AddIgnoredFields(Arrays.asList(new String[] { "images", "interfaces" }));
}
#method_after
public static void Init() {
    mUpdateVmsStatic = new ObjectIdentityChecker(VmHandler.class, Arrays.asList(new String[] { "VM", "VmStatic", "VmDynamic" }), VMStatus.class);
    mUpdateVmsStatic.AddPermittedFields(new String[] { "vm_name", "description", "domain", "os", "osType", "creation_date", "num_of_monitors", "allowConsoleReconnect", "usb_policy", "is_auto_suspend", "auto_startup", "dedicated_vm_for_vds", "default_display_type", "priority", "default_boot_sequence", "initrd_url", "kernel_url", "kernel_params", "migrationSupport", "minAllocatedMem", "quotaId", "quotaName", "quotaEnforcementType", "cpuPinning", "vmPayload", "balloonEnabled", // images list is relational entity - ignore value changes
    "images", // interfaces is relational entity - ignore value changes
    "interfaces" });
    mUpdateVmsStatic.AddFields(Arrays.asList(new Enum<?>[] { VMStatus.Down }), Arrays.asList(new String[] { "vds_group_id", "time_zone", "is_stateless", "nice_level", "mem_size_mb", "num_of_sockets", "cpu_per_socket", "iso_path", "userDefinedProperties", "predefinedProperties", "customProperties" }));
}
#end_block

#method_before
@Override
public String render(Boolean valueToRender) {
    if (valueToRender == null)
        return "";
    if (trueText == null || falseText == null) {
        return valueToRender.toString();
    }
    return valueToRender.booleanValue() ? trueText : falseText;
}
#method_after
@Override
public String render(Boolean valueToRender) {
    if (valueToRender == null) {
        return "";
    }
    if (trueText == null || falseText == null) {
        return valueToRender.toString();
    }
    return valueToRender.booleanValue() ? trueText : falseText;
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    if (!Config.<Boolean>GetValue(ConfigValues.SupportStorageFormat, getVds().getvds_group_compatibility_version().toString())) {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool));
    } else {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool), getParameters().getStoragePoolFormatType().getValue());
    }
    ProceedProxyReturnValue();
    Guid taskId = new Guid(_result.mUuid);
    AsyncTaskStatus taskStatus;
    log.infoFormat("spmStart polling started: taskId = {0}", taskId);
    do {
        // TODO: make configurable
        ThreadUtils.sleep(1000);
        taskStatus = (AsyncTaskStatus) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetTaskStatus, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId)).getReturnValue();
        log.debugFormat("spmStart polling - task status: {0}", taskStatus.getStatus().toString());
    } while (taskStatus.getStatus() != AsyncTaskStatusEnum.finished && taskStatus.getStatus() != AsyncTaskStatusEnum.unknown);
    log.infoFormat("spmStart polling ended: taskId = {0}, result = {1}, status = {2}, message = {3}", taskId, taskStatus.getResult().toString(), taskStatus.getStatus(), taskStatus.getMessage());
    setReturnValue(taskStatus.getTaskEndedSuccessfully() ? SpmStatus.SPM : SpmStatus.Free);
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMClearTask, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId));
    } catch (java.lang.Exception e) {
        log.errorFormat("Could not clear spmStart task (id - {0}), continuing with SPM selection.", taskId);
    }
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    if (!Config.<Boolean>GetValue(ConfigValues.SupportStorageFormat, getVds().getvds_group_compatibility_version().toString())) {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool));
    } else {
        _result = getBroker().spmStart(getParameters().getStoragePoolId().toString(), getParameters().getPrevId(), getParameters().getPrevLVER(), getParameters().getRecoveryMode().getValue(), (new Boolean(getParameters().getSCSIFencing())).toString().toLowerCase(), Config.<Integer>GetValue(ConfigValues.MaxNumberOfHostsInStoragePool), getParameters().getStoragePoolFormatType().getValue());
    }
    ProceedProxyReturnValue();
    Guid taskId = new Guid(_result.mUuid);
    AsyncTaskStatus taskStatus;
    log.infoFormat("spmStart polling started: taskId = {0}", taskId);
    do {
        // TODO: make configurable
        ThreadUtils.sleep(1000);
        taskStatus = (AsyncTaskStatus) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetTaskStatus, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId)).getReturnValue();
        log.debugFormat("spmStart polling - task status: {0}", taskStatus.getStatus().toString());
    } while (taskStatus.getStatus() != AsyncTaskStatusEnum.finished && taskStatus.getStatus() != AsyncTaskStatusEnum.unknown);
    log.infoFormat("spmStart polling ended: taskId = {0} task status = {1}", taskId, taskStatus.getStatus());
    if (!taskStatus.getTaskEndedSuccessfully()) {
        log.errorFormat("Start SPM Task failed - result: {0}, message: {1}", taskStatus.getResult().toString(), taskStatus.getMessage());
    }
    SpmStatusResult spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(getVds().getId(), getParameters().getStoragePoolId())).getReturnValue();
    if (spmStatus != null) {
        log.infoFormat("spmStart polling ended, spm status: {0}", spmStatus.getSpmStatus().toString());
    } else {
        log.errorFormat("spmStart polling ended, failed to get the spm status");
    }
    try {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMClearTask, new HSMTaskGuidBaseVDSCommandParameters(getVds().getId(), taskId));
    } catch (java.lang.Exception e) {
        log.errorFormat("Could not clear spmStart task (id - {0}), continuing with SPM selection.", taskId);
    }
    setReturnValue(spmStatus);
}
#end_block

#method_before
private void initServerUrl() throws NotificationServiceException {
    String serverAddressProp = prop.get(NotificationProperties.ENGINE_ADDRESS);
    String protocol = isHttpsProtocol ? "https" : "http";
    serverUrl = String.format(HEALTH_SERVLET_URL, protocol, StringUtils.isEmpty(serverAddressProp) ? DEFAULT_SERVER_ADDRESS : serverAddressProp);
    try {
        new URL(serverUrl);
    } catch (MalformedURLException e) {
        throw new NotificationServiceException(String.format("Invalid engine server address format: [%s]. " + "Please verify the format of [%s]. Should be ip:port or hostname:port whereas [%s])", serverUrl, NotificationProperties.ENGINE_ADDRESS, serverAddressProp), e);
    }
}
#method_after
private void initServerUrl() throws NotificationServiceException {
    LocalConfig config = LocalConfig.getInstance();
    try {
        if (isHttpsProtocol) {
            serverUrl = config.getExternalHttpsUrl(HEALTH_SERVLET_PATH);
        } else {
            serverUrl = config.getExternalHttpUrl(HEALTH_SERVLET_PATH);
        }
        log.info("Engine health servlet URL is \"" + serverUrl + "\".");
    } catch (MalformedURLException exception) {
        throw new NotificationServiceException("Can't get engine health servlet URL.", exception);
    }
}
#end_block

#method_before
private void monitorEngineServerStatus() {
    boolean isResponsive = false;
    Set<String> errors = new HashSet<String>();
    int retries = serverMonitorRetries;
    while (retries > 0) {
        retries--;
        try {
            isResponsive = checkServerStatus(serverUrl, errors);
            if (!isResponsive) {
                if (retries > 0) {
                    Thread.sleep(serverMonitorTimeout);
                }
            } else {
                // server is up and health servlet returned HTTP_OK
                break;
            }
        } catch (InterruptedException e) {
        // ignore this error
        } catch (Exception e) {
            errors.add(e.getMessage());
        }
    }
    // errors should contain distinct list of errors while trying to obtain server status
    if (errors.size() > 0) {
        log.error("Failed to get server status with:" + errors);
        errors.clear();
    }
    // analyzes server status and report if needed
    reportServerStatus(isResponsive);
}
#method_after
private void monitorEngineServerStatus() {
    boolean isResponsive = false;
    Set<String> errors = new HashSet<String>();
    int retries = serverMonitorRetries;
    while (retries > 0) {
        retries--;
        try {
            isResponsive = checkServerStatus(errors);
            if (!isResponsive) {
                if (retries > 0) {
                    Thread.sleep(serverMonitorTimeout);
                }
            } else {
                // server is up and health servlet returned HTTP_OK
                break;
            }
        } catch (InterruptedException e) {
        // ignore this error
        } catch (Exception e) {
            errors.add(e.getMessage());
        }
    }
    // errors should contain distinct list of errors while trying to obtain server status
    if (errors.size() > 0) {
        log.error("Failed to get server status with:" + errors);
        errors.clear();
    }
    // analyzes server status and report if needed
    reportServerStatus(isResponsive);
}
#end_block

#method_before
private boolean checkServerStatus(String serverUrl, Set<String> errors) {
    boolean isResponsive = true;
    HttpURLConnection engineConn = null;
    URL engine;
    try {
        engine = new URL(serverUrl);
        if (isHttpsProtocol) {
            engineConn = (HttpsURLConnection) engine.openConnection();
            ((HttpsURLConnection) engineConn).setSSLSocketFactory(sslFactory);
            if (sslIgnoreHostVerification) {
                ((HttpsURLConnection) engineConn).setHostnameVerifier(IgnoredHostnameVerifier);
            }
        } else {
            engineConn = (HttpURLConnection) engine.openConnection();
        }
    } catch (IOException e) {
        errors.add(e.getMessage());
        isResponsive = false;
    }
    if (isResponsive) {
        try {
            int responseCode = engineConn.getResponseCode();
            if (responseCode != HttpURLConnection.HTTP_OK) {
                isResponsive = false;
                log.debug(MessageFormat.format("Server is non responsive with response code: {0}", responseCode));
            }
        } catch (Exception e) {
            errors.add(e.getMessage());
            isResponsive = false;
        } finally {
            if (engineConn != null) {
                engineConn.disconnect();
                engineConn = null;
            }
        }
    }
    log.debug("checkServerStatus return: " + isResponsive);
    return isResponsive;
}
#method_after
private boolean checkServerStatus(Set<String> errors) {
    boolean isResponsive = true;
    HttpURLConnection engineConn = null;
    try {
        engineConn = (HttpURLConnection) serverUrl.openConnection();
        if (isHttpsProtocol) {
            ((HttpsURLConnection) engineConn).setSSLSocketFactory(sslFactory);
            if (sslIgnoreHostVerification) {
                ((HttpsURLConnection) engineConn).setHostnameVerifier(IgnoredHostnameVerifier);
            }
        }
    } catch (IOException e) {
        errors.add(e.getMessage());
        isResponsive = false;
    }
    if (isResponsive) {
        try {
            int responseCode = engineConn.getResponseCode();
            if (responseCode != HttpURLConnection.HTTP_OK) {
                isResponsive = false;
                log.debug(MessageFormat.format("Server is non responsive with response code: {0}", responseCode));
            }
        } catch (Exception e) {
            errors.add(e.getMessage());
            isResponsive = false;
        } finally {
            if (engineConn != null) {
                engineConn.disconnect();
                engineConn = null;
            }
        }
    }
    log.debug("checkServerStatus return: " + isResponsive);
    return isResponsive;
}
#end_block

#method_before
@Test
public void testPasswordDomainMap() throws Exception {
    String keyStorePassword = "NoSoup4U";
    String clearTextPassword = keyStorePassword;
    String keyStorePath = ClassLoader.getSystemResource("key.p12").getPath();
    String encryptedPassword = EncryptionUtils.encrypt(clearTextPassword, keyStorePath, keyStorePassword);
    DomainsPasswordMap map = new DomainsPasswordMap("redhat.com:" + encryptedPassword + ",jboss.com:" + encryptedPassword, keyStorePath, keyStorePassword);
    assertEquals(clearTextPassword, map.get("redhat.com"));
    assertEquals(clearTextPassword, map.get("jboss.com"));
}
#method_after
@Test
public void testPasswordDomainMap() throws Exception {
    String keyStorePassword = "NoSoup4U";
    String clearTextPassword = keyStorePassword;
    String keyStorePath = URLDecoder.decode(ClassLoader.getSystemResource("key.p12").getPath(), "UTF-8");
    String alias = "1";
    String encryptedPassword = EncryptionUtils.encrypt(clearTextPassword, keyStorePath, keyStorePassword, alias);
    DomainsPasswordMap map = new DomainsPasswordMap("redhat.com:" + encryptedPassword + ",jboss.com:" + encryptedPassword, keyStorePath, keyStorePassword, alias);
    assertEquals(clearTextPassword, map.get("redhat.com"));
    assertEquals(clearTextPassword, map.get("jboss.com"));
}
#end_block

#method_before
public final static String encrypt(String source, String certificateFile, String passwd) throws Exception {
    String result = "";
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            Certificate cert = store.getCertificate("1");
            result = encrypt(source, cert);
        } catch (Exception e) {
            log.error("Error doing the encryption", e);
            throw e;
        }
    }
    return result;
}
#method_after
public final static String encrypt(String source, String certificateFile, String passwd, String alias) throws Exception {
    String result = "";
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            Certificate cert = store.getCertificate(alias);
            result = encrypt(source, cert);
        } catch (Exception e) {
            log.error("Error doing the encryption", e);
            throw e;
        }
    }
    return result;
}
#end_block

#method_before
private static String decrypt(String source, Key key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
    String result = "";
    byte[] cipherbytes = Encoding.Base64.getBytes(source);
    Cipher rsa = Cipher.getInstance(algo);
    rsa.init(Cipher.DECRYPT_MODE, key);
    byte[] plainbytes = rsa.doFinal(cipherbytes);
    result = Encoding.UTF8.getString(plainbytes);
    return result;
}
#method_after
public static String decrypt(String source, String keyFile, String passwd, String alias) throws Exception {
    String result = source;
    try {
        if (!StringHelper.isNullOrEmpty(source.trim())) {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            Key key = store.getKey(alias, passwd.toCharArray());
            result = decrypt(source, key);
        }
    } catch (Exception e) {
        log.error("Failed to decrypt " + e.getMessage());
        log.debug("Failed to decrypt", e);
        throw e;
    }
    return result;
}
#end_block

#method_before
public static final String Decrypt(String source, String keyFile, String passwd, RefObject<String> error) {
    error.argvalue = "";
    String result = source;
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            Key key = store.getKey("1", passwd.toCharArray());
            result = Decrypt(source, key, error);
        } catch (Exception e) {
            log.error("Error doing the decryption", e);
            error.argvalue = e.getMessage();
        }
    }
    return result;
}
#method_after
public static final String Decrypt(String source, String keyFile, String passwd, RefObject<String> error) {
    error.argvalue = "";
    String result = source;
    if (!StringHelper.isNullOrEmpty(source.trim())) {
        try {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            // Get the first one.
            String alias = "None";
            Enumeration<String> aliases = store.aliases();
            while (aliases.hasMoreElements()) {
                alias = aliases.nextElement();
                break;
            }
            Key key = store.getKey(alias, passwd.toCharArray());
            result = Decrypt(source, key, error);
        } catch (Exception e) {
            log.error("Error doing the decryption", e);
            error.argvalue = e.getMessage();
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vds_group_id", vds.getstatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    VDSGroup targetCluster = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getClusterId());
    if (targetCluster == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (getVdsGroup().getstorage_pool_id() != null && isNumberOfVdsInStoragePoolExceed(getVdsGroup().getstorage_pool_id().getValue())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAXIMUM_NUMBER_OF_HOSTS_IN_DATA_CENTER);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDAO().getForVdsGroup(targetCluster.getId());
    if (targetStoragePool != null && targetStoragePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vds_group_id", vds.getstatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.getstorage_pool_type() == StorageType.LOCALFS) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServer(getTargetCluster())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup sourceCluster = getVdsGroup();
    final Guid targetClusterId = getParameters().getClusterId();
    if (sourceCluster.getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDAO().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // handle spm
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (sourceCluster.getstorage_pool_id() != null) {
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (targetStoragePool != null) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    if (targetStoragePool != null) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setvds_group_id(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            return;
        }
    }
    // handle spm
    getParameters().setCompensationEnabled(true);
    getParameters().setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    if (getSourceCluster().getstorage_pool_id() != null) {
        VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!removeVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
            return;
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VDS : AuditLogType.USER_FAILED_UPDATE_VDS;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VDS : errorType;
}
#end_block

#method_before
public static void Init() {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            for (storage_pool sp : DbFacade.getInstance().getStoragePoolDAO().getAll()) {
                if (!_irsProxyData.containsKey(sp.getId())) {
                    _irsProxyData.put(sp.getId(), new IrsProxyData(sp.getId()));
                }
            }
            return null;
        }
    });
}
#method_after
public static void Init() {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            for (storage_pool sp : DbFacade.getInstance().getStoragePoolDao().getAll()) {
                if (!_irsProxyData.containsKey(sp.getId())) {
                    _irsProxyData.put(sp.getId(), new IrsProxyData(sp.getId()));
                }
            }
            return null;
        }
    });
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
                        if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
                            ProceedStoragePoolStats();
                        }
                        return null;
                    }
                });
            }
        }
    } catch (java.lang.Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                        if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
                            ProceedStoragePoolStats();
                        }
                        return null;
                    }
                });
            }
        }
    } catch (java.lang.Exception ex) {
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void ProceedStoragePoolStats() {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    if (mCurrentVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(mCurrentVdsId, _storagePoolId));
    }
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
    if (storagePool != null) {
        if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
            // update pool status to problematic until fence will happen
            if (storagePool.getstatus() != StoragePoolStatus.Problematic && storagePool.getstatus() != StoragePoolStatus.NotOperational) {
                if (result != null && result.getVdsError() != null) {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
                } else {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
                }
            }
            // then cause failover with attempts
            if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
                java.util.HashMap<Guid, AsyncTaskStatus> tasksList = (java.util.HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(mCurrentVdsId)).getReturnValue();
                boolean allTasksFinished = true;
                if (tasksList != null) {
                    for (AsyncTaskStatus taskStatus : tasksList.values()) {
                        if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                            allTasksFinished = false;
                            break;
                        }
                    }
                }
                if ((tasksList == null) || allTasksFinished) {
                    setmIrsProxy(null);
                    setmCurrentIrsHost(null);
                } else {
                    if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                        _errorAttempts++;
                        log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getname(), _errorAttempts);
                    } else {
                        setmIrsProxy(null);
                        setmCurrentIrsHost(null);
                        _errorAttempts = 0;
                    }
                }
            }
        } else if (result != null && result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
            // if recovered from network exception set back to up
            DbFacade.getInstance().getStoragePoolDAO().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
            storagePool.setstatus(StoragePoolStatus.Up);
            ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        }
        GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
        tempVar.setIgnoreFailoverLimit(true);
        VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
        if (storagePoolInfoResult.getSucceeded()) {
            KeyValuePairCompat<storage_pool, java.util.List<storage_domains>> data = (KeyValuePairCompat<storage_pool, java.util.List<storage_domains>>) storagePoolInfoResult.getReturnValue();
            int masterVersion = data.getKey().getmaster_domain_version();
            java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
            for (storage_domains domainData : data.getValue()) {
                domainsInVds.add(domainData.getId());
                ProceedStorageDomain(domainData, masterVersion, storagePool);
            }
            List<storage_domains> domainsInDb = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(_storagePoolId);
            for (final storage_domains domainInDb : domainsInDb) {
                if (domainInDb.getstorage_domain_type() != StorageDomainType.Master && domainInDb.getstatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                    // domain not attached to pool anymore
                    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            DbFacade.getInstance().getStoragePoolIsoMapDAO().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
                            return null;
                        }
                    });
                }
            }
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void ProceedStoragePoolStats() {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    if (mCurrentVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(mCurrentVdsId, _storagePoolId));
    }
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null) {
        if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
            // update pool status to problematic until fence will happen
            if (storagePool.getstatus() != StoragePoolStatus.Problematic && storagePool.getstatus() != StoragePoolStatus.NotOperational) {
                if (result != null && result.getVdsError() != null) {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
                } else {
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
                }
            }
            // then cause failover with attempts
            if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
                java.util.HashMap<Guid, AsyncTaskStatus> tasksList = (java.util.HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(mCurrentVdsId)).getReturnValue();
                boolean allTasksFinished = true;
                if (tasksList != null) {
                    for (AsyncTaskStatus taskStatus : tasksList.values()) {
                        if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                            allTasksFinished = false;
                            break;
                        }
                    }
                }
                if ((tasksList == null) || allTasksFinished) {
                    setmIrsProxy(null);
                    setmCurrentIrsHost(null);
                } else {
                    if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                        _errorAttempts++;
                        log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getname(), _errorAttempts);
                    } else {
                        setmIrsProxy(null);
                        setmCurrentIrsHost(null);
                        _errorAttempts = 0;
                    }
                }
            }
        } else if (result != null && result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getstatus() == StoragePoolStatus.Problematic || storagePool.getstatus() == StoragePoolStatus.Contend)) {
            // if recovered from network exception set back to up
            DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
            storagePool.setstatus(StoragePoolStatus.Up);
            ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        }
        GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
        tempVar.setIgnoreFailoverLimit(true);
        VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
        if (storagePoolInfoResult.getSucceeded()) {
            KeyValuePairCompat<storage_pool, java.util.List<storage_domains>> data = (KeyValuePairCompat<storage_pool, java.util.List<storage_domains>>) storagePoolInfoResult.getReturnValue();
            int masterVersion = data.getKey().getmaster_domain_version();
            java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
            for (storage_domains domainData : data.getValue()) {
                domainsInVds.add(domainData.getId());
                ProceedStorageDomain(domainData, masterVersion, storagePool);
            }
            List<storage_domains> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
            for (final storage_domains domainInDb : domainsInDb) {
                if (domainInDb.getstorage_domain_type() != StorageDomainType.Master && domainInDb.getstatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                    // domain not attached to pool anymore
                    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
                            return null;
                        }
                    });
                }
            }
        }
    }
}
#end_block

#method_before
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(data.getId(), _storagePoolId);
    storage_domain_static domainFromDb = null;
    storage_pool_iso_map domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDAO().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.Maintenance || data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDAO().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && (data.getstatus() == StorageDomainStatus.InActive || data.getstatus() == StorageDomainStatus.Maintenance) && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDAO().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDAO().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || data.getstatus() == StorageDomainStatus.Active) {
            DbFacade.getInstance().getStorageDomainDynamicDAO().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    storage_domain_static domainFromDb = null;
    storage_pool_iso_map domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && data.getstatus() == StorageDomainStatus.InActive && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                KeyValuePairCompat<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                setmIrsProxy(new IrsServerWrapper(returnValue.getKey(), returnValue.getValue()));
                Class[] inputTypes = new Class[] { storage_pool.class, boolean.class };
                Object[] inputParams = new Object[] { storagePool, _isSpmStartCalled };
                // TODO use thread pool
                SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "StorageEventOnTimer", inputTypes, inputParams, 0, TimeUnit.MILLISECONDS);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                KeyValuePairCompat<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                setmIrsProxy(new IrsServerWrapper(returnValue.getKey(), returnValue.getValue()));
                Class[] inputTypes = new Class[] { storage_pool.class, boolean.class };
                Object[] inputParams = new Object[] { storagePool, _isSpmStartCalled };
                // TODO use thread pool
                SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "StorageEventOnTimer", inputTypes, inputParams, 0, TimeUnit.MILLISECONDS);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private List<VDS> GetNonOperationalVdssInPool() {
    List<VDS> allVds = DbFacade.getInstance().getVdsDAO().getAll();
    List<VDS> nonOperationalvdsInPool = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (VDSStatus.NonOperational == vds.getstatus() && _storagePoolId.equals(vds.getstorage_pool_id())) {
            nonOperationalvdsInPool.add(vds);
        }
    }
    return nonOperationalvdsInPool;
}
#method_after
private List<VDS> GetNonOperationalVdssInPool() {
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAll();
    List<VDS> nonOperationalvdsInPool = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (VDSStatus.NonOperational == vds.getstatus() && _storagePoolId.equals(vds.getstorage_pool_id())) {
            nonOperationalvdsInPool.add(vds);
        }
    }
    return nonOperationalvdsInPool;
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!curVdsId.equals(Guid.Empty) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDAO().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        mCurrentVdsId = selectedVds.getId();
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDAO().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!curVdsId.equals(Guid.Empty) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        mCurrentVdsId = selectedVds.getId();
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private List<VDS> GetPrioritizedVdsInPool() {
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = DbFacade.getInstance().getVdsDAO().getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (!mTriedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            vdsRelevantForSpmSelection.add(vds);
        }
    }
    return vdsRelevantForSpmSelection;
}
#method_after
private List<VDS> GetPrioritizedVdsInPool() {
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    // Gets a list of the hosts in the storagePool, that are "UP", ordered
    // by vds_spm_priority (not including -1) and secondly ordered by RANDOM(), to
    // deal with the case that there are several hosts with the same priority.
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getListForSpmSelection(_storagePoolId);
    List<VDS> vdsRelevantForSpmSelection = new ArrayList<VDS>();
    for (VDS vds : allVds) {
        if (!mTriedVdssList.contains(vds.getId()) && !vds.getId().equals(curVdsId)) {
            vdsRelevantForSpmSelection.add(vds);
        }
    }
    return vdsRelevantForSpmSelection;
}
#end_block

#method_before
private String HandleSelectedVdsForSPM(storage_pool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        MovePoolToProblematicInDB(storagePool, true);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.Problematic) {
            storagePool.setstatus(prevStatus);
        } else {
            storagePool.setstatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        returnValue = selectedVds.argvalue.gethost_name();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.AddCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#method_after
private String HandleSelectedVdsForSPM(storage_pool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        MovePoolToProblematicInDB(storagePool, true);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.Problematic) {
            storagePool.setstatus(prevStatus);
        } else {
            storagePool.setstatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        returnValue = selectedVds.argvalue.gethost_name();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.AddCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#end_block

#method_before
private void WaitForVdsIfIsInitializing(Guid curVdsId) {
    if (curVdsId != Guid.Empty && DbFacade.getInstance().getVdsDAO().get(curVdsId).getstatus() == VDSStatus.Initializing) {
        // 5 Sec
        final int DELAY = 5;
        int total = 0;
        Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
        String vdsName = DbFacade.getInstance().getVdsDAO().get(curVdsId).getvds_name();
        while (total <= maxSecToWait && DbFacade.getInstance().getVdsDAO().get(curVdsId).getstatus() == VDSStatus.Initializing) {
            try {
                Thread.sleep(DELAY * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
                // exit the while block
                break;
            }
            total += DELAY;
            log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
        }
    }
}
#method_after
private void WaitForVdsIfIsInitializing(Guid curVdsId) {
    if (curVdsId != Guid.Empty && DbFacade.getInstance().getVdsDao().get(curVdsId).getstatus() == VDSStatus.Initializing) {
        // 5 Sec
        final int DELAY = 5;
        int total = 0;
        Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
        String vdsName = DbFacade.getInstance().getVdsDao().get(curVdsId).getvds_name();
        while (total <= maxSecToWait && DbFacade.getInstance().getVdsDao().get(curVdsId).getstatus() == VDSStatus.Initializing) {
            try {
                Thread.sleep(DELAY * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
                // exit the while block
                break;
            }
            total += DELAY;
            log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
        }
    }
}
#end_block

#method_before
private static void MovePoolToProblematicInDB(storage_pool storagePool, boolean resetSpmInDB) {
    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
    if (resetSpmInDB) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
    }
}
#method_after
private static void MovePoolToProblematicInDB(storage_pool storagePool, boolean resetSpmInDB) {
    ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
    if (resetSpmInDB) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
    }
}
#end_block

#method_before
private SpmStatusResult HandleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final storage_pool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getvds_spm_id() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getvds_spm_id() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getvds_name(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = GetNonOperationalVdssInPool();
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getvds_spm_id() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDAO().get(curVdsId);
                    if (currentVds != null && currentVds.getstatus() == VDSStatus.Up && currentVds.getvds_spm_id() != null && currentVds.getvds_spm_id().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getstatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getvds_name());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getname(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (java.lang.Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDAO().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDAO().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getvds_name());
                    if (vdsToFenceObject.getstatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setstatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getvds_name(), storagePool.getname(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            storage_pool pool = DbFacade.getInstance().getStoragePoolDAO().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDAO().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult HandleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final storage_pool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getvds_spm_id() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getvds_spm_id() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getvds_name(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = GetNonOperationalVdssInPool();
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getvds_spm_id() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getstatus() == VDSStatus.Up && currentVds.getvds_spm_id() != null && currentVds.getvds_spm_id().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getstatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getvds_name());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getname(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (java.lang.Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getvds_name());
                    if (vdsToFenceObject.getstatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setstatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getvds_name(), storagePool.getname(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
public void ResetIrs() {
    setmCurrentIrsHost(null);
    setmIrsProxy(null);
    mCurrentVdsId = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
    if (storagePool != null) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDAO().update(storagePool);
    }
}
#method_after
public void ResetIrs() {
    setmCurrentIrsHost(null);
    setmIrsProxy(null);
    mCurrentVdsId = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null) {
        storagePool.setspm_vds_id(null);
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
    }
}
#end_block

#method_before
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final java.util.ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = (Set<Guid>) TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Set<Guid>>() {

        @Override
        public Set<Guid> runInTransaction() {
            Set<Guid> domainsInProblems = null;
            storage_pool storagePool = DbFacade.getInstance().getStoragePoolDAO().get(_storagePoolId);
            if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
                try {
                    // build a list of all domains in pool
                    // which are in status Active or Unknown
                    Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDAO().getAllIds(_storagePoolId, StorageDomainStatus.Active));
                    domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDAO().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
                    // build a list of all the domains in
                    // pool (domainsInPool) that are not
                    // visible by the host.
                    List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
                    Set<Guid> dataDomainIds = new HashSet<Guid>();
                    for (VDSDomainsData tempData : data) {
                        dataDomainIds.add(tempData.getDomainId());
                    }
                    for (Guid tempDomainId : domainsInPool) {
                        if (!dataDomainIds.contains(tempDomainId)) {
                            domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                        }
                    }
                    // build a list of domains that the host
                    // reports as in problem (code!=0) or (code==0
                    // && lastChecl >
                    // ConfigValues.MaxStorageVdsTimeoutCheckSec)
                    // and are contained in the Active or
                    // Unknown domains in pool
                    List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
                    for (VDSDomainsData tempData : data) {
                        if (domainsInPool.contains(tempData.getDomainId())) {
                            if (tempData.getCode() != 0) {
                                domainsSeenByVdsInProblem.add(tempData.getDomainId());
                            } else if (tempData.getLastCheck() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsTimeoutCheckSec)) {
                                domainsSeenByVdsInProblem.add(tempData.getDomainId());
                            } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                                AuditLogableBase logable = new AuditLogableBase();
                                logable.setVdsId(vdsId);
                                logable.setStorageDomainId(tempData.getDomainId());
                                logable.AddCustomValue("Delay", Double.toString(tempData.getDelay()));
                                AuditLogDirector.log(logable, AuditLogType.VDS_DOMAIN_DELAY_INTERVAL);
                            }
                        }
                    }
                    // build a list of all potential domains
                    // in problem
                    domainsInProblems = new HashSet<Guid>();
                    domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
                    domainsInProblems.addAll(domainsSeenByVdsInProblem);
                } catch (RuntimeException ex) {
                    log.error("error in UpdateVdsDomainsData", ex);
                }
            }
            return domainsInProblems;
        }
    });
    if (domainsInProblems != null) {
        synchronized (_lockObject) {
            // domains status
            if (duringReconstructMaster.get()) {
                log.debug("The pool is during reconstruct master, skipping handling problematic domains " + _storagePoolId);
                return;
            }
            updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
        }
    }
}
#method_after
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    storage_pool_iso_map map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    if (domainsInProblems != null) {
        synchronized (_lockObject) {
            // domains status
            if (duringReconstructMaster.get()) {
                log.debug("The pool is during reconstruct master, skipping handling problematic domains " + _storagePoolId);
                return;
            }
            updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
        }
    }
}
#end_block

#method_before
private void ProcessDomainRecovery(final Guid domainId) {
    TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            // build a list of all the hosts in status UP in
            // Pool.
            List<Guid> vdssInPool = new ArrayList<Guid>();
            List<VDS> allVds = DbFacade.getInstance().getVdsDAO().getAll();
            for (VDS tempVDS : allVds) {
                if (tempVDS.getstatus() == VDSStatus.Up && tempVDS.getstorage_pool_id().equals(_storagePoolId)) {
                    vdssInPool.add(tempVDS.getId());
                }
            }
            // build a list of all the hosts that did not report
            // on this domain as in problem.
            // Mark the above list as hosts we suspect are in
            // problem.
            java.util.Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
            List<Guid> vdssInProblem = new ArrayList<Guid>();
            for (Guid tempVDSId : vdssInPool) {
                if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
                    vdssInProblem.add(tempVDSId);
                }
            }
            // If not All the hosts in status UP reported on
            // this domain as in problem. We assume the problem
            // is with the hosts
            // that did report on a problem with this domain.
            // (and not a problem with the domain itself).
            storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDAO().get(domainId);
            String domainIdTuple = getDomainIdTuple(domainId);
            if (vdssInProblem.size() > 0) {
                if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
                    // operational.
                    for (Guid vdsId : _domainsInProblem.get(domainId)) {
                        VDS vds = DbFacade.getInstance().getVdsDAO().get(vdsId);
                        if (vds == null) {
                            log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                        } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                            log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                            clearVdsFromCache(vdsId, vds.getvds_name());
                        } else {
                            log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {2}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                        }
                    }
                } else {
                    log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
                }
            } else {
                // Domain.
                if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
                    log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. Moving the Domain to NonOperational.", domainIdTuple);
                    ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
                } else if (duringReconstructMaster.compareAndSet(false, true)) {
                    try {
                        ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
                    } finally {
                        duringReconstructMaster.set(false);
                    }
                } else {
                    log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. But not moving the Domain to NonOperational. Because of is reconstract now", domainIdTuple);
                    return null;
                }
            }
            // clear from cache of _vdssInProblem and
            // _domainsInProblem
            clearDomainFromCache(domainId);
            ClearTimer(domainId);
            return null;
        }
    });
}
#method_after
private void ProcessDomainRecovery(final Guid domainId) {
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getstatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    clearVdsFromCache(vdsId, vds.getvds_name());
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
        }
    } else {
        // Domain.
        if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
            log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. Moving the Domain to NonOperational.", domainIdTuple);
            ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else if (duringReconstructMaster.compareAndSet(false, true)) {
            try {
                ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId);
            } finally {
                duringReconstructMaster.set(false);
            }
        } else {
            log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. But not moving the Domain to NonOperational. Because of is reconstract now", domainIdTuple);
            return;
        }
    }
    // clear from cache of _vdssInProblem and
    // _domainsInProblem
    clearDomainFromCache(domainId);
    ClearTimer(domainId);
}
#end_block

#method_before
private String getDomainIdTuple(Guid domainId) {
    storage_domain_static storage_domain = DbFacade.getInstance().getStorageDomainStaticDAO().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#method_after
private static String getDomainIdTuple(Guid domainId) {
    storage_domain_static storage_domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#end_block

#method_before
private void startReconstruct() {
    storage_domain_static masterDomain = null;
    List<storage_domain_static> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDAO().getAllForStoragePool(getParameters().getStoragePoolId());
    for (storage_domain_static storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        if (getCurrentIrsProxyData().duringReconstructMaster.compareAndSet(false, true)) {
            try {
                ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomain.getId(), getParameters().getStoragePoolId());
            } finally {
                getCurrentIrsProxyData().duringReconstructMaster.set(false);
            }
        } else {
            log.debug("The pool is during reconstruct master, skipping handling problematic domains " + getParameters().getStoragePoolId());
        }
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    storage_domain_static masterDomain = null;
    List<storage_domain_static> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (storage_domain_static storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        if (getCurrentIrsProxyData().duringReconstructMaster.compareAndSet(false, true)) {
            try {
                ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomain.getId(), getParameters().getStoragePoolId());
            } finally {
                getCurrentIrsProxyData().duringReconstructMaster.set(false);
            }
        } else {
            log.debug("The pool is during reconstruct master, skipping handling problematic domains " + getParameters().getStoragePoolId());
        }
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
private static void SetVmTemplateStatus(Guid vmTemplateGuid, VmTemplateStatus status, CompensationContext compensationContext) {
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDAO().get(vmTemplateGuid);
    if (vmTemplate != null) {
        if (compensationContext != null) {
            compensationContext.snapshotEntityStatus(vmTemplate, vmTemplate.getstatus());
        }
        vmTemplate.setstatus(status);
        DbFacade.getInstance().getVmTemplateDAO().update(vmTemplate);
    } else {
        log.warnFormat("VmTemplateHandler::SetVmTemplateStatus: vmTemplate is null, not setting status '{0}' to vmTemplate", status);
    }
}
#method_after
private static void SetVmTemplateStatus(Guid vmTemplateGuid, VmTemplateStatus status, CompensationContext compensationContext) {
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDao().get(vmTemplateGuid);
    if (vmTemplate != null) {
        if (compensationContext != null) {
            compensationContext.snapshotEntityStatus(vmTemplate, vmTemplate.getstatus());
        }
        vmTemplate.setstatus(status);
        DbFacade.getInstance().getVmTemplateDao().update(vmTemplate);
    } else {
        log.warnFormat("VmTemplateHandler::SetVmTemplateStatus: vmTemplate is null, not setting status '{0}' to vmTemplate", status);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getstorage_pool_id());
            retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(getTemplateDisks()) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getstorage_pool_id().getValue())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getstorage_pool_id());
            retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(getTemplateDisks()) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getstorage_pool_id().getValue())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!getTemplateDisks().isEmpty()) {
        MoveOrCopyAllImageGroups();
    } else {
        endVmTemplateRelatedOps();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    freeLock();
    if (!getTemplateDisks().isEmpty()) {
        moveOrCopyAllImageGroups();
    } else {
        endVmTemplateRelatedOps();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
        UpdateTemplateInSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#method_after
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
        updateTemplateInSpm();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() != null) {
        setDescription(getVmTemplateName());
    }
    if (!VmTemplateHandler.verifyVmTemplateStatusForUse(getVmTemplateId(), false)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean retVal = storageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (retVal) {
        // export must be to export domain
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    retVal = retVal && super.canDoAction();
    // check if template (with no override option)
    if (retVal && !getParameters().getForceOverride()) {
        retVal = !ExportVmCommand.CheckTemplateInStorageDomain(getVmTemplate().getstorage_pool_id().getValue(), getParameters().getStorageDomainId(), getVmTemplateId());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NAME_ALREADY_EXISTS);
        }
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() != null) {
        setDescription(getVmTemplateName());
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean retVal = storageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    if (retVal) {
        // export must be to export domain
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    retVal = retVal && super.canDoAction();
    // check if template (with no override option)
    if (retVal && !getParameters().getForceOverride()) {
        retVal = !ExportVmCommand.CheckTemplateInStorageDomain(getVmTemplate().getstorage_pool_id().getValue(), getParameters().getStorageDomainId(), getVmTemplateId());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NAME_ALREADY_EXISTS);
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    Map<String, String> locks = new HashMap<String, String>();
    locks.putAll(super.getExclusiveLocks());
    locks.put(getVmTemplateId().toString(), LockingGroup.TEMPLATE.name());
    return locks;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    Map<String, String> locks = new HashMap<String, String>();
    Map<String, String> parentLocks = super.getExclusiveLocks();
    if (parentLocks != null) {
        locks.putAll(parentLocks);
    }
    locks.put(getVmTemplateId().toString(), LockingGroup.TEMPLATE.name());
    return locks;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // add command specific can do action variables
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    // check template exists
    if (template == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BlankVmTemplateId.equals(vmTemplateId)) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
        return false;
    }
    if (!VmTemplateHandler.verifyVmTemplateStatusForUse(getVmTemplateId(), false)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
    }
    // check storage pool valid
    if (template.getstorage_pool_id() != null && !Guid.Empty.equals(template.getstorage_pool_id()) && !((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(template.getstorage_pool_id().getValue())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        return false;
    }
    imageTemplates = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()), false, false);
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDoaminsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                storage_domain_static domain = DbFacade.getInstance().getStorageDomainStaticDAO().get(domainId);
                if (domain == null) {
                    problematicDomains.add(domainId.toString());
                } else {
                    problematicDomains.add(domain.getstorage_name());
                }
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getvm_name());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()), false, false);
            Set<Guid> domainsIds = getStorageDoaminsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getvm_name());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (template == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BlankVmTemplateId.equals(vmTemplateId)) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
        return false;
    }
    // check storage pool valid
    if (template.getstorage_pool_id() != null && !Guid.Empty.equals(template.getstorage_pool_id()) && !((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsValid, new IrsBaseVDSCommandParameters(template.getstorage_pool_id().getValue())).getReturnValue()).booleanValue()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
        return false;
    }
    imageTemplates = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()), false, false);
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDoaminsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                storage_domain_static domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
                if (domain == null) {
                    problematicDomains.add(domainId.toString());
                } else {
                    problematicDomains.add(domain.getstorage_name());
                }
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getvm_name());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()), false, false);
            Set<Guid> domainsIds = getStorageDoaminsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getvm_name());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId())) {
        if (hasImages) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    if (RemoveVmTemplateImages()) {
                        setSucceeded(true);
                    }
                    return null;
                }
            });
        } else {
            HandleEndAction();
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    freeLock();
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId())) {
        if (hasImages) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    if (RemoveVmTemplateImages()) {
                        setSucceeded(true);
                    }
                    return null;
                }
            });
        } else {
            HandleEndAction();
        }
    }
}
#end_block

#method_before
private void RemoveTemplateFromDb() {
    RemoveNetwork();
    DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplate().getId());
}
#method_after
private void RemoveTemplateFromDb() {
    RemoveNetwork();
    DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplate().getId());
}
#end_block

#method_before
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#method_after
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterPolicyModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.PostOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setstorage_pool_id(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue("")) {
                onGlusterHostsDown(clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        OnSaveHosts();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<roles>) source : new ArrayList<roles>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public static void GetRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.RunQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, new GlusterServersQueryParameters(hostAddress, rootPassword), aQuery);
}
#method_after
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, parameters, aQuery);
}
#end_block

#method_before
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<ClusterListModel, ClusterPolicyModel> getClusterPolicyProvider(ClientGinjector ginjector, final Provider<ClusterPolicyPopupPresenterWidget> popupProvider) {
    return new DetailTabModelProvider<ClusterListModel, ClusterPolicyModel>(ginjector, ClusterListModel.class, ClusterPolicyModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterPolicyModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<ClusterListModel, ClusterGeneralModel> getClusterPolicyProvider(ClientGinjector ginjector, final Provider<ClusterPolicyPopupPresenterWidget> popupProvider) {
    return new DetailTabModelProvider<ClusterListModel, ClusterGeneralModel>(ginjector, ClusterListModel.class, ClusterGeneralModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterGeneralModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getEditPolicyCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void executeCommand() {
    super.executeCommand();
    Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.NewGuid();
    setDestinationImageId(Guid.NewGuid());
    getDiskImage().getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(getDiskImage().getImageId(), getDiskImage().getit_guid()));
    setDiskImage(getDiskImage().getSnapshots().get(getDiskImage().getSnapshots().size() - 1));
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getdescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, newImage.getvolume_format(), newImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
    getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setvm_snapshot_id(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setParentId(ImagesHandler.BlankImageTemplateId);
    newImage.setit_guid(ImagesHandler.BlankImageTemplateId);
    newImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setactive(true);
    saveImage(newImage);
    newImage.setDiskAlias(getDiskImage().getDiskAlias());
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getactual_size());
    DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    super.executeCommand();
    Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.NewGuid();
    setDestinationImageId(Guid.NewGuid());
    getDiskImage().getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(getDiskImage().getImageId(), getDiskImage().getit_guid()));
    setDiskImage(getDiskImage().getSnapshots().get(getDiskImage().getSnapshots().size() - 1));
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getdescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, newImage.getvolume_format(), newImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
    getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setvm_snapshot_id(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setParentId(ImagesHandler.BlankImageTemplateId);
    newImage.setit_guid(ImagesHandler.BlankImageTemplateId);
    newImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setactive(true);
    saveImage(newImage);
    newImage.setDiskAlias(getDiskImage().getDiskAlias());
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getactual_size());
    DbFacade.getInstance().getDiskImageDynamicDAO().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB(false);
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        VDSReturnValue vdsReturnValue = performImageVdsmOperation();
        getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveDisk) {
            removeImageFromDB(false);
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void storageDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    Backend.getInstance().runInternalAction(VdcActionType.HandleFailedStorageDomain, new StorageDomainPoolParametersBase(storageDomainId, storagePoolId), ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void storageDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    StorageDomainPoolParametersBase parameters = new StorageDomainPoolParametersBase(storageDomainId, storagePoolId);
    parameters.setIsInternal(true);
    parameters.setInactive(true);
    Backend.getInstance().runInternalAction(VdcActionType.DeactivateStorageDomain, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
public void masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, false);
    parameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
    Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void masterDomainNotOperational(Guid storageDomainId, Guid storagePoolId) {
    VdcActionParametersBase parameters = new ReconstructMasterParameters(storagePoolId, storageDomainId, true);
    Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getvm_name())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getvm_name(), vmFromParams.getvm_name())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getvm_name())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.getauto_startup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getos(), vmFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getvds_group_id().equals(vmFromParams.getvds_group_id())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getdefault_display_type(), vmFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getnum_of_monitors() < vmFromParams.getnum_of_monitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        if (!checkPciAndIDeLimit(vmFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getnum_of_sockets(), vmFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getiso_path())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getusb_policy(), vmFromParams.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!isPinningAndMigrationValid(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getvm_name())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getvm_name(), vmFromParams.getvm_name())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getvm_name())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.getauto_startup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getos(), vmFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getvds_group_id().equals(vmFromParams.getvds_group_id())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getdefault_display_type(), vmFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getnum_of_monitors() < vmFromParams.getnum_of_monitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getnum_of_sockets(), vmFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getiso_path())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getusb_policy(), vmFromParams.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!isPinningAndMigrationValid(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setimage_group_id(Guid.NewGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getDiskImage().getstorage_ids().get(0), getVmTemplateId(), getDiskImage().getimage_group_id().getValue(), getImage().getImageId(), mNewCreatedDiskImage.getimage_group_id(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getvolume_format(), mNewCreatedDiskImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
    } catch (Exception e) {
        log.errorFormat("CreateCloneOfTemplateCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setimage_group_id(Guid.NewGuid());
    Guid storagePoolID = mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(storagePoolID, getDiskImage().getstorage_ids().get(0), getVmTemplateId(), getDiskImage().getimage_group_id().getValue(), getImage().getImageId(), mNewCreatedDiskImage.getimage_group_id(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, mNewCreatedDiskImage.getvolume_format(), mNewCreatedDiskImage.getvolume_type(), getDiskImage().isWipeAfterDelete(), false, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
    } catch (Exception e) {
        log.errorFormat("CreateCloneOfTemplateCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#end_block

#method_before
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDAO().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = CreateTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                UpdateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = CreateTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            UpdateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDAO().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIDeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    });
    if (interfaceNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    } else if (!interfaceNetwork.isVmNetwork()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
        addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
        return false;
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getstorage_ids() != null && !getDiskImage().getstorage_ids().isEmpty() ? getDiskImage().getstorage_ids().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getimage_group_id() != null ? getDiskImage().getimage_group_id().getValue() : Guid.Empty;
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(CreateTask(vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (VdcBLLException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new VdcFault(e, e.getVdsError().getCode()));
        log.info(String.format("%1$s Image not exist in Irs", getDiskImage().getImageId()));
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getstorage_pool_id() != null ? getDiskImage().getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getstorage_ids() != null && !getDiskImage().getstorage_ids().isEmpty() ? getDiskImage().getstorage_ids().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getimage_group_id() != null ? getDiskImage().getimage_group_id().getValue() : Guid.Empty;
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true, getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalTaskIdList().add(createTask(vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (VdcBLLException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new VdcFault(e, e.getVdsError().getCode()));
        log.info(String.format("%1$s Image not exist in Irs", getDiskImage().getImageId()));
    }
    return vdsReturnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = CanDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getvm_name();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    if (returnValue && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // check that we have no more then 8 interfaces (kvm limitation in version 2.x)
        if (!validateNumberOfNics(getVmInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            returnValue = false;
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue && !isCpuPinningValid(getParameters().getVm().getCpuPinning())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                addVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (addVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map domain : domains) {
        if (domain.getstatus() == null || domain.getstatus() == StorageDomainStatus.Unknown) {
            domain.setstatus(StorageDomainStatus.Active);
        } else if (domain.getstatus() == StorageDomainStatus.Maintenance) {
            domain.setstatus(StorageDomainStatus.InActive);
        } else if (domain.getstatus() == StorageDomainStatus.Locked) {
            throw new VdcBLLException(VdcBllErrors.CANT_RECONSTRUCT_WHEN_A_DOMAIN_IN_POOL_IS_LOCKED, "Cannot reconstruct master domain when a domain in the " + "pool is locked.");
        }
    }
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                SetStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    try {
        for (VDS vds : getAllRunningVdssInPool()) {
            try {
                if (!_isLastMaster && commandSucceeded) {
                    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                    if (returnValue.getSucceeded()) {
                        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                    } else {
                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                    }
                }
                // only if we deactivate the storage domain we want to disconnect from it.
                if (getParameters().isInactive()) {
                    StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                }
            } catch (Exception e) {
                log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
            }
        }
    } catch (Exception ex) {
        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on all up hosts in the pool. error {0}", ex.getMessage());
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                if (returnValue.getSucceeded()) {
                    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } else {
                    log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnValue.getVdsError().getMessage());
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        ExecuteAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            failedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
    }
}
#method_after
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    decreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        executeAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            failedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        failedToRunVm();
        _isRerun = false;
    }
}
#end_block

#method_before
protected boolean processImageInIrs() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getsize(), getParameters().getDiskInfo().getvolume_type(), getParameters().getDiskInfo().getvolume_format(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
    if (vdsReturnValue.getSucceeded()) {
        getParameters().setTaskIds(new ArrayList<Guid>());
        getParameters().getTaskIds().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
        return true;
    }
    return false;
}
#method_after
protected boolean processImageInIrs() {
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getsize(), getParameters().getDiskInfo().getvolume_type(), getParameters().getDiskInfo().getvolume_format(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
    if (vdsReturnValue.getSucceeded()) {
        getParameters().setTaskIds(new ArrayList<Guid>());
        getParameters().getTaskIds().add(createTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getParameters().getVmTemplateId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getParameters().getInterface().getVmId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_VM_CANNOT_BE_SET);
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    if (!VmCommand.checkPciAndIDeLimit(getVmTemplate().getnum_of_monitors(), allInterfaces, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the network exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(getParameters().getVmTemplateId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getParameters().getInterface().getVmId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_VM_CANNOT_BE_SET);
        return false;
    }
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getnum_of_monitors(), allInterfaces, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the network exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    if (oldIface == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIDeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    if (oldIface == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<Network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

        @Override
        public boolean eval(Network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(_oldDisk.getId());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!checkPciAndIDeLimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    // Validate update boot disk.
    if (retValue && getParameters().getDiskInfo().isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(_oldDisk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                break;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    return retValue && validateShareableDisk();
}
#method_after
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(_oldDisk.getId());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!checkPciAndIdeLimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    // Validate update boot disk.
    if (retValue && getParameters().getDiskInfo().isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(_oldDisk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                break;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    return retValue && validateShareableDisk();
}
#end_block

#method_before
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            clearAddressOnInterfaceChange();
            _oldDisk.setBoot(getParameters().getDiskInfo().isBoot());
            _oldDisk.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
            _oldDisk.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
            _oldDisk.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
            _oldDisk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
            _oldDisk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
            _oldDisk.setShareable(getParameters().getDiskInfo().isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(_oldDisk);
            if (_oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) _oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDevice(getVm().getStaticData());
            setSucceeded(updateVmInSpm(getVm().getstorage_pool_id(), Arrays.asList(getVm())));
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#method_after
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            clearAddressOnInterfaceChange();
            _oldDisk.setBoot(getParameters().getDiskInfo().isBoot());
            _oldDisk.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
            _oldDisk.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
            _oldDisk.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
            _oldDisk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
            _oldDisk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
            _oldDisk.setShareable(getParameters().getDiskInfo().isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(_oldDisk);
            if (_oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) _oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            setSucceeded(updateVmInSpm(getVm().getstorage_pool_id(), Arrays.asList(getVm())));
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0);
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getstorage_pool_id().getValue(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), sourceDomainId, getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), getParameters().getOperation(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(CreateTask(taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // change storage domain in db only if object moved
        if (getParameters().getOperation() == ImageOperation.Move || getParameters().getParentCommand() == VdcActionType.ImportVm || getParameters().getParentCommand() == VdcActionType.ImportVmTemplate) {
            List<DiskImage> snapshots = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
            setSnapshotForShareableDisk(snapshots);
            for (DiskImage snapshot : snapshots) {
                getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(snapshot.getImageId(), snapshot.getstorage_ids().get(0)));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(snapshot.getImageId(), getParameters().getStorageDomainId()));
            }
        } else if (getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        // update qutoa
        if (getParameters().getQuotaId() != null) {
            getImage().setQuotaId(getParameters().getQuotaId());
            getImageDao().updateQuotaForImageAndSnapshots(getParameters().getDestImageGroupId(), getParameters().getQuotaId());
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getstorage_ids().get(0);
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getstorage_pool_id().getValue(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), sourceDomainId, getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), getParameters().getOperation(), getParameters().getPostZero(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(createTask(taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // change storage domain in db only if object moved
        if (getParameters().getOperation() == ImageOperation.Move || getParameters().getParentCommand() == VdcActionType.ImportVm || getParameters().getParentCommand() == VdcActionType.ImportVmTemplate) {
            List<DiskImage> snapshots = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getDestImageGroupId());
            setSnapshotForShareableDisk(snapshots);
            for (DiskImage snapshot : snapshots) {
                getImageStorageDomainMapDao().remove(new image_storage_domain_map_id(snapshot.getImageId(), snapshot.getstorage_ids().get(0)));
                getImageStorageDomainMapDao().save(new image_storage_domain_map(snapshot.getImageId(), getParameters().getStorageDomainId()));
            }
        } else if (getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        // update qutoa
        if (getParameters().getQuotaId() != null) {
            getImage().setQuotaId(getParameters().getQuotaId());
            getImageDao().updateQuotaForImageAndSnapshots(getParameters().getDestImageGroupId(), getParameters().getQuotaId());
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId().getValue());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    mNewCreatedDiskImage.setvolume_type(VolumeType.Sparse);
    mNewCreatedDiskImage.setvolume_format(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId().getValue(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getsize(), mNewCreatedDiskImage.getvolume_type(), mNewCreatedDiskImage.getvolume_format(), getDiskImage().getimage_group_id().getValue(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setTaskIds(new java.util.ArrayList<Guid>());
            getParameters().getTaskIds().add(CreateTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (java.lang.Exception e) {
        log.errorFormat("CreateSnapshotCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.NewGuid());
    mNewCreatedDiskImage = cloneDiskImage(getDestinationImageId());
    mNewCreatedDiskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getDestinationStorageDomainId())));
    setStoragePoolId(mNewCreatedDiskImage.getstorage_pool_id() != null ? mNewCreatedDiskImage.getstorage_pool_id().getValue() : Guid.Empty);
    getParameters().setStoragePoolId(getStoragePoolId().getValue());
    // override volume type and volume format to sparse and cow according to
    // storage team request
    mNewCreatedDiskImage.setvolume_type(VolumeType.Sparse);
    mNewCreatedDiskImage.setvolume_format(VolumeFormat.COW);
    VDSReturnValue vdsReturnValue = null;
    try {
        vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateSnapshot, new CreateSnapshotVDSCommandParameters(getStoragePoolId().getValue(), getDestinationStorageDomainId(), getImageGroupId(), getImage().getImageId(), getDiskImage().getsize(), mNewCreatedDiskImage.getvolume_type(), mNewCreatedDiskImage.getvolume_format(), getDiskImage().getimage_group_id().getValue(), getDestinationImageId(), "", getStoragePool().getcompatibility_version().toString()));
        if (vdsReturnValue.getSucceeded()) {
            getParameters().setTaskIds(new java.util.ArrayList<Guid>());
            getParameters().getTaskIds().add(createTask(vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationImageId()));
            getReturnValue().getInternalTaskIdList().add(getParameters().getTaskIds().get(0));
            // Shouldn't happen anymore:
            if (getDestinationImageId().equals(Guid.Empty)) {
                throw new RuntimeException();
            }
        }
    } catch (java.lang.Exception e) {
        log.errorFormat("CreateSnapshotCommand::CreateSnapshotInIrsServer::Failed creating snapshot from image id -'{0}'", getImage().getImageId());
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    }
    return vdsReturnValue;
}
#end_block

#method_before
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    setupMock();
    setupExpectedGlusterServers();
}
#method_after
@Before
@Override
public void setUp() throws Exception {
    super.setUp();
    setupMock();
    setupExpectedFingerPrint();
}
#end_block

#method_before
private void setupMock() {
    vdsInstallerMock = mock(VdsInstallerSSH.class);
    callback = mock(SimpleCallback.class);
    doReturn(vdsInstallerMock).when(getQuery()).getVdsInstallerSSHInstance();
    doReturn(callback).when(getQuery()).getCallBack();
    doReturn(outputXml).when(getQuery()).getCliOutput();
}
#method_after
private void setupMock() {
    clientMock = mock(SSHClient.class);
    doReturn(clientMock).when(getQuery()).createSSHClient();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    wrapper = getVdsInstallerSSHInstance();
    if (connect()) {
        if (executeCommand()) {
            String glusterServers = getCliOutput();
            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder docBuilder;
            try {
                docBuilder = docBuilderFactory.newDocumentBuilder();
                Document doc = docBuilder.parse(glusterServers);
                // normalize text representation
                doc.getDocumentElement().normalize();
                NodeList listOfPeers = doc.getElementsByTagName(PEER);
                parseHostName(listOfPeers);
            } catch (ParserConfigurationException e1) {
                log.errorFormat("There is problem in parsing xml." + e1.getMessage());
            } catch (SAXException e2) {
                log.errorFormat("Error in parsing xml." + e2.getMessage());
            } catch (IOException e3) {
                log.errorFormat("There is problem in reading the file." + e3.getMessage());
            }
            // Add current server also in the list
            hostNamesOrIp.add(getParameters().getServerName());
            getQueryReturnValue().setReturnValue(getServerFingerPrintMap());
        } else {
            log.error("Could not get the peer list form the host: " + getParameters().getServerName());
        }
    } else {
        log.error("Could not connect to host: " + getParameters().getServerName());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        getQueryReturnValue().setReturnValue(extractServers(serversXml));
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
public boolean connect() {
    return wrapper.connect(getParameters().getServerName(), getParameters().getRootPassword());
}
#method_after
protected SSHClient connect(String serverName) {
    SSHClient client = createSSHClient();
    Integer timeout = Config.<Integer>GetValue(ConfigValues.ConnectToServerTimeoutInSeconds) * 1000;
    client.setHardTimeout(timeout);
    client.setSoftTimeout(timeout);
    client.setHost(serverName, PORT);
    try {
        client.connect();
        return client;
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", serverName, e.getMessage()));
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public boolean executeCommand() {
    callback = getCallBack();
    wrapper.setCallback(callback);
    return wrapper.executeCommand(SSH_COMMAND);
}
#method_after
protected String executeCommand(SSHClient client) throws Exception {
    ByteArrayOutputStream out = new ConstraintByteArrayOutputStream(500);
    String command = Config.<String>GetValue(ConfigValues.GlusterPeerStatusCommand);
    client.executeCommand(command, null, out, null);
    return new String(out.toByteArray(), "UTF-8");
}
#end_block

#method_before
private String getFingerprint(String hostName) {
    String fingerPrint = "";
    try {
        fingerPrint = wrapper.getServerKeyFingerprint(hostName);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of server {0} with message: {1}", hostName, ExceptionUtils.getMessage(e));
    } finally {
        wrapper.shutdown();
    }
    return fingerPrint;
}
#method_after
private String getFingerprint(String hostName) {
    SSHClient client = null;
    try {
        client = connect(hostName);
        return getFingerprint(client);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
private String getFingerprint(String hostName) {
    String fingerPrint = "";
    try {
        fingerPrint = wrapper.getServerKeyFingerprint(hostName);
    } catch (Throwable e) {
        log.errorFormat("Could not fetch fingerprint of server {0} with message: {1}", hostName, ExceptionUtils.getMessage(e));
    } finally {
        wrapper.shutdown();
    }
    return fingerPrint;
}
#method_after
private String getFingerprint(SSHClient client) {
    PublicKey serverKey = client.getServerKey();
    if (serverKey == null) {
        log.error("Could not get server key");
        return null;
    }
    return OpenSSHUtils.getKeyFingerprintString(serverKey);
}
#end_block

#method_before
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword) {
    return _doConnect(server, user, userPassword, keyStore, keyStorePassword, Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000);
}
#method_after
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword) {
    return _doConnect(server, user, userPassword, keyStore, keyStorePassword, Config.<Integer>GetValue(ConfigValues.SSHInactivityHardTimoutSeconds) * 1000, Config.<Integer>GetValue(ConfigValues.SSHInactivityTimoutSeconds) * 1000);
}
#end_block

#method_before
private void _openSession(String server, long timeout) throws Exception {
    log.debug(String.format("_openSession enter (%1$s, %2$d)", server, timeout));
    try {
        if (this.client != null) {
            log.debug("_openSession already has client");
        } else {
            this.host = server;
            this.client = new SSHClient();
            this.client.setHardTimeout(timeout);
            this.client.setSoftTimeout(timeout);
            this.client.setHost(this.host, this.port);
            log.debug("connecting");
            this.client.connect();
        }
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", this.host, e.getMessage()));
        throw e;
    }
    log.debug("_openSession return");
}
#method_after
private void _openSession(String server, long hardTimeout, long softTimeout) throws Exception {
    log.debug(String.format("_openSession enter (%1$s, %2$d, %3$d)", server, hardTimeout, softTimeout));
    try {
        if (this.client != null) {
            log.debug("_openSession already has client");
        } else {
            this.client = new SSHClient();
            this.client.setHardTimeout(hardTimeout);
            this.client.setSoftTimeout(softTimeout);
            // port until API supports port
            this.client.setHost(server, this.port);
            log.debug("connecting");
            this.client.connect();
        }
    } catch (Exception e) {
        log.debug(String.format("Could not connect to server %1$s: %2$s", this.client.getDisplayHost()), e);
        throw e;
    }
    log.debug("_openSession return");
}
#end_block

#method_before
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long timeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d)", server, user, userPassword, keyStore, keyStorePassword, timeout));
    boolean ret = false;
    try {
        _openSession(server, timeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("JKS");
                ks.load(in, null);
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getServerKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.host, fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s: %2$s", this.host, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#method_after
private boolean _doConnect(String server, String user, String userPassword, String keyStore, String keyStorePassword, long hardTimeout, long softTimeout) {
    log.debug(String.format("_doConnect enter (%1$s, %2$s, %3$s, %4$s, %5$s, %6$d, %7$d)", server, user, userPassword, keyStore, keyStorePassword, hardTimeout, softTimeout));
    boolean ret = false;
    try {
        _openSession(server, hardTimeout, softTimeout);
        this.client.setUser(user);
        if (keyStore == null) {
            log.debug("Using password authentication.");
            this.client.setPassword(userPassword);
        } else {
            log.debug("Using Public Key Authentication.");
            String alias = Config.<String>GetValue(ConfigValues.CertAlias);
            KeyStore.PrivateKeyEntry entry;
            InputStream in = null;
            try {
                in = new FileInputStream(keyStore);
                KeyStore ks = KeyStore.getInstance("JKS");
                ks.load(in, null);
                entry = (KeyStore.PrivateKeyEntry) ks.getEntry(alias, new KeyStore.PasswordProtection(keyStorePassword.toCharArray()));
            } catch (Exception e) {
                throw new KeyStoreException(String.format("Failed to get certificate entry from key store: %1$s/%2$s", keyStore, alias), e);
            } finally {
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        log.error("Cannot close key store", e);
                    }
                }
            }
            if (entry == null) {
                throw new KeyStoreException(String.format("Bad key store: %1$s/%2$s", keyStore, alias));
            }
            this.client.setKeyPair(new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey()));
        }
        PublicKey serverKey = this.client.getServerKey();
        String fingerprint = "Unknown";
        if (serverKey == null) {
            log.error("Unable to get host key");
        } else {
            String tmpFingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
            if (tmpFingerprint == null) {
                log.error("Unable to get host fingerprint");
            } else {
                fingerprint = tmpFingerprint;
            }
        }
        _callbackAddMessage(String.format("<BSTRAP component='RHEV_INSTALL' status='OK' message='Connected to Host %1$s with SSH key fingerprint: %2$s'/>", this.client.getDisplayHost(), fingerprint));
        this.client.authenticate();
        _callbackConnected();
        ret = true;
    } catch (Exception e) {
        String m = String.format("Could not connect to server %1$s", this.client.getDisplayHost());
        log.error(m, e);
        _callbackFailed(m);
        return false;
    }
    log.debug("_doConnect return " + ret);
    return ret;
}
#end_block

#method_before
public final boolean connect(String server, String rootPassword, long timeout) {
    return _doConnect(server, "root", rootPassword, null, null, timeout);
}
#method_after
public final boolean connect(String server, String rootPassword, long hardTimeout) {
    return _doConnect(server, "root", rootPassword, null, null, hardTimeout, hardTimeout);
}
#end_block

#method_before
public final boolean connect(String server, String keyStore, String keyStorePassword) {
    return _doConnect(server, "root", null, keyStore, keyStorePassword);
}
#method_after
public final boolean connect(String server, String rootPassword, long hardTimeout, long softTimeout) {
    return _doConnect(server, "root", rootPassword, null, null, hardTimeout, softTimeout);
}
#end_block

#method_before
public final boolean executeCommand(String command) {
    /**
     * Send status per line recieved from stdout of command.
     */
    class MessageOutputStream extends OutputStream {

        byte[] buffer;

        ByteBuffer bbuffer;

        void _send() {
            int n;
            do {
                n = -1;
                for (int i = 0; i < bbuffer.position(); i++) {
                    if (buffer[i] == (byte) '\n') {
                        n = i;
                        break;
                    }
                }
                if (n != -1) {
                    String message;
                    try {
                        message = new String(buffer, 0, n, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        log.error("Cannot decode message", e);
                        message = "[unable to decode message]";
                    }
                    bbuffer.position(bbuffer.position() - n - 1);
                    System.arraycopy(buffer, n + 1, buffer, 0, bbuffer.position());
                    log.debug(message);
                    _callbackAddMessage(message);
                }
            } while (n != -1);
        }

        public MessageOutputStream() {
            buffer = new byte[2048];
            bbuffer = ByteBuffer.wrap(buffer);
        }

        @Override
        public void finalize() {
            close();
        }

        @Override
        public void close() {
            if (bbuffer.position() != 0) {
                String message;
                try {
                    message = new String(buffer, 0, bbuffer.position(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    log.error("Cannot decode message", e);
                    message = "[unable to decode message]";
                }
                bbuffer.clear();
                log.debug(message);
                _callbackAddMessage(message);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) {
            bbuffer.put(b, off, len);
            _send();
        }

        @Override
        public void write(int b) {
            bbuffer.put((byte) b);
            _send();
        }
    }
    log.info(String.format("SSH execute %1$s '%2$s'", this.host, command));
    boolean ret = false;
    try {
        ByteArrayOutputStream stderr = new ConstraintByteArrayOutputStream(1024);
        try {
            this.client.executeCommand(command, new ByteArrayInputStream(new byte[0]), new MessageOutputStream(), stderr);
        } finally {
            if (stderr.size() > 0) {
                _callbackAddError(new String(stderr.toByteArray(), "UTF-8"));
            }
        }
        if (stderr.size() == 0) {
            ret = true;
        }
    } catch (Exception e) {
        String m = String.format("SSH error running command %1$s '%2$s': %3$s", this.host, command, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
    }
    log.debug("executeCommand leave " + ret);
    return ret;
}
#method_after
public final boolean executeCommand(String command, InputStream stdin) {
    /**
     * Send status per line recieved from stdout of command.
     */
    class MessageOutputStream extends OutputStream {

        byte[] buffer;

        ByteBuffer bbuffer;

        void _send() {
            int n;
            do {
                n = -1;
                for (int i = 0; i < bbuffer.position(); i++) {
                    if (buffer[i] == (byte) '\n') {
                        n = i;
                        break;
                    }
                }
                if (n != -1) {
                    String message;
                    try {
                        message = new String(buffer, 0, n, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        log.error("Cannot decode message", e);
                        message = "[unable to decode message]";
                    }
                    bbuffer.position(bbuffer.position() - n - 1);
                    System.arraycopy(buffer, n + 1, buffer, 0, bbuffer.position());
                    log.debug(message);
                    _callbackAddMessage(message);
                }
            } while (n != -1);
        }

        public MessageOutputStream() {
            buffer = new byte[2048];
            bbuffer = ByteBuffer.wrap(buffer);
        }

        @Override
        public void finalize() {
            close();
        }

        @Override
        public void close() {
            if (bbuffer.position() != 0) {
                String message;
                try {
                    message = new String(buffer, 0, bbuffer.position(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    log.error("Cannot decode message", e);
                    message = "[unable to decode message]";
                }
                bbuffer.clear();
                log.debug(message);
                _callbackAddMessage(message);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) {
            bbuffer.put(b, off, len);
            _send();
        }

        @Override
        public void write(int b) {
            bbuffer.put((byte) b);
            _send();
        }
    }
    log.info(String.format("SSH execute %1$s '%2$s'", this.client.getDisplayHost(), command));
    boolean ret = false;
    try {
        ByteArrayOutputStream stderr = new ConstraintByteArrayOutputStream(1024);
        try {
            this.client.executeCommand(command, stdin, new MessageOutputStream(), stderr);
        } finally {
            if (stderr.size() > 0) {
                _callbackAddError(new String(stderr.toByteArray(), "UTF-8"));
            }
        }
        if (stderr.size() == 0) {
            ret = true;
        }
    } catch (Exception e) {
        log.error(String.format("SSH error running command %1$s:'%2$s'", this.client.getDisplayHost(), command), e);
        _callbackFailed(String.format("SSH command failed while executing at host '%1$s', refer to logs for further information", this.client.getDisplayHost()));
    }
    log.debug("executeCommand leave " + ret);
    return ret;
}
#end_block

#method_before
public final boolean executeCommand(String command) {
    /**
     * Send status per line recieved from stdout of command.
     */
    class MessageOutputStream extends OutputStream {

        byte[] buffer;

        ByteBuffer bbuffer;

        void _send() {
            int n;
            do {
                n = -1;
                for (int i = 0; i < bbuffer.position(); i++) {
                    if (buffer[i] == (byte) '\n') {
                        n = i;
                        break;
                    }
                }
                if (n != -1) {
                    String message;
                    try {
                        message = new String(buffer, 0, n, "UTF-8");
                    } catch (UnsupportedEncodingException e) {
                        log.error("Cannot decode message", e);
                        message = "[unable to decode message]";
                    }
                    bbuffer.position(bbuffer.position() - n - 1);
                    System.arraycopy(buffer, n + 1, buffer, 0, bbuffer.position());
                    log.debug(message);
                    _callbackAddMessage(message);
                }
            } while (n != -1);
        }

        public MessageOutputStream() {
            buffer = new byte[2048];
            bbuffer = ByteBuffer.wrap(buffer);
        }

        @Override
        public void finalize() {
            close();
        }

        @Override
        public void close() {
            if (bbuffer.position() != 0) {
                String message;
                try {
                    message = new String(buffer, 0, bbuffer.position(), "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    log.error("Cannot decode message", e);
                    message = "[unable to decode message]";
                }
                bbuffer.clear();
                log.debug(message);
                _callbackAddMessage(message);
            }
        }

        @Override
        public void write(byte[] b, int off, int len) {
            bbuffer.put(b, off, len);
            _send();
        }

        @Override
        public void write(int b) {
            bbuffer.put((byte) b);
            _send();
        }
    }
    log.info(String.format("SSH execute %1$s '%2$s'", this.host, command));
    boolean ret = false;
    try {
        ByteArrayOutputStream stderr = new ConstraintByteArrayOutputStream(1024);
        try {
            this.client.executeCommand(command, new ByteArrayInputStream(new byte[0]), new MessageOutputStream(), stderr);
        } finally {
            if (stderr.size() > 0) {
                _callbackAddError(new String(stderr.toByteArray(), "UTF-8"));
            }
        }
        if (stderr.size() == 0) {
            ret = true;
        }
    } catch (Exception e) {
        String m = String.format("SSH error running command %1$s '%2$s': %3$s", this.host, command, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
    }
    log.debug("executeCommand leave " + ret);
    return ret;
}
#method_after
public final boolean executeCommand(String command) {
    return executeCommand(command, new ByteArrayInputStream(new byte[0]));
}
#end_block

#method_before
public final boolean receiveFile(String source, String destination) {
    log.info(String.format("SSH receive %1$s:'%2$s' '%3$s')", this.host, source, destination));
    boolean ret = false;
    try {
        this.client.receiveFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s': %4$s", this.host, source, destination, e.getMessage());
        log.error(m, e);
        _callbackFailed(m);
    } catch (Exception e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s': %4$s", this.host, source, destination, e.getMessage());
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("receiveFile leave " + ret);
    return ret;
}
#method_after
public final boolean receiveFile(String source, String destination) {
    log.info(String.format("SSH receive %1$s:'%2$s' '%3$s')", this.client.getDisplayHost(), source, destination));
    boolean ret = false;
    try {
        this.client.receiveFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s'", this.client.getDisplayHost(), source, destination);
        log.error(m, e);
        _callbackFailed(m);
    } catch (Exception e) {
        String m = String.format("SSH could not receive file %1$s:'%2$s': '%3$s'", this.client.getDisplayHost(), source, destination);
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("receiveFile leave " + ret);
    return ret;
}
#end_block

#method_before
public final boolean sendFile(String source, String destination) {
    log.debug(String.format("SSH send %1$s:'%2$s' '%3$s'", this.host, source, destination));
    boolean ret = false;
    try {
        this.client.sendFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        log.error(String.format("SSH could not send file %2$s %1$s:%3$s", this.host, source, destination), e);
        _callbackFailed(e.getMessage());
    } catch (Exception e) {
        String m = String.format("SSH could not send file %2$s %1$s:%3$s: %4$s", this.host, source, destination, e.getMessage());
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("sendFile leave " + ret);
    return ret;
}
#method_after
public final boolean sendFile(String source, String destination) {
    log.debug(String.format("SSH send %1$s:'%2$s' '%3$s'", this.client.getDisplayHost(), source, destination));
    boolean ret = false;
    try {
        this.client.sendFile(source, destination);
        _callbackEndTransfer();
        ret = true;
    } catch (FileNotFoundException e) {
        log.error(String.format("SSH could not send file %2$s %1$s:%3$s", this.client.getDisplayHost(), source, destination), e);
        _callbackFailed(e.getMessage());
    } catch (Exception e) {
        String m = String.format("SSH could not send file %2$s %1$s:%3$s", this.client.getDisplayHost(), source, destination);
        log.error(m, e);
        _callbackAddError(m);
    }
    log.debug("sendFile leave " + ret);
    return ret;
}
#end_block

#method_before
public String getServerKeyFingerprint(String server, long timeout) throws Exception {
    String fingerprint = null;
    _openSession(server, timeout);
    PublicKey serverKey = this.client.getServerKey();
    if (serverKey != null) {
        fingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    }
    return fingerprint;
}
#method_after
public String getServerKeyFingerprint(String server, long timeout) throws Exception {
    String fingerprint = null;
    _openSession(server, timeout, timeout);
    PublicKey serverKey = this.client.getServerKey();
    if (serverKey != null) {
        fingerprint = OpenSSHUtils.getKeyFingerprintString(serverKey);
    }
    return fingerprint;
}
#end_block

#method_before
@Before
public void setup() throws IOException {
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    sshd = new SSHD();
    try {
        KeyStore ks = KeyStore.getInstance("JKS");
        ks.load(new FileInputStream(hostKstore), /*hostKstorePassword.toCharArray()*/
        null);
        sshd.setUser(user, password, ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey());
    } catch (Throwable e) {
        throw new RuntimeException(e);
    }
    try {
        sshd.start();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
    port = sshd.getPort();
}
#method_after
@Before
public void setup() throws IOException {
    IConfigUtilsInterface confInstance = new DefaultValuesConfigUtil();
    Config.setConfigUtils(confInstance);
    host = System.getProperty("ssh-host");
    if (host == null) {
        host = "localhost";
        user = "root";
        password = "password";
        sshd = new SSHD();
        try {
            KeyStore ks = KeyStore.getInstance("JKS");
            ks.load(new FileInputStream(hostKstore), /*hostKstorePassword.toCharArray()*/
            null);
            sshd.setUser(user, password, ks.getCertificate(Config.<String>GetValue(ConfigValues.CertAlias)).getPublicKey());
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
        try {
            sshd.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        port = sshd.getPort();
    } else {
        port = Integer.parseInt(System.getProperty("ssh-test-port", "22"));
        user = System.getProperty("ssh-test-user", "root");
        password = System.getProperty("ssh-test-password", "password");
    }
}
#end_block

#method_before
@Test
public void testInvalidCommand() throws Exception {
    MyVdsInstallerCallback callbacks = new MyVdsInstallerCallback();
    VdsInstallerSSH vssh = new VdsInstallerSSH();
    vssh.setPort(port);
    vssh.setCallback(callbacks);
    try {
        assertTrue(vssh.connect(host, password));
        callbacks.reset();
        assertFalse(vssh.executeCommand("xxxx"));
        assertFalse(callbacks.connected);
        assertFalse(callbacks.endTransfer);
        assertNull(callbacks.message);
        assertNotNull(callbacks.error);
        assertNotNull(callbacks.fail);
    } finally {
        vssh.shutdown();
        vssh = null;
    }
}
#method_after
@Test
public void testInvalidCommand() throws Exception {
    MyVdsInstallerCallback callbacks = new MyVdsInstallerCallback();
    VdsInstallerSSH vssh = new VdsInstallerSSH();
    vssh.setPort(port);
    vssh.setCallback(callbacks);
    try {
        assertTrue(vssh.connect(host, password));
        callbacks.reset();
        assertFalse(vssh.executeCommand("/xxxx"));
        assertFalse(callbacks.connected);
        assertFalse(callbacks.endTransfer);
        assertNull(callbacks.message);
        assertNotNull(callbacks.error);
        assertNotNull(callbacks.fail);
    } finally {
        vssh.shutdown();
        vssh = null;
    }
}
#end_block

#method_before
@Test
public void testFingerprint() throws Exception {
    VdsInstallerSSH mina = new VdsInstallerSSH();
    mina.setPort(port);
    try {
        assertEquals(OpenSSHUtils.getKeyFingerprintString(sshd.getKey()), mina.getServerKeyFingerprint(host, 5000));
    } finally {
        mina.shutdown();
        mina = null;
    }
}
#method_after
@Test
public void testFingerprint() throws Exception {
    Assume.assumeNotNull(sshd);
    VdsInstallerSSH vdsi = new VdsInstallerSSH();
    vdsi.setPort(port);
    try {
        assertEquals(OpenSSHUtils.getKeyFingerprintString(sshd.getKey()), vdsi.getServerKeyFingerprint(host, 5000));
    } finally {
        vdsi.shutdown();
        vdsi = null;
    }
}
#end_block

#method_before
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending manner
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDAO().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#method_after
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDAO().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void saveVmDevicesToDb() {
    // Sort VM devices in ascending order
    List<VmDevice> sortedVmDevices = new ArrayList<VmDevice>();
    sortedVmDevices.addAll(vmDeviceToSave.values());
    sortVmDeviceList(sortedVmDevices);
    updateAllInTransaction(sortedVmDevices, getDbFacade().getVmDeviceDAO());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#method_after
private void saveVmDevicesToDb() {
    List<VmDevice> list = new ArrayList<VmDevice>(vmDeviceToSave.values());
    Collections.sort(list);
    updateAllInTransaction("UpdateVmDeviceRuntimeInfo", list, getDbFacade().getVmDeviceDAO());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDAO().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#end_block

#method_before
/**
 * Update all the given entities in a transaction, so that a new connection/transaction won't be opened for each
 * entity update.
 *
 * @param <T>
 *            The type of entity.
 * @param procieudreName
 *            The name of stored procedure to use for update
 * @param entities
 *            The entities to update.
 * @param dao
 *            The DAO used for updating.
 */
private static <T extends BusinessEntity<?>> void updateAllInTransaction(final String procedureName, final Collection<T> entities, final MassOperationsDao<T> dao) {
    if (!entities.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                dao.updateAll(procedureName, entities);
                return null;
            }
        });
    }
}
#method_after
/**
 * Update all the given entities in a transaction, so that a new connection/transaction won't be opened for each
 * entity update.
 *
 * @param <T>
 *            The type of entity.
 * @param procedureName
 *            The name of stored procedure to use for update
 * @param entities
 *            The entities to update.
 * @param dao
 *            The DAO used for updating.
 */
private static <T extends BusinessEntity<?>> void updateAllInTransaction(final String procedureName, final Collection<T> entities, final MassOperationsDao<T> dao) {
    if (!entities.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                dao.updateAll(procedureName, entities);
                return null;
            }
        });
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (disk == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getimageStatus() == ImageStatus.ILLEGAL) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        return false;
    }
    retValue = retValue && acquireLockInternal() && isVmExist() && isVmUpOrDown() && isDiskCanBeAddedToVm(disk) && isDiskPassPCIAndIDELimit(disk);
    if (retValue && getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (retValue && disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (retValue && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (retValue && isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getstorage_ids().get(0), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && isImageDisk) {
        retValue = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVm().getId()));
    }
    if (retValue && getParameters().isPlugUnPlug() && getVm().getstatus() != VMStatus.Down) {
        retValue = isOSSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (disk == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getimageStatus() == ImageStatus.ILLEGAL) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        return false;
    }
    retValue = acquireLockInternal() && isVmExist() && isVmUpOrDown() && isDiskCanBeAddedToVm(disk) && isDiskPassPCIAndIDELimit(disk);
    if (retValue && getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (retValue && disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (retValue && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (retValue && isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getstorage_ids().get(0), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && isImageDisk) {
        retValue = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVm().getId()));
    }
    if (retValue && getParameters().isPlugUnPlug() && getVm().getstatus() != VMStatus.Down) {
        retValue = isOSSupportingHotPlug() && isHotPlugSupported() && isInterfaceSupportedForPlugUnPlug(disk);
    }
    return retValue;
}
#end_block

#method_before
@Override
public void updateAll(String procedureName, Collection<T> entities) {
    if (procedureName == null) {
        procedureName = getProcedureNameForUpdate();
    }
    for (T entity : entities) {
        getCallsHandler().executeModification(procedureName, createFullParametersMapper(entity));
    }
}
#method_after
@Override
public /**
 * Enables to send update procedure name as a parameter that overrides the default
 * one.
 * In case this parameter is null the default procedure is used.
 */
void updateAll(String procedureName, Collection<T> entities) {
    if (procedureName == null) {
        procedureName = getProcedureNameForUpdate();
    }
    for (T entity : entities) {
        getCallsHandler().executeModification(procedureName, createFullParametersMapper(entity));
    }
}
#end_block

#method_before
@Override
protected DiskImage getImage() {
    switch(getActionState()) {
        case END_SUCCESS:
        case END_FAILURE:
            if (_diskImage == null) {
                List<DiskImage> diskImages = getDiskImageDAO().getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
                _diskImage = (diskImages.isEmpty()) ? null : diskImages.get(0);
            }
            return _diskImage;
        default:
            return super.getImage();
    }
}
#method_after
@Override
protected DiskImage getImage() {
    switch(getActionState()) {
        case END_SUCCESS:
        case END_FAILURE:
            if (_diskImage == null) {
                List<DiskImage> diskImages = getDiskImageDao().getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
                _diskImage = (diskImages.isEmpty()) ? null : diskImages.get(0);
            }
            return _diskImage;
        default:
            return super.getImage();
    }
}
#end_block

#method_before
@Override
protected boolean canPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return getDiskImageDAO().get(getParameters().getDestinationImageId()) != null;
}
#method_after
@Override
protected boolean canPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return getDiskImageDao().get(getParameters().getDestinationImageId()) != null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ExecuteVmCommand();
}
#method_after
@Override
protected void executeCommand() {
    executeVmCommand();
}
#end_block

#method_before
private void GetImageChildren(Guid snapshot, List<Guid> children) {
    List<Guid> list = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDAO().getAllSnapshotsForParent(snapshot)) {
        list.add(image.getImageId());
    }
    children.addAll(list);
    for (Guid snapshotId : list) {
        GetImageChildren(snapshotId, children);
    }
}
#method_after
private void GetImageChildren(Guid snapshot, List<Guid> children) {
    List<Guid> list = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDao().getAllSnapshotsForParent(snapshot)) {
        list.add(image.getImageId());
    }
    children.addAll(list);
    for (Guid snapshotId : list) {
        GetImageChildren(snapshotId, children);
    }
}
#end_block

#method_before
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = DbFacade.getInstance().getDiskImageDAO().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#method_after
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDAO().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        RemoveVmNetwork();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDAO().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
    rollbackQuota();
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (diskImage.getVmEntityType() == VmEntityType.TEMPLATE) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setstorage_ids(getDiskImageDAO().get(diskImage.getImageId()).getstorage_ids());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getstorage_ids().get(0));
        setStorageDomainId(diskImage.getstorage_ids().get(0));
    }
    if (!diskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STOARGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
    if (retValue && diskImage.getimageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue) {
        if (disk.getVmEntityType() == VmEntityType.VM) {
            retValue = canRemoveVmImageDisk();
        } else if (disk.getVmEntityType() == VmEntityType.TEMPLATE) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (diskImage.getVmEntityType() == VmEntityType.TEMPLATE) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setstorage_ids(getDiskImageDao().get(diskImage.getImageId()).getstorage_ids());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getstorage_ids().get(0));
        setStorageDomainId(diskImage.getstorage_ids().get(0));
    }
    if (!diskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STOARGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
    if (retValue && diskImage.getimageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue) {
        if (disk.getVmEntityType() == VmEntityType.VM) {
            retValue = canRemoveVmImageDisk();
        } else if (disk.getVmEntityType() == VmEntityType.TEMPLATE) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#method_after
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParemeters(getParameters());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#end_block

#method_before
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSanpshot = getDiskImageDAO().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSanpshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#method_after
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSanpshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSanpshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#end_block

#method_before
private void initializeObjectState() {
    Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
    if (snapshot != null) {
        setSnapshotName(snapshot.getDescription());
    }
}
#method_after
private void initializeObjectState() {
    if (StringUtils.isEmpty(getSnapshotName())) {
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        if (snapshot != null) {
            setSnapshotName(snapshot.getDescription());
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<DiskImage> disks = DbFacade.getInstance().getDiskImageDao().getAllForQuotaId(getParameters().getQuotaId());
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
    }
    getQueryReturnValue().setReturnValue(disks);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<DiskImage> disks = getDbFacade().getDiskImageDao().getAllForQuotaId(getParameters().getQuotaId());
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getImageId(), diskImage.getit_guid()));
    }
    getQueryReturnValue().setReturnValue(disks);
}
#end_block

#method_before
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                            }
                        }
                    }
                    retVal = ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#method_after
private boolean canDoAction_beforeCloneVm(boolean retVal, List<String> canDoActionMessages, Map<Guid, storage_domains> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    retVal = checkStoragePool();
    if (retVal) {
        Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
        for (Guid destGuid : destGuids) {
            storage_domains storageDomain = getStorageDomain(destGuid);
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validator.isDomainExistAndActive(canDoActionMessages) || !validator.domainIsValidDestination(canDoActionMessages)) {
                retVal = false;
                break;
            } else {
                domainsMap.put(destGuid, storageDomain);
            }
        }
    }
    if (retVal && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
        retVal = false;
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        retVal = validator.isDomainExistAndActive(canDoActionMessages);
        if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        // Load images from Import/Export domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            List<VM> vms = (List<VM>) qretVal.getReturnValue();
            VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

                @Override
                public boolean eval(VM vm) {
                    return vm.getId().equals(getParameters().getVm().getId());
                }
            });
            if (vm != null) {
                // At this point we should work with the VM that was read from
                // the OVF
                setVm(vm);
                // Iterate over all the VM images (active image and snapshots)
                for (DiskImage image : getVm().getImages()) {
                    if (getParameters().getCopyCollapse()) {
                        // a match with the image from the VM.
                        for (DiskImage p : imageList) {
                            // only if requested by the user
                            if (p.getImageId().equals(image.getImageId())) {
                                if (p.getvolume_format() != null) {
                                    image.setvolume_format(p.getvolume_format());
                                }
                                if (p.getvolume_type() != null) {
                                    image.setvolume_type(p.getvolume_type());
                                }
                                // Validate the configuration of the image got from the parameters.
                                retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                                break;
                            }
                        }
                    } else {
                        // If no copy collapse sent, validate each image configuration (snapshot or active image).
                        retVal = validateImageConfig(canDoActionMessages, domainsMap, image);
                    }
                    if (!retVal) {
                        break;
                    } else {
                        image.setstorage_pool_id(getParameters().getStoragePoolId());
                        // we put the source domain id in order that copy will
                        // work
                        // ok
                        // we fix it to DestDomainId in
                        // MoveOrCopyAllImageGroups();
                        image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    }
                }
                if (retVal) {
                    Map<Guid, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                    for (Guid id : images.keySet()) {
                        List<DiskImage> list = images.get(id);
                        getVm().getDiskMap().put(id, list.get(list.size() - 1));
                    }
                }
            } else {
                retVal = false;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    ExecuteVmCommand();
}
#method_after
@Override
protected void executeCommand() {
    executeVmCommand();
}
#end_block

#method_before
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = DbFacade.getInstance().getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#method_after
private DiskImage getDiskForVolumeInfo(DiskImage disk) {
    if (getParameters().getCopyCollapse()) {
        DiskImage ancestor = getDiskImageDao().getAncestor(disk.getImageId());
        if (ancestor == null) {
            log.warnFormat("Can't find ancestor of Disk with ID {0}, using original disk for volume info.", disk.getImageId());
            ancestor = disk;
        }
        return ancestor;
    } else {
        return disk;
    }
}
#end_block

#method_before
public String getDisplayHost() {
    StringBuffer ret = new StringBuffer(100);
    if (this.host == null) {
        ret.append("N/A");
    } else {
        if (this.user != null) {
            ret.append(this.user);
            ret.append("@");
        }
        ret.append(this.host);
        if (this.port != DEFAULT_SSH_PORT) {
            ret.append(":");
            ret.append(this.port);
        }
    }
    return ret.toString();
}
#method_after
public String getDisplayHost() {
    StringBuilder ret = new StringBuilder(100);
    if (this.host == null) {
        ret.append("N/A");
    } else {
        if (this.user != null) {
            ret.append(this.user);
            ret.append("@");
        }
        ret.append(this.host);
        if (this.port != DEFAULT_SSH_PORT) {
            ret.append(":");
            ret.append(this.port);
        }
    }
    return ret.toString();
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = verifyAddVM(reasons, storagePoolId, vmPriority);
    if (returnValue && !getParameters().getDontCheckTemplateImages()) {
        for (storage_domains storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<storage_domains> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmHandler.handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (storage_domains domain : destStorages) {
                if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                } else if (!StorageDomainSpaceChecker.hasSpaceForRequest(domain, getNeededDiskSize(domain.getId()))) {
                    returnValue = false;
                    reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
                    break;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
protected boolean CanDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && CheckPCIAndIDELimit(getParameters().getVmStaticData().getnum_of_monitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && CanAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean CanDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && CheckPCIAndIDELimit(getParameters().getVmStaticData().getnum_of_monitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (CanAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                addVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void ExecuteVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                AddVmStatic();
                addVmDynamic();
                AddVmNetwork();
                AddVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (AddVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected String InitInitialCommand(VDS vds, String initialCommand) {
    initialCommand = initialCommand.replace("{vdsInstaller}", _remoteBootstrapRunningScriptPath);
    initialCommand = initialCommand.replace("{vds-server}", vds.gethost_name());
    initialCommand = initialCommand.replace("{URL1}", Config.<String>GetValue(ConfigValues.VdcBootStrapUrl));
    initialCommand = initialCommand.replace("{GUID}", _fileGuid.toString());
    initialCommand = initialCommand.replace("{server_SSL_enabled}", Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers).toString());
    initialCommand = initialCommand.replace("{OrganizationName}", HandleOrganizationNameString(Config.<String>GetValue(ConfigValues.OrganizationName)));
    DateTime utcNow = DateTime.getUtcNow();
    serverInstallationTime = utcNow.toString("yyyy-MM-ddTHH:mm:ss");
    initialCommand = initialCommand.replace("{utc_time}", serverInstallationTime);
    initialCommand = initialCommand.replace("{management_port}", (Integer.toString(vds.getport())));
    String publicUrlPort = Config.<String>GetValue(ConfigValues.PublicURLPort);
    if (StringHelper.isNullOrEmpty(publicUrlPort)) {
        initialCommand = initialCommand.replace("{EnginePort}", "");
    } else {
        initialCommand = initialCommand.replace("{EnginePort}", String.format("-p %1$s", publicUrlPort));
    }
    initialCommand = initialCommand.replace("{OverrideFirewall}", isOverrideFirewallAllowed() ? "-f " + remoteFwRulesFilePath : "");
    return initialCommand;
}
#method_after
protected String InitInitialCommand(VDS vds, String initialCommand) {
    initialCommand = initialCommand.replace("{vds-server}", vds.gethost_name());
    initialCommand = initialCommand.replace("{URL1}", Config.<String>GetValue(ConfigValues.VdcBootStrapUrl));
    initialCommand = initialCommand.replace("{GUID}", _fileGuid.toString());
    initialCommand = initialCommand.replace("{server_SSL_enabled}", Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers).toString());
    initialCommand = initialCommand.replace("{OrganizationName}", HandleOrganizationNameString(Config.<String>GetValue(ConfigValues.OrganizationName)));
    initialCommand = initialCommand.replace("{management_port}", (Integer.toString(vds.getport())));
    String publicUrlPort = Config.<String>GetValue(ConfigValues.PublicURLPort);
    if (StringUtils.isEmpty(publicUrlPort)) {
        initialCommand = initialCommand.replace("{EnginePort}", "");
    } else {
        initialCommand = initialCommand.replace("{EnginePort}", String.format("-p %1$s", publicUrlPort));
    }
    initialCommand = initialCommand.replace("{SSHKey}", _remoteSSHKey);
    initialCommand = initialCommand.replace("{OverrideFirewall}", isOverrideFirewallAllowed() ? "-f " + remoteFwRulesFilePath : "");
    return initialCommand;
}
#end_block

#method_before
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String path = Config.resolveBootstrapInstallerPath();
                _executionSucceded = _wrapper.sendFile(path, _remoteBootstrapRunningScriptPath);
                if (isOverrideFirewallAllowed() && _executionSucceded) {
                    _currentInstallStage = VdsInstallStages.UploadScript;
                    _executionSucceded = uploadFirewallRulesConfFile(getIpTableConfig());
                }
                break;
            }
        case RunScript:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _bootStrapInitialCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_bootStrapInitialCommand);
                log.infoFormat(" RunScript ended:" + fRes.toString());
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                log.infoFormat("Installation of {0}. Sending SSH Command {1}. (Stage: {2})", _serverName, _finishCommand, getCurrentInstallStage());
                Boolean fRes = _wrapper.executeCommand(_finishCommand);
                log.infoFormat(" FinishCommand ended:" + fRes.toString());
                break;
            }
    }
}
#method_after
protected void RunStage() {
    if (this.getClass() == VdsInstaller.class) {
        log.infoFormat("Installation of {0}. Executing installation stage. (Stage: {1})", _serverName, getCurrentInstallStage());
    }
    switch(_currentInstallStage) {
        case Start:
            {
                _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                _executionSucceded = true;
                break;
            }
        case ConnectToServer:
            {
                _executionSucceded = _wrapper.connect(_serverName, _rootPassword);
                break;
            }
        case CheckUniqueVds:
            {
                _wrapper.executeCommand(Config.<String>GetValue(ConfigValues.BootstrapNodeIDCommand));
                break;
            }
        case UploadScript:
            {
                String thumbprint = VdsInstallerSSH.getEngineSSHKeyFingerprint();
                if (thumbprint == null) {
                    _executionSucceded = false;
                } else {
                    _executionSucceded = uploadStringAsFile(thumbprint, _remoteSSHKey);
                }
                if (_executionSucceded && isOverrideFirewallAllowed()) {
                    String ipTablesConfig = getIpTableConfig();
                    if (StringUtils.isNotEmpty(ipTablesConfig)) {
                        _executionSucceded = uploadStringAsFile(ipTablesConfig, remoteFwRulesFilePath);
                    }
                }
                if (_executionSucceded) {
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                }
                break;
            }
        case RunScript:
            {
                runBootstrapCommand(false);
                break;
            }
        case DownloadCertificateRequest:
            {
                // First parameter will always run on Linux, so use path.combine
                // just for the second param.
                Boolean fRes = _wrapper.receiveFile(_remoteDirectory + "/" + _certRequestFileName, buildCAPath(_requestsDirectory, _certRequestFileName));
                log.infoFormat(" DownloadCertificateRequest ended:" + fRes.toString());
                break;
            }
        case SignCertificateRequest:
            {
                _executionSucceded = _caWrapper.SignCertificateRequest(_certRequestFileName, Config.<Integer>GetValue(ConfigValues.VdsCertificateValidityInYears) * 365, _certFileNameLocal);
                log.infoFormat(" SignCertificateRequest ended:" + _executionSucceded);
                if (_executionSucceded) {
                    String currRequest = buildCAPath(_requestsDirectory, _certRequestFileName);
                    try {
                        FileUtil.deleteFile(currRequest);
                    } catch (RuntimeException exp) {
                        log.errorFormat("Installation of {0}. Could not delete certificate request file from: {1}. error: {2}. (Stage: {3}", _serverName, currRequest, exp.getMessage(), getCurrentInstallStage());
                    }
                    _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
                } else {
                    log.error("Error signing certificate request");
                }
                break;
            }
        case UploadSignedCertificate:
            {
                // Second parameter will always run on Linux, so use
                // path.combine just for the first param.
                Boolean fRes = _wrapper.sendFile(buildCAPath(_certificatesDirectory, _certFileNameLocal), _remoteDirectory + "/" + _certFileName);
                log.infoFormat(" UploadSignedCertificate ended:" + fRes.toString());
                break;
            }
        case UploadCA:
            {
                String path = String.format("%1$s/%2$s", _remoteDirectory, _caFileName);
                _wrapper.sendFile(Config.resolveCACertificatePath(), path);
                break;
            }
        case FinishCommand:
            {
                runBootstrapCommand(true);
                break;
            }
    }
}
#end_block

#method_before
private String getIpTableConfig() {
    String ipTableConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
    if (supportGluster) {
        int i = 0;
        String glusterIpTableConfig = Config.<String>GetValue(ConfigValues.GlusterIPTablesConfig);
        if (glusterIpTableConfig == null) {
            glusterIpTableConfig = "";
        }
        String[] ipTables = ipTableConfig.split("\n");
        while (i < ipTables.length) {
            if (ipTables[i].toLowerCase().indexOf("reject") >= 0) {
                ipTableConfig = StringUtils.join(ipTables, "\n", 0, i) + "\n" + glusterIpTableConfig + "\n" + StringUtils.join(ipTables, "\n", i, ipTables.length - 1);
                break;
            }
            i++;
        }
    }
    return ipTableConfig;
}
#method_after
private String getIpTableConfig() {
    String ipTablesConfig = Config.<String>GetValue(ConfigValues.IPTablesConfig);
    String serviceIPTablesConfig = "";
    if (supportVirt) {
        serviceIPTablesConfig += Config.<String>GetValue(ConfigValues.IPTablesConfigForVirt);
    }
    if (supportGluster) {
        serviceIPTablesConfig += Config.<String>GetValue(ConfigValues.IPTablesConfigForGluster);
    }
    ipTablesConfig.replace(IP_TABLE_CUSTOM_RULES_PLACE_HOLDER, serviceIPTablesConfig);
    return ipTablesConfig;
}
#end_block

#method_before
@Override
public void endTransfer() {
    if (_currentInstallStage == VdsInstallStages.UploadScript || _currentInstallStage == VdsInstallStages.DownloadCertificateRequest || _currentInstallStage == VdsInstallStages.UploadSignedCertificate || _currentInstallStage == VdsInstallStages.UploadCA) {
        log.infoFormat("Installation of {0}. successfully done sftp operation ( Stage: {1})", _serverName, _translatedMessages.get(_currentInstallStage));
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        _executionSucceded = true;
    } else if (_currentInstallStage != VdsInstallStages.Error) {
        log.warnFormat("Installation of {0}. Illegal stage for sftp operation. (Stage: {1})", _serverName, getCurrentInstallStage());
        _currentInstallStage = VdsInstallStages.Error;
    }
}
#method_after
@Override
public void endTransfer() {
    if (// iso upload
    _currentInstallStage == VdsInstallStages.UploadScript || _currentInstallStage == VdsInstallStages.DownloadCertificateRequest || _currentInstallStage == VdsInstallStages.UploadSignedCertificate || _currentInstallStage == VdsInstallStages.UploadCA) {
        log.infoFormat("Installation of {0}. successfully done sftp operation ( Stage: {1})", _serverName, _translatedMessages.get(_currentInstallStage));
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        _executionSucceded = true;
    } else if (_currentInstallStage != VdsInstallStages.Error) {
        log.warnFormat("Installation of {0}. Illegal stage for sftp operation. (Stage: {1})", _serverName, getCurrentInstallStage());
        _currentInstallStage = VdsInstallStages.Error;
    }
}
#end_block

#method_before
private void setNonOperational(NonOperationalReason reason) {
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVds().getId(), reason);
    tempVar.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar);
}
#method_after
private void setNonOperational(NonOperationalReason reason) {
    SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(getVds().getId(), reason);
    tempVar.setSaveToDb(true);
    Backend.getInstance().runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        if (getVdsGroup().supportsGlusterService()) {
            if (!_glusterPeerListSucceeded) {
                type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
            } else if (!_glusterPeerProbeSucceeded) {
                type = AuditLogType.GLUSTER_HOST_ADD_FAILED;
            }
        }
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#end_block

#method_before
private void initGlusterPeerProcess() {
    List<VDS> vdsList = DbFacade.getInstance().getVdsDAO().getAllForVdsGroup(getVdsGroupId());
    // If the cluster already having Gluster servers, get an up server
    if (vdsList != null && vdsList.size() > 1) {
        VDS upServer = null;
        for (int i = 0; i < vdsList.size(); i++) {
            if (!Guid.OpEquality(getVdsId(), vdsList.get(i).getId()) && vdsList.get(i).getstatus() == VDSStatus.Up) {
                upServer = vdsList.get(i);
                break;
            }
        }
        // If new server is not part of the existing gluster peers, add into peer group
        if (upServer != null) {
            if (!hostExists(getGlusterPeers(upServer.getId()), upServer.getId())) {
                String newServerName = getVds().gethost_name().isEmpty() ? getVds().getManagmentIp() : getVds().gethost_name();
                glusterPeerProbe(upServer.getId(), newServerName);
            }
        }
    }
}
#method_after
private void initGlusterPeerProcess() {
    _glusterPeerListSucceeded = true;
    _glusterPeerProbeSucceeded = true;
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(getVdsGroupId(), VDSStatus.Up);
    // If the cluster already having Gluster servers, get an up server
    if (vdsList != null && vdsList.size() > 0) {
        VDS upServer = null;
        for (VDS vds : vdsList) {
            if (!getVdsId().equals(vds.getId())) {
                upServer = vds;
                break;
            }
        }
        // If new server is not part of the existing gluster peers, add into peer group
        if (upServer != null) {
            List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer.getId());
            if (glusterServers.size() == 0) {
                setNonOperational(NonOperationalReason.GLUSTER_PEER_LIST_FAILED);
            } else if (!hostExists(glusterServers, getVds())) {
                if (!glusterPeerProbe(upServer.getId(), getVds().gethost_name())) {
                    setNonOperational(NonOperationalReason.GLUSTER_PEER_PROBE_FAILED);
                }
            }
        }
    }
}
#end_block

#method_before
private boolean hostExists(List<VDS> glusterServers, Guid serverId) {
    for (VDS vds : glusterServers) {
        if (vds.getId().equals(serverId)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean hostExists(List<GlusterServerInfo> glusterServers, VDS server) {
    for (GlusterServerInfo glusterServer : glusterServers) {
        if (glusterServer.getHostnameOrIp().equals(server.gethost_name())) {
            return true;
        }
        for (VdsNetworkInterface vdsNwInterface : getVdsInterfaces(server.getId())) {
            if (glusterServer.getHostnameOrIp().equals(vdsNwInterface.getAddress())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private List<VDS> getGlusterPeers(Guid upServerId) {
    List<VDS> glusterServers = new ArrayList<VDS>();
    VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GlusterHostsList, new VdsIdVDSCommandParametersBase(upServerId));
    setSucceeded(returnValue.getSucceeded());
    if (getSucceeded()) {
        glusterServers = (List<VDS>) returnValue.getReturnValue();
    } else {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogDirector.log(new AuditLogableBase(upServerId), AuditLogType.GLUSTER_HOST_LIST_FAILED);
    }
    return glusterServers;
}
#method_after
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<GlusterServerInfo>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogDirector.log(new AuditLogableBase(upServerId), AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
        _glusterPeerListSucceeded = false;
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#end_block

#method_before
private void glusterPeerProbe(Guid upServerId, String newServerName) {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServerId, newServerName));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogDirector.log(new AuditLogableBase(upServerId), AuditLogType.GLUSTER_HOST_ADD_FAILED);
        return;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.GLUSTER_HOST_ADD_FAILED);
            _glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().gethost_name(), e.getMessage());
        _glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), getParameters().getDescription());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), getParameters().getDescription());
    }
    return jobProperties;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmNotDuringMigration()) && validate(vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, checkVmIsDown(), true, true, disksList);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CREATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmNotDuringMigration()) && validate(vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, checkVmIsDown(), true, true, disksList);
    }
    return result;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        initializeObjectState();
        jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), getSnapshotName());
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        initializeObjectState();
        jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), getSnapshotName());
    }
    return jobProperties;
}
#end_block

#method_before
// TODO: this is a temporary method used until ImagesHandler.PerformImagesChecks will get decoupeld to several tests
// Until then, this method is called and passes hasImages() onwards so the VM validations are done even for diskless
protected boolean validateImagesAndVMStates() {
    return ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, hasImages(), hasImages(), hasImages(), hasImages(), true, true, true, true, null);
}
#method_after
// TODO: this is a temporary method used until ImagesHandler.PerformImagesChecks will get decoupeld to several tests
protected boolean validateImagesAndVMStates() {
    return ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, hasImages(), hasImages(), hasImages(), hasImages(), true, true, true, true, null);
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.SnapshotName.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
        if (snapshot != null) {
            jobProperties.put(VdcObjectType.Snapshot.name().toLowerCase(), snapshot.getDescription());
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public void rollbackQuota() {
    for (DiskImage image : getImagesList()) {
        Guid quotaId = image.getQuotaId();
        if (quotaId != null) {
            // Uncache the details of this quota. next time the quota will be called, a new calculation
            // would be done base on the DB.
            QuotaManager.getInstance().rollbackQuota(getStoragePool(), Arrays.asList(quotaId));
        }
    }
}
#method_after
@Override
public void rollbackQuota() {
    if (getImagesList().isEmpty()) {
        return;
    }
    setStoragePoolId(getImagesList().get(0).getstorage_pool_id());
    for (DiskImage image : getImagesList()) {
        Guid quotaId = image.getQuotaId();
        if (quotaId != null) {
            // Uncache the details of this quota. next time the quota will be called, a new calculation
            // would be done base on the DB.
            QuotaManager.getInstance().rollbackQuota(getStoragePool(), Arrays.asList(quotaId));
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // get vm status from db to check its really down before locking
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    VmHandler.LockVm(vmDynamic, getCompensationContext());
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.NewGuid());
    getParameters().setVmTemplateID(getVmTemplateId());
    getParameters().setEntityId(getVmTemplateId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces);
            setSucceeded(true);
            return null;
        }
    });
    // end the command synchronously
    if (getReturnValue().getTaskIdList().isEmpty()) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // get vm status from db to check its really down before locking
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    VmHandler.LockVm(vmDynamic, getCompensationContext());
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.NewGuid());
    getParameters().setVmTemplateID(getVmTemplateId());
    getParameters().setEntityId(getVmTemplateId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces);
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDAO().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(getVmTemplate().getDiskImageMap().values(), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDAO().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    endDefaultOperations();
    setSucceeded(true);
}
#method_after
@Override
protected void EndSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void endSuccessfullySynchronous() {
    endDefaultOperations();
    setSucceeded(true);
}
#method_after
private void endSuccessfullySynchronous() {
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endDefaultOperations() {
    endTemplateRelatedOperations();
    endUnlockRelatedOperations();
}
#method_after
private void endDefaultOperations() {
    endTemplateRelatedOperations();
    endUnlockOps();
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVmId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    rollbackQuota();
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDAO().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage diskImage : mImages) {
        DiskImage disk = diskInfoDestinationMap.get(diskImage.getId());
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getMasterVm().getQuotaId(), disk.getstorage_ids().get(0), // TODO: not sure if this is good
        disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
private List<StorageQuotaValidationParameter> getStorageQuotaListParameters() {
    List<StorageQuotaValidationParameter> list = new ArrayList<StorageQuotaValidationParameter>();
    for (DiskImage disk : diskInfoDestinationMap.values()) {
        list.add(new StorageQuotaValidationParameter(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getMasterVm().getQuotaId(), disk.getstorage_ids().get(0), // TODO: not sure if this is good
        disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public void Cluster_SelectedItemChanged() {
    updateQuotaByCluster(vm.getQuotaId());
}
#method_after
@Override
public void Cluster_SelectedItemChanged() {
    updateQuotaByCluster(null, null);
}
#end_block

#method_before
private void InitTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getvm_mem_size_mb());
    getModel().getOSType().setSelectedItem(this.vm.getvm_os());
    getModel().getDomain().setSelectedItem(this.vm.getvm_domain());
    getModel().getUsbPolicy().setSelectedItem(this.vm.getusb_policy());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getnum_of_monitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getdefault_boot_sequence());
    getModel().getNumOfSockets().setEntity(this.vm.getnum_of_sockets());
    getModel().getTotalCPUCores().setEntity(this.vm.getnum_of_cpus());
    getModel().getIsStateless().setEntity(this.vm.getis_stateless());
    if (!StringHelper.isNullOrEmpty(this.vm.gettime_zone())) {
        getModel().getTimeZone().setSelectedItem(// $NON-NLS-1$
        new KeyValuePairCompat<String, String>(this.vm.gettime_zone(), ""));
        UpdateTimeZone();
    } else {
        UpdateDefaultTimeZone();
    }
    // Update domain list
    UpdateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == this.vm.getdefault_display_type()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(this.vm.getpriority());
}
#method_after
private void InitTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getvm_mem_size_mb());
    getModel().getOSType().setSelectedItem(this.vm.getvm_os());
    getModel().getDomain().setSelectedItem(this.vm.getvm_domain());
    getModel().getUsbPolicy().setSelectedItem(this.vm.getusb_policy());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getnum_of_monitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getdefault_boot_sequence());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.vm.getnum_of_cpus()));
    getModel().getNumOfSockets().setSelectedItem(this.vm.getnum_of_sockets());
    getModel().getIsStateless().setEntity(this.vm.getis_stateless());
    if (!StringHelper.isNullOrEmpty(this.vm.gettime_zone())) {
        getModel().getTimeZone().setSelectedItem(// $NON-NLS-1$
        new KeyValuePairCompat<String, String>(this.vm.gettime_zone(), ""));
        UpdateTimeZone();
    } else {
        UpdateDefaultTimeZone();
    }
    // Update domain list
    UpdateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == this.vm.getdefault_display_type()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(this.vm.getpriority());
}
#end_block

#method_before
private void DisableNewTemplateModel(String errMessage) {
    getModel().setIsValid(false);
    getModel().setMessage(errMessage);
    getModel().getName().setIsChangable(false);
    getModel().getDescription().setIsChangable(false);
    getModel().getCluster().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsTemplatePublic().setIsChangable(false);
    getModel().getIsTemplatePrivate().setIsChangable(false);
    getModel().getDefaultCommand().setIsAvailable(false);
}
#method_after
private void DisableNewTemplateModel(String errMessage) {
    getModel().setIsValid(false);
    getModel().setMessage(errMessage);
    getModel().getName().setIsChangable(false);
    getModel().getDescription().setIsChangable(false);
    getModel().getCluster().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsTemplatePublic().setIsChangable(false);
    getModel().getDefaultCommand().setIsAvailable(false);
}
#end_block

#method_before
@Override
public ImageResource getValue(IVdcQueryable quota) {
    boolean quotaExceeded = false;
    if (quota instanceof QuotaStorage) {
        quotaExceeded = getQuotaExceeded((QuotaStorage) quota);
    } else if (quota instanceof QuotaVdsGroup) {
        quotaExceeded = getQuotaExceeded((QuotaVdsGroup) quota);
    } else {
        return null;
    }
    if (quotaExceeded) {
        // $NON-NLS-1$
        setTitle("Quota exceeded");
    }
    return quotaExceeded ? getResources().alertImage() : null;
}
#method_after
@Override
public ImageResource getValue(IVdcQueryable quota) {
    boolean quotaExceeded = false;
    if (quota instanceof QuotaStorage) {
        quotaExceeded = getQuotaExceeded((QuotaStorage) quota);
    } else if (quota instanceof QuotaVdsGroup) {
        quotaExceeded = getQuotaExceeded((QuotaVdsGroup) quota);
    } else {
        return null;
    }
    if (quotaExceeded) {
        setTitle(applicationConstants.quotaExceeded());
    }
    return quotaExceeded ? getResources().alertImage() : null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    removeQuotaFromCache();
    setQuotaParameter();
    QuotaDAO dao = getQuotaDAO();
    dao.update(getParameters().getQuota());
    getReturnValue().setSucceeded(true);
    afterEdit();
}
#method_after
@Override
protected void executeCommand() {
    removeQuotaFromCache();
    setQuotaParameter();
    QuotaDAO dao = getQuotaDAO();
    dao.update(getParameters().getQuota());
    getReturnValue().setSucceeded(true);
    afterUpdate();
}
#end_block

#method_before
public boolean isGlusterPeerProbeNeeded() {
    return this.isGlusterPeerProbeNeeded;
}
#method_after
public boolean isGlusterPeerProbeNeeded() {
    return this.glusterPeerProbeNeeded;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // Also gluster peer probe is not needed when importing an existing gluster cluster
        if (getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
                return;
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid oVirtId = getParameters().getVdsForUniqueId();
    if (oVirtId != null) {
        // if fails to remove deprecated entry, we might attempt to add new oVirt host with an existing unique-id.
        if (!removeDeprecatedOvirtEntry(oVirtId)) {
            log.errorFormat("Failed to remove duplicated oVirt entry with id {0}. Abort adding oVirt Host type", oVirtId);
            throw new VdcBLLException(VdcBllErrors.HOST_ALREADY_EXISTS);
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVdsStaticToDb();
            AddVdsDynamicToDb();
            AddVdsStatisticsToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // set vds spm id
    if (getVdsGroup().getstorage_pool_id() != null) {
        VdsActionParameters tempVar = new VdsActionParameters(getVdsIdRef().getValue());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCompensationEnabled(true);
        CompensationContext compensationContext = getCompensationContext();
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, tempVar, new CommandContext(compensationContext));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            InitializeVds();
            AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
            TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
            setSucceeded(true);
            setActionReturnValue(getVdsIdRef());
            // If the installation failed, we don't want to compensate for the failure since it will remove the
            // host, but instead the host should be left in an "install failed" status.
            getCompensationContext().resetCompensation();
            return null;
        }
    });
    // clients). they are installed as part of the approve process
    if (Config.<Boolean>GetValue(ConfigValues.InstallVds) && !getParameters().getAddPending()) {
        final InstallVdsParameters installVdsParameters = new InstallVdsParameters(getVdsId(), getParameters().getRootPassword());
        installVdsParameters.setOverrideFirewall(getParameters().getOverrideFirewall());
        installVdsParameters.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VDS.name().toLowerCase(), getParameters().getvds().getvds_name());
        Step installStep = ExecutionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), StepEnum.INSTALLING_HOST, ExecutionMessageDirector.resolveStepMessage(StepEnum.INSTALLING_HOST, values));
        final ExecutionContext installCtx = new ExecutionContext();
        installCtx.setJob(getExecutionContext().getJob());
        installCtx.setStep(installStep);
        installCtx.setMonitored(true);
        installCtx.setShouldEndJob(true);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.InstallVds, installVdsParameters, new CommandContext(installCtx));
            }
        });
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    } else {
        // Also gluster peer probe is not needed when importing an existing gluster cluster
        if (isGlusterSupportEnabled() && getAllVds(getVdsGroupId()).size() > 1) {
            String hostName = (getParameters().getvds().gethost_name().isEmpty()) ? getParameters().getvds().getManagmentIp() : getParameters().getvds().gethost_name();
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServer.getId(), hostName));
            setSucceeded(returnValue.getSucceeded());
            if (!getSucceeded()) {
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_HOST_ADD_FAILED;
                return;
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (getVdsGroup().supportsGlusterService() && getParameters().isGlusterPeerProbeNeeded()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else if (getParameters().getVdsStaticData().getport() < 1 || getParameters().getVdsStaticData().getport() > 65536) {
                addCanDoActionMessage(VdcBllMessages.VDS_PORT_IS_NOT_LEGAL);
                returnValue = false;
            } else {
                returnValue = returnValue && validateHostUniqueness(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#end_block

