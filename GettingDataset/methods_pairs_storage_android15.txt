465
#method_before
@Deprecated
protected int getExtraLayoutSpace(RecyclerView.State state) {
    if (state.hasTargetScrollPosition()) {
        return mOrientationHelper.getTotalSpace();
    } else {
        return 0;
    }
}
#method_after
@SuppressWarnings("DeprecatedIsStillUsed")
@Deprecated
protected int getExtraLayoutSpace(RecyclerView.State state) {
    if (state.hasTargetScrollPosition()) {
        return mOrientationHelper.getTotalSpace();
    } else {
        return 0;
    }
}
#end_block

#method_before
private void calculateExtraLayoutSpace(RecyclerView.State state, int scrollDirection, int[] extraLayoutSpace) {
    int extraLayoutSpaceStart = getExtraLayoutSpaceAround(state);
    int extraLayoutSpaceEnd = extraLayoutSpaceStart;
    if (scrollDirection == LayoutState.LAYOUT_START || scrollDirection == LayoutState.LAYOUT_END) {
        int extraScrollSpace = getExtraLayoutSpaceForScrolling(state);
        if (scrollDirection == LayoutState.LAYOUT_START) {
            extraLayoutSpaceStart = Math.max(extraScrollSpace, extraLayoutSpaceStart);
        } else {
            extraLayoutSpaceEnd = Math.max(extraScrollSpace, extraLayoutSpaceEnd);
        }
    }
    extraLayoutSpace[0] = extraLayoutSpaceStart;
    extraLayoutSpace[1] = extraLayoutSpaceEnd;
}
#method_after
protected void calculateExtraLayoutSpace(@NonNull RecyclerView.State state, @NonNull int[] extraLayoutSpace) {
    int extraLayoutSpaceStart = 0;
    int extraLayoutSpaceEnd = 0;
    // If calculateExtraLayoutSpace is not overridden, call the
    // deprecated getExtraLayoutSpace for backwards compatibility
    @SuppressWarnings("deprecation")
    int extraScrollSpace = getExtraLayoutSpace(state);
    if (mLayoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
        extraLayoutSpaceStart = extraScrollSpace;
    } else {
        extraLayoutSpaceEnd = extraScrollSpace;
    }
    extraLayoutSpace[0] = extraLayoutSpaceStart;
    extraLayoutSpace[1] = extraLayoutSpaceEnd;
}
#end_block

#method_before
@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    // create layout state
    if (DEBUG) {
        Log.d(TAG, "is pre layout:" + state.isPreLayout());
    }
    if (mPendingSavedState != null || mPendingScrollPosition != RecyclerView.NO_POSITION) {
        if (state.getItemCount() == 0) {
            removeAndRecycleAllViews(recycler);
            return;
        }
    }
    if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
        mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
    }
    ensureLayoutState();
    mLayoutState.mRecycle = false;
    // resolve layout direction
    resolveShouldLayoutReverse();
    final View focused = getFocusedChild();
    if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION || mPendingSavedState != null) {
        mAnchorInfo.reset();
        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
        // calculate anchor position and coordinate
        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
        mAnchorInfo.mValid = true;
    } else if (focused != null && (mOrientationHelper.getDecoratedStart(focused) >= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(focused) <= mOrientationHelper.getStartAfterPadding())) {
        // This case relates to when the anchor child is the focused view and due to layout
        // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows
        // up after tapping an EditText which shrinks RV causing the focused view (The tapped
        // EditText which is the anchor child) to get kicked out of the screen. Will update the
        // anchor coordinate in order to make sure that the focused view is laid out. Otherwise,
        // the available space in layoutState will be calculated as negative preventing the
        // focused view from being laid out in fill.
        // Note that we won't update the anchor position between layout passes (refer to
        // TestResizingRelayoutWithAutoMeasure), which happens if we were to call
        // updateAnchorInfoForLayout for an anchor that's not the focused view (e.g. a reference
        // child which can change between layout passes).
        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
    }
    if (DEBUG) {
        Log.d(TAG, "Anchor info:" + mAnchorInfo);
    }
    // LLM may decide to layout items for "extra" pixels to account for scrolling target,
    // caching or predictive animations.
    int layoutDirection = mLayoutState.mLastScrollDelta >= 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
    mReusableIntPair[0] = 0;
    mReusableIntPair[1] = 0;
    calculateExtraLayoutSpace(state, layoutDirection, mReusableIntPair);
    int extraForStart = mReusableIntPair[0] + mOrientationHelper.getStartAfterPadding();
    int extraForEnd = mReusableIntPair[1] + mOrientationHelper.getEndPadding();
    if (state.isPreLayout() && mPendingScrollPosition != RecyclerView.NO_POSITION && mPendingScrollPositionOffset != INVALID_OFFSET) {
        // if the child is visible and we are going to move it around, we should layout
        // extra items in the opposite direction to make sure new items animate nicely
        // instead of just fading in
        final View existing = findViewByPosition(mPendingScrollPosition);
        if (existing != null) {
            final int current;
            final int upcomingOffset;
            if (mShouldReverseLayout) {
                current = mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(existing);
                upcomingOffset = current - mPendingScrollPositionOffset;
            } else {
                current = mOrientationHelper.getDecoratedStart(existing) - mOrientationHelper.getStartAfterPadding();
                upcomingOffset = mPendingScrollPositionOffset - current;
            }
            if (upcomingOffset > 0) {
                extraForStart += upcomingOffset;
            } else {
                extraForEnd -= upcomingOffset;
            }
        }
    }
    int startOffset;
    int endOffset;
    final int firstLayoutDirection;
    if (mAnchorInfo.mLayoutFromEnd) {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL : LayoutState.ITEM_DIRECTION_HEAD;
    } else {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL;
    }
    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
    detachAndScrapAttachedViews(recycler);
    mLayoutState.mInfinite = resolveIsInfinite();
    mLayoutState.mIsPreLayout = state.isPreLayout();
    if (mAnchorInfo.mLayoutFromEnd) {
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = extraForStart;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;
        final int firstElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForEnd += mLayoutState.mAvailable;
        }
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = extraForEnd;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
        if (mLayoutState.mAvailable > 0) {
            // end could not consume all. add more items towards start
            extraForStart = mLayoutState.mAvailable;
            updateLayoutStateToFillStart(firstElement, startOffset);
            mLayoutState.mExtra = extraForStart;
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
        }
    } else {
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = extraForEnd;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
        final int lastElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForStart += mLayoutState.mAvailable;
        }
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = extraForStart;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;
        if (mLayoutState.mAvailable > 0) {
            extraForEnd = mLayoutState.mAvailable;
            // start could not consume all it should. add more items towards end
            updateLayoutStateToFillEnd(lastElement, endOffset);
            mLayoutState.mExtra = extraForEnd;
            fill(recycler, mLayoutState, state, false);
            endOffset = mLayoutState.mOffset;
        }
    }
    // changed
    if (getChildCount() > 0) {
        // find which side we should check for gaps.
        if (mShouldReverseLayout ^ mStackFromEnd) {
            int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        } else {
            int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        }
    }
    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);
    if (!state.isPreLayout()) {
        mOrientationHelper.onLayoutComplete();
    } else {
        mAnchorInfo.reset();
    }
    mLastStackFromEnd = mStackFromEnd;
    if (DEBUG) {
        validateChildOrder();
    }
}
#method_after
@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    // create layout state
    if (DEBUG) {
        Log.d(TAG, "is pre layout:" + state.isPreLayout());
    }
    if (mPendingSavedState != null || mPendingScrollPosition != RecyclerView.NO_POSITION) {
        if (state.getItemCount() == 0) {
            removeAndRecycleAllViews(recycler);
            return;
        }
    }
    if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
        mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
    }
    ensureLayoutState();
    mLayoutState.mRecycle = false;
    // resolve layout direction
    resolveShouldLayoutReverse();
    final View focused = getFocusedChild();
    if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION || mPendingSavedState != null) {
        mAnchorInfo.reset();
        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
        // calculate anchor position and coordinate
        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
        mAnchorInfo.mValid = true;
    } else if (focused != null && (mOrientationHelper.getDecoratedStart(focused) >= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(focused) <= mOrientationHelper.getStartAfterPadding())) {
        // This case relates to when the anchor child is the focused view and due to layout
        // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows
        // up after tapping an EditText which shrinks RV causing the focused view (The tapped
        // EditText which is the anchor child) to get kicked out of the screen. Will update the
        // anchor coordinate in order to make sure that the focused view is laid out. Otherwise,
        // the available space in layoutState will be calculated as negative preventing the
        // focused view from being laid out in fill.
        // Note that we won't update the anchor position between layout passes (refer to
        // TestResizingRelayoutWithAutoMeasure), which happens if we were to call
        // updateAnchorInfoForLayout for an anchor that's not the focused view (e.g. a reference
        // child which can change between layout passes).
        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
    }
    if (DEBUG) {
        Log.d(TAG, "Anchor info:" + mAnchorInfo);
    }
    // LLM may decide to layout items for "extra" pixels to account for scrolling target,
    // caching or predictive animations.
    mLayoutState.mLayoutDirection = mLayoutState.mLastScrollDelta >= 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
    mReusableIntPair[0] = 0;
    mReusableIntPair[1] = 0;
    calculateExtraLayoutSpace(state, mReusableIntPair);
    int extraForStart = Math.max(0, mReusableIntPair[0]) + mOrientationHelper.getStartAfterPadding();
    int extraForEnd = Math.max(0, mReusableIntPair[1]) + mOrientationHelper.getEndPadding();
    if (state.isPreLayout() && mPendingScrollPosition != RecyclerView.NO_POSITION && mPendingScrollPositionOffset != INVALID_OFFSET) {
        // if the child is visible and we are going to move it around, we should layout
        // extra items in the opposite direction to make sure new items animate nicely
        // instead of just fading in
        final View existing = findViewByPosition(mPendingScrollPosition);
        if (existing != null) {
            final int current;
            final int upcomingOffset;
            if (mShouldReverseLayout) {
                current = mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(existing);
                upcomingOffset = current - mPendingScrollPositionOffset;
            } else {
                current = mOrientationHelper.getDecoratedStart(existing) - mOrientationHelper.getStartAfterPadding();
                upcomingOffset = mPendingScrollPositionOffset - current;
            }
            if (upcomingOffset > 0) {
                extraForStart += upcomingOffset;
            } else {
                extraForEnd -= upcomingOffset;
            }
        }
    }
    int startOffset;
    int endOffset;
    final int firstLayoutDirection;
    if (mAnchorInfo.mLayoutFromEnd) {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL : LayoutState.ITEM_DIRECTION_HEAD;
    } else {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL;
    }
    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
    detachAndScrapAttachedViews(recycler);
    mLayoutState.mInfinite = resolveIsInfinite();
    mLayoutState.mIsPreLayout = state.isPreLayout();
    // noRecycleSpace not needed: recycling doesn't happen in below's fill
    // invocations because mScrollingOffset is set to SCROLLING_OFFSET_NaN
    mLayoutState.mNoRecycleSpace = 0;
    if (mAnchorInfo.mLayoutFromEnd) {
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtraFillSpace = extraForStart;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;
        final int firstElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForEnd += mLayoutState.mAvailable;
        }
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtraFillSpace = extraForEnd;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
        if (mLayoutState.mAvailable > 0) {
            // end could not consume all. add more items towards start
            extraForStart = mLayoutState.mAvailable;
            updateLayoutStateToFillStart(firstElement, startOffset);
            mLayoutState.mExtraFillSpace = extraForStart;
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
        }
    } else {
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtraFillSpace = extraForEnd;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
        final int lastElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForStart += mLayoutState.mAvailable;
        }
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtraFillSpace = extraForStart;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;
        if (mLayoutState.mAvailable > 0) {
            extraForEnd = mLayoutState.mAvailable;
            // start could not consume all it should. add more items towards end
            updateLayoutStateToFillEnd(lastElement, endOffset);
            mLayoutState.mExtraFillSpace = extraForEnd;
            fill(recycler, mLayoutState, state, false);
            endOffset = mLayoutState.mOffset;
        }
    }
    // changed
    if (getChildCount() > 0) {
        // find which side we should check for gaps.
        if (mShouldReverseLayout ^ mStackFromEnd) {
            int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        } else {
            int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        }
    }
    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);
    if (!state.isPreLayout()) {
        mOrientationHelper.onLayoutComplete();
    } else {
        mAnchorInfo.reset();
    }
    mLastStackFromEnd = mStackFromEnd;
    if (DEBUG) {
        validateChildOrder();
    }
}
#end_block

#method_before
private void layoutForPredictiveAnimations(RecyclerView.Recycler recycler, RecyclerView.State state, int startOffset, int endOffset) {
    // another view out of bounds.
    if (!state.willRunPredictiveAnimations() || getChildCount() == 0 || state.isPreLayout() || !supportsPredictiveItemAnimations()) {
        return;
    }
    // to make the logic simpler, we calculate the size of children and call fill.
    int scrapExtraStart = 0, scrapExtraEnd = 0;
    final List<RecyclerView.ViewHolder> scrapList = recycler.getScrapList();
    final int scrapSize = scrapList.size();
    final int firstChildPos = getPosition(getChildAt(0));
    for (int i = 0; i < scrapSize; i++) {
        RecyclerView.ViewHolder scrap = scrapList.get(i);
        if (scrap.isRemoved()) {
            continue;
        }
        final int position = scrap.getLayoutPosition();
        final int direction = position < firstChildPos != mShouldReverseLayout ? LayoutState.LAYOUT_START : LayoutState.LAYOUT_END;
        if (direction == LayoutState.LAYOUT_START) {
            scrapExtraStart += mOrientationHelper.getDecoratedMeasurement(scrap.itemView);
        } else {
            scrapExtraEnd += mOrientationHelper.getDecoratedMeasurement(scrap.itemView);
        }
    }
    if (DEBUG) {
        Log.d(TAG, "for unused scrap, decided to add " + scrapExtraStart + " towards start and " + scrapExtraEnd + " towards end");
    }
    mLayoutState.mScrapList = scrapList;
    if (scrapExtraStart > 0) {
        View anchor = getChildClosestToStart();
        updateLayoutStateToFillStart(getPosition(anchor), startOffset);
        mLayoutState.mExtra = scrapExtraStart;
        mLayoutState.mAvailable = 0;
        mLayoutState.assignPositionFromScrapList();
        fill(recycler, mLayoutState, state, false);
    }
    if (scrapExtraEnd > 0) {
        View anchor = getChildClosestToEnd();
        updateLayoutStateToFillEnd(getPosition(anchor), endOffset);
        mLayoutState.mExtra = scrapExtraEnd;
        mLayoutState.mAvailable = 0;
        mLayoutState.assignPositionFromScrapList();
        fill(recycler, mLayoutState, state, false);
    }
    mLayoutState.mScrapList = null;
}
#method_after
private void layoutForPredictiveAnimations(RecyclerView.Recycler recycler, RecyclerView.State state, int startOffset, int endOffset) {
    // another view out of bounds.
    if (!state.willRunPredictiveAnimations() || getChildCount() == 0 || state.isPreLayout() || !supportsPredictiveItemAnimations()) {
        return;
    }
    // to make the logic simpler, we calculate the size of children and call fill.
    int scrapExtraStart = 0, scrapExtraEnd = 0;
    final List<RecyclerView.ViewHolder> scrapList = recycler.getScrapList();
    final int scrapSize = scrapList.size();
    final int firstChildPos = getPosition(getChildAt(0));
    for (int i = 0; i < scrapSize; i++) {
        RecyclerView.ViewHolder scrap = scrapList.get(i);
        if (scrap.isRemoved()) {
            continue;
        }
        final int position = scrap.getLayoutPosition();
        final int direction = position < firstChildPos != mShouldReverseLayout ? LayoutState.LAYOUT_START : LayoutState.LAYOUT_END;
        if (direction == LayoutState.LAYOUT_START) {
            scrapExtraStart += mOrientationHelper.getDecoratedMeasurement(scrap.itemView);
        } else {
            scrapExtraEnd += mOrientationHelper.getDecoratedMeasurement(scrap.itemView);
        }
    }
    if (DEBUG) {
        Log.d(TAG, "for unused scrap, decided to add " + scrapExtraStart + " towards start and " + scrapExtraEnd + " towards end");
    }
    mLayoutState.mScrapList = scrapList;
    if (scrapExtraStart > 0) {
        View anchor = getChildClosestToStart();
        updateLayoutStateToFillStart(getPosition(anchor), startOffset);
        mLayoutState.mExtraFillSpace = scrapExtraStart;
        mLayoutState.mAvailable = 0;
        mLayoutState.assignPositionFromScrapList();
        fill(recycler, mLayoutState, state, false);
    }
    if (scrapExtraEnd > 0) {
        View anchor = getChildClosestToEnd();
        updateLayoutStateToFillEnd(getPosition(anchor), endOffset);
        mLayoutState.mExtraFillSpace = scrapExtraEnd;
        mLayoutState.mAvailable = 0;
        mLayoutState.assignPositionFromScrapList();
        fill(recycler, mLayoutState, state, false);
    }
    mLayoutState.mScrapList = null;
}
#end_block

#method_before
private void updateLayoutState(int layoutDirection, int requiredSpace, boolean canUseExistingSpace, RecyclerView.State state) {
    // If parent provides a hint, don't measure unlimited.
    mLayoutState.mInfinite = resolveIsInfinite();
    boolean layoutToEnd = layoutDirection == LayoutState.LAYOUT_END;
    mReusableIntPair[0] = 0;
    mReusableIntPair[1] = 0;
    calculateExtraLayoutSpace(state, layoutDirection, mReusableIntPair);
    mLayoutState.mExtra = layoutToEnd ? mReusableIntPair[1] : mReusableIntPair[0];
    mLayoutState.mExtra2 = layoutToEnd ? mReusableIntPair[0] : mReusableIntPair[1];
    mLayoutState.mLayoutDirection = layoutDirection;
    int scrollingOffset;
    if (layoutToEnd) {
        mLayoutState.mExtra += mOrientationHelper.getEndPadding();
        // get the first child in the direction we are going
        final View child = getChildClosestToEnd();
        // the direction in which we are traversing children
        mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL;
        mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;
        mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);
        // calculate how much we can scroll without adding new children (independent of layout)
        scrollingOffset = mOrientationHelper.getDecoratedEnd(child) - mOrientationHelper.getEndAfterPadding();
    } else {
        final View child = getChildClosestToStart();
        mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();
        mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL : LayoutState.ITEM_DIRECTION_HEAD;
        mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;
        mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);
        scrollingOffset = -mOrientationHelper.getDecoratedStart(child) + mOrientationHelper.getStartAfterPadding();
    }
    mLayoutState.mAvailable = requiredSpace;
    if (canUseExistingSpace) {
        mLayoutState.mAvailable -= scrollingOffset;
    }
    mLayoutState.mScrollingOffset = scrollingOffset;
}
#method_after
private void updateLayoutState(int layoutDirection, int requiredSpace, boolean canUseExistingSpace, RecyclerView.State state) {
    // If parent provides a hint, don't measure unlimited.
    mLayoutState.mInfinite = resolveIsInfinite();
    mLayoutState.mLayoutDirection = layoutDirection;
    mReusableIntPair[0] = 0;
    mReusableIntPair[1] = 0;
    calculateExtraLayoutSpace(state, mReusableIntPair);
    int extraForStart = Math.max(0, mReusableIntPair[0]);
    int extraForEnd = Math.max(0, mReusableIntPair[1]);
    boolean layoutToEnd = layoutDirection == LayoutState.LAYOUT_END;
    mLayoutState.mExtraFillSpace = layoutToEnd ? extraForEnd : extraForStart;
    mLayoutState.mNoRecycleSpace = layoutToEnd ? extraForStart : extraForEnd;
    int scrollingOffset;
    if (layoutToEnd) {
        mLayoutState.mExtraFillSpace += mOrientationHelper.getEndPadding();
        // get the first child in the direction we are going
        final View child = getChildClosestToEnd();
        // the direction in which we are traversing children
        mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL;
        mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;
        mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);
        // calculate how much we can scroll without adding new children (independent of layout)
        scrollingOffset = mOrientationHelper.getDecoratedEnd(child) - mOrientationHelper.getEndAfterPadding();
    } else {
        final View child = getChildClosestToStart();
        mLayoutState.mExtraFillSpace += mOrientationHelper.getStartAfterPadding();
        mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL : LayoutState.ITEM_DIRECTION_HEAD;
        mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;
        mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);
        scrollingOffset = -mOrientationHelper.getDecoratedStart(child) + mOrientationHelper.getStartAfterPadding();
    }
    mLayoutState.mAvailable = requiredSpace;
    if (canUseExistingSpace) {
        mLayoutState.mAvailable -= scrollingOffset;
    }
    mLayoutState.mScrollingOffset = scrollingOffset;
}
#end_block

#method_before
private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt, int extraLayoutSpace) {
    if (dt < 0) {
        if (DEBUG) {
            Log.d(TAG, "Called recycle from start with a negative value. This might happen" + " during layout changes but may be sign of a bug");
        }
        return;
    }
    // ignore padding, ViewGroup may not clip children.
    final int limit = dt - extraLayoutSpace;
    final int childCount = getChildCount();
    if (mShouldReverseLayout) {
        for (int i = childCount - 1; i >= 0; i--) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedEnd(child) > limit || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {
                // stop here
                recycleChildren(recycler, childCount - 1, i);
                return;
            }
        }
    } else {
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedEnd(child) > limit || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {
                // stop here
                recycleChildren(recycler, 0, i);
                return;
            }
        }
    }
}
#method_after
private void recycleViewsFromStart(RecyclerView.Recycler recycler, int scrollingOffset, int noRecycleSpace) {
    if (scrollingOffset < 0) {
        if (DEBUG) {
            Log.d(TAG, "Called recycle from start with a negative value. This might happen" + " during layout changes but may be sign of a bug");
        }
        return;
    }
    // ignore padding, ViewGroup may not clip children.
    final int limit = scrollingOffset - noRecycleSpace;
    final int childCount = getChildCount();
    if (mShouldReverseLayout) {
        for (int i = childCount - 1; i >= 0; i--) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedEnd(child) > limit || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {
                // stop here
                recycleChildren(recycler, childCount - 1, i);
                return;
            }
        }
    } else {
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedEnd(child) > limit || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {
                // stop here
                recycleChildren(recycler, 0, i);
                return;
            }
        }
    }
}
#end_block

#method_before
private void recycleViewsFromEnd(RecyclerView.Recycler recycler, int dt, int extraLayoutSpace) {
    final int childCount = getChildCount();
    if (dt < 0) {
        if (DEBUG) {
            Log.d(TAG, "Called recycle from end with a negative value. This might happen" + " during layout changes but may be sign of a bug");
        }
        return;
    }
    final int limit = mOrientationHelper.getEnd() - dt + extraLayoutSpace;
    if (mShouldReverseLayout) {
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedStart(child) < limit || mOrientationHelper.getTransformedStartWithDecoration(child) < limit) {
                // stop here
                recycleChildren(recycler, 0, i);
                return;
            }
        }
    } else {
        for (int i = childCount - 1; i >= 0; i--) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedStart(child) < limit || mOrientationHelper.getTransformedStartWithDecoration(child) < limit) {
                // stop here
                recycleChildren(recycler, childCount - 1, i);
                return;
            }
        }
    }
}
#method_after
private void recycleViewsFromEnd(RecyclerView.Recycler recycler, int scrollingOffset, int noRecycleSpace) {
    final int childCount = getChildCount();
    if (scrollingOffset < 0) {
        if (DEBUG) {
            Log.d(TAG, "Called recycle from end with a negative value. This might happen" + " during layout changes but may be sign of a bug");
        }
        return;
    }
    final int limit = mOrientationHelper.getEnd() - scrollingOffset + noRecycleSpace;
    if (mShouldReverseLayout) {
        for (int i = 0; i < childCount; i++) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedStart(child) < limit || mOrientationHelper.getTransformedStartWithDecoration(child) < limit) {
                // stop here
                recycleChildren(recycler, 0, i);
                return;
            }
        }
    } else {
        for (int i = childCount - 1; i >= 0; i--) {
            View child = getChildAt(i);
            if (mOrientationHelper.getDecoratedStart(child) < limit || mOrientationHelper.getTransformedStartWithDecoration(child) < limit) {
                // stop here
                recycleChildren(recycler, childCount - 1, i);
                return;
            }
        }
    }
}
#end_block

#method_before
private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {
    if (!layoutState.mRecycle || layoutState.mInfinite) {
        return;
    }
    if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
        recycleViewsFromEnd(recycler, layoutState.mScrollingOffset, layoutState.mExtra2);
    } else {
        recycleViewsFromStart(recycler, layoutState.mScrollingOffset, layoutState.mExtra2);
    }
}
#method_after
private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {
    if (!layoutState.mRecycle || layoutState.mInfinite) {
        return;
    }
    int scrollingOffset = layoutState.mScrollingOffset;
    int noRecycleSpace = layoutState.mNoRecycleSpace;
    if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
        recycleViewsFromEnd(recycler, scrollingOffset, noRecycleSpace);
    } else {
        recycleViewsFromStart(recycler, scrollingOffset, noRecycleSpace);
    }
}
#end_block

#method_before
int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) {
    // max offset we should set is mFastScroll + available
    final int start = layoutState.mAvailable;
    if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
        // TODO ugly bug fix. should not happen
        if (layoutState.mAvailable < 0) {
            layoutState.mScrollingOffset += layoutState.mAvailable;
        }
        recycleByLayoutState(recycler, layoutState);
    }
    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
    while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {
        layoutChunkResult.resetInternal();
        if (RecyclerView.VERBOSE_TRACING) {
            TraceCompat.beginSection("LLM LayoutChunk");
        }
        layoutChunk(recycler, state, layoutState, layoutChunkResult);
        if (RecyclerView.VERBOSE_TRACING) {
            TraceCompat.endSection();
        }
        if (layoutChunkResult.mFinished) {
            break;
        }
        layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
        /**
         * Consume the available space if:
         * * layoutChunk did not request to be ignored
         * * OR we are laying out scrap children
         * * OR we are not doing pre-layout
         */
        if (!layoutChunkResult.mIgnoreConsumed || layoutState.mScrapList != null || !state.isPreLayout()) {
            layoutState.mAvailable -= layoutChunkResult.mConsumed;
            // we keep a separate remaining space because mAvailable is important for recycling
            remainingSpace -= layoutChunkResult.mConsumed;
        }
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            layoutState.mScrollingOffset += layoutChunkResult.mConsumed;
            if (layoutState.mAvailable < 0) {
                layoutState.mScrollingOffset += layoutState.mAvailable;
            }
            recycleByLayoutState(recycler, layoutState);
        }
        if (stopOnFocusable && layoutChunkResult.mFocusable) {
            break;
        }
    }
    if (DEBUG) {
        validateChildOrder();
    }
    return start - layoutState.mAvailable;
}
#method_after
int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) {
    // max offset we should set is mFastScroll + available
    final int start = layoutState.mAvailable;
    if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
        // TODO ugly bug fix. should not happen
        if (layoutState.mAvailable < 0) {
            layoutState.mScrollingOffset += layoutState.mAvailable;
        }
        recycleByLayoutState(recycler, layoutState);
    }
    int remainingSpace = layoutState.mAvailable + layoutState.mExtraFillSpace;
    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
    while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {
        layoutChunkResult.resetInternal();
        if (RecyclerView.VERBOSE_TRACING) {
            TraceCompat.beginSection("LLM LayoutChunk");
        }
        layoutChunk(recycler, state, layoutState, layoutChunkResult);
        if (RecyclerView.VERBOSE_TRACING) {
            TraceCompat.endSection();
        }
        if (layoutChunkResult.mFinished) {
            break;
        }
        layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
        /**
         * Consume the available space if:
         * * layoutChunk did not request to be ignored
         * * OR we are laying out scrap children
         * * OR we are not doing pre-layout
         */
        if (!layoutChunkResult.mIgnoreConsumed || layoutState.mScrapList != null || !state.isPreLayout()) {
            layoutState.mAvailable -= layoutChunkResult.mConsumed;
            // we keep a separate remaining space because mAvailable is important for recycling
            remainingSpace -= layoutChunkResult.mConsumed;
        }
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            layoutState.mScrollingOffset += layoutChunkResult.mConsumed;
            if (layoutState.mAvailable < 0) {
                layoutState.mScrollingOffset += layoutState.mAvailable;
            }
            recycleByLayoutState(recycler, layoutState);
        }
        if (stopOnFocusable && layoutChunkResult.mFocusable) {
            break;
        }
    }
    if (DEBUG) {
        validateChildOrder();
    }
    return start - layoutState.mAvailable;
}
#end_block

#method_before
@Override
public void onPackageAdded(String packageName, int uid) {
    final PackageInfo app = getPackageInfo(packageName);
    if (app == null) {
        Slog.wtf(TAG, "Failed to get information of installed package: " + packageName);
        return;
    }
    if (uid == INVALID_UID) {
        Slog.wtf(TAG, "Failed to get the uid of installed package: " + packageName + "uid: " + uid);
        return;
    }
    if (app.requestedPermissions == null) {
        return;
    }
    sendPackagePermissionsForUid(uid, getNetdPermissionMask(app.requestedPermissions));
}
#method_after
@Override
public void onPackageAdded(String packageName, int uid) {
    sendPackagePermissionsForUid(uid, getPermissionForUid(uid));
}
#end_block

#method_before
@Override
public void onPackageRemoved(String packageName, int uid) {
    int permission = 0;
    // If there are still packages remain under the same uid, check the permission of the
    // remaining packages. We only remove the permission for a given uid when all packages
    // for that uid no longer have that permission.
    String[] packages = mPackageManager.getPackagesForUid(uid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            final PackageInfo app = getPackageInfo(name);
            if (app != null && app.requestedPermissions != null) {
                permission |= getNetdPermissionMask(app.requestedPermissions);
            }
        }
    }
    sendPackagePermissionsForUid(uid, permission);
}
#method_after
@Override
public void onPackageRemoved(String packageName, int uid) {
    sendPackagePermissionsForUid(uid, getPermissionForUid(uid));
}
#end_block

#method_before
// Intended to be called only once at startup, after the system is ready. Installs a broadcast
public synchronized void startMonitoring() {
    log("Monitoring");
    setupObserver();
    List<PackageInfo> apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS | MATCH_ANY_USER);
    if (apps == null) {
        loge("No apps");
        return;
    }
    SparseIntArray netdPermsUids = new SparseIntArray();
    for (PackageInfo app : apps) {
        int uid = app.applicationInfo != null ? app.applicationInfo.uid : INVALID_UID;
        if (uid < 0) {
            continue;
        }
        boolean isNetwork = hasNetworkPermission(app);
        boolean hasRestrictedPermission = hasRestrictedNetworkPermission(app);
        if (isNetwork || hasRestrictedPermission) {
            Boolean permission = mApps.get(uid);
            // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
            if (permission == null || permission == NETWORK) {
                mApps.put(uid, hasRestrictedPermission);
            }
        }
        // TODO: unify the management of the permissions into one codepath.
        if (app.requestedPermissions != null) {
            int otherNetdPerms = getNetdPermissionMask(app.requestedPermissions);
            if (otherNetdPerms != 0) {
                netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);
            }
        }
    }
    // exclude dying users
    List<UserInfo> users = mUserManager.getUsers(true);
    if (users != null) {
        for (UserInfo user : users) {
            mUsers.add(user.id);
        }
    }
    log("Users: " + mUsers.size() + ", Apps: " + mApps.size());
    update(mUsers, mApps, true);
    sendPackagePermissionsToNetd(netdPermsUids);
}
#method_after
// Intended to be called only once at startup, after the system is ready. Installs a broadcast
public synchronized void startMonitoring() {
    log("Monitoring");
    PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
    if (pmi != null) {
        pmi.getPackageList(new PackageListObserver());
    } else {
        loge("failed to get the PackageManagerInternal service");
    }
    List<PackageInfo> apps = mPackageManager.getInstalledPackages(GET_PERMISSIONS | MATCH_ANY_USER);
    if (apps == null) {
        loge("No apps");
        return;
    }
    SparseIntArray netdPermsUids = new SparseIntArray();
    for (PackageInfo app : apps) {
        int uid = app.applicationInfo != null ? app.applicationInfo.uid : INVALID_UID;
        if (uid < 0) {
            continue;
        }
        boolean isNetwork = hasNetworkPermission(app);
        boolean hasRestrictedPermission = hasRestrictedNetworkPermission(app);
        if (isNetwork || hasRestrictedPermission) {
            Boolean permission = mApps.get(uid);
            // permissions, don't downgrade (i.e., if it's already SYSTEM, leave it as is).
            if (permission == null || permission == NETWORK) {
                mApps.put(uid, hasRestrictedPermission);
            }
        }
        // TODO: unify the management of the permissions into one codepath.
        int otherNetdPerms = getNetdPermissionMask(app.requestedPermissions, app.requestedPermissionsFlags);
        netdPermsUids.put(uid, netdPermsUids.get(uid) | otherNetdPerms);
    }
    // exclude dying users
    List<UserInfo> users = mUserManager.getUsers(true);
    if (users != null) {
        for (UserInfo user : users) {
            mUsers.add(user.id);
        }
    }
    final SparseArray<ArraySet<String>> systemPermission = SystemConfig.getInstance().getSystemPermissions();
    for (int i = 0; i < systemPermission.size(); i++) {
        ArraySet<String> perms = systemPermission.valueAt(i);
        int uid = systemPermission.keyAt(i);
        int netdPermission = 0;
        // Get the uids of native services that have UPDATE_DEVICE_STATS permission.
        if (perms != null) {
            netdPermission |= perms.contains(UPDATE_DEVICE_STATS) ? INetd.PERMISSION_UPDATE_DEVICE_STATS : 0;
        }
        // For internet permission, the native services have their own selinux domains and
        // sepolicy will control the socket creation during run time. netd cannot block the
        // socket creation based on the permission information here.
        netdPermission |= INetd.PERMISSION_INTERNET;
        netdPermsUids.put(uid, netdPermsUids.get(uid) | netdPermission);
    }
    log("Users: " + mUsers.size() + ", Apps: " + mApps.size());
    update(mUsers, mApps, true);
    sendPackagePermissionsToNetd(netdPermsUids);
}
#end_block

#method_before
private static int getNetdPermissionMask(String[] requestedPermissions) {
    int permissions = 0;
    for (String permissionName : requestedPermissions) {
        if (permissionName.equals(INTERNET)) {
            permissions |= INetd.PERMISSION_INTERNET;
        }
        if (permissionName.equals(UPDATE_DEVICE_STATS)) {
            permissions |= INetd.PERMISSION_UPDATE_DEVICE_STATS;
        }
    }
    return permissions;
}
#method_after
private static int getNetdPermissionMask(String[] requestedPermissions, int[] requestedPermissionsFlags) {
    int permissions = 0;
    if (requestedPermissions == null || requestedPermissionsFlags == null)
        return permissions;
    for (int i = 0; i < requestedPermissions.length; i++) {
        if (requestedPermissions[i].equals(INTERNET) && ((requestedPermissionsFlags[i] & REQUESTED_PERMISSION_GRANTED) != 0)) {
            permissions |= INetd.PERMISSION_INTERNET;
        }
        if (requestedPermissions[i].equals(UPDATE_DEVICE_STATS) && ((requestedPermissionsFlags[i] & REQUESTED_PERMISSION_GRANTED) != 0)) {
            permissions |= INetd.PERMISSION_UPDATE_DEVICE_STATS;
        }
    }
    return permissions;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mContext.getPackageManager()).thenReturn(mPackageManager);
    mPermissionMonitor = spy(new PermissionMonitor(mContext, mNMS, mNetdService));
    LocalServices.removeServiceForTest(PackageManagerInternal.class);
    LocalServices.addService(PackageManagerInternal.class, mMockPmi);
    when(mMockPmi.getPackageList(any())).thenReturn(new PackageList(new ArrayList<String>(), /* observer */
    null));
    mPermissionMonitor.setupObserver();
    final ArgumentCaptor<PackageManagerInternal.PackageListObserver> observerCaptor = ArgumentCaptor.forClass(PackageManagerInternal.PackageListObserver.class);
    verify(mMockPmi).getPackageList(observerCaptor.capture());
    mObserver = observerCaptor.getValue();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mContext.getPackageManager()).thenReturn(mPackageManager);
    mPermissionMonitor = spy(new PermissionMonitor(mContext, mNMS, mNetdService));
    LocalServices.removeServiceForTest(PackageManagerInternal.class);
    LocalServices.addService(PackageManagerInternal.class, mMockPmi);
    when(mMockPmi.getPackageList(any())).thenReturn(new PackageList(new ArrayList<String>(), /* observer */
    null));
    when(mPackageManager.getInstalledPackages(anyInt())).thenReturn(/* empty app list */
    null);
    mPermissionMonitor.startMonitoring();
    final ArgumentCaptor<PackageManagerInternal.PackageListObserver> observerCaptor = ArgumentCaptor.forClass(PackageManagerInternal.PackageListObserver.class);
    verify(mMockPmi).getPackageList(observerCaptor.capture());
    mObserver = observerCaptor.getValue();
}
#end_block

#method_before
private PackageInfo packageInfoWithPermissions(String[] permissions, String partition) {
    final PackageInfo packageInfo = new PackageInfo();
    packageInfo.requestedPermissions = permissions;
    packageInfo.applicationInfo = new ApplicationInfo();
    int privateFlags = 0;
    switch(partition) {
        case PARTITION_OEM:
            privateFlags = PRIVATE_FLAG_OEM;
            break;
        case PARTITION_PRODUCT:
            privateFlags = PRIVATE_FLAG_PRODUCT;
            break;
        case PARTITION_VENDOR:
            privateFlags = PRIVATE_FLAG_VENDOR;
            break;
    }
    packageInfo.applicationInfo.privateFlags = privateFlags;
    return packageInfo;
}
#method_after
private PackageInfo packageInfoWithPermissions(String[] permissions, String partition) {
    int[] requestedPermissionsFlags = new int[permissions.length];
    for (int i = 0; i < permissions.length; i++) {
        requestedPermissionsFlags[i] = REQUESTED_PERMISSION_GRANTED;
    }
    return packageInfoWithPermissions(permissions, partition, requestedPermissionsFlags);
}
#end_block

#method_before
private PackageInfo packageInfoWithPermissions(String[] permissions, String partition) {
    final PackageInfo packageInfo = new PackageInfo();
    packageInfo.requestedPermissions = permissions;
    packageInfo.applicationInfo = new ApplicationInfo();
    int privateFlags = 0;
    switch(partition) {
        case PARTITION_OEM:
            privateFlags = PRIVATE_FLAG_OEM;
            break;
        case PARTITION_PRODUCT:
            privateFlags = PRIVATE_FLAG_PRODUCT;
            break;
        case PARTITION_VENDOR:
            privateFlags = PRIVATE_FLAG_VENDOR;
            break;
    }
    packageInfo.applicationInfo.privateFlags = privateFlags;
    return packageInfo;
}
#method_after
private PackageInfo packageInfoWithPermissions(String[] permissions, String partition, int[] requestedPermissionsFlags) {
    final PackageInfo packageInfo = new PackageInfo();
    packageInfo.requestedPermissions = permissions;
    packageInfo.applicationInfo = new ApplicationInfo();
    packageInfo.requestedPermissionsFlags = requestedPermissionsFlags;
    int privateFlags = 0;
    switch(partition) {
        case PARTITION_OEM:
            privateFlags = PRIVATE_FLAG_OEM;
            break;
        case PARTITION_PRODUCT:
            privateFlags = PRIVATE_FLAG_PRODUCT;
            break;
        case PARTITION_VENDOR:
            privateFlags = PRIVATE_FLAG_VENDOR;
            break;
    }
    packageInfo.applicationInfo.privateFlags = privateFlags;
    return packageInfo;
}
#end_block

#method_before
public void expectPermission(int permission, int[] apps) {
    for (final int app : apps) {
        if (!mPermissions.containsKey(app)) {
            fail("uid " + app + " does not exist.");
        }
        if (mPermissions.get(app) != permission) {
            fail("uid " + app + " has wrong permission: " + permission);
        }
    }
}
#method_after
public void expectPermission(int permission, int[] apps) {
    for (final int app : apps) {
        if (!mPermissions.containsKey(app)) {
            fail("uid " + app + " does not exist.");
        }
        if (mPermissions.get(app) != permission) {
            fail("uid " + app + " has wrong permission: " + mPermissions.get(app));
        }
    }
}
#end_block

#method_before
@Test
public void testPackagePermissionUpdate() throws Exception {
    final NetdServiceMonitor mNetdServiceMonitor = new NetdServiceMonitor(mNetdService);
    // MOCK_UID1: MOCK_PACKAGE1 only has internet permission.
    // MOCK_UID2: MOCK_PACKAGE2 does not have any permission.
    // SYSTEM_UID1: SYSTEM_PACKAGE1 has internet permission and update device stats permission.
    // SYSTEM_UID2: SYSTEM_PACKAGE2 has only update device stats permission.
    SparseIntArray netdPermissionsAppIds = new SparseIntArray();
    netdPermissionsAppIds.put(MOCK_UID1, INetd.PERMISSION_INTERNET);
    netdPermissionsAppIds.put(MOCK_UID2, INetd.NO_PERMISSIONS);
    netdPermissionsAppIds.put(SYSTEM_UID1, INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS);
    netdPermissionsAppIds.put(SYSTEM_UID2, INetd.PERMISSION_UPDATE_DEVICE_STATS);
    // Send the permission information to netd, expect permission updated.
    mPermissionMonitor.sendPackagePermissionsToNetd(netdPermissionsAppIds);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { MOCK_UID1 });
    mNetdServiceMonitor.expectPermission(INetd.NO_PERMISSIONS, new int[] { MOCK_UID2 });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { SYSTEM_UID1 });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { SYSTEM_UID2 });
    // Update permission of MOCK_UID1, expect new permission show up.
    mPermissionMonitor.sendPackagePermissionsForUid(MOCK_UID1, INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { MOCK_UID1 });
    // Change permissions of SYSTE_UID2, expect new permission show up and old permission
    // revoked.
    mPermissionMonitor.sendPackagePermissionsForUid(SYSTEM_UID2, INetd.PERMISSION_INTERNET);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { SYSTEM_UID2 });
    // Revoke permission from SYSTEM_UID1, expect no permission stored.
    mPermissionMonitor.sendPackagePermissionsForUid(SYSTEM_UID1, INetd.NO_PERMISSIONS);
    mNetdServiceMonitor.expectPermission(INetd.NO_PERMISSIONS, new int[] { SYSTEM_UID1 });
}
#method_after
@Test
public void testPackagePermissionUpdate() throws Exception {
    final NetdServiceMonitor mNetdServiceMonitor = new NetdServiceMonitor(mNetdService);
    // MOCK_UID1: MOCK_PACKAGE1 only has internet permission.
    // MOCK_UID2: MOCK_PACKAGE2 does not have any permission.
    // SYSTEM_UID1: SYSTEM_PACKAGE1 has internet permission and update device stats permission.
    // SYSTEM_UID2: SYSTEM_PACKAGE2 has only update device stats permission.
    SparseIntArray netdPermissionsAppIds = new SparseIntArray();
    netdPermissionsAppIds.put(MOCK_UID1, INetd.PERMISSION_INTERNET);
    netdPermissionsAppIds.put(MOCK_UID2, INetd.NO_PERMISSIONS);
    netdPermissionsAppIds.put(SYSTEM_UID1, INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS);
    netdPermissionsAppIds.put(SYSTEM_UID2, INetd.PERMISSION_UPDATE_DEVICE_STATS);
    // Send the permission information to netd, expect permission updated.
    mPermissionMonitor.sendPackagePermissionsToNetd(netdPermissionsAppIds);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { MOCK_UID1 });
    mNetdServiceMonitor.expectPermission(INetd.NO_PERMISSIONS, new int[] { MOCK_UID2 });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { SYSTEM_UID1 });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { SYSTEM_UID2 });
    // Update permission of MOCK_UID1, expect new permission show up.
    mPermissionMonitor.sendPackagePermissionsForUid(MOCK_UID1, INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { MOCK_UID1 });
    // Change permissions of SYSTEM_UID2, expect new permission show up and old permission
    // revoked.
    mPermissionMonitor.sendPackagePermissionsForUid(SYSTEM_UID2, INetd.PERMISSION_INTERNET);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { SYSTEM_UID2 });
    // Revoke permission from SYSTEM_UID1, expect no permission stored.
    mPermissionMonitor.sendPackagePermissionsForUid(SYSTEM_UID1, INetd.NO_PERMISSIONS);
    mNetdServiceMonitor.expectPermission(INetd.NO_PERMISSIONS, new int[] { SYSTEM_UID1 });
}
#end_block

#method_before
private void addPackage(String packageName, int uid, String[] permissions) throws Exception {
    PackageInfo packageInfo = packageInfoWithPermissions(permissions, PARTITION_SYSTEM);
    when(mPackageManager.getPackageInfo(eq(packageName), anyInt())).thenReturn(packageInfo);
    mObserver.onPackageAdded(packageName, uid);
}
#method_after
private PackageInfo addPackage(String packageName, int uid, String[] permissions) throws Exception {
    PackageInfo packageInfo = packageInfoWithPermissions(permissions, PARTITION_SYSTEM);
    when(mPackageManager.getPackageInfo(eq(packageName), anyInt())).thenReturn(packageInfo);
    when(mPackageManager.getPackagesForUid(eq(uid))).thenReturn(new String[] { packageName });
    mObserver.onPackageAdded(packageName, uid);
    return packageInfo;
}
#end_block

#method_before
@Test
public void testPackageInstall() throws Exception {
    final NetdServiceMonitor mNetdServiceMonitor = new NetdServiceMonitor(mNetdService);
    addPackage(MOCK_PACKAGE1, MOCK_UID1, new String[] { INTERNET, UPDATE_DEVICE_STATS });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { MOCK_UID1 });
    addPackage(MOCK_PACKAGE2, MOCK_UID2, new String[] { INTERNET });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { MOCK_UID2 });
    // Reinstall with different permission should override the previous one
    addPackage(MOCK_PACKAGE1, MOCK_UID1, new String[] {});
    mNetdServiceMonitor.expectPermission(INetd.NO_PERMISSIONS, new int[] { MOCK_UID1 });
}
#method_after
@Test
public void testPackageInstall() throws Exception {
    final NetdServiceMonitor mNetdServiceMonitor = new NetdServiceMonitor(mNetdService);
    addPackage(MOCK_PACKAGE1, MOCK_UID1, new String[] { INTERNET, UPDATE_DEVICE_STATS });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { MOCK_UID1 });
    addPackage(MOCK_PACKAGE2, MOCK_UID2, new String[] { INTERNET });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { MOCK_UID2 });
}
#end_block

#method_before
@Test
public void testPackageUninstallWithMultiplePackages() throws Exception {
    final NetdServiceMonitor mNetdServiceMonitor = new NetdServiceMonitor(mNetdService);
    addPackage(MOCK_PACKAGE1, MOCK_UID1, new String[] { INTERNET, UPDATE_DEVICE_STATS });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { MOCK_UID1 });
    // Mock another package with the same uid but different permissions.
    PackageInfo packageInfo = packageInfoWithPermissions(new String[] { INTERNET }, PARTITION_SYSTEM);
    when(mPackageManager.getPackageInfo(eq(MOCK_PACKAGE2), anyInt())).thenReturn(packageInfo);
    when(mPackageManager.getPackagesForUid(MOCK_UID1)).thenReturn(new String[] { MOCK_PACKAGE2 });
    mObserver.onPackageRemoved(MOCK_PACKAGE1, MOCK_UID1);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { MOCK_UID1 });
}
#method_after
@Test
public void testPackageUninstallWithMultiplePackages() throws Exception {
    final NetdServiceMonitor mNetdServiceMonitor = new NetdServiceMonitor(mNetdService);
    addPackage(MOCK_PACKAGE1, MOCK_UID1, new String[] { INTERNET, UPDATE_DEVICE_STATS });
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET | INetd.PERMISSION_UPDATE_DEVICE_STATS, new int[] { MOCK_UID1 });
    // Mock another package with the same uid but different permissions.
    PackageInfo packageInfo2 = packageInfoWithPermissions(new String[] { INTERNET }, PARTITION_SYSTEM);
    when(mPackageManager.getPackageInfo(eq(MOCK_PACKAGE2), anyInt())).thenReturn(packageInfo2);
    when(mPackageManager.getPackagesForUid(MOCK_UID1)).thenReturn(new String[] { MOCK_PACKAGE2 });
    mObserver.onPackageRemoved(MOCK_PACKAGE1, MOCK_UID1);
    mNetdServiceMonitor.expectPermission(INetd.PERMISSION_INTERNET, new int[] { MOCK_UID1 });
}
#end_block

#method_before
private void handleAlwaysOnNetworkRequest(NetworkRequest networkRequest, String settingName, boolean defaultValue) {
    final boolean enable = toBool(Settings.Global.getInt(mContext.getContentResolver(), settingName, encodeBool(defaultValue)));
    final boolean isEnabled = (mNetworkRequests.get(networkRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, networkRequest, new Binder()));
    } else {
        handleReleaseNetworkRequest(networkRequest, Process.SYSTEM_UID);
    }
}
#method_after
private void handleAlwaysOnNetworkRequest(NetworkRequest networkRequest, String settingName, boolean defaultValue) {
    final boolean enable = toBool(Settings.Global.getInt(mContext.getContentResolver(), settingName, encodeBool(defaultValue)));
    final boolean isEnabled = (mNetworkRequests.get(networkRequest) != null);
    if (enable == isEnabled) {
        // Nothing to do.
        return;
    }
    if (enable) {
        handleRegisterNetworkRequest(new NetworkRequestInfo(null, networkRequest, new Binder()));
    } else {
        handleReleaseNetworkRequest(networkRequest, Process.SYSTEM_UID, /* callOnUnavailable */
        false);
    }
}
#end_block

#method_before
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final NetworkCapabilities caps = getUnfilteredActiveNetworkState(uid).networkCapabilities;
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#method_after
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final NetworkCapabilities caps = getNetworkCapabilities(getActiveNetwork());
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#end_block

#method_before
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (LinkProperties.isValidMtu(mtu, newLp.hasGlobalIPv6Address()) == false) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG || DDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#method_after
private void updateMtu(LinkProperties newLp, LinkProperties oldLp) {
    final String iface = newLp.getInterfaceName();
    final int mtu = newLp.getMtu();
    if (oldLp == null && mtu == 0) {
        // Silently ignore unset MTU value.
        return;
    }
    if (oldLp != null && newLp.isIdenticalMtu(oldLp)) {
        if (VDBG)
            log("identical MTU - not setting");
        return;
    }
    if (!LinkProperties.isValidMtu(mtu, newLp.hasGlobalIpv6Address())) {
        if (mtu != 0)
            loge("Unexpected mtu value: " + mtu + ", " + iface);
        return;
    }
    // Cannot set MTU without interface name
    if (TextUtils.isEmpty(iface)) {
        loge("Setting MTU size with null iface.");
        return;
    }
    try {
        if (VDBG || DDBG)
            log("Setting MTU size: " + iface + ", " + mtu);
        mNMS.setMtu(iface, mtu);
    } catch (Exception e) {
        Slog.e(TAG, "exception in setMtu()" + e);
    }
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                updateNetworkScore(nai, msg.arg1);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = msg.arg1 == 1;
                break;
            }
        case NetworkAgent.EVENT_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventSocketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasConnectivityManagedCapability()) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                updateNetworkScore(nai, msg.arg1);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = msg.arg1 == 1;
                // Mark the network as temporarily accepting partial connectivity so that it
                // will be validated (and possibly become default) even if it only provides
                // partial internet access. Note that if user connects to partial connectivity
                // and choose "don't ask again", then wifi disconnected by some reasons(maybe
                // out of wifi coverage) and if the same wifi is available again, the device
                // will auto connect to this wifi even though the wifi has "no internet".
                // TODO: Evaluate using a separate setting in IpMemoryStore.
                nai.networkMisc.acceptPartialConnectivity = msg.arg1 == 1;
                break;
            }
        case NetworkAgent.EVENT_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventSocketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                if (nai.everCaptivePortalDetected && !nai.captivePortalLoginNotified && valid) {
                    nai.captivePortalLoginNotified = true;
                    showNetworkNotification(nai, NotificationType.LOGGED_IN);
                }
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid) {
                        handleFreshlyValidatedNetwork(nai);
                        // Clear NO_INTERNET and LOST_INTERNET notifications if network becomes
                        // valid.
                        mNotifier.clearNotification(nai.network.netId, NotificationType.NO_INTERNET);
                        mNotifier.clearNotification(nai.network.netId, NotificationType.LOST_INTERNET);
                    }
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (visible) {
                        nai.captivePortalLoginNotified = false;
                    }
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    // Only clear SIGN_IN and NETWORK_SWITCH notifications here, or else other
                    // notifications belong to the same network may be cleared unexpected.
                    mNotifier.clearNotification(netId, NotificationType.SIGN_IN);
                    mNotifier.clearNotification(netId, NotificationType.NETWORK_SWITCH);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean partialConnectivity = (msg.arg1 == NETWORK_TEST_RESULT_PARTIAL_CONNECTIVITY) || (nai.networkMisc.acceptPartialConnectivity && nai.partialConnectivity);
                // Once a network is determined to have partial connectivity, it cannot
                // go back to full connectivity without a disconnect. This is because
                // NetworkMonitor can only communicate either PARTIAL_CONNECTIVITY or VALID,
                // but not both.
                // TODO: Provide multi-testResult to improve the communication between
                // ConnectivityService and NetworkMonitor, so that ConnectivityService could
                // know the real status of network.
                final boolean partialConnectivityChanged = (partialConnectivity && !nai.partialConnectivity);
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                if (nai.everCaptivePortalDetected && !nai.captivePortalLoginNotified && valid) {
                    nai.captivePortalLoginNotified = true;
                    showNetworkNotification(nai, NotificationType.LOGGED_IN);
                }
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid) {
                        handleFreshlyValidatedNetwork(nai);
                        // Clear NO_INTERNET and LOST_INTERNET notifications if network becomes
                        // valid.
                        mNotifier.clearNotification(nai.network.netId, NotificationType.NO_INTERNET);
                        mNotifier.clearNotification(nai.network.netId, NotificationType.LOST_INTERNET);
                    }
                } else if (partialConnectivityChanged) {
                    nai.partialConnectivity = partialConnectivity;
                    updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (visible) {
                        nai.captivePortalLoginNotified = false;
                    }
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    // Only clear SIGN_IN and NETWORK_SWITCH notifications here, or else other
                    // notifications belong to the same network may be cleared unexpectedly.
                    mNotifier.clearNotification(netId, NotificationType.SIGN_IN);
                    mNotifier.clearNotification(netId, NotificationType.NETWORK_SWITCH);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (!maybeHandleAsyncChannelMessage(msg) && !maybeHandleNetworkMonitorMessage(msg) && !maybeHandleNetworkAgentInfoMessage(msg)) {
        maybeHandleNetworkAgentMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (!maybeHandleAsyncChannelMessage(msg) && !maybeHandleNetworkMonitorMessage(msg) && !maybeHandleNetworkAgentInfoMessage(msg) && !maybeHandleNetworkFactoryMessage(msg)) {
        maybeHandleNetworkAgentMessage(msg);
    }
}
#end_block

#method_before
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.request.isListen())
                    continue;
                NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, (nai != null ? nai.getCurrentScore() : 0), 0, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#method_after
private void handleAsyncChannelHalfConnect(Message msg) {
    AsyncChannel ac = (AsyncChannel) msg.obj;
    if (mNetworkFactoryInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkFactory connected");
            // Finish setting up the full connection
            mNetworkFactoryInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
            // A network factory has connected.  Send it all current NetworkRequests.
            for (NetworkRequestInfo nri : mNetworkRequests.values()) {
                if (nri.request.isListen())
                    continue;
                NetworkAgentInfo nai = getNetworkForRequest(nri.request.requestId);
                final int score;
                final int serial;
                if (nai != null) {
                    score = nai.getCurrentScore();
                    serial = nai.factorySerialNumber;
                } else {
                    score = 0;
                    serial = NetworkFactory.SerialNumber.NONE;
                }
                ac.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, serial, nri.request);
            }
        } else {
            loge("Error connecting NetworkFactory");
            mNetworkFactoryInfos.remove(msg.obj);
        }
    } else if (mNetworkAgentInfos.containsKey(msg.replyTo)) {
        if (msg.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
            if (VDBG)
                log("NetworkAgent connected");
            // A network agent has requested a connection.  Establish the connection.
            mNetworkAgentInfos.get(msg.replyTo).asyncChannel.sendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
        } else {
            loge("Error connecting NetworkAgent");
            NetworkAgentInfo nai = mNetworkAgentInfos.remove(msg.replyTo);
            if (nai != null) {
                final boolean wasDefault = isDefaultNetwork(nai);
                synchronized (mNetworkForNetId) {
                    mNetworkForNetId.remove(nai.network.netId);
                    mNetIdInUse.delete(nai.network.netId);
                }
                // Just in case.
                mLegacyTypeTracker.remove(nai, wasDefault);
            }
        }
    }
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // Clear all notifications of this network.
    mNotifier.clearNotification(nai.network.netId);
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // Clear all notifications of this network.
    mNotifier.clearNotification(nai.network.netId);
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.clatd.update();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, null);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNetd.networkDestroy(nai.network.netId);
        } catch (RemoteException | ServiceSpecificException e) {
            loge("Exception destroying network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
private void handleRegisterNetworkRequestWithIntent(Message msg) {
    final NetworkRequestInfo nri = (NetworkRequestInfo) (msg.obj);
    NetworkRequestInfo existingRequest = findExistingNetworkRequestInfo(nri.mPendingIntent);
    if (existingRequest != null) {
        // remove the existing request.
        if (DBG)
            log("Replacing " + existingRequest.request + " with " + nri.request + " because their intents matched.");
        handleReleaseNetworkRequest(existingRequest.request, getCallingUid());
    }
    handleRegisterNetworkRequest(nri);
}
#method_after
private void handleRegisterNetworkRequestWithIntent(Message msg) {
    final NetworkRequestInfo nri = (NetworkRequestInfo) (msg.obj);
    NetworkRequestInfo existingRequest = findExistingNetworkRequestInfo(nri.mPendingIntent);
    if (existingRequest != null) {
        // remove the existing request.
        if (DBG)
            log("Replacing " + existingRequest.request + " with " + nri.request + " because their intents matched.");
        handleReleaseNetworkRequest(existingRequest.request, getCallingUid(), /* callOnUnavailable */
        false);
    }
    handleRegisterNetworkRequest(nri);
}
#end_block

#method_before
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (nri.request.isListen()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.request.isRequest() && getNetworkForRequest(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, 0);
    }
}
#method_after
private void handleRegisterNetworkRequest(NetworkRequestInfo nri) {
    mNetworkRequests.put(nri.request, nri);
    mNetworkRequestInfoLogs.log("REGISTER " + nri);
    if (nri.request.isListen()) {
        for (NetworkAgentInfo network : mNetworkAgentInfos.values()) {
            if (nri.request.networkCapabilities.hasSignalStrength() && network.satisfiesImmutableCapabilitiesOf(nri.request)) {
                updateSignalStrengthThresholds(network, "REGISTER", nri.request);
            }
        }
    }
    rematchAllNetworksAndRequests(null, 0);
    if (nri.request.isRequest() && getNetworkForRequest(nri.request.requestId) == null) {
        sendUpdatedScoreToFactories(nri.request, null);
    }
}
#end_block

#method_before
private void handleReleaseNetworkRequestWithIntent(PendingIntent pendingIntent, int callingUid) {
    NetworkRequestInfo nri = findExistingNetworkRequestInfo(pendingIntent);
    if (nri != null) {
        handleReleaseNetworkRequest(nri.request, callingUid);
    }
}
#method_after
private void handleReleaseNetworkRequestWithIntent(PendingIntent pendingIntent, int callingUid) {
    NetworkRequestInfo nri = findExistingNetworkRequestInfo(pendingIntent);
    if (nri != null) {
        handleReleaseNetworkRequest(nri.request, callingUid, /* callOnUnavailable */
        false);
    }
}
#end_block

#method_before
private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid) {
    final NetworkRequestInfo nri = getNriForAppRequest(request, callingUid, "release NetworkRequest");
    if (nri == null) {
        return;
    }
    if (VDBG || (DBG && nri.request.isRequest())) {
        log("releasing " + nri.request + " (release request)");
    }
    handleRemoveNetworkRequest(nri);
}
#method_after
private void handleReleaseNetworkRequest(NetworkRequest request, int callingUid, boolean callOnUnavailable) {
    final NetworkRequestInfo nri = getNriForAppRequest(request, callingUid, "release NetworkRequest");
    if (nri == null) {
        return;
    }
    if (VDBG || (DBG && nri.request.isRequest())) {
        log("releasing " + nri.request + " (release request)");
    }
    handleRemoveNetworkRequest(nri);
    if (callOnUnavailable) {
        callCallbackForRequest(nri, null, ConnectivityManager.CALLBACK_UNAVAIL, 0);
    }
}
#end_block

#method_before
@Override
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    enforceConnectivityInternalPermission();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_ACCEPT_UNVALIDATED, encodeBool(accept), encodeBool(always), network));
}
#method_after
@Override
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    enforceNetworkStackSettingsOrSetup();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_ACCEPT_UNVALIDATED, encodeBool(accept), encodeBool(always), network));
}
#end_block

#method_before
@Override
public void setAvoidUnvalidated(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_AVOID_UNVALIDATED, network));
}
#method_after
@Override
public void setAvoidUnvalidated(Network network) {
    enforceNetworkStackSettingsOrSetup();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_AVOID_UNVALIDATED, network));
}
#end_block

#method_before
private void handleSetAcceptUnvalidated(Network network, boolean accept, boolean always) {
    if (DBG)
        log("handleSetAcceptUnvalidated network=" + network + " accept=" + accept + " always=" + always);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null) {
        // Nothing to do.
        return;
    }
    if (nai.everValidated) {
        // The network validated while the dialog box was up. Take no action.
        return;
    }
    if (!nai.networkMisc.explicitlySelected) {
        Slog.wtf(TAG, "BUG: setAcceptUnvalidated non non-explicitly selected network");
    }
    if (accept != nai.networkMisc.acceptUnvalidated) {
        int oldScore = nai.getCurrentScore();
        nai.networkMisc.acceptUnvalidated = accept;
        rematchAllNetworksAndRequests(nai, oldScore);
        sendUpdatedScoreToFactories(nai);
    }
    if (always) {
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_SAVE_ACCEPT_UNVALIDATED, encodeBool(accept));
    }
    if (!accept) {
        // Tell the NetworkAgent to not automatically reconnect to the network.
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
        // Teardown the network.
        teardownUnneededNetwork(nai);
    }
}
#method_after
private void handleSetAcceptUnvalidated(Network network, boolean accept, boolean always) {
    if (DBG)
        log("handleSetAcceptUnvalidated network=" + network + " accept=" + accept + " always=" + always);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null) {
        // Nothing to do.
        return;
    }
    if (nai.everValidated) {
        // The network validated while the dialog box was up. Take no action.
        return;
    }
    if (!nai.networkMisc.explicitlySelected) {
        Slog.wtf(TAG, "BUG: setAcceptUnvalidated non non-explicitly selected network");
    }
    if (accept != nai.networkMisc.acceptUnvalidated) {
        int oldScore = nai.getCurrentScore();
        nai.networkMisc.acceptUnvalidated = accept;
        // If network becomes partial connectivity and user already accepted to use this
        // network, we should respect the user's option and don't need to popup the
        // PARTIAL_CONNECTIVITY notification to user again.
        nai.networkMisc.acceptPartialConnectivity = accept;
        rematchAllNetworksAndRequests(nai, oldScore);
        sendUpdatedScoreToFactories(nai);
    }
    if (always) {
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_SAVE_ACCEPT_UNVALIDATED, encodeBool(accept));
    }
    if (!accept) {
        // Tell the NetworkAgent to not automatically reconnect to the network.
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
        // Teardown the network.
        teardownUnneededNetwork(nai);
    }
}
#end_block

#method_before
private void showNetworkNotification(NetworkAgentInfo nai, NotificationType type) {
    final String action;
    switch(type) {
        case LOGGED_IN:
            action = Settings.ACTION_WIFI_SETTINGS;
            mHandler.removeMessages(EVENT_TIMEOUT_NOTIFICATION);
            mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NOTIFICATION, nai.network.netId, 0), TIMEOUT_NOTIFICATION_DELAY_MS);
            break;
        case NO_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_UNVALIDATED;
            break;
        case LOST_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_LOST_VALIDATION;
            break;
        default:
            Slog.wtf(TAG, "Unknown notification type " + type);
            return;
    }
    Intent intent = new Intent(action);
    if (type != NotificationType.LOGGED_IN) {
        intent.setData(Uri.fromParts("netId", Integer.toString(nai.network.netId), null));
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClassName("com.android.settings", "com.android.settings.wifi.WifiNoInternetDialog");
    }
    PendingIntent pendingIntent = PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, UserHandle.CURRENT);
    mNotifier.showNotification(nai.network.netId, type, nai, null, pendingIntent, true);
}
#method_after
private void showNetworkNotification(NetworkAgentInfo nai, NotificationType type) {
    final String action;
    switch(type) {
        case LOGGED_IN:
            action = Settings.ACTION_WIFI_SETTINGS;
            mHandler.removeMessages(EVENT_TIMEOUT_NOTIFICATION);
            mHandler.sendMessageDelayed(mHandler.obtainMessage(EVENT_TIMEOUT_NOTIFICATION, nai.network.netId, 0), TIMEOUT_NOTIFICATION_DELAY_MS);
            break;
        case NO_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_UNVALIDATED;
            break;
        case LOST_INTERNET:
            action = ConnectivityManager.ACTION_PROMPT_LOST_VALIDATION;
            break;
        case PARTIAL_CONNECTIVITY:
            action = ConnectivityManager.ACTION_PROMPT_PARTIAL_CONNECTIVITY;
            break;
        default:
            Slog.wtf(TAG, "Unknown notification type " + type);
            return;
    }
    Intent intent = new Intent(action);
    if (type != NotificationType.LOGGED_IN) {
        intent.setData(Uri.fromParts("netId", Integer.toString(nai.network.netId), null));
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.setClassName("com.android.settings", "com.android.settings.wifi.WifiNoInternetDialog");
    }
    PendingIntent pendingIntent = PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, UserHandle.CURRENT);
    mNotifier.showNotification(nai.network.netId, type, nai, null, pendingIntent, true);
}
#end_block

#method_before
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // Also don't prompt on captive portals because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    showNetworkNotification(nai, NotificationType.NO_INTERNET);
}
#method_after
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated || // connected.
    nai.networkMisc.acceptPartialConnectivity) {
        return;
    }
    // popup the notification immediately when the network is partial connectivity.
    if (nai.partialConnectivity) {
        showNetworkNotification(nai, NotificationType.PARTIAL_CONNECTIVITY);
    } else {
        showNetworkNotification(nai, NotificationType.NO_INTERNET);
    }
}
#end_block

#method_before
private void handleNetworkUnvalidated(NetworkAgentInfo nai) {
    NetworkCapabilities nc = nai.networkCapabilities;
    if (DBG)
        log("handleNetworkUnvalidated " + nai.name() + " cap=" + nc);
    if (nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) && mMultinetworkPolicyTracker.shouldNotifyWifiUnvalidated()) {
        showNetworkNotification(nai, NotificationType.LOST_INTERNET);
    }
}
#method_after
private void handleNetworkUnvalidated(NetworkAgentInfo nai) {
    NetworkCapabilities nc = nai.networkCapabilities;
    if (DBG)
        log("handleNetworkUnvalidated " + nai.name() + " cap=" + nc);
    if (!nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    if (mMultinetworkPolicyTracker.shouldNotifyWifiUnvalidated()) {
        showNetworkNotification(nai, NotificationType.LOST_INTERNET);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_SOCKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    // this several times is fine.
                    try {
                        nai.networkMonitor().notifySystemReady();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
        case EVENT_TIMEOUT_NOTIFICATION:
            mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1, /* callOnUnavailable */
                false);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_ACCEPT_PARTIAL_CONNECTIVITY:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptPartialConnectivity(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_SOCKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    // this several times is fine.
                    try {
                        nai.networkMonitor().notifySystemReady();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
        case EVENT_TIMEOUT_NOTIFICATION:
            mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
            break;
    }
}
#end_block

#method_before
@Override
public VpnInfo[] getAllVpnInfo() {
    enforceConnectivityInternalPermission();
    synchronized (mVpns) {
        if (mLockdownEnabled) {
            return new VpnInfo[0];
        }
        List<VpnInfo> infoList = new ArrayList<>();
        for (int i = 0; i < mVpns.size(); i++) {
            VpnInfo info = createVpnInfo(mVpns.valueAt(i));
            if (info != null) {
                infoList.add(info);
            }
        }
        return infoList.toArray(new VpnInfo[infoList.size()]);
    }
}
#method_after
private VpnInfo[] getAllVpnInfo() {
    ensureRunningOnConnectivityServiceThread();
    synchronized (mVpns) {
        if (mLockdownEnabled) {
            return new VpnInfo[0];
        }
        List<VpnInfo> infoList = new ArrayList<>();
        for (int i = 0; i < mVpns.size(); i++) {
            VpnInfo info = createVpnInfo(mVpns.valueAt(i));
            if (info != null) {
                infoList.add(info);
            }
        }
        return infoList.toArray(new VpnInfo[infoList.size()]);
    }
}
#end_block

#method_before
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNetwork = getDefaultNetwork();
        if (defaultNetwork != null && defaultNetwork.linkProperties != null) {
            info.primaryUnderlyingIface = getDefaultNetwork().linkProperties.getInterfaceName();
        }
    } else if (underlyingNetworks.length > 0) {
        LinkProperties linkProperties = getLinkProperties(underlyingNetworks[0]);
        if (linkProperties != null) {
            info.primaryUnderlyingIface = linkProperties.getInterfaceName();
        }
    }
    return info.primaryUnderlyingIface == null ? null : info;
}
#method_after
@Nullable
private VpnInfo createVpnInfo(Vpn vpn) {
    VpnInfo info = vpn.getVpnInfo();
    if (info == null) {
        return null;
    }
    Network[] underlyingNetworks = vpn.getUnderlyingNetworks();
    // the underlyingNetworks list.
    if (underlyingNetworks == null) {
        NetworkAgentInfo defaultNai = getDefaultNetwork();
        if (defaultNai != null && defaultNai.linkProperties != null) {
            underlyingNetworks = new Network[] { defaultNai.network };
        }
    }
    if (underlyingNetworks != null && underlyingNetworks.length > 0) {
        List<String> interfaces = new ArrayList<>();
        for (Network network : underlyingNetworks) {
            LinkProperties lp = getLinkProperties(network);
            if (lp != null) {
                interfaces.add(lp.getInterfaceName());
            }
        }
        if (!interfaces.isEmpty()) {
            info.underlyingIfaces = interfaces.toArray(new String[interfaces.size()]);
        }
    }
    return info.underlyingIfaces == null ? null : info;
}
#end_block

#method_before
@Override
public void registerNetworkFactory(Messenger messenger, String name) {
    enforceConnectivityInternalPermission();
    NetworkFactoryInfo nfi = new NetworkFactoryInfo(name, messenger, new AsyncChannel());
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_FACTORY, nfi));
}
#method_after
@Override
public int registerNetworkFactory(Messenger messenger, String name) {
    enforceConnectivityInternalPermission();
    NetworkFactoryInfo nfi = new NetworkFactoryInfo(name, messenger, new AsyncChannel(), NetworkFactory.SerialNumber.nextSerialNumber());
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_FACTORY, nfi));
    return nfi.factorySerialNumber;
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(toStableParcelable(nai.network), name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#method_after
// TODO : remove this method. It's a stopgap measure to help sheperding a number of dependent
// changes that would conflict throughout the automerger graph. Having this method temporarily
// helps with the process of going through with all these dependent changes across the entire
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    return registerNetworkAgent(messenger, networkInfo, linkProperties, networkCapabilities, currentScore, networkMisc, NetworkFactory.SerialNumber.NONE);
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(toStableParcelable(nai.network), name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc, int factorySerialNumber) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mDnsResolver, mNMS, factorySerialNumber);
    // Make sure the network capabilities reflect what the agent info says.
    nai.setNetworkCapabilities(mixInCapabilities(nai, nc));
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(nai.network, name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            try {
                networkAgent.networkMonitor().notifyLinkPropertiesChanged();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        try {
            networkAgent.networkMonitor().notifyLinkPropertiesChanged(newLp);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private NetworkCapabilities mixInCapabilities(NetworkAgentInfo nai, NetworkCapabilities nc) {
    // avoid connect/teardown loops.
    if (nai.everConnected && !nai.isVPN() && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(nc)) {
        // TODO: consider not complaining when a network agent degrades its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(nc);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (nai.lastValidated) {
        newNc.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        newNc.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        newNc.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        newNc.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        newNc.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        newNc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (nai.isSuspended()) {
        newNc.removeCapability(NET_CAPABILITY_NOT_SUSPENDED);
    } else {
        newNc.addCapability(NET_CAPABILITY_NOT_SUSPENDED);
    }
    return newNc;
}
#method_after
private NetworkCapabilities mixInCapabilities(NetworkAgentInfo nai, NetworkCapabilities nc) {
    // avoid connect/teardown loops.
    if (nai.everConnected && !nai.isVPN() && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(nc)) {
        // TODO: consider not complaining when a network agent degrades its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(nc);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (nai.lastValidated) {
        newNc.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        newNc.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        newNc.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        newNc.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        newNc.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        newNc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (nai.isSuspended()) {
        newNc.removeCapability(NET_CAPABILITY_NOT_SUSPENDED);
    } else {
        newNc.addCapability(NET_CAPABILITY_NOT_SUSPENDED);
    }
    if (nai.partialConnectivity) {
        newNc.addCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    } else {
        newNc.removeCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    }
    return newNc;
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.setNetworkCapabilities(newNc);
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    updateLinkProperties(nai, newLp, new LinkProperties(nai.linkProperties));
}
#method_after
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    ensureRunningOnConnectivityServiceThread();
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    updateLinkProperties(nai, newLp, new LinkProperties(nai.linkProperties));
}
#end_block

#method_before
private void sendUpdatedScoreToFactories(NetworkAgentInfo nai) {
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest nr = nai.requestAt(i);
        // Don't send listening requests to factories. b/17393458
        if (nr.isListen())
            continue;
        sendUpdatedScoreToFactories(nr, nai.getCurrentScore());
    }
}
#method_after
private void sendUpdatedScoreToFactories(NetworkAgentInfo nai) {
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest nr = nai.requestAt(i);
        // Don't send listening requests to factories. b/17393458
        if (nr.isListen())
            continue;
        sendUpdatedScoreToFactories(nr, nai);
    }
}
#end_block

#method_before
private void sendUpdatedScoreToFactories(NetworkRequest networkRequest, int score) {
    if (VDBG || DDBG) {
        log("sending new Min Network Score(" + score + "): " + networkRequest.toString());
    }
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, 0, networkRequest);
    }
}
#method_after
private void sendUpdatedScoreToFactories(NetworkRequest networkRequest, NetworkAgentInfo nai) {
    int score = 0;
    int serial = 0;
    if (nai != null) {
        score = nai.getCurrentScore();
        serial = nai.factorySerialNumber;
    }
    if (VDBG || DDBG) {
        log("sending new Min Network Score(" + score + "): " + networkRequest.toString());
    }
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        nfi.asyncChannel.sendMessage(android.net.NetworkFactory.CMD_REQUEST_NETWORK, score, serial, networkRequest);
    }
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG || DDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG || DDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG || DDBG) {
                        log("   accepting network in place of " + currentNetwork.name());
                    }
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG || DDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG || DDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = getNetworkForRequest(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG || DDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG || DDBG) {
                        log("   accepting network in place of " + currentNetwork.name());
                    }
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG || DDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                setNetworkForRequest(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have a lot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, newNetwork);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                clearNetworkForRequest(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, null);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        updateDataActivityTracking(newNetwork, oldDefaultNetwork);
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", newNetwork.name(), nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            networkAgent.networkMonitor().notifyNetworkConnected();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        if (networkAgent.isVPN()) {
            updateAllVpnsCapabilities();
        }
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            if (networkAgent.networkMisc.acceptPartialConnectivity) {
                networkAgent.networkMonitor().setAcceptPartialConnectivity();
            }
            networkAgent.networkMonitor().notifyNetworkConnected(networkAgent.linkProperties, networkAgent.networkCapabilities);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        if (networkAgent.isVPN()) {
            updateAllVpnsCapabilities();
        }
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
private Network[] getDefaultNetworks() {
    ArrayList<Network> defaultNetworks = new ArrayList<>();
    NetworkAgentInfo defaultNetwork = getDefaultNetwork();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.everConnected && (nai == defaultNetwork || nai.isVPN())) {
            defaultNetworks.add(nai.network);
        }
    }
    return defaultNetworks.toArray(new Network[0]);
}
#method_after
private Network[] getDefaultNetworks() {
    ensureRunningOnConnectivityServiceThread();
    ArrayList<Network> defaultNetworks = new ArrayList<>();
    NetworkAgentInfo defaultNetwork = getDefaultNetwork();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.everConnected && (nai == defaultNetwork || nai.isVPN())) {
            defaultNetworks.add(nai.network);
        }
    }
    return defaultNetworks.toArray(new Network[0]);
}
#end_block

#method_before
private void notifyIfacesChangedForNetworkStats() {
    try {
        mStatsService.forceUpdateIfaces(getDefaultNetworks());
    } catch (Exception ignored) {
    }
}
#method_after
private void notifyIfacesChangedForNetworkStats() {
    ensureRunningOnConnectivityServiceThread();
    String activeIface = null;
    LinkProperties activeLinkProperties = getActiveLinkProperties();
    if (activeLinkProperties != null) {
        activeIface = activeLinkProperties.getInterfaceName();
    }
    try {
        mStatsService.forceUpdateIfaces(getDefaultNetworks(), getAllVpnInfo(), getAllNetworkState(), activeIface);
    } catch (Exception ignored) {
    }
}
#end_block

#method_before
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext);
}
#method_after
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    final String defaultUrl = mContext.getResources().getString(R.string.config_networkDefaultCaptivePortalServerUrl);
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext, defaultUrl);
}
#end_block

#method_before
@Override
public void startNattKeepalive(Network network, int intervalSeconds, Messenger messenger, IBinder binder, String srcAddr, int srcPort, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), intervalSeconds, messenger, binder, srcAddr, srcPort, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#method_after
@Override
public void startNattKeepalive(Network network, int intervalSeconds, ISocketKeepaliveCallback cb, String srcAddr, int srcPort, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), null, /* fd */
    intervalSeconds, cb, srcAddr, srcPort, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#end_block

#method_before
@Override
public void startNattKeepaliveWithFd(Network network, FileDescriptor fd, int resourceId, int intervalSeconds, Messenger messenger, IBinder binder, String srcAddr, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), fd, resourceId, intervalSeconds, messenger, binder, srcAddr, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#method_after
@Override
public void startNattKeepaliveWithFd(Network network, FileDescriptor fd, int resourceId, int intervalSeconds, ISocketKeepaliveCallback cb, String srcAddr, String dstAddr) {
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), fd, resourceId, intervalSeconds, cb, srcAddr, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#end_block

#method_before
@Override
public void startTcpKeepalive(Network network, FileDescriptor fd, int intervalSeconds, Messenger messenger, IBinder binder) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startTcpKeepalive(getNetworkAgentInfoForNetwork(network), fd, intervalSeconds, messenger, binder);
}
#method_after
@Override
public void startTcpKeepalive(Network network, FileDescriptor fd, int intervalSeconds, ISocketKeepaliveCallback cb) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startTcpKeepalive(getNetworkAgentInfoForNetwork(network), fd, intervalSeconds, cb);
}
#end_block

#method_before
@Test
public void testNonExistentAuthority() {
    File file = buildPath(mContext.getFilesDir(), "file.test");
    try {
        FileProvider.getUriForFile(mContext, "com.example.nonexistent", file);
        fail("Expected exception for non-existent authority");
    } catch (IllegalArgumentException e) {
    }
}
#method_after
@Test
public void testNonExistentAuthority() {
    File file = buildPath(mContext.getFilesDir(), "file.test");
    try {
        FileProvider.getUriForFile(mContext, "example.nonexistent", file);
        fail("Expected exception for non-existent authority");
    } catch (IllegalArgumentException e) {
        assertEquals("Couldn't find meta-data for provider with authority example.nonexistent", e.getMessage());
    }
}
#end_block

#method_before
public static FileDescriptor accept(FileDescriptor fd, InetSocketAddress peerAddress) throws ErrnoException, SocketException {
    return accept(fd, (SocketAddress) peerAddress);
}
#method_after
// Ideally we'd just have the version that accepts SocketAddress but we're stuck with
// this one for legacy reasons. http://b/123568439
public static FileDescriptor accept(FileDescriptor fd, InetSocketAddress peerAddress) throws ErrnoException, SocketException {
    return accept(fd, (SocketAddress) peerAddress);
}
#end_block

#method_before
public void test_sendfile_null() throws Exception {
    File in = createTempFile("test_sendfile_null", "Hello, world!");
    try {
        int len = "Hello".length();
        assertEquals("Hello", checkSendfile(in, null, len, null));
    } finally {
        in.delete();
    }
}
#method_after
public void test_sendfile_null() throws Exception {
    File in = createTempFile("test_sendfile_null", "Hello, world!");
    try {
        int len = "Hello".length();
        assertEquals("Hello", checkSendfile(ANDROID_SYSTEM_OS_INT64_REF, in, null, len, null));
        assertEquals("Hello", checkSendfile(LIBCORE_OS, in, null, len, null));
    } finally {
        in.delete();
    }
}
#end_block

#method_before
public void test_sendfile_offset() throws Exception {
    File in = createTempFile("test_sendfile_offset", "Hello, world!");
    try {
        // checkSendfile(in, startOffset, maxBytes, expectedEndOffset)
        assertEquals("Hello", checkSendfile(in, 0L, 5, 5L));
        assertEquals("ello,", checkSendfile(in, 1L, 5, 6L));
        // At offset 9, only 4 bytes/chars available, even though we're asking for 5.
        assertEquals("rld!", checkSendfile(in, 9L, 5, 13L));
        assertEquals("", checkSendfile(in, 1L, 0, 1L));
    } finally {
        in.delete();
    }
}
#method_after
public void test_sendfile_offset() throws Exception {
    File in = createTempFile("test_sendfile_offset", "Hello, world!");
    try {
        // checkSendfile(sendFileImplToUse, in, startOffset, maxBytes, expectedEndOffset)
        assertEquals("Hello", checkSendfile(ANDROID_SYSTEM_OS_INT64_REF, in, 0L, 5, 5L));
        assertEquals("Hello", checkSendfile(LIBCORE_OS, in, 0L, 5, 5L));
        assertEquals("ello,", checkSendfile(ANDROID_SYSTEM_OS_INT64_REF, in, 1L, 5, 6L));
        assertEquals("ello,", checkSendfile(LIBCORE_OS, in, 1L, 5, 6L));
        // At offset 9, only 4 bytes/chars available, even though we're asking for 5.
        assertEquals("rld!", checkSendfile(ANDROID_SYSTEM_OS_INT64_REF, in, 9L, 5, 13L));
        assertEquals("rld!", checkSendfile(LIBCORE_OS, in, 9L, 5, 13L));
        assertEquals("", checkSendfile(ANDROID_SYSTEM_OS_INT64_REF, in, 1L, 0, 1L));
        assertEquals("", checkSendfile(LIBCORE_OS, in, 1L, 0, 1L));
    } finally {
        in.delete();
    }
}
#end_block

#method_before
private static String checkSendfile(File in, Long startOffset, int maxBytes, Long expectedEndOffset) throws IOException, ErrnoException {
    File out = File.createTempFile(OsTest.class.getSimpleName() + "_checkSendFile", ".out");
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        try (FileOutputStream outStream = new FileOutputStream(out)) {
            FileDescriptor outFd = outStream.getFD();
            Int64Ref offset = (startOffset == null) ? null : new Int64Ref(startOffset);
            android.system.Os.sendfile(outFd, inFd, offset, maxBytes);
            assertEquals(expectedEndOffset, offset == null ? null : offset.value);
        }
        return IoUtils.readFileAsString(out.getPath());
    } finally {
        out.delete();
    }
}
#method_after
private static String checkSendfile(SendFileImpl sendFileImplToUse, File in, Long startOffset, int maxBytes, Long expectedEndOffset) throws IOException, ErrnoException {
    File out = File.createTempFile(OsTest.class.getSimpleName() + "_checkSendFile_" + sendFileImplToUse, ".out");
    try (FileInputStream inStream = new FileInputStream(in)) {
        FileDescriptor inFd = inStream.getFD();
        try (FileOutputStream outStream = new FileOutputStream(out)) {
            FileDescriptor outFd = outStream.getFD();
            switch(sendFileImplToUse) {
                case ANDROID_SYSTEM_OS_INT64_REF:
                    {
                        Int64Ref offset = (startOffset == null) ? null : new Int64Ref(startOffset);
                        android.system.Os.sendfile(outFd, inFd, offset, maxBytes);
                        assertEquals(expectedEndOffset, offset == null ? null : offset.value);
                        break;
                    }
                case LIBCORE_OS:
                    {
                        Int64Ref offset = (startOffset == null) ? null : new Int64Ref(startOffset);
                        libcore.io.Libcore.os.sendfile(outFd, inFd, offset, maxBytes);
                        assertEquals(expectedEndOffset, offset == null ? null : offset.value);
                        break;
                    }
                default:
                    {
                        fail();
                        break;
                    }
            }
        }
        return IoUtils.readFileAsString(out.getPath());
    } finally {
        out.delete();
    }
}
#end_block

#method_before
public void testGetDefault_instanceofBlockguardOs() {
    libcore.io.Os os = Os.getDefault();
    assertTrue(os.getClass().toString(), os instanceof BlockGuardOs);
}
#method_after
public void testGetDefault_instanceofBlockguardOs() {
    Os os = Os.getDefault();
    assertTrue(os.getClass().toString(), os instanceof BlockGuardOs);
}
#end_block

#method_before
@Override
public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {
    final File file = getFileForUri(uri);
    final int fileMode = modeToMode(mode);
    if ((fileMode & ParcelFileDescriptor.MODE_CREATE) == ParcelFileDescriptor.MODE_CREATE) {
        // If the file is being created, create all its parent directories that don't already
        // exist.
        file.getParentFile().mkdirs();
    }
    // Track the file
    mFileTracker.put(uri, new ContentValues());
    return ParcelFileDescriptor.open(file, fileMode);
}
#method_after
@Override
public ParcelFileDescriptor openFile(@NonNull Uri uri, @NonNull String mode) throws FileNotFoundException {
    final File file = getFileForUri(uri);
    final int fileMode = modeToMode(mode);
    if ((fileMode & ParcelFileDescriptor.MODE_CREATE) == ParcelFileDescriptor.MODE_CREATE) {
        // If the file is being created, create all its parent directories that don't already
        // exist.
        file.getParentFile().mkdirs();
        if (!mFileTracker.containsKey(uri)) {
            // Track the file, if not already tracked.
            mFileTracker.put(uri, new ContentValues());
        }
    }
    return ParcelFileDescriptor.open(file, fileMode);
}
#end_block

#method_before
@Override
public void setInsets(int l, int t, int r, int b) {
    super.setInsets(l, t, r, b);
    mRootView.setPadding(l, t, r, b);
    if (mRangeBar != null) {
        updateRangePadding();
        updateSelectionPadding();
    }
}
#method_after
@Override
public void setInsets(int l, int t, int r, int b) {
    super.setInsets(l, t, r, b);
    setPadding(l, t, r, b);
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int totalHeight = mRowContent != null ? mRowContent.getHeight(mSliceStyle, mViewPolicy) : 0;
    int rowHeight = getRowContentHeight();
    if (rowHeight != 0) {
        // Might be gone if we have range / progress but nothing else
        mRootView.setVisibility(View.VISIBLE);
        heightMeasureSpec = MeasureSpec.makeMeasureSpec(rowHeight, MeasureSpec.EXACTLY);
        measureChild(mRootView, widthMeasureSpec, heightMeasureSpec);
    } else {
        mRootView.setVisibility(View.GONE);
    }
    if (mRangeBar != null) {
        // If we're on a platform where SeekBar can't be stretched vertically, find out the
        // exact size it would like to be so we can honor that in onLayout.
        int rangeMeasureSpec = sCanSpecifyLargerRangeBarHeight ? MeasureSpec.makeMeasureSpec(mSliceStyle.getRowRangeHeight(), MeasureSpec.EXACTLY) : MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
        measureChild(mRangeBar, widthMeasureSpec, rangeMeasureSpec);
        // Remember the measured height later for onLayout, since super.onMeasure will overwrite
        // it.
        mMeasuredRangeHeight = mRangeBar.getMeasuredHeight();
    } else if (mSelectionSpinner != null) {
        int selectionMeasureSpec = MeasureSpec.makeMeasureSpec(mSliceStyle.getRowSelectionHeight(), MeasureSpec.EXACTLY);
        measureChild(mSelectionSpinner, widthMeasureSpec, selectionMeasureSpec);
    }
    int totalHeightSpec = MeasureSpec.makeMeasureSpec(totalHeight, MeasureSpec.EXACTLY);
    super.onMeasure(widthMeasureSpec, totalHeightSpec);
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int childWidth = 0;
    int rowHeight = getRowContentHeight();
    if (rowHeight != 0) {
        // Might be gone if we have range / progress but nothing else
        mRootView.setVisibility(View.VISIBLE);
        measureChildWithExactHeight(mRootView, widthMeasureSpec, rowHeight);
        childWidth = mRootView.getMeasuredWidth();
    } else {
        mRootView.setVisibility(View.GONE);
    }
    if (mRangeBar != null) {
        // exact size it would like to be so we can honor that in onLayout.
        if (sCanSpecifyLargerRangeBarHeight) {
            measureChildWithExactHeight(mRangeBar, widthMeasureSpec, mSliceStyle.getRowRangeHeight());
        } else {
            measureChild(mRangeBar, widthMeasureSpec, MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
        }
        // Remember the measured height later for onLayout, since super.onMeasure will overwrite
        // it.
        mMeasuredRangeHeight = mRangeBar.getMeasuredHeight();
        childWidth = Math.max(childWidth, mRangeBar.getMeasuredWidth());
    } else if (mSelectionSpinner != null) {
        measureChildWithExactHeight(mSelectionSpinner, widthMeasureSpec, mSliceStyle.getRowSelectionHeight());
        childWidth = Math.max(childWidth, mSelectionSpinner.getMeasuredWidth());
    }
    childWidth = Math.max(childWidth + mInsetStart + mInsetEnd, getSuggestedMinimumWidth());
    int totalHeight = mRowContent != null ? mRowContent.getHeight(mSliceStyle, mViewPolicy) : 0;
    setMeasuredDimension(resolveSizeAndState(childWidth, widthMeasureSpec, 0), totalHeight + mInsetTop + mInsetBottom);
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int insets = mInsetStart + mInsetEnd;
    mRootView.layout(0, 0, mRootView.getMeasuredWidth() + insets, getRowContentHeight());
    if (mRangeBar != null) {
        // If we're on aa platform where SeekBar can't be stretched vertically, then
        // mMeasuredRangeHeight can (and probably will) be smaller than the ideal height, so we
        // need to add some padding to make mRangeBar look like it's the larger size.
        int verticalPadding = (mSliceStyle.getRowRangeHeight() - mMeasuredRangeHeight) / 2;
        int top = getRowContentHeight() + verticalPadding;
        int bottom = top + mMeasuredRangeHeight;
        mRangeBar.layout(0, top, mRangeBar.getMeasuredWidth(), bottom);
    } else if (mSelectionSpinner != null) {
        int top = getRowContentHeight();
        int bottom = top + mSelectionSpinner.getMeasuredHeight();
        mSelectionSpinner.layout(0, top, mSelectionSpinner.getMeasuredWidth(), bottom);
    }
}
#method_after
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int leftPadding = getPaddingLeft();
    mRootView.layout(leftPadding, mInsetTop, mRootView.getMeasuredWidth() + leftPadding, getRowContentHeight() + mInsetTop);
    if (mRangeBar != null) {
        // If we're on a platform where SeekBar can't be stretched vertically, then
        // mMeasuredRangeHeight can (and probably will) be smaller than the ideal height, so we
        // need to add some padding to make mRangeBar look like it's the larger size.
        int verticalPadding = (mSliceStyle.getRowRangeHeight() - mMeasuredRangeHeight) / 2;
        int top = getRowContentHeight() + verticalPadding + mInsetTop;
        int bottom = top + mMeasuredRangeHeight;
        mRangeBar.layout(leftPadding, top, mRangeBar.getMeasuredWidth() + leftPadding, bottom);
    } else if (mSelectionSpinner != null) {
        int top = getRowContentHeight() + mInsetTop;
        int bottom = top + mSelectionSpinner.getMeasuredHeight();
        mSelectionSpinner.layout(leftPadding, top, mSelectionSpinner.getMeasuredWidth() + leftPadding, bottom);
    }
}
#end_block

#method_before
private void populateViews(boolean isUpdate) {
    boolean skipSliderUpdate = isUpdate && mIsRangeSliding;
    if (!skipSliderUpdate) {
        resetViewState();
    }
    if (mRowContent.getLayoutDir() != -1) {
        setLayoutDirection(mRowContent.getLayoutDir());
    }
    if (mRowContent.isDefaultSeeMore()) {
        showSeeMore();
        return;
    }
    CharSequence contentDescr = mRowContent.getContentDescription();
    if (contentDescr != null) {
        mContent.setContentDescription(contentDescr);
    }
    mStartItem = mRowContent.getStartItem();
    boolean showStart = mStartItem != null && mRowIndex > 0;
    if (showStart) {
        showStart = addItem(mStartItem, mTintColor, true);
    }
    mStartContainer.setVisibility(showStart ? View.VISIBLE : View.GONE);
    final SliceItem titleItem = mRowContent.getTitleItem();
    if (titleItem != null) {
        mPrimaryText.setText(titleItem.getSanitizedText());
    }
    if (mSliceStyle != null) {
        mPrimaryText.setTextSize(TypedValue.COMPLEX_UNIT_PX, mIsHeader ? mSliceStyle.getHeaderTitleSize() : mSliceStyle.getTitleSize());
        mPrimaryText.setTextColor(mSliceStyle.getTitleColor());
    }
    mPrimaryText.setVisibility(titleItem != null ? View.VISIBLE : View.GONE);
    addSubtitle(titleItem != null);
    SliceItem primaryAction = mRowContent.getPrimaryAction();
    if (primaryAction != null && primaryAction != mStartItem) {
        mRowAction = new SliceActionImpl(primaryAction);
        if (mRowAction.isToggle()) {
            // If primary action is a toggle, add it and we're done
            addAction(mRowAction, mTintColor, mEndContainer, false);
            // TODO: if start item is tappable, touch feedback should exclude it
            setViewClickable(mRootView, true);
            return;
        }
    }
    final SliceItem range = mRowContent.getRange();
    if (range != null) {
        if (mRowAction != null) {
            setViewClickable(mRootView, true);
        }
        if (!skipSliderUpdate) {
            determineRangeValues(range);
            addRange(range);
        } else {
            // Even if we're skipping the update, we should still update the range item
            mRangeItem = range;
        }
        return;
    }
    final SliceItem selection = mRowContent.getSelection();
    if (selection != null) {
        addSelection(selection);
        return;
    }
    updateEndItems();
    updateActionSpinner();
}
#method_after
private void populateViews(boolean isUpdate) {
    boolean skipSliderUpdate = isUpdate && mIsRangeSliding;
    if (!skipSliderUpdate) {
        resetViewState();
    }
    if (mRowContent.getLayoutDir() != -1) {
        setLayoutDirection(mRowContent.getLayoutDir());
    }
    if (mRowContent.isDefaultSeeMore()) {
        showSeeMore();
        return;
    }
    CharSequence contentDescr = mRowContent.getContentDescription();
    if (contentDescr != null) {
        mContent.setContentDescription(contentDescr);
    }
    mStartItem = mRowContent.getStartItem();
    boolean showStart = mStartItem != null && (mRowIndex > 0 || mRowContent.hasTitleItems());
    if (showStart) {
        showStart = addItem(mStartItem, mTintColor, true);
    }
    mStartContainer.setVisibility(showStart ? View.VISIBLE : View.GONE);
    final SliceItem titleItem = mRowContent.getTitleItem();
    if (titleItem != null) {
        mPrimaryText.setText(titleItem.getSanitizedText());
    }
    if (mSliceStyle != null) {
        mPrimaryText.setTextSize(TypedValue.COMPLEX_UNIT_PX, mIsHeader ? mSliceStyle.getHeaderTitleSize() : mSliceStyle.getTitleSize());
        mPrimaryText.setTextColor(mSliceStyle.getTitleColor());
    }
    mPrimaryText.setVisibility(titleItem != null ? View.VISIBLE : View.GONE);
    addSubtitle(titleItem != null);
    mBottomDivider.setVisibility(mRowContent.hasBottomDivider() ? View.VISIBLE : View.GONE);
    SliceItem primaryAction = mRowContent.getPrimaryAction();
    if (primaryAction != null && primaryAction != mStartItem) {
        mRowAction = new SliceActionImpl(primaryAction);
        if (mRowAction.isToggle()) {
            // If primary action is a toggle, add it and we're done
            addAction(mRowAction, mTintColor, mEndContainer, false);
            // TODO: if start item is tappable, touch feedback should exclude it
            setViewClickable(mRootView, true);
            return;
        }
    }
    final SliceItem range = mRowContent.getRange();
    if (range != null) {
        if (mRowAction != null) {
            setViewClickable(mRootView, true);
        }
        mRangeItem = range;
        if (!skipSliderUpdate) {
            setRangeBounds();
            addRange();
        }
        return;
    }
    final SliceItem selection = mRowContent.getSelection();
    if (selection != null) {
        mSelectionItem = selection;
        addSelection(selection);
        return;
    }
    updateEndItems();
    updateActionSpinner();
}
#end_block

#method_before
private void updateEndItems() {
    if (mRowContent == null) {
        return;
    }
    mEndContainer.removeAllViews();
    // If we're here we can can show end items; check for top level actions first
    List endItems = mRowContent.getEndItems();
    if (mHeaderActions != null) {
        // Use these if we have them instead
        endItems = mHeaderActions;
    }
    // Add start item to end of row for the top row if end items are empty.
    if (mRowIndex == 0 && mStartItem != null && endItems.isEmpty()) {
        endItems.add(mStartItem);
    }
    // If we're here we might be able to show end items
    int endItemCount = 0;
    boolean firstItemIsADefaultToggle = false;
    boolean singleActionAtTheEnd = false;
    SliceItem endAction = null;
    for (int i = 0; i < endItems.size(); i++) {
        final SliceItem endItem = (endItems.get(i) instanceof SliceItem) ? (SliceItem) endItems.get(i) : ((SliceActionImpl) endItems.get(i)).getSliceItem();
        if (endItemCount < MAX_END_ITEMS) {
            if (addItem(endItem, mTintColor, false)) {
                if (endAction == null && SliceQuery.find(endItem, FORMAT_ACTION) != null) {
                    endAction = endItem;
                }
                endItemCount++;
                if (endItemCount == 1) {
                    firstItemIsADefaultToggle = !mToggles.isEmpty() && SliceQuery.find(endItem.getSlice(), FORMAT_IMAGE) == null;
                    singleActionAtTheEnd = endItems.size() == 1 && SliceQuery.find(endItem, FORMAT_ACTION) != null;
                }
            }
        }
    }
    mEndContainer.setVisibility(endItemCount > 0 ? VISIBLE : GONE);
    // If there is a row action and the first end item is a default toggle, or action divider
    // is set by presenter and a single action is at the end of the row, show the divider.
    mDivider.setVisibility(mRowAction != null && (firstItemIsADefaultToggle || (mRowContent.hasActionDivider() && singleActionAtTheEnd)) ? View.VISIBLE : View.GONE);
    boolean hasStartAction = mStartItem != null && SliceQuery.find(mStartItem, FORMAT_ACTION) != null;
    boolean hasEndItemAction = endAction != null;
    boolean endAndRowActionTheSame = false;
    if (mRowAction != null) {
        setViewClickable(mRootView, true);
    } else if (hasEndItemAction != hasStartAction && (endItemCount == 1 || hasStartAction)) {
        // This row only has 1 action in start or end position; make whole row clickable for it
        endAndRowActionTheSame = true;
        if (!mToggles.isEmpty()) {
            mRowAction = mToggles.keySet().iterator().next();
        } else if (!mActions.isEmpty() && mActions.size() == 1) {
            mRowAction = mActions.valueAt(0).getAction();
        }
        setViewClickable(mRootView, true);
    }
    if (mRowAction != null && !endAndRowActionTheSame && mLoadingActions.contains(mRowAction.getSliceItem())) {
        mShowActionSpinner = true;
    }
}
#method_after
private void updateEndItems() {
    if (mRowContent == null) {
        return;
    }
    mEndContainer.removeAllViews();
    // If we're here we can can show end items; check for top level actions first
    List endItems = mRowContent.getEndItems();
    if (mHeaderActions != null) {
        // Use these if we have them instead
        endItems = mHeaderActions;
    }
    // doesn't show title items.
    if (mRowIndex == 0 && mStartItem != null && endItems.isEmpty() && !mRowContent.hasTitleItems()) {
        endItems.add(mStartItem);
    }
    // If we're here we might be able to show end items
    int endItemCount = 0;
    boolean firstItemIsADefaultToggle = false;
    boolean singleActionAtTheEnd = false;
    SliceItem endAction = null;
    for (int i = 0; i < endItems.size(); i++) {
        final SliceItem endItem = (endItems.get(i) instanceof SliceItem) ? (SliceItem) endItems.get(i) : ((SliceActionImpl) endItems.get(i)).getSliceItem();
        if (endItemCount < MAX_END_ITEMS) {
            if (addItem(endItem, mTintColor, false)) {
                if (endAction == null && SliceQuery.find(endItem, FORMAT_ACTION) != null) {
                    endAction = endItem;
                }
                endItemCount++;
                if (endItemCount == 1) {
                    firstItemIsADefaultToggle = !mToggles.isEmpty() && SliceQuery.find(endItem.getSlice(), FORMAT_IMAGE) == null;
                    singleActionAtTheEnd = endItems.size() == 1 && SliceQuery.find(endItem, FORMAT_ACTION) != null;
                }
            }
        }
    }
    mEndContainer.setVisibility(endItemCount > 0 ? VISIBLE : GONE);
    // If there is a row action and the first end item is a default toggle, or action divider
    // is set by presenter and a single action is at the end of the row, show the divider.
    mActionDivider.setVisibility(mRowAction != null && (firstItemIsADefaultToggle || (mRowContent.hasActionDivider() && singleActionAtTheEnd)) ? View.VISIBLE : View.GONE);
    boolean hasStartAction = mStartItem != null && SliceQuery.find(mStartItem, FORMAT_ACTION) != null;
    boolean hasEndItemAction = endAction != null;
    boolean endAndRowActionTheSame = false;
    if (mRowAction != null) {
        setViewClickable(mRootView, true);
    } else if (hasEndItemAction != hasStartAction && (endItemCount == 1 || hasStartAction)) {
        // This row only has 1 action in start or end position; make whole row clickable for it
        endAndRowActionTheSame = true;
        if (!mToggles.isEmpty()) {
            mRowAction = mToggles.keySet().iterator().next();
        } else if (!mActions.isEmpty() && mActions.size() == 1) {
            mRowAction = mActions.valueAt(0).getAction();
        }
        setViewClickable(mRootView, true);
    }
    if (mRowAction != null && !endAndRowActionTheSame && mLoadingActions.contains(mRowAction.getSliceItem())) {
        mShowActionSpinner = true;
    }
}
#end_block

#method_before
private void addRange(final SliceItem range) {
    if (mHandler == null) {
        mHandler = new Handler();
    }
    final boolean isSeekBar = FORMAT_ACTION.equals(range.getFormat());
    final ProgressBar progressBar = isSeekBar ? new SeekBar(getContext()) : new ProgressBar(getContext(), null, android.R.attr.progressBarStyleHorizontal);
    Drawable progressDrawable = DrawableCompat.wrap(progressBar.getProgressDrawable());
    if (mTintColor != -1 && progressDrawable != null) {
        DrawableCompat.setTint(progressDrawable, mTintColor);
        progressBar.setProgressDrawable(progressDrawable);
    }
    SliceItem max = SliceQuery.findSubtype(range, FORMAT_INT, SUBTYPE_MAX);
    if (max != null) {
        progressBar.setMax(max.getInt() - mRangeMinValue);
    }
    progressBar.setProgress(mRangeValue);
    progressBar.setVisibility(View.VISIBLE);
    addView(progressBar);
    mRangeBar = progressBar;
    if (isSeekBar) {
        SliceItem thumb = mRowContent.getInputRangeThumb();
        SeekBar seekBar = (SeekBar) mRangeBar;
        if (thumb != null && thumb.getIcon() != null) {
            Drawable d = thumb.getIcon().loadDrawable(getContext());
            if (d != null) {
                seekBar.setThumb(d);
            }
        }
        Drawable thumbDrawable = DrawableCompat.wrap(seekBar.getThumb());
        if (mTintColor != -1 && thumbDrawable != null) {
            DrawableCompat.setTint(thumbDrawable, mTintColor);
            seekBar.setThumb(thumbDrawable);
        }
        seekBar.setOnSeekBarChangeListener(mSeekBarChangeListener);
    }
    updateRangePadding();
}
#method_after
private void addRange() {
    if (mHandler == null) {
        mHandler = new Handler();
    }
    final boolean isSeekBar = FORMAT_ACTION.equals(mRangeItem.getFormat());
    final ProgressBar progressBar = isSeekBar ? new SeekBar(getContext()) : new ProgressBar(getContext(), null, android.R.attr.progressBarStyleHorizontal);
    Drawable progressDrawable = DrawableCompat.wrap(progressBar.getProgressDrawable());
    if (mTintColor != -1 && progressDrawable != null) {
        DrawableCompat.setTint(progressDrawable, mTintColor);
        progressBar.setProgressDrawable(progressDrawable);
    }
    // N.B. We don't use progressBar.setMin because it doesn't work properly in backcompat
    // and/or sliders.
    progressBar.setMax(mRangeMaxValue - mRangeMinValue);
    progressBar.setProgress(mRangeValue);
    progressBar.setVisibility(View.VISIBLE);
    addView(progressBar);
    mRangeBar = progressBar;
    if (isSeekBar) {
        SliceItem thumb = mRowContent.getInputRangeThumb();
        SeekBar seekBar = (SeekBar) mRangeBar;
        if (thumb != null && thumb.getIcon() != null) {
            Drawable d = thumb.getIcon().loadDrawable(getContext());
            if (d != null) {
                seekBar.setThumb(d);
            }
        }
        Drawable thumbDrawable = DrawableCompat.wrap(seekBar.getThumb());
        if (mTintColor != -1 && thumbDrawable != null) {
            DrawableCompat.setTint(thumbDrawable, mTintColor);
            seekBar.setThumb(thumbDrawable);
        }
        seekBar.setOnSeekBarChangeListener(mSeekBarChangeListener);
    }
}
#end_block

#method_before
void sendSliderValue() {
    if (mRangeItem != null) {
        try {
            mLastSentRangeUpdate = System.currentTimeMillis();
            mRangeItem.fireAction(getContext(), new Intent().addFlags(Intent.FLAG_RECEIVER_FOREGROUND).putExtra(EXTRA_RANGE_VALUE, mRangeValue));
            if (mObserver != null) {
                EventInfo info = new EventInfo(getMode(), ACTION_TYPE_SLIDER, ROW_TYPE_SLIDER, mRowIndex);
                info.state = mRangeValue;
                mObserver.onSliceAction(info, mRangeItem);
            }
        } catch (CanceledException e) {
            Log.e(TAG, "PendingIntent for slice cannot be sent", e);
        }
    }
}
#method_after
void sendSliderValue() {
    if (mRangeItem == null) {
        return;
    }
    try {
        mLastSentRangeUpdate = System.currentTimeMillis();
        mRangeItem.fireAction(getContext(), new Intent().addFlags(Intent.FLAG_RECEIVER_FOREGROUND).putExtra(EXTRA_RANGE_VALUE, mRangeValue));
        if (mObserver != null) {
            EventInfo info = new EventInfo(getMode(), ACTION_TYPE_SLIDER, ROW_TYPE_SLIDER, mRowIndex);
            info.state = mRangeValue;
            mObserver.onSliceAction(info, mRangeItem);
        }
    } catch (CanceledException e) {
        Log.e(TAG, "PendingIntent for slice cannot be sent", e);
    }
}
#end_block

#method_before
private void addSelection(final SliceItem selection) {
    if (mHandler == null) {
        mHandler = new Handler();
    }
    mSelectionOptionKeys = new ArrayList<String>();
    mSelectionOptionValues = new ArrayList<CharSequence>();
    final List<SliceItem> optionItems = selection.getSlice().getItems();
    for (int i = 0; i < optionItems.size(); i++) {
        final SliceItem optionItem = optionItems.get(i);
        final SliceItem optionKeyItem = SliceQuery.findSubtype(optionItem, FORMAT_TEXT, SUBTYPE_SELECTION_OPTION_KEY);
        final SliceItem optionValueItem = SliceQuery.find(optionItem, FORMAT_TEXT, HINT_SELECTION_OPTION_VALUE, null);
        if (optionKeyItem == null || optionValueItem == null) {
            continue;
        }
        mSelectionOptionKeys.add(optionKeyItem.getText().toString());
        mSelectionOptionValues.add(optionValueItem.getSanitizedText());
    }
    mSelectionSpinner = (Spinner) LayoutInflater.from(getContext()).inflate(R.layout.abc_slice_row_selection, this, false);
    final ArrayAdapter<CharSequence> adapter = new ArrayAdapter<>(getContext(), R.layout.abc_slice_row_selection_text, mSelectionOptionValues);
    adapter.setDropDownViewResource(R.layout.abc_slice_row_selection_dropdown_text);
    mSelectionSpinner.setAdapter(adapter);
    addView(mSelectionSpinner);
    updateSelectionPadding();
}
#method_after
private void addSelection(final SliceItem selection) {
    if (mHandler == null) {
        mHandler = new Handler();
    }
    mSelectionOptionKeys = new ArrayList<String>();
    mSelectionOptionValues = new ArrayList<CharSequence>();
    final List<SliceItem> optionItems = selection.getSlice().getItems();
    for (int i = 0; i < optionItems.size(); i++) {
        final SliceItem optionItem = optionItems.get(i);
        if (!optionItem.hasHint(HINT_SELECTION_OPTION)) {
            continue;
        }
        final SliceItem optionKeyItem = SliceQuery.findSubtype(optionItem, FORMAT_TEXT, SUBTYPE_SELECTION_OPTION_KEY);
        final SliceItem optionValueItem = SliceQuery.findSubtype(optionItem, FORMAT_TEXT, SUBTYPE_SELECTION_OPTION_VALUE);
        if (optionKeyItem == null || optionValueItem == null) {
            continue;
        }
        mSelectionOptionKeys.add(optionKeyItem.getText().toString());
        mSelectionOptionValues.add(optionValueItem.getSanitizedText());
    }
    mSelectionSpinner = (Spinner) LayoutInflater.from(getContext()).inflate(R.layout.abc_slice_row_selection, this, false);
    final ArrayAdapter<CharSequence> adapter = new ArrayAdapter<>(getContext(), R.layout.abc_slice_row_selection_text, mSelectionOptionValues);
    adapter.setDropDownViewResource(R.layout.abc_slice_row_selection_dropdown_text);
    mSelectionSpinner.setAdapter(adapter);
    addView(mSelectionSpinner);
    // XXX: onItemSelected is called automatically.
    mSelectionSpinner.setOnItemSelectedListener(this);
}
#end_block

#method_before
@Override
public void onClick(View view) {
    if (mRowAction == null || mRowAction.getActionItem() == null) {
        return;
    }
    SliceActionView sav = mRowAction.isToggle() ? mToggles.get(mRowAction) : mActions.get(mRowAction);
    if (sav != null && !(view instanceof SliceActionView)) {
        // Row might have a single action item set on it, in that case we activate that item
        // and it will handle displaying any loading states / updating state for toggles
        sav.sendAction();
    } else {
        if (mRowIndex == 0) {
            // Header clicks are a little weird and SliceView needs to know about them to
            // maintain loading state; this is hooked up in LargeSliceAdapter -- it will call
            // through to SliceView parent which has the info to perform the click.
            performClick();
        } else {
            try {
                mShowActionSpinner = mRowAction.getActionItem().fireActionInternal(getContext(), null);
                if (mShowActionSpinner && mLoadingListener != null) {
                    mLoadingListener.onSliceActionLoading(mRowAction.getSliceItem(), mRowIndex);
                    mLoadingActions.add(mRowAction.getSliceItem());
                }
                updateActionSpinner();
            } catch (CanceledException e) {
                Log.e(TAG, "PendingIntent for slice cannot be sent", e);
            }
        }
    }
}
#method_after
@Override
public void onClick(View view) {
    if (mRowAction == null || mRowAction.getActionItem() == null) {
        return;
    }
    SliceActionView sav = mRowAction.isToggle() ? mToggles.get(mRowAction) : mActions.get(mRowAction);
    if (sav != null && !(view instanceof SliceActionView)) {
        // Row might have a single action item set on it, in that case we activate that item
        // and it will handle displaying any loading states / updating state for toggles
        sav.sendAction();
    } else {
        if (mRowIndex == 0) {
            // Header clicks are a little weird and SliceView needs to know about them to
            // maintain loading state; this is hooked up in SliceAdapter -- it will call
            // through to SliceView parent which has the info to perform the click.
            performClick();
        } else {
            try {
                mShowActionSpinner = mRowAction.getActionItem().fireActionInternal(getContext(), null);
                if (mObserver != null) {
                    EventInfo info = new EventInfo(getMode(), EventInfo.ACTION_TYPE_CONTENT, EventInfo.ROW_TYPE_LIST, mRowIndex);
                    mObserver.onSliceAction(info, mRowAction.getSliceItem());
                }
                if (mShowActionSpinner && mLoadingListener != null) {
                    mLoadingListener.onSliceActionLoading(mRowAction.getSliceItem(), mRowIndex);
                    mLoadingActions.add(mRowAction.getSliceItem());
                }
                updateActionSpinner();
            } catch (CanceledException e) {
                Log.e(TAG, "PendingIntent for slice cannot be sent", e);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
    if (parent != mSelectionSpinner) {
        return;
    }
    if (position < 0 || position >= mSelectionOptionKeys.size()) {
        return;
    }
    final String optionKey = mSelectionOptionKeys.get(position);
// TODO: Send intent.
}
#method_after
@Override
public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
    if (mSelectionItem == null || parent != mSelectionSpinner || position < 0 || position >= mSelectionOptionKeys.size()) {
        return;
    }
    if (mObserver != null) {
        EventInfo info = new EventInfo(getMode(), ACTION_TYPE_SELECTION, ROW_TYPE_SELECTION, mRowIndex);
        // TODO: Record selected item somehow?
        mObserver.onSliceAction(info, mSelectionItem);
    }
    final String optionKey = mSelectionOptionKeys.get(position);
    try {
        final boolean loading = mSelectionItem.fireActionInternal(getContext(), new Intent().addFlags(Intent.FLAG_RECEIVER_FOREGROUND).putExtra(EXTRA_SELECTION, optionKey));
        if (loading) {
            mShowActionSpinner = true;
            if (mLoadingListener != null) {
                mLoadingListener.onSliceActionLoading(mRowAction.getSliceItem(), mRowIndex);
                mLoadingActions.add(mRowAction.getSliceItem());
            }
            updateActionSpinner();
        }
    } catch (CanceledException e) {
        Log.e(TAG, "PendingIntent for slice cannot be sent", e);
    }
}
#end_block

#method_before
private void resetViewState() {
    mRootView.setVisibility(VISIBLE);
    setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    setViewClickable(mRootView, false);
    setViewClickable(mContent, false);
    mStartContainer.removeAllViews();
    mEndContainer.removeAllViews();
    mEndContainer.setVisibility(GONE);
    mPrimaryText.setText(null);
    mSecondaryText.setText(null);
    mLastUpdatedText.setText(null);
    mLastUpdatedText.setVisibility(GONE);
    mToggles.clear();
    mActions.clear();
    mRowAction = null;
    mStartItem = null;
    mDivider.setVisibility(GONE);
    if (mSeeMoreView != null) {
        mRootView.removeView(mSeeMoreView);
        mSeeMoreView = null;
    }
    mIsRangeSliding = false;
    mRangeHasPendingUpdate = false;
    mRangeItem = null;
    mRangeMinValue = 0;
    mRangeValue = 0;
    mLastSentRangeUpdate = 0;
    mHandler = null;
    if (mRangeBar != null) {
        removeView(mRangeBar);
        mRangeBar = null;
    }
    mActionSpinner.setVisibility(GONE);
    if (mSelectionSpinner != null) {
        removeView(mSelectionSpinner);
        mSelectionSpinner = null;
    }
}
#method_after
private void resetViewState() {
    mRootView.setVisibility(VISIBLE);
    setLayoutDirection(View.LAYOUT_DIRECTION_INHERIT);
    setViewClickable(mRootView, false);
    setViewClickable(mContent, false);
    mStartContainer.removeAllViews();
    mEndContainer.removeAllViews();
    mEndContainer.setVisibility(GONE);
    mPrimaryText.setText(null);
    mSecondaryText.setText(null);
    mLastUpdatedText.setText(null);
    mLastUpdatedText.setVisibility(GONE);
    mToggles.clear();
    mActions.clear();
    mRowAction = null;
    mStartItem = null;
    mBottomDivider.setVisibility(GONE);
    mActionDivider.setVisibility(GONE);
    if (mSeeMoreView != null) {
        mRootView.removeView(mSeeMoreView);
        mSeeMoreView = null;
    }
    mIsRangeSliding = false;
    mRangeHasPendingUpdate = false;
    mRangeItem = null;
    mRangeMinValue = 0;
    mRangeMaxValue = 0;
    mRangeValue = 0;
    mLastSentRangeUpdate = 0;
    mHandler = null;
    if (mRangeBar != null) {
        removeView(mRangeBar);
        mRangeBar = null;
    }
    mActionSpinner.setVisibility(GONE);
    if (mSelectionSpinner != null) {
        removeView(mSelectionSpinner);
        mSelectionSpinner = null;
    }
    mSelectionItem = null;
}
#end_block

#method_before
@Override
public boolean isValid() {
    return super.isValid() && (mStartItem != null || mPrimaryAction != null || mTitleItem != null || mSubtitleItem != null || mEndItems.size() > 0 || mRange != null || isDefaultSeeMore());
}
#method_after
@Override
public boolean isValid() {
    return super.isValid() && (mStartItem != null || mPrimaryAction != null || mTitleItem != null || mSubtitleItem != null || mEndItems.size() > 0 || mRange != null || mSelection != null || isDefaultSeeMore());
}
#end_block

#method_before
@Nullable
public SliceItem getStartItem() {
    return mIsHeader ? null : mStartItem;
}
#method_after
@Nullable
public SliceItem getStartItem() {
    return mIsHeader && !mShowTitleItems ? null : mStartItem;
}
#end_block

#method_before
private static boolean isValidRowContent(SliceItem slice, SliceItem item) {
    // needs to be here, but better safe than sorry.
    if (item.hasAnyHints(HINT_KEYWORDS, HINT_TTL, HINT_LAST_UPDATED, HINT_HORIZONTAL) || SUBTYPE_CONTENT_DESCRIPTION.equals(item.getSubType()) || SUBTYPE_SELECTION_OPTION_KEY.equals(item.getSubType())) {
        return false;
    }
    final String itemFormat = item.getFormat();
    // themselves, they're just used to inform rendering.
    return FORMAT_IMAGE.equals(itemFormat) || FORMAT_TEXT.equals(itemFormat) || FORMAT_LONG.equals(itemFormat) || FORMAT_ACTION.equals(itemFormat) || FORMAT_REMOTE_INPUT.equals(itemFormat) || FORMAT_SLICE.equals(itemFormat) || (FORMAT_INT.equals(itemFormat) && SUBTYPE_RANGE.equals(slice.getSubType()));
}
#method_after
private static boolean isValidRowContent(SliceItem slice, SliceItem item) {
    // needs to be here, but better safe than sorry.
    if (item.hasAnyHints(HINT_KEYWORDS, HINT_TTL, HINT_LAST_UPDATED, HINT_HORIZONTAL) || SUBTYPE_CONTENT_DESCRIPTION.equals(item.getSubType()) || SUBTYPE_SELECTION_OPTION_KEY.equals(item.getSubType()) || SUBTYPE_SELECTION_OPTION_VALUE.equals(item.getSubType())) {
        return false;
    }
    final String itemFormat = item.getFormat();
    // themselves, they're just used to inform rendering.
    return FORMAT_IMAGE.equals(itemFormat) || FORMAT_TEXT.equals(itemFormat) || FORMAT_LONG.equals(itemFormat) || FORMAT_ACTION.equals(itemFormat) || FORMAT_REMOTE_INPUT.equals(itemFormat) || FORMAT_SLICE.equals(itemFormat) || (FORMAT_INT.equals(itemFormat) && SUBTYPE_RANGE.equals(slice.getSubType()));
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@Nullable
public SliceSpec getSpec() {
    return mSpec;
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
@Nullable
public SliceSpec getSpec() {
    return mSpec;
}
#end_block

#method_before
@RestrictTo(Scope.LIBRARY_GROUP)
public boolean hasHint(@SliceHint String hint) {
    return ArrayUtils.contains(mHints, hint);
}
#method_after
@RestrictTo(Scope.LIBRARY_GROUP_PREFIX)
public boolean hasHint(@SliceHint String hint) {
    return ArrayUtils.contains(mHints, hint);
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@Override
public void onPreParceling(boolean isStream) {
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
@Override
public void onPreParceling(boolean isStream) {
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@Override
public void onPostParceling() {
    for (int i = mItems.length - 1; i >= 0; i--) {
        if (mItems[i].mObj == null) {
            mItems = ArrayUtils.removeElement(SliceItem.class, mItems, mItems[i]);
            if (mItems == null) {
                mItems = new SliceItem[0];
            }
        }
    }
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
@Override
public void onPostParceling() {
    for (int i = mItems.length - 1; i >= 0; i--) {
        if (mItems[i].mObj == null) {
            mItems = ArrayUtils.removeElement(SliceItem.class, mItems, mItems[i]);
            if (mItems == null) {
                mItems = new SliceItem[0];
            }
        }
    }
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public Builder setSpec(SliceSpec spec) {
    mSpec = spec;
    return this;
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
public Builder setSpec(SliceSpec spec) {
    mSpec = spec;
    return this;
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public Slice.Builder addRemoteInput(RemoteInput remoteInput, @Nullable String subType, @SliceHint List<String> hints) {
    Preconditions.checkNotNull(remoteInput);
    return addRemoteInput(remoteInput, subType, hints.toArray(new String[hints.size()]));
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
public Slice.Builder addRemoteInput(RemoteInput remoteInput, @Nullable String subType, @SliceHint List<String> hints) {
    Preconditions.checkNotNull(remoteInput);
    return addRemoteInput(remoteInput, subType, hints.toArray(new String[hints.size()]));
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public Slice.Builder addRemoteInput(RemoteInput remoteInput, @Nullable String subType, @SliceHint String... hints) {
    Preconditions.checkNotNull(remoteInput);
    mItems.add(new SliceItem(remoteInput, FORMAT_REMOTE_INPUT, subType, hints));
    return this;
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)
public Slice.Builder addRemoteInput(RemoteInput remoteInput, @Nullable String subType, @SliceHint String... hints) {
    Preconditions.checkNotNull(remoteInput);
    mItems.add(new SliceItem(remoteInput, FORMAT_REMOTE_INPUT, subType, hints));
    return this;
}
#end_block

#method_before
@RestrictTo(Scope.LIBRARY)
public Slice.Builder addItem(SliceItem item) {
    mItems.add(item);
    return this;
}
#method_after
@RestrictTo(Scope.LIBRARY_GROUP)
public Slice.Builder addItem(SliceItem item) {
    mItems.add(item);
    return this;
}
#end_block

#method_before
@RestrictTo(Scope.LIBRARY_GROUP)
@Nullable
public static Slice bindSlice(Context context, @NonNull Uri uri, Set<SliceSpec> supportedSpecs) {
    if (Build.VERSION.SDK_INT >= 28) {
        return callBindSlice(context, uri, supportedSpecs);
    } else {
        return SliceProviderCompat.bindSlice(context, uri, supportedSpecs);
    }
}
#method_after
@RestrictTo(Scope.LIBRARY_GROUP_PREFIX)
@Nullable
public static Slice bindSlice(Context context, @NonNull Uri uri, Set<SliceSpec> supportedSpecs) {
    if (Build.VERSION.SDK_INT >= 28) {
        return callBindSlice(context, uri, supportedSpecs);
    } else {
        return SliceProviderCompat.bindSlice(context, uri, supportedSpecs);
    }
}
#end_block

#method_before
private Object waitForFinalization() {
    if (finalizerTimeoutMs == 0) {
        finalizerTimeoutMs = VMRuntime.getRuntime().getFinalizerTimeoutMs();
    }
    long startCount = FinalizerDaemon.INSTANCE.progressCounter.get();
    // Avoid remembering object being finalized, so as not to keep it alive.
    if (!sleepFor(finalizerTimeoutMs)) {
        // Don't report possibly spurious timeout if we are interrupted.
        return null;
    }
    if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
        // We assume that only remove() and doFinalize() may take time comparable to
        // the finalizer timeout.
        // We observed neither the effect of the gotoSleep() nor the increment preceding a
        // later wakeUp. Any remove() call by the FinalizerDaemon during our sleep
        // interval must have been followed by a wakeUp call before we checked needToWork.
        // But then we would have seen the counter increment.  Thus there cannot have
        // been such a remove() call.
        // The FinalizerDaemon must not have progressed (from either the beginning or the
        // last progressCounter increment) to either the next increment or gotoSleep()
        // call.  Thus we must have taken essentially the whole finalizerTimeoutMs in a
        // single doFinalize() call.  Thus it's OK to time out.  finalizingObject was set
        // just before the counter increment, which preceded the doFinalize call.  Thus we
        // are guaranteed to get the correct finalizing value below, unless doFinalize()
        // just finished as we were timing out, in which case we may get null or a later
        // one.  In this last case, we are very likely to discard it below.
        Object finalizing = FinalizerDaemon.INSTANCE.finalizingObject;
        sleepFor(500);
        // the case which a very slow finalization just finished as we were timing out.
        if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
            return finalizing;
        }
    }
    return null;
}
#method_after
private Object waitForFinalization() {
    if (finalizerTimeoutMs == 0) {
        finalizerTimeoutMs = VMRuntime.getRuntime().getFinalizerTimeoutMs();
        // Temporary app backward compatibility. Remove eventually.
        MAX_FINALIZE_NANOS = NANOS_PER_MILLI * finalizerTimeoutMs;
    }
    long startCount = FinalizerDaemon.INSTANCE.progressCounter.get();
    // Avoid remembering object being finalized, so as not to keep it alive.
    if (!sleepForMillis(finalizerTimeoutMs)) {
        // Don't report possibly spurious timeout if we are interrupted.
        return null;
    }
    if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
        // We assume that only remove() and doFinalize() may take time comparable to
        // the finalizer timeout.
        // We observed neither the effect of the gotoSleep() nor the increment preceding a
        // later wakeUp. Any remove() call by the FinalizerDaemon during our sleep
        // interval must have been followed by a wakeUp call before we checked needToWork.
        // But then we would have seen the counter increment.  Thus there cannot have
        // been such a remove() call.
        // The FinalizerDaemon must not have progressed (from either the beginning or the
        // last progressCounter increment) to either the next increment or gotoSleep()
        // call.  Thus we must have taken essentially the whole finalizerTimeoutMs in a
        // single doFinalize() call.  Thus it's OK to time out.  finalizingObject was set
        // just before the counter increment, which preceded the doFinalize call.  Thus we
        // are guaranteed to get the correct finalizing value below, unless doFinalize()
        // just finished as we were timing out, in which case we may get null or a later
        // one.  In this last case, we are very likely to discard it below.
        Object finalizing = FinalizerDaemon.INSTANCE.finalizingObject;
        sleepForMillis(500);
        // the case which a very slow finalization just finished as we were timing out.
        if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
            return finalizing;
        }
    }
    return null;
}
#end_block

#method_before
private SSLEngine getEngine() throws Exception {
    SSLContext context = SSLContext.getInstance("TLS");
    context.init(null, null, null);
    return context.createSSLEngine();
}
#method_after
private static SSLEngine getEngine() throws Exception {
    SSLContext context = SSLContext.getInstance("TLS");
    context.init(null, null, null);
    return context.createSSLEngine();
}
#end_block

#method_before
private SSLEngine getEngine(String host, int port) throws Exception {
    SSLContext context = SSLContext.getInstance("TLS");
    context.init(null, null, null);
    return context.createSSLEngine(host, port);
}
#method_after
private static SSLEngine getEngine(String host, int port) throws Exception {
    SSLContext context = SSLContext.getInstance("TLS");
    context.init(null, null, null);
    return context.createSSLEngine(host, port);
}
#end_block

#method_before
private SSLEngine getRawEngine(String host, int port) throws Exception {
    return new SSLEngine(host, port) {

        @Override
        public SSLEngineResult wrap(ByteBuffer[] byteBuffers, int i, int i1, ByteBuffer byteBuffer) throws SSLException {
            return null;
        }

        @Override
        public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer[] byteBuffers, int i, int i1) throws SSLException {
            return null;
        }

        @Override
        public Runnable getDelegatedTask() {
            return null;
        }

        @Override
        public void closeInbound() throws SSLException {
        }

        @Override
        public boolean isInboundDone() {
            return false;
        }

        @Override
        public void closeOutbound() {
        }

        @Override
        public boolean isOutboundDone() {
            return false;
        }

        @Override
        public String[] getSupportedCipherSuites() {
            return new String[0];
        }

        @Override
        public String[] getEnabledCipherSuites() {
            return new String[0];
        }

        @Override
        public void setEnabledCipherSuites(String[] strings) {
        }

        @Override
        public String[] getSupportedProtocols() {
            return new String[0];
        }

        @Override
        public String[] getEnabledProtocols() {
            return new String[0];
        }

        @Override
        public void setEnabledProtocols(String[] strings) {
        }

        @Override
        public SSLSession getSession() {
            return null;
        }

        @Override
        public void beginHandshake() throws SSLException {
        }

        @Override
        public HandshakeStatus getHandshakeStatus() {
            return null;
        }

        @Override
        public void setUseClientMode(boolean b) {
        }

        @Override
        public boolean getUseClientMode() {
            return false;
        }

        @Override
        public void setNeedClientAuth(boolean b) {
        }

        @Override
        public boolean getNeedClientAuth() {
            return false;
        }

        @Override
        public void setWantClientAuth(boolean b) {
        }

        @Override
        public boolean getWantClientAuth() {
            return false;
        }

        @Override
        public void setEnableSessionCreation(boolean b) {
        }

        @Override
        public boolean getEnableSessionCreation() {
            return false;
        }
    };
}
#method_after
private static SSLEngine getRawEngine(String host, int port) throws Exception {
    return new SSLEngine(host, port) {

        @Override
        public SSLEngineResult wrap(ByteBuffer[] byteBuffers, int i, int i1, ByteBuffer byteBuffer) throws SSLException {
            return null;
        }

        @Override
        public SSLEngineResult unwrap(ByteBuffer byteBuffer, ByteBuffer[] byteBuffers, int i, int i1) throws SSLException {
            return null;
        }

        @Override
        public Runnable getDelegatedTask() {
            return null;
        }

        @Override
        public void closeInbound() throws SSLException {
        }

        @Override
        public boolean isInboundDone() {
            return false;
        }

        @Override
        public void closeOutbound() {
        }

        @Override
        public boolean isOutboundDone() {
            return false;
        }

        @Override
        public String[] getSupportedCipherSuites() {
            return new String[0];
        }

        @Override
        public String[] getEnabledCipherSuites() {
            return new String[0];
        }

        @Override
        public void setEnabledCipherSuites(String[] strings) {
        }

        @Override
        public String[] getSupportedProtocols() {
            return new String[0];
        }

        @Override
        public String[] getEnabledProtocols() {
            return new String[0];
        }

        @Override
        public void setEnabledProtocols(String[] strings) {
        }

        @Override
        public SSLSession getSession() {
            return null;
        }

        @Override
        public void beginHandshake() throws SSLException {
        }

        @Override
        public HandshakeStatus getHandshakeStatus() {
            return null;
        }

        @Override
        public void setUseClientMode(boolean b) {
        }

        @Override
        public boolean getUseClientMode() {
            return false;
        }

        @Override
        public void setNeedClientAuth(boolean b) {
        }

        @Override
        public boolean getNeedClientAuth() {
            return false;
        }

        @Override
        public void setWantClientAuth(boolean b) {
        }

        @Override
        public boolean getWantClientAuth() {
            return false;
        }

        @Override
        public void setEnableSessionCreation(boolean b) {
        }

        @Override
        public boolean getEnableSessionCreation() {
            return false;
        }
    };
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothSocket createL2capChannel(int psm) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "createL2capChannel: Bluetooth is not enabled");
        throw new IOException();
    }
    if (DBG)
        Log.d(TAG, "createL2capChannel: psm=" + psm);
    return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP_LE, -1, true, true, this, psm, null);
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@NonNull
public BluetoothSocket createL2capChannel(int psm) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "createL2capChannel: Bluetooth is not enabled");
        throw new IOException();
    }
    if (DBG)
        Log.d(TAG, "createL2capChannel: psm=" + psm);
    return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP_LE, -1, true, true, this, psm, null);
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTH)
public BluetoothSocket createInsecureL2capChannel(int psm) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "createInsecureL2capChannel: Bluetooth is not enabled");
        throw new IOException();
    }
    if (DBG) {
        Log.d(TAG, "createInsecureL2capChannel: psm=" + psm);
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP_LE, -1, false, false, this, psm, null);
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH)
@NonNull
public BluetoothSocket createInsecureL2capChannel(int psm) throws IOException {
    if (!isBluetoothEnabled()) {
        Log.e(TAG, "createInsecureL2capChannel: Bluetooth is not enabled");
        throw new IOException();
    }
    if (DBG) {
        Log.d(TAG, "createInsecureL2capChannel: psm=" + psm);
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_L2CAP_LE, -1, false, false, this, psm, null);
}
#end_block

#method_before
@Test
public void filterText_usingKeyboard() throws Exception {
    sMockImeSessionRule.assumeAvailable();
    final String AA = "Two A's";
    final String AB = "A and B";
    final String B = "Only B";
    final MockImeSession mockImeSession = sMockImeSessionRule.getMockImeSession();
    enableService();
    // Set expectations.
    sReplier.addResponse(new CannedFillResponse.Builder().addDataset(new CannedDataset.Builder().setField(ID_USERNAME, "aa").setPresentation(createPresentation(AA)).build()).addDataset(new CannedDataset.Builder().setField(ID_USERNAME, "ab").setPresentation(createPresentation(AB)).build()).addDataset(new CannedDataset.Builder().setField(ID_USERNAME, "b").setPresentation(createPresentation(B)).build()).build());
    final ImeEventStream stream = mockImeSession.openEventStream();
    // Trigger auto-fill.
    mActivity.onUsername(View::requestFocus);
    sReplier.getNextFillRequest();
    // Wait until the MockIme gets bound to the TestActivity.
    expectBindInput(stream, Process.myPid(), MOCK_IME_TIMEOUT_MS);
    expectEvent(stream, editorMatcher("onStartInput", mActivity.getUsername().getId()), MOCK_IME_TIMEOUT_MS);
    // With no filter text all datasets should be shown
    sUiBot.assertDatasets(AA, AB, B);
    // Only two datasets start with 'a'
    final ImeCommand cmd1 = mockImeSession.callCommitText("a", 1);
    expectCommand(stream, cmd1, MOCK_IME_TIMEOUT_MS);
    sUiBot.assertDatasets(AA, AB);
    // Only one dataset start with 'aa'
    final ImeCommand cmd2 = mockImeSession.callCommitText("a", 1);
    expectCommand(stream, cmd2, MOCK_IME_TIMEOUT_MS);
    sUiBot.assertDatasets(AA);
    // Only two datasets start with 'a'
    // NOTE: MockIme on O doesn't support it
    runShellCommand("input keyevent KEYCODE_DEL");
    sUiBot.assertDatasets(AA, AB);
    // With no filter text all datasets should be shown
    // NOTE: MockIme on O doesn't support it
    runShellCommand("input keyevent KEYCODE_DEL");
    sUiBot.assertDatasets(AA, AB, B);
    // No dataset start with 'aaa'
    final ImeCommand cmd5 = mockImeSession.callCommitText("aaa", 1);
    expectCommand(stream, cmd5, MOCK_IME_TIMEOUT_MS);
    sUiBot.assertNoDatasets();
}
#method_after
@Test
public void filterText_usingKeyboard() throws Exception {
    sMockImeSessionRule.assumeAvailable();
    Log.v(TAG, "filterText_usingKeyboard(): Good News, Everyone! MockIme is available!");
    final String AA = "Two A's";
    final String AB = "A and B";
    final String B = "Only B";
    final MockImeSession mockImeSession = sMockImeSessionRule.getMockImeSession();
    enableService();
    // Set expectations.
    sReplier.addResponse(new CannedFillResponse.Builder().addDataset(new CannedDataset.Builder().setField(ID_USERNAME, "aa").setPresentation(createPresentation(AA)).build()).addDataset(new CannedDataset.Builder().setField(ID_USERNAME, "ab").setPresentation(createPresentation(AB)).build()).addDataset(new CannedDataset.Builder().setField(ID_USERNAME, "b").setPresentation(createPresentation(B)).build()).build());
    final ImeEventStream stream = mockImeSession.openEventStream();
    // Trigger auto-fill.
    mActivity.onUsername(View::requestFocus);
    sReplier.getNextFillRequest();
    // Wait until the MockIme gets bound to the TestActivity.
    expectBindInput(stream, Process.myPid(), MOCK_IME_TIMEOUT_MS);
    expectEvent(stream, editorMatcher("onStartInput", mActivity.getUsername().getId()), MOCK_IME_TIMEOUT_MS);
    // With no filter text all datasets should be shown
    sUiBot.assertDatasets(AA, AB, B);
    // Only two datasets start with 'a'
    final ImeCommand cmd1 = mockImeSession.callCommitText("a", 1);
    expectCommand(stream, cmd1, MOCK_IME_TIMEOUT_MS);
    sUiBot.assertDatasets(AA, AB);
    // Only one dataset start with 'aa'
    final ImeCommand cmd2 = mockImeSession.callCommitText("a", 1);
    expectCommand(stream, cmd2, MOCK_IME_TIMEOUT_MS);
    sUiBot.assertDatasets(AA);
    // Only two datasets start with 'a'
    // NOTE: MockIme on O doesn't support it
    runShellCommand("input keyevent KEYCODE_DEL");
    sUiBot.assertDatasets(AA, AB);
    // With no filter text all datasets should be shown
    // NOTE: MockIme on O doesn't support it
    runShellCommand("input keyevent KEYCODE_DEL");
    sUiBot.assertDatasets(AA, AB, B);
    // No dataset start with 'aaa'
    final ImeCommand cmd5 = mockImeSession.callCommitText("aaa", 1);
    expectCommand(stream, cmd5, MOCK_IME_TIMEOUT_MS);
    sUiBot.assertNoDatasets();
}
#end_block

#method_before
private void initialize(@Nullable ImeSettings.Builder imeSettings) throws Exception {
    // Make sure that MockIME is not selected.
    if (mContext.getSystemService(InputMethodManager.class).getInputMethodList().stream().anyMatch(info -> getMockImeComponentName().equals(info.getComponent()))) {
        // NOTE: 'ime reset' was introduced on P
        executeShellCommand(mUiAutomation, "ime disable " + getMockImeId());
    }
    if (mContext.getSystemService(InputMethodManager.class).getEnabledInputMethodList().stream().anyMatch(info -> getMockImeComponentName().equals(info.getComponent()))) {
        throw new IllegalStateException();
    }
    writeMockImeSettings(mContext, mImeEventActionName, imeSettings);
    mHandlerThread.start();
    mContext.registerReceiver(mEventReceiver, new IntentFilter(mImeEventActionName), null, /* broadcastPermission */
    new Handler(mHandlerThread.getLooper()));
    executeShellCommand(mUiAutomation, "ime enable " + getMockImeId());
    executeShellCommand(mUiAutomation, "ime set " + getMockImeId());
    PollingCheck.check("Make sure that MockIME becomes available", TIMEOUT, () -> getMockImeId().equals(getCurrentInputMethodId()));
}
#method_after
private void initialize(@Nullable ImeSettings.Builder imeSettings) throws Exception {
    // NOTE: on P we call 'ime reset', but it's not available on O, so we're just ignoring it -
    // we don't really need the IME and it will be effectively disabled after this APK is
    // uninstalled.
    writeMockImeSettings(mContext, mImeEventActionName, imeSettings);
    mHandlerThread.start();
    mContext.registerReceiver(mEventReceiver, new IntentFilter(mImeEventActionName), null, /* broadcastPermission */
    new Handler(mHandlerThread.getLooper()));
    executeShellCommand(mUiAutomation, "ime enable " + getMockImeId());
    executeShellCommand(mUiAutomation, "ime set " + getMockImeId());
    PollingCheck.check("Make sure that MockIME becomes available", TIMEOUT, () -> getMockImeId().equals(getCurrentInputMethodId()));
}
#end_block

#method_before
public void close() throws Exception {
    // NOTE: 'ime reset' was introduced on P
    executeShellCommand(mUiAutomation, "ime disable " + getMockImeId());
    PollingCheck.check("Make sure that MockIME becomes unavailable", TIMEOUT, () -> mContext.getSystemService(InputMethodManager.class).getEnabledInputMethodList().stream().noneMatch(info -> getMockImeComponentName().equals(info.getComponent())));
    mContext.unregisterReceiver(mEventReceiver);
    mHandlerThread.quitSafely();
    mContext.getContentResolver().call(SettingsProvider.AUTHORITY, "delete", null, null);
}
#method_after
public void close() throws Exception {
    // NOTE: on P we call 'ime reset', but it's not available on O, so we're just ignoring it -
    // we don't really need the IME and it will be effectively disabled after this APK is
    // uninstalled.
    mContext.unregisterReceiver(mEventReceiver);
    mHandlerThread.quitSafely();
    mContext.getContentResolver().call(SettingsProvider.AUTHORITY, "delete", null, null);
}
#end_block

#method_before
OneoffTask convert(@NonNull WorkSpec workSpec) {
    OneoffTask.Builder builder = new OneoffTask.Builder();
    builder.setService(WorkManagerGcmService.class).setTag(workSpec.id).setUpdateCurrent(true).setPersisted(false);
    // Next run time is in seconds.
    long now = SECONDS.convert(now(), MILLISECONDS);
    long nextRunTimeInSeconds = SECONDS.convert(workSpec.calculateNextRunTime(), MILLISECONDS);
    // GCMNetworkManager needs the execution window to be relative from the present.
    long offset = Math.max(nextRunTimeInSeconds - now, 0);
    builder.setExecutionWindow(offset, offset + EXECUTION_WINDOW_SIZE);
    applyConstraints(builder, workSpec);
    return builder.build();
}
#method_after
OneoffTask convert(@NonNull WorkSpec workSpec) {
    OneoffTask.Builder builder = new OneoffTask.Builder();
    builder.setService(WorkManagerGcmService.class).setTag(workSpec.id).setUpdateCurrent(true).setPersisted(false);
    // Next run time is in seconds.
    long now = SECONDS.convert(now(), MILLISECONDS);
    long nextRunTimeInSeconds = SECONDS.convert(workSpec.calculateNextRunTime(), MILLISECONDS);
    // GCMNetworkManager needs the execution window to be relative from the present.
    long offset = Math.max(nextRunTimeInSeconds - now, 0);
    builder.setExecutionWindow(offset, offset + EXECUTION_WINDOW_SIZE_IN_SECONDS);
    applyConstraints(builder, workSpec);
    return builder.build();
}
#end_block

#method_before
@Override
public int onRunTask(@NonNull TaskParams taskParams) {
    Logger.get().debug(TAG, String.format("Handing task %s", taskParams));
    String tag = taskParams.getTag();
    if (tag == null || tag.isEmpty()) {
        // Bad request. No WorkSpec id.
        Logger.get().debug(TAG, "Bad request. No tag.");
        return GcmNetworkManager.RESULT_FAILURE;
    }
    WorkSpecExecutionListener listener = new WorkSpecExecutionListener(tag);
    mWorkManager.getProcessor().addExecutionListener(listener);
    mWorkManager.startWork(tag);
    try {
        listener.getLatch().await(AWAIT_TIME_IN_MINUTES, TimeUnit.MINUTES);
    } catch (InterruptedException exception) {
        Logger.get().debug(TAG, String.format("%s being rescheduled", tag), exception);
        return reschedule(tag);
    } finally {
        mWorkManager.getProcessor().removeExecutionListener(listener);
    }
    if (listener.needsReschedule()) {
        Logger.get().debug(TAG, String.format("%s being rescheduled", tag));
        return reschedule(tag);
    }
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(tag);
    switch(workSpec.state) {
        case SUCCEEDED:
        case CANCELLED:
            Logger.get().debug(TAG, String.format("%s is being treated as successful", tag));
            return GcmNetworkManager.RESULT_SUCCESS;
        case FAILED:
            Logger.get().debug(TAG, String.format("%s is being treated as failed", tag));
            return GcmNetworkManager.RESULT_FAILURE;
        default:
            Logger.get().debug(TAG, "Rescheduling eligible work.");
            return reschedule(tag);
    }
}
#method_after
@Override
public int onRunTask(@NonNull TaskParams taskParams) {
    // Tasks may be executed concurrently but every Task will be executed in a unique thread
    // per tag, which in our case is a workSpecId. Therefore its safe to block here with
    // a latch because there is 1 thread per workSpecId.
    Logger.get().debug(TAG, String.format("Handling task %s", taskParams));
    String workSpecId = taskParams.getTag();
    if (workSpecId == null || workSpecId.isEmpty()) {
        // Bad request. No WorkSpec id.
        Logger.get().debug(TAG, "Bad request. No workSpecId.");
        return GcmNetworkManager.RESULT_FAILURE;
    }
    WorkSpecExecutionListener listener = new WorkSpecExecutionListener(workSpecId);
    Processor processor = mWorkManager.getProcessor();
    processor.addExecutionListener(listener);
    mWorkManager.startWork(workSpecId);
    try {
        listener.getLatch().await(AWAIT_TIME_IN_MINUTES, TimeUnit.MINUTES);
    } catch (InterruptedException exception) {
        Logger.get().debug(TAG, String.format("Rescheduling WorkSpec %s", workSpecId));
        return reschedule(workSpecId);
    } finally {
        processor.removeExecutionListener(listener);
    }
    if (listener.needsReschedule()) {
        Logger.get().debug(TAG, String.format("Rescheduling WorkSpec %s", workSpecId));
        return reschedule(workSpecId);
    }
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    WorkSpec workSpec = workDatabase.workSpecDao().getWorkSpec(workSpecId);
    switch(workSpec.state) {
        case SUCCEEDED:
        case CANCELLED:
            Logger.get().debug(TAG, String.format("Returning RESULT_SUCCESS for WorkSpec %s", workSpecId));
            return GcmNetworkManager.RESULT_SUCCESS;
        case FAILED:
            Logger.get().debug(TAG, String.format("Returning RESULT_FAILURE for WorkSpec %s", workSpecId));
            return GcmNetworkManager.RESULT_FAILURE;
        default:
            Logger.get().debug(TAG, "Rescheduling eligible work.");
            return reschedule(workSpecId);
    }
}
#end_block

#method_before
private int reschedule(@NonNull String tag) {
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    try {
        workDatabase.beginTransaction();
        // Mark the workSpec as unscheduled. We are doing this explicitly here because
        // there are many cases where WorkerWrapper may not have had a chance to update this
        // flag. For e.g. this will happen if the Worker took longer than 10 minutes.
        workDatabase.workSpecDao().markWorkSpecScheduled(tag, WorkSpec.SCHEDULE_NOT_REQUESTED_YET);
        // We reschedule on our own to apply our own backoff policy.
        Schedulers.schedule(mWorkManager.getConfiguration(), mWorkManager.getWorkDatabase(), mWorkManager.getSchedulers());
        workDatabase.setTransactionSuccessful();
    } finally {
        workDatabase.endTransaction();
    }
    Logger.get().debug(TAG, String.format("%s being treated as successful", tag));
    return GcmNetworkManager.RESULT_SUCCESS;
}
#method_after
private int reschedule(@NonNull String workSpecId) {
    WorkDatabase workDatabase = mWorkManager.getWorkDatabase();
    try {
        workDatabase.beginTransaction();
        // Mark the workSpec as unscheduled. We are doing this explicitly here because
        // there are many cases where WorkerWrapper may not have had a chance to update this
        // flag. For e.g. this will happen if the Worker took longer than 10 minutes.
        workDatabase.workSpecDao().markWorkSpecScheduled(workSpecId, WorkSpec.SCHEDULE_NOT_REQUESTED_YET);
        // We reschedule on our own to apply our own backoff policy.
        Schedulers.schedule(mWorkManager.getConfiguration(), mWorkManager.getWorkDatabase(), mWorkManager.getSchedulers());
        workDatabase.setTransactionSuccessful();
    } finally {
        workDatabase.endTransaction();
    }
    Logger.get().debug(TAG, String.format("Returning RESULT_SUCCESS for WorkSpec %s", workSpecId));
    return GcmNetworkManager.RESULT_SUCCESS;
}
#end_block

#method_before
@Override
public void onExecuted(@NonNull String workSpecId, boolean needsReschedule) {
    if (!mTag.equals(workSpecId)) {
        Logger.get().warning(TAG, String.format("Notified for %s, but was looking for %s", workSpecId, mTag));
    } else {
        mNeedsReschedule = needsReschedule;
        mLatch.countDown();
    }
}
#method_after
@Override
public void onExecuted(@NonNull String workSpecId, boolean needsReschedule) {
    if (!mWorkSpecId.equals(workSpecId)) {
        Logger.get().warning(TAG, String.format("Notified for %s, but was looking for %s", workSpecId, mWorkSpecId));
    } else {
        mNeedsReschedule = needsReschedule;
        mLatch.countDown();
    }
}
#end_block

#method_before
@NonNull
// TODO https://issuetracker.google.com/issues/110576968
@SuppressLint("NewApi")
static Scheduler createBestAvailableBackgroundScheduler(@NonNull Context context, @NonNull WorkManagerImpl workManager) {
    Scheduler scheduler;
    if (Build.VERSION.SDK_INT >= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL) {
        scheduler = new SystemJobScheduler(context, workManager);
        setComponentEnabled(context, SystemJobService.class, true);
        Logger.get().debug(TAG, "Created SystemJobScheduler and enabled SystemJobService");
    } else {
        scheduler = tryGcmBasedScheduler(context);
        if (scheduler == null) {
            scheduler = new SystemAlarmScheduler(context);
            setComponentEnabled(context, SystemAlarmService.class, true);
            Logger.get().debug(TAG, "Created SystemAlarmScheduler");
        }
    }
    return scheduler;
}
#method_after
@NonNull
// TODO https://issuetracker.google.com/issues/110576968
@SuppressLint("NewApi")
static Scheduler createBestAvailableBackgroundScheduler(@NonNull Context context, @NonNull WorkManagerImpl workManager) {
    Scheduler scheduler;
    if (Build.VERSION.SDK_INT >= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL) {
        scheduler = new SystemJobScheduler(context, workManager);
        setComponentEnabled(context, SystemJobService.class, true);
        Logger.get().debug(TAG, "Created SystemJobScheduler and enabled SystemJobService");
    } else {
        scheduler = tryCreateGcmBasedScheduler(context);
        if (scheduler == null) {
            scheduler = new SystemAlarmScheduler(context);
            setComponentEnabled(context, SystemAlarmService.class, true);
            Logger.get().debug(TAG, "Created SystemAlarmScheduler");
        }
    }
    return scheduler;
}
#end_block

#method_before
private static boolean enqueueWorkWithPrerequisites(WorkManagerImpl workManagerImpl, @NonNull List<? extends WorkRequest> workList, String[] prerequisiteIds, String name, ExistingWorkPolicy existingWorkPolicy) {
    boolean needsScheduling = false;
    long currentTimeMillis = System.currentTimeMillis();
    WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
    boolean hasPrerequisite = (prerequisiteIds != null && prerequisiteIds.length > 0);
    boolean hasCompletedAllPrerequisites = true;
    boolean hasFailedPrerequisites = false;
    boolean hasCancelledPrerequisites = false;
    if (hasPrerequisite) {
        // chain of work could have been wiped out already.
        for (String id : prerequisiteIds) {
            WorkSpec prerequisiteWorkSpec = workDatabase.workSpecDao().getWorkSpec(id);
            if (prerequisiteWorkSpec == null) {
                Logger.get().error(TAG, String.format("Prerequisite %s doesn't exist; not enqueuing", id));
                return false;
            }
            WorkInfo.State prerequisiteState = prerequisiteWorkSpec.state;
            hasCompletedAllPrerequisites &= (prerequisiteState == SUCCEEDED);
            if (prerequisiteState == FAILED) {
                hasFailedPrerequisites = true;
            } else if (prerequisiteState == CANCELLED) {
                hasCancelledPrerequisites = true;
            }
        }
    }
    boolean isNamed = !TextUtils.isEmpty(name);
    // We only apply existing work policies for unique tag sequences that are the beginning of
    // chains.
    boolean shouldApplyExistingWorkPolicy = isNamed && !hasPrerequisite;
    if (shouldApplyExistingWorkPolicy) {
        // Get everything with the unique tag.
        List<WorkSpec.IdAndState> existingWorkSpecIdAndStates = workDatabase.workSpecDao().getWorkSpecIdAndStatesForName(name);
        if (!existingWorkSpecIdAndStates.isEmpty()) {
            // If appending, these are the new prerequisites.
            if (existingWorkPolicy == APPEND) {
                DependencyDao dependencyDao = workDatabase.dependencyDao();
                List<String> newPrerequisiteIds = new ArrayList<>();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    if (!dependencyDao.hasDependents(idAndState.id)) {
                        hasCompletedAllPrerequisites &= (idAndState.state == SUCCEEDED);
                        if (idAndState.state == FAILED) {
                            hasFailedPrerequisites = true;
                        } else if (idAndState.state == CANCELLED) {
                            hasCancelledPrerequisites = true;
                        }
                        newPrerequisiteIds.add(idAndState.id);
                    }
                }
                prerequisiteIds = newPrerequisiteIds.toArray(prerequisiteIds);
                hasPrerequisite = (prerequisiteIds.length > 0);
            } else {
                // enqueued or running.
                if (existingWorkPolicy == KEEP) {
                    for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                        if (idAndState.state == ENQUEUED || idAndState.state == RUNNING) {
                            return false;
                        }
                    }
                }
                // Cancel all of these workers.
                // Don't allow rescheduling in CancelWorkRunnable because it will happen inside
                // the current transaction.  We want it to happen separately to avoid race
                // conditions (see ag/4502245, which tries to avoid work trying to run before
                // it's actually been committed to the database).
                CancelWorkRunnable.forName(name, workManagerImpl, false).run();
                // Because we cancelled some work but didn't allow rescheduling inside
                // CancelWorkRunnable, we need to make sure we do schedule work at the end of
                // this runnable.
                needsScheduling = true;
                // And delete all the database records.
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    workSpecDao.delete(idAndState.id);
                }
            }
        }
    }
    for (WorkRequest work : workList) {
        WorkSpec workSpec = work.getWorkSpec();
        if (hasPrerequisite && !hasCompletedAllPrerequisites) {
            if (hasFailedPrerequisites) {
                workSpec.state = FAILED;
            } else if (hasCancelledPrerequisites) {
                workSpec.state = CANCELLED;
            } else {
                workSpec.state = BLOCKED;
            }
        } else {
            // unblocked.
            if (!workSpec.isPeriodic()) {
                workSpec.periodStartTime = currentTimeMillis;
            } else {
                workSpec.periodStartTime = 0L;
            }
        }
        if (Build.VERSION.SDK_INT >= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL && Build.VERSION.SDK_INT <= 25) {
            tryDelegateConstrainedWorkSpec(workSpec);
        } else if (Build.VERSION.SDK_INT <= WorkManagerImpl.MAX_PRE_JOB_SCHEDULER_API_LEVEL && workManagerImpl.usesScheduler(Schedulers.GCM_SCHEDULER)) {
            tryDelegateConstrainedWorkSpec(workSpec);
        }
        // If we have one WorkSpec with an enqueued state, then we need to schedule.
        if (workSpec.state == ENQUEUED) {
            needsScheduling = true;
        }
        workDatabase.workSpecDao().insertWorkSpec(workSpec);
        if (hasPrerequisite) {
            for (String prerequisiteId : prerequisiteIds) {
                Dependency dep = new Dependency(work.getStringId(), prerequisiteId);
                workDatabase.dependencyDao().insertDependency(dep);
            }
        }
        for (String tag : work.getTags()) {
            workDatabase.workTagDao().insert(new WorkTag(tag, work.getStringId()));
        }
        if (isNamed) {
            workDatabase.workNameDao().insert(new WorkName(name, work.getStringId()));
        }
    }
    return needsScheduling;
}
#method_after
private static boolean enqueueWorkWithPrerequisites(WorkManagerImpl workManagerImpl, @NonNull List<? extends WorkRequest> workList, String[] prerequisiteIds, String name, ExistingWorkPolicy existingWorkPolicy) {
    boolean needsScheduling = false;
    long currentTimeMillis = System.currentTimeMillis();
    WorkDatabase workDatabase = workManagerImpl.getWorkDatabase();
    boolean hasPrerequisite = (prerequisiteIds != null && prerequisiteIds.length > 0);
    boolean hasCompletedAllPrerequisites = true;
    boolean hasFailedPrerequisites = false;
    boolean hasCancelledPrerequisites = false;
    if (hasPrerequisite) {
        // chain of work could have been wiped out already.
        for (String id : prerequisiteIds) {
            WorkSpec prerequisiteWorkSpec = workDatabase.workSpecDao().getWorkSpec(id);
            if (prerequisiteWorkSpec == null) {
                Logger.get().error(TAG, String.format("Prerequisite %s doesn't exist; not enqueuing", id));
                return false;
            }
            WorkInfo.State prerequisiteState = prerequisiteWorkSpec.state;
            hasCompletedAllPrerequisites &= (prerequisiteState == SUCCEEDED);
            if (prerequisiteState == FAILED) {
                hasFailedPrerequisites = true;
            } else if (prerequisiteState == CANCELLED) {
                hasCancelledPrerequisites = true;
            }
        }
    }
    boolean isNamed = !TextUtils.isEmpty(name);
    // We only apply existing work policies for unique tag sequences that are the beginning of
    // chains.
    boolean shouldApplyExistingWorkPolicy = isNamed && !hasPrerequisite;
    if (shouldApplyExistingWorkPolicy) {
        // Get everything with the unique tag.
        List<WorkSpec.IdAndState> existingWorkSpecIdAndStates = workDatabase.workSpecDao().getWorkSpecIdAndStatesForName(name);
        if (!existingWorkSpecIdAndStates.isEmpty()) {
            // If appending, these are the new prerequisites.
            if (existingWorkPolicy == APPEND) {
                DependencyDao dependencyDao = workDatabase.dependencyDao();
                List<String> newPrerequisiteIds = new ArrayList<>();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    if (!dependencyDao.hasDependents(idAndState.id)) {
                        hasCompletedAllPrerequisites &= (idAndState.state == SUCCEEDED);
                        if (idAndState.state == FAILED) {
                            hasFailedPrerequisites = true;
                        } else if (idAndState.state == CANCELLED) {
                            hasCancelledPrerequisites = true;
                        }
                        newPrerequisiteIds.add(idAndState.id);
                    }
                }
                prerequisiteIds = newPrerequisiteIds.toArray(prerequisiteIds);
                hasPrerequisite = (prerequisiteIds.length > 0);
            } else {
                // enqueued or running.
                if (existingWorkPolicy == KEEP) {
                    for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                        if (idAndState.state == ENQUEUED || idAndState.state == RUNNING) {
                            return false;
                        }
                    }
                }
                // Cancel all of these workers.
                // Don't allow rescheduling in CancelWorkRunnable because it will happen inside
                // the current transaction.  We want it to happen separately to avoid race
                // conditions (see ag/4502245, which tries to avoid work trying to run before
                // it's actually been committed to the database).
                CancelWorkRunnable.forName(name, workManagerImpl, false).run();
                // Because we cancelled some work but didn't allow rescheduling inside
                // CancelWorkRunnable, we need to make sure we do schedule work at the end of
                // this runnable.
                needsScheduling = true;
                // And delete all the database records.
                WorkSpecDao workSpecDao = workDatabase.workSpecDao();
                for (WorkSpec.IdAndState idAndState : existingWorkSpecIdAndStates) {
                    workSpecDao.delete(idAndState.id);
                }
            }
        }
    }
    for (WorkRequest work : workList) {
        WorkSpec workSpec = work.getWorkSpec();
        if (hasPrerequisite && !hasCompletedAllPrerequisites) {
            if (hasFailedPrerequisites) {
                workSpec.state = FAILED;
            } else if (hasCancelledPrerequisites) {
                workSpec.state = CANCELLED;
            } else {
                workSpec.state = BLOCKED;
            }
        } else {
            // unblocked.
            if (!workSpec.isPeriodic()) {
                workSpec.periodStartTime = currentTimeMillis;
            } else {
                workSpec.periodStartTime = 0L;
            }
        }
        if (Build.VERSION.SDK_INT >= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL && Build.VERSION.SDK_INT <= 25) {
            tryDelegateConstrainedWorkSpec(workSpec);
        } else if (Build.VERSION.SDK_INT <= WorkManagerImpl.MAX_PRE_JOB_SCHEDULER_API_LEVEL && usesScheduler(workManagerImpl, Schedulers.GCM_SCHEDULER)) {
            tryDelegateConstrainedWorkSpec(workSpec);
        }
        // If we have one WorkSpec with an enqueued state, then we need to schedule.
        if (workSpec.state == ENQUEUED) {
            needsScheduling = true;
        }
        workDatabase.workSpecDao().insertWorkSpec(workSpec);
        if (hasPrerequisite) {
            for (String prerequisiteId : prerequisiteIds) {
                Dependency dep = new Dependency(work.getStringId(), prerequisiteId);
                workDatabase.dependencyDao().insertDependency(dep);
            }
        }
        for (String tag : work.getTags()) {
            workDatabase.workTagDao().insert(new WorkTag(tag, work.getStringId()));
        }
        if (isNamed) {
            workDatabase.workNameDao().insert(new WorkName(name, work.getStringId()));
        }
    }
    return needsScheduling;
}
#end_block

#method_before
public boolean enableCellBroadcast(int messageIdentifier, int ranType) {
    boolean success = false;
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns -1, we will use the default phone internally.
            success = iSms.enableCellBroadcastForSubscriber(getSubIdOrDefault(), messageIdentifier, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#method_after
public boolean enableCellBroadcast(int messageIdentifier, int ranType) {
    boolean success = false;
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns INVALID, we will use the default phone internally.
            success = iSms.enableCellBroadcastForSubscriber(getSubIdOrDefault(), messageIdentifier, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#end_block

#method_before
public boolean disableCellBroadcast(int messageIdentifier, int ranType) {
    boolean success = false;
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns -1, we will use the default phone internally.
            success = iSms.disableCellBroadcastForSubscriber(getSubIdOrDefault(), messageIdentifier, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#method_after
public boolean disableCellBroadcast(int messageIdentifier, int ranType) {
    boolean success = false;
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns INVALID, we will use the default phone internally.
            success = iSms.disableCellBroadcastForSubscriber(getSubIdOrDefault(), messageIdentifier, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#end_block

#method_before
@UnsupportedAppUsage
public boolean enableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
    boolean success = false;
    if (endMessageId < startMessageId) {
        throw new IllegalArgumentException("endMessageId < startMessageId");
    }
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns -1, we will use the default phone internally.
            success = iSms.enableCellBroadcastRangeForSubscriber(getSubIdOrDefault(), startMessageId, endMessageId, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#method_after
@UnsupportedAppUsage
public boolean enableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
    boolean success = false;
    if (endMessageId < startMessageId) {
        throw new IllegalArgumentException("endMessageId < startMessageId");
    }
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns INVALID, we will use the default phone internally.
            success = iSms.enableCellBroadcastRangeForSubscriber(getSubIdOrDefault(), startMessageId, endMessageId, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#end_block

#method_before
@UnsupportedAppUsage
public boolean disableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
    boolean success = false;
    if (endMessageId < startMessageId) {
        throw new IllegalArgumentException("endMessageId < startMessageId");
    }
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns -1, we will use the default phone internally.
            success = iSms.disableCellBroadcastRangeForSubscriber(getSubIdOrDefault(), startMessageId, endMessageId, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#method_after
@UnsupportedAppUsage
public boolean disableCellBroadcastRange(int startMessageId, int endMessageId, int ranType) {
    boolean success = false;
    if (endMessageId < startMessageId) {
        throw new IllegalArgumentException("endMessageId < startMessageId");
    }
    try {
        ISms iSms = getISmsService();
        if (iSms != null) {
            // If getSubIdOrDefault() returns INVALID, we will use the default phone internally.
            success = iSms.disableCellBroadcastRangeForSubscriber(getSubIdOrDefault(), startMessageId, endMessageId, ranType);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return success;
}
#end_block

#method_before
@UnsupportedAppUsage
public void stop() {
    try {
        mService.stopKeepalive(mNetwork, mSlot);
    } catch (RemoteException e) {
        Log.e(TAG, "Error stopping packet keepalive: ", e);
        stopLooper();
    }
}
#method_after
@UnsupportedAppUsage
public void stop() {
    try {
        mExecutor.execute(() -> {
            try {
                if (mSlot != null) {
                    mService.stopKeepalive(mNetwork, mSlot);
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Error stopping packet keepalive: ", e);
                throw e.rethrowFromSystemServer();
            }
        });
    } catch (RejectedExecutionException e) {
    // The internal executor has already stopped due to previous event.
    }
}
#end_block

#method_before
@UnsupportedAppUsage
public PacketKeepalive startNattKeepalive(Network network, int intervalSeconds, PacketKeepaliveCallback callback, InetAddress srcAddr, int srcPort, InetAddress dstAddr) {
    final PacketKeepalive k = new PacketKeepalive(network, callback);
    try {
        mService.startNattKeepalive(network, intervalSeconds, k.mMessenger, new Binder(), srcAddr.getHostAddress(), srcPort, dstAddr.getHostAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "Error starting packet keepalive: ", e);
        k.stopLooper();
        return null;
    }
    return k;
}
#method_after
@UnsupportedAppUsage
public PacketKeepalive startNattKeepalive(Network network, int intervalSeconds, PacketKeepaliveCallback callback, InetAddress srcAddr, int srcPort, InetAddress dstAddr) {
    final PacketKeepalive k = new PacketKeepalive(network, callback);
    try {
        mService.startNattKeepalive(network, intervalSeconds, k.mCallback, srcAddr.getHostAddress(), srcPort, dstAddr.getHostAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "Error starting packet keepalive: ", e);
        throw e.rethrowFromSystemServer();
    }
    return k;
}
#end_block

#method_before
@NonNull
public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback) {
    return new NattSocketKeepalive(mService, network, socket.getFileDescriptor(), socket.getResourceId(), source, destination, executor, callback);
}
#method_after
@NonNull
public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull UdpEncapsulationSocket socket, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback) {
    ParcelFileDescriptor dup;
    try {
        dup = ParcelFileDescriptor.dup(socket.getFileDescriptor());
    } catch (IOException ignored) {
        // Construct an invalid fd, so that if the user later calls start(), it will fail with
        // ERROR_INVALID_SOCKET.
        dup = new ParcelFileDescriptor(new FileDescriptor());
    }
    return new NattSocketKeepalive(mService, network, dup, socket.getResourceId(), source, destination, executor, callback);
}
#end_block

#method_before
@SystemApi
@RequiresPermission(android.Manifest.permission.PACKET_KEEPALIVE_OFFLOAD)
@NonNull
public SocketKeepalive createNattKeepalive(@NonNull Network network, @NonNull ParcelFileDescriptor pfd, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback) {
    return new NattSocketKeepalive(mService, network, pfd.getFileDescriptor(), INVALID_RESOURCE_ID, /* Unused */
    source, destination, executor, callback);
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.PACKET_KEEPALIVE_OFFLOAD)
@NonNull
public SocketKeepalive createNattKeepalive(@NonNull Network network, @NonNull ParcelFileDescriptor pfd, @NonNull InetAddress source, @NonNull InetAddress destination, @NonNull @CallbackExecutor Executor executor, @NonNull Callback callback) {
    ParcelFileDescriptor dup;
    try {
        dup = pfd.dup();
    } catch (IOException ignored) {
        // Construct an invalid fd, so that if the user later calls start(), it will fail with
        // ERROR_INVALID_SOCKET.
        dup = new ParcelFileDescriptor(new FileDescriptor());
    }
    return new NattSocketKeepalive(mService, network, dup, INVALID_RESOURCE_ID, /* Unused */
    source, destination, executor, callback);
}
#end_block

#method_before
@SystemApi
@RequiresPermission(android.Manifest.permission.PACKET_KEEPALIVE_OFFLOAD)
@NonNull
public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull Socket socket, @NonNull Executor executor, @NonNull Callback callback) {
    return new TcpSocketKeepalive(mService, network, socket, executor, callback);
}
#method_after
@SystemApi
@RequiresPermission(android.Manifest.permission.PACKET_KEEPALIVE_OFFLOAD)
@NonNull
public SocketKeepalive createSocketKeepalive(@NonNull Network network, @NonNull Socket socket, @NonNull Executor executor, @NonNull Callback callback) {
    ParcelFileDescriptor dup;
    try {
        dup = ParcelFileDescriptor.fromSocket(socket);
    } catch (UncheckedIOException ignored) {
        // Construct an invalid fd, so that if the user later calls start(), it will fail with
        // ERROR_INVALID_SOCKET.
        dup = new ParcelFileDescriptor(new FileDescriptor());
    }
    return new TcpSocketKeepalive(mService, network, dup, executor, callback);
}
#end_block

#method_before
@UnsupportedAppUsage
public void registerNetworkFactory(Messenger messenger, String name) {
    try {
        mService.registerNetworkFactory(messenger, name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public int registerNetworkFactory(Messenger messenger, String name) {
    try {
        return mService.registerNetworkFactory(messenger, name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo ni, LinkProperties lp, NetworkCapabilities nc, int score, NetworkMisc misc) {
    try {
        return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
// TODO : remove this method. It is a stopgap measure to help sheperding a number
// of dependent changes that would conflict throughout the automerger graph. Having this
// temporarily helps with the process of going through with all these dependent changes across
// the entire tree.
public int registerNetworkAgent(Messenger messenger, NetworkInfo ni, LinkProperties lp, NetworkCapabilities nc, int score, NetworkMisc misc) {
    return registerNetworkAgent(messenger, ni, lp, nc, score, misc, NetworkFactory.SerialNumber.NONE);
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo ni, LinkProperties lp, NetworkCapabilities nc, int score, NetworkMisc misc) {
    try {
        return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo ni, LinkProperties lp, NetworkCapabilities nc, int score, NetworkMisc misc, int factorySerialNumber) {
    try {
        return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc, factorySerialNumber);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    try {
        mService.setAcceptUnvalidated(network, accept, always);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.NETWORK_SETTINGS)
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    try {
        mService.setAcceptUnvalidated(network, accept, always);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public void setAvoidUnvalidated(Network network) {
    try {
        mService.setAvoidUnvalidated(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.NETWORK_SETTINGS)
public void setAvoidUnvalidated(Network network) {
    try {
        mService.setAvoidUnvalidated(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@SystemApi
@TestApi
@RequiresPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK)
public void startCaptivePortalApp(Network network, Bundle appExtras) {
    try {
        mService.startCaptivePortalAppInternal(network, appExtras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@SystemApi
@TestApi
@RequiresPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK)
public void startCaptivePortalApp(@NonNull Network network, @NonNull Bundle appExtras) {
    try {
        mService.startCaptivePortalAppInternal(network, appExtras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
private void startStateMachineUpdaters() {
    mCarrierConfigChange.startListening();
    final Handler handler = mTetherMasterSM.getHandler();
    IntentFilter filter = new IntentFilter();
    filter.addAction(UsbManager.ACTION_USB_STATE);
    filter.addAction(CONNECTIVITY_ACTION);
    filter.addAction(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
    filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
    mContext.registerReceiver(mStateReceiver, filter, null, handler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_MEDIA_SHARED);
    filter.addAction(Intent.ACTION_MEDIA_UNSHARED);
    filter.addDataScheme("file");
    mContext.registerReceiver(mStateReceiver, filter, null, handler);
    final UserManagerInternal umi = LocalServices.getService(UserManagerInternal.class);
    // This check is useful only for some unit tests; example: ConnectivityServiceTest.
    if (umi != null) {
        umi.addUserRestrictionsListener(new TetheringUserRestrictionListener(this));
    }
}
#method_after
private void startStateMachineUpdaters(Handler handler) {
    mCarrierConfigChange.startListening();
    mDefaultSubscriptionChange.startListening();
    IntentFilter filter = new IntentFilter();
    filter.addAction(UsbManager.ACTION_USB_STATE);
    filter.addAction(CONNECTIVITY_ACTION);
    filter.addAction(WifiManager.WIFI_AP_STATE_CHANGED_ACTION);
    filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
    mContext.registerReceiver(mStateReceiver, filter, null, handler);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_MEDIA_SHARED);
    filter.addAction(Intent.ACTION_MEDIA_UNSHARED);
    filter.addDataScheme("file");
    mContext.registerReceiver(mStateReceiver, filter, null, handler);
    final UserManagerInternal umi = LocalServices.getService(UserManagerInternal.class);
    // This check is useful only for some unit tests; example: ConnectivityServiceTest.
    if (umi != null) {
        umi.addUserRestrictionsListener(new TetheringUserRestrictionListener(this));
    }
}
#end_block

#method_before
private void updateConfiguration() {
    mConfig = new TetheringConfiguration(mContext, mLog);
    mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);
    mEntitlementMgr.updateConfiguration(mConfig);
}
#method_after
private void updateConfiguration() {
    final int subId = mDeps.getDefaultDataSubscriptionId();
    mConfig = new TetheringConfiguration(mContext, mLog, subId);
    mUpstreamNetworkMonitor.updateMobileRequiresDun(mConfig.isDunRequired);
    mEntitlementMgr.updateConfiguration(mConfig);
}
#end_block

#method_before
private void maybeUpdateConfiguration() {
    final int dunCheck = TetheringConfiguration.checkDunRequired(mContext);
    if (dunCheck == mConfig.dunCheck)
        return;
    updateConfiguration();
}
#method_after
private void maybeUpdateConfiguration() {
    final boolean isDunRequired = TetheringConfiguration.checkDunRequired(mContext);
    if (isDunRequired == mConfig.isDunRequired)
        return;
    updateConfiguration();
}
#end_block

#method_before
private int setWifiTethering(final boolean enable) {
    int rval = TETHER_ERROR_MASTER_ERROR;
    final long ident = Binder.clearCallingIdentity();
    try {
        synchronized (mPublicSync) {
            mWifiTetherRequested = enable;
            final WifiManager mgr = getWifiManager();
            if (mgr == null) {
                Log.e(TAG, "setWifiTethering: failed to get WifiManager!");
                return TETHER_ERROR_SERVICE_UNAVAIL;
            }
            if ((enable && mgr.startSoftAp(null)) || (!enable && mgr.stopSoftAp())) {
                rval = TETHER_ERROR_NO_ERROR;
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return rval;
}
#method_after
private int setWifiTethering(final boolean enable) {
    final long ident = Binder.clearCallingIdentity();
    try {
        synchronized (mPublicSync) {
            final WifiManager mgr = getWifiManager();
            if (mgr == null) {
                mLog.e("setWifiTethering: failed to get WifiManager!");
                return TETHER_ERROR_SERVICE_UNAVAIL;
            }
            if ((enable && mgr.startSoftAp(null)) || (!enable && mgr.stopSoftAp())) {
                mWifiTetherRequested = enable;
                return TETHER_ERROR_NO_ERROR;
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return TETHER_ERROR_MASTER_ERROR;
}
#end_block

#method_before
private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(null) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            // If provisioning is successful, enable tethering, otherwise just send the error.
            if (resultCode == TETHER_ERROR_NO_ERROR) {
                enableTetheringInternal(type, true, receiver);
            } else {
                sendTetherResult(receiver, resultCode);
            }
        }
    };
    // The following is necessary to avoid unmarshalling issues when sending the receiver
    // across processes.
    Parcel parcel = Parcel.obtain();
    rr.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    ResultReceiver receiverForSending = ResultReceiver.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return receiverForSending;
}
#method_after
private ResultReceiver getProxyReceiver(final int type, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(null) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            // If provisioning is successful, enable tethering, otherwise just send the error.
            if (resultCode == TETHER_ERROR_NO_ERROR) {
                enableTetheringInternal(type, true, receiver);
            } else {
                sendTetherResult(receiver, resultCode);
            }
            mEntitlementMgr.updateEntitlementCacheValue(type, resultCode);
        }
    };
    // The following is necessary to avoid unmarshalling issues when sending the receiver
    // across processes.
    Parcel parcel = Parcel.obtain();
    rr.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    ResultReceiver receiverForSending = ResultReceiver.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return receiverForSending;
}
#end_block

#method_before
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = (UsbManager) mContext.getSystemService(Context.USB_SERVICE);
    if (usbManager == null) {
        Log.e(TAG, "setUsbTethering: failed to get UsbManager!");
        return TETHER_ERROR_SERVICE_UNAVAIL;
    }
    synchronized (mPublicSync) {
        usbManager.setCurrentFunctions(enable ? UsbManager.FUNCTION_RNDIS : UsbManager.FUNCTION_NONE);
    }
    return TETHER_ERROR_NO_ERROR;
}
#method_after
public int setUsbTethering(boolean enable) {
    if (VDBG)
        Log.d(TAG, "setUsbTethering(" + enable + ")");
    UsbManager usbManager = (UsbManager) mContext.getSystemService(Context.USB_SERVICE);
    if (usbManager == null) {
        mLog.e("setUsbTethering: failed to get UsbManager!");
        return TETHER_ERROR_SERVICE_UNAVAIL;
    }
    synchronized (mPublicSync) {
        usbManager.setCurrentFunctions(enable ? UsbManager.FUNCTION_RNDIS : UsbManager.FUNCTION_NONE);
    }
    return TETHER_ERROR_NO_ERROR;
}
#end_block

#method_before
protected void chooseUpstreamType(boolean tryCell) {
    // We rebuild configuration on ACTION_CONFIGURATION_CHANGED, but we
    // do not currently know how to watch for changes in DUN settings.
    maybeUpdateConfiguration();
    final TetheringConfiguration config = mConfig;
    final NetworkState ns = (config.chooseUpstreamAutomatically) ? mUpstreamNetworkMonitor.getCurrentPreferredUpstream() : mUpstreamNetworkMonitor.selectPreferredUpstreamType(config.preferredUpstreamIfaceTypes);
    if (ns == null) {
        if (tryCell) {
            mUpstreamNetworkMonitor.registerMobileNetworkRequest();
        // We think mobile should be coming up; don't set a retry.
        } else {
            sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);
        }
    }
    mUpstreamNetworkMonitor.setCurrentUpstream((ns != null) ? ns.network : null);
    setUpstreamNetwork(ns);
}
#method_after
protected void chooseUpstreamType(boolean tryCell) {
    // We rebuild configuration on ACTION_CONFIGURATION_CHANGED, but we
    // do not currently know how to watch for changes in DUN settings.
    maybeUpdateConfiguration();
    final TetheringConfiguration config = mConfig;
    final NetworkState ns = (config.chooseUpstreamAutomatically) ? mUpstreamNetworkMonitor.getCurrentPreferredUpstream() : mUpstreamNetworkMonitor.selectPreferredUpstreamType(config.preferredUpstreamIfaceTypes);
    if (ns == null) {
        if (tryCell) {
            mUpstreamNetworkMonitor.registerMobileNetworkRequest();
        // We think mobile should be coming up; don't set a retry.
        } else {
            sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);
        }
    }
    setUpstreamNetwork(ns);
    final Network newUpstream = (ns != null) ? ns.network : null;
    if (mTetherUpstream != newUpstream) {
        mTetherUpstream = newUpstream;
        mUpstreamNetworkMonitor.setCurrentUpstream(mTetherUpstream);
        reportUpstreamChanged(mTetherUpstream);
    }
}
#end_block

#method_before
@Override
public void exit() {
    mOffload.stop();
    mUpstreamNetworkMonitor.stop();
    notifyDownstreamsOfNewUpstreamIface(null);
    handleNewUpstreamNetworkState(null);
}
#method_after
@Override
public void exit() {
    mOffload.stop();
    mUpstreamNetworkMonitor.stop();
    notifyDownstreamsOfNewUpstreamIface(null);
    handleNewUpstreamNetworkState(null);
    if (mTetherUpstream != null) {
        mTetherUpstream = null;
        reportUpstreamChanged(null);
    }
}
#end_block

#method_before
private void maybeTrackNewInterfaceLocked(final String iface, int interfaceType) {
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new IpServer(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(), mConfig.enableLegacyDhcpServer, mDeps.getIpServerDependencies(mContext)));
    mTetherStates.put(iface, tetherState);
    tetherState.ipServer.start();
}
#method_after
private void maybeTrackNewInterfaceLocked(final String iface, int interfaceType) {
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new IpServer(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(), mConfig.enableLegacyDhcpServer, mDeps.getIpServerDependencies()));
    mTetherStates.put(iface, tetherState);
    tetherState.ipServer.start();
}
#end_block

#method_before
@Nullable
/* package */
OnClickListener getOnClickListener() {
    return mOnClickListener;
}
#method_after
@Nullable
OnClickListener getOnClickListener() {
    return mOnClickListener;
}
#end_block

#method_before
private boolean isHandheld() {
    // handheld nature is not exposed to package manager, for now
    // we check for touchscreen and NOT watch and NOT tv
    PackageManager pm = getContext().getPackageManager();
    return pm.hasSystemFeature(pm.FEATURE_TOUCHSCREEN) && !pm.hasSystemFeature(pm.FEATURE_WATCH) && !pm.hasSystemFeature(pm.FEATURE_TELEVISION);
}
#method_after
private boolean isHandheld() {
    // handheld nature is not exposed to package manager, for now
    // we check for touchscreen and NOT watch, NOT tv and NOT car
    PackageManager pm = getContext().getPackageManager();
    return pm.hasSystemFeature(pm.FEATURE_TOUCHSCREEN) && !pm.hasSystemFeature(pm.FEATURE_WATCH) && !pm.hasSystemFeature(pm.FEATURE_TELEVISION) && !pm.hasSystemFeature(pm.FEATURE_AUTOMOTIVE);
}
#end_block

#method_before
public <T> void query(@Nullable Network network, @NonNull byte[] query, @QueryFlag int flags, @NonNull @CallbackExecutor Executor executor, @Nullable CancellationSignal cancellationSignal, @NonNull AnswerCallback<T> callback) {
    if (cancellationSignal != null && cancellationSignal.isCanceled()) {
        return;
    }
    final Object lock = new Object();
    final FileDescriptor queryfd;
    try {
        queryfd = resNetworkSend((network != null ? network.netId : NETID_UNSET), query, query.length, flags);
    } catch (ErrnoException e) {
        callback.onQueryException(e);
        return;
    }
    registerFDListener(executor, queryfd, callback, cancellationSignal, lock);
    maybeAddCancellationSignal(cancellationSignal, queryfd, lock);
}
#method_after
public <T> void query(@Nullable Network network, @NonNull byte[] query, @QueryFlag int flags, @NonNull @CallbackExecutor Executor executor, @Nullable CancellationSignal cancellationSignal, @NonNull AnswerCallback<T> callback) {
    if (cancellationSignal != null && cancellationSignal.isCanceled()) {
        return;
    }
    final Object lock = new Object();
    final FileDescriptor queryfd;
    try {
        queryfd = resNetworkSend((network != null ? network.netId : NETID_UNSET), query, query.length, flags);
    } catch (ErrnoException e) {
        executor.execute(() -> {
            callback.onQueryException(e);
        });
        return;
    }
    registerFDListener(executor, queryfd, callback, cancellationSignal, lock);
    maybeAddCancellationSignal(cancellationSignal, queryfd, lock);
}
#end_block

#method_before
public <T> void query(@Nullable Network network, @NonNull String domain, @QueryClass int nsClass, @QueryType int nsType, @QueryFlag int flags, @NonNull @CallbackExecutor Executor executor, @Nullable CancellationSignal cancellationSignal, @NonNull AnswerCallback<T> callback) {
    if (cancellationSignal != null && cancellationSignal.isCanceled()) {
        return;
    }
    final Object lock = new Object();
    final FileDescriptor queryfd;
    try {
        queryfd = resNetworkQuery((network != null ? network.netId : NETID_UNSET), domain, nsClass, nsType, flags);
    } catch (ErrnoException e) {
        callback.onQueryException(e);
        return;
    }
    registerFDListener(executor, queryfd, callback, cancellationSignal, lock);
    maybeAddCancellationSignal(cancellationSignal, queryfd, lock);
}
#method_after
public <T> void query(@Nullable Network network, @NonNull String domain, @QueryClass int nsClass, @QueryType int nsType, @QueryFlag int flags, @NonNull @CallbackExecutor Executor executor, @Nullable CancellationSignal cancellationSignal, @NonNull AnswerCallback<T> callback) {
    if (cancellationSignal != null && cancellationSignal.isCanceled()) {
        return;
    }
    final Object lock = new Object();
    final FileDescriptor queryfd;
    try {
        queryfd = resNetworkQuery((network != null ? network.netId : NETID_UNSET), domain, nsClass, nsType, flags);
    } catch (ErrnoException e) {
        executor.execute(() -> {
            callback.onQueryException(e);
        });
        return;
    }
    registerFDListener(executor, queryfd, callback, cancellationSignal, lock);
    maybeAddCancellationSignal(cancellationSignal, queryfd, lock);
}
#end_block

#method_before
public void query(@Nullable Network network, @NonNull String domain, @QueryFlag int flags, @NonNull @CallbackExecutor Executor executor, @Nullable CancellationSignal cancellationSignal, @NonNull InetAddressAnswerCallback callback) {
    if (cancellationSignal != null && cancellationSignal.isCanceled()) {
        return;
    }
    final Object lock = new Object();
    final boolean queryIpv6 = haveIpv6(network);
    final boolean queryIpv4 = haveIpv4(network);
    final FileDescriptor v4fd;
    final FileDescriptor v6fd;
    int queryCount = 0;
    if (queryIpv6) {
        try {
            v6fd = resNetworkQuery((network != null ? network.netId : NETID_UNSET), domain, CLASS_IN, TYPE_AAAA, flags);
        } catch (ErrnoException e) {
            callback.onQueryException(e);
            return;
        }
        queryCount++;
    } else
        v6fd = null;
    if (queryIpv4) {
        try {
            v4fd = resNetworkQuery((network != null ? network.netId : NETID_UNSET), domain, CLASS_IN, TYPE_A, flags);
        } catch (ErrnoException e) {
            if (queryIpv6)
                resNetworkCancel(v6fd);
            callback.onQueryException(e);
            return;
        }
        queryCount++;
    } else
        v4fd = null;
    final InetAddressAnswerAccumulator accumulator = new InetAddressAnswerAccumulator(queryCount, callback);
    if (queryIpv4)
        registerFDListener(executor, v4fd, accumulator, cancellationSignal, lock);
    if (queryIpv6)
        registerFDListener(executor, v6fd, accumulator, cancellationSignal, lock);
    if (cancellationSignal == null)
        return;
    cancellationSignal.setOnCancelListener(() -> {
        synchronized (lock) {
            if (queryIpv4)
                cancelQuery(v4fd);
            if (queryIpv6)
                cancelQuery(v6fd);
        }
    });
}
#method_after
public void query(@Nullable Network network, @NonNull String domain, @QueryFlag int flags, @NonNull @CallbackExecutor Executor executor, @Nullable CancellationSignal cancellationSignal, @NonNull InetAddressAnswerCallback callback) {
    if (cancellationSignal != null && cancellationSignal.isCanceled()) {
        return;
    }
    final Object lock = new Object();
    final boolean queryIpv6 = haveIpv6(network);
    final boolean queryIpv4 = haveIpv4(network);
    final FileDescriptor v4fd;
    final FileDescriptor v6fd;
    int queryCount = 0;
    if (queryIpv6) {
        try {
            v6fd = resNetworkQuery((network != null ? network.netId : NETID_UNSET), domain, CLASS_IN, TYPE_AAAA, flags);
        } catch (ErrnoException e) {
            executor.execute(() -> {
                callback.onQueryException(e);
            });
            return;
        }
        queryCount++;
    } else
        v6fd = null;
    // Avoiding gateways drop packets if queries are sent too close together
    try {
        Thread.sleep(SLEEP_TIME);
    } catch (InterruptedException ex) {
    }
    if (queryIpv4) {
        try {
            v4fd = resNetworkQuery((network != null ? network.netId : NETID_UNSET), domain, CLASS_IN, TYPE_A, flags);
        } catch (ErrnoException e) {
            // Closes fd, marks it invalid.
            if (queryIpv6)
                resNetworkCancel(v6fd);
            executor.execute(() -> {
                callback.onQueryException(e);
            });
            return;
        }
        queryCount++;
    } else
        v4fd = null;
    final InetAddressAnswerAccumulator accumulator = new InetAddressAnswerAccumulator(queryCount, callback);
    if (queryIpv6)
        registerFDListener(executor, v6fd, accumulator, cancellationSignal, lock);
    if (queryIpv4)
        registerFDListener(executor, v4fd, accumulator, cancellationSignal, lock);
    if (cancellationSignal == null)
        return;
    cancellationSignal.setOnCancelListener(() -> {
        synchronized (lock) {
            if (queryIpv4)
                cancelQuery(v4fd);
            if (queryIpv6)
                cancelQuery(v6fd);
        }
    });
}
#end_block

#method_before
private <T> void registerFDListener(@NonNull Executor executor, @NonNull FileDescriptor queryfd, @NonNull AnswerCallback<T> answerCallback, @Nullable CancellationSignal cancellationSignal, @NonNull Object lock) {
    Looper.getMainLooper().getQueue().addOnFileDescriptorEventListener(queryfd, FD_EVENTS, (fd, events) -> {
        executor.execute(() -> {
            synchronized (lock) {
                if (cancellationSignal != null && cancellationSignal.isCanceled()) {
                    return;
                }
                byte[] answerbuf = null;
                try {
                    answerbuf = resNetworkResult(fd);
                } catch (ErrnoException e) {
                    Log.e(TAG, "resNetworkResult:" + e.toString());
                    answerCallback.onQueryException(e);
                    return;
                }
                try {
                    answerCallback.onAnswer(answerCallback.parser.parse(answerbuf));
                } catch (ParseException e) {
                    answerCallback.onParseException(e);
                }
            }
        });
        // Unregister this fd listener
        return 0;
    });
}
#method_after
private <T> void registerFDListener(@NonNull Executor executor, @NonNull FileDescriptor queryfd, @NonNull AnswerCallback<T> answerCallback, @Nullable CancellationSignal cancellationSignal, @NonNull Object lock) {
    Looper.getMainLooper().getQueue().addOnFileDescriptorEventListener(queryfd, FD_EVENTS, (fd, events) -> {
        executor.execute(() -> {
            synchronized (lock) {
                if (cancellationSignal != null && cancellationSignal.isCanceled()) {
                    return;
                }
                byte[] answerbuf = null;
                try {
                    // Closes fd, marks it invalid.
                    answerbuf = resNetworkResult(fd);
                } catch (ErrnoException e) {
                    Log.e(TAG, "resNetworkResult:" + e.toString());
                    answerCallback.onQueryException(e);
                    return;
                }
                try {
                    answerCallback.onAnswer(answerCallback.parser.parse(answerbuf));
                } catch (ParseException e) {
                    answerCallback.onParseException(e);
                }
            }
        });
        // Unregister this fd listener
        return 0;
    });
}
#end_block

#method_before
private void cancelQuery(@NonNull FileDescriptor queryfd) {
    if (!queryfd.valid())
        return;
    Looper.getMainLooper().getQueue().removeOnFileDescriptorEventListener(queryfd);
    resNetworkCancel(queryfd);
}
#method_after
private void cancelQuery(@NonNull FileDescriptor queryfd) {
    if (!queryfd.valid())
        return;
    Looper.getMainLooper().getQueue().removeOnFileDescriptorEventListener(queryfd);
    // Closes fd, marks it invalid.
    resNetworkCancel(queryfd);
}
#end_block

#method_before
private boolean checkConnectivity(@Nullable Network network, int domain, @NonNull SocketAddress addr) {
    final FileDescriptor socket;
    try {
        socket = Os.socket(domain, SOCK_DGRAM, IPPROTO_UDP);
    } catch (ErrnoException e) {
        return false;
    }
    try {
        if (network != null)
            network.bindSocket(socket);
        Os.connect(socket, addr);
    } catch (IOException | ErrnoException e) {
        IoUtils.closeQuietly(socket);
        return false;
    }
    return true;
}
#method_after
private boolean checkConnectivity(@Nullable Network network, int domain, @NonNull SocketAddress addr) {
    final FileDescriptor socket;
    try {
        socket = Os.socket(domain, SOCK_DGRAM, IPPROTO_UDP);
    } catch (ErrnoException e) {
        return false;
    }
    try {
        if (network != null)
            network.bindSocket(socket);
        Os.connect(socket, addr);
    } catch (IOException | ErrnoException e) {
        return false;
    } finally {
        IoUtils.closeQuietly(socket);
    }
    return true;
}
#end_block

#method_before
Bundle extractTrackInfoData() {
    List<MediaPlayer.TrackInfo> trackInfos = mMediaPlayer.getTrackInfo();
    mVideoTrackCount = 0;
    mAudioTrackInfos = new ArrayList<>();
    mSubtitleTracks = new LinkedHashMap<>();
    ArrayList<String> subtitleTracksLanguageList = new ArrayList<>();
    TrackInfo selectedSubtitleTrackInfo = mSelectedSubtitleTrackInfo;
    mSubtitleController.reset();
    for (int i = 0; i < trackInfos.size(); ++i) {
        final TrackInfo trackInfo = trackInfos.get(i);
        int trackType = trackInfo.getTrackType();
        if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
            mVideoTrackCount++;
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_AUDIO) {
            mAudioTrackInfos.add(trackInfo);
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
            SubtitleTrack track = mSubtitleController.addTrack(trackInfo.getFormat());
            if (track != null) {
                mSubtitleTracks.put(trackInfo, track);
                String language = trackInfo.getLanguage().getISO3Language();
                if (language.equals(SUBTITLE_TRACK_LANG_UNDEFINED)) {
                    language = "";
                }
                subtitleTracksLanguageList.add(language);
            }
        }
    }
    // Select first tracks as default
    if (mAudioTrackInfos.size() > 0) {
        mSelectedAudioTrackInfo = mAudioTrackInfos.get(0);
    }
    // Re-select originally selected subtitle track since SubtitleController has been reset.
    if (selectedSubtitleTrackInfo != null) {
        selectSubtitleTrack(selectedSubtitleTrackInfo);
    }
    Bundle data = new Bundle();
    data.putInt(MediaControlView.KEY_VIDEO_TRACK_COUNT, mVideoTrackCount);
    data.putInt(MediaControlView.KEY_AUDIO_TRACK_COUNT, mAudioTrackInfos.size());
    data.putStringArrayList(MediaControlView.KEY_SUBTITLE_TRACK_LANGUAGE_LIST, subtitleTracksLanguageList);
    return data;
}
#method_after
Bundle extractTrackInfoData() {
    List<MediaPlayer.TrackInfo> trackInfos = mMediaPlayer.getTrackInfo();
    mVideoTrackCount = 0;
    mAudioTrackInfos = new ArrayList<>();
    mSubtitleTracks = new LinkedHashMap<>();
    ArrayList<String> subtitleTracksLanguageList = new ArrayList<>();
    TrackInfo selectedSubtitleTrackInfo = mSelectedSubtitleTrackInfo;
    mSubtitleController.reset();
    for (int i = 0; i < trackInfos.size(); ++i) {
        final TrackInfo trackInfo = trackInfos.get(i);
        int trackType = trackInfo.getTrackType();
        if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
            mVideoTrackCount++;
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_AUDIO) {
            mAudioTrackInfos.add(trackInfo);
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
            SubtitleTrack track = mSubtitleController.addTrack(trackInfo.getFormat());
            if (track != null) {
                mSubtitleTracks.put(trackInfo, track);
                String language = trackInfo.getLanguage().getISO3Language();
                subtitleTracksLanguageList.add(language);
            }
        }
    }
    // Select first tracks as default
    if (mAudioTrackInfos.size() > 0) {
        mSelectedAudioTrackInfo = mAudioTrackInfos.get(0);
    }
    // Re-select originally selected subtitle track since SubtitleController has been reset.
    if (selectedSubtitleTrackInfo != null) {
        selectSubtitleTrack(selectedSubtitleTrackInfo);
    }
    Bundle data = new Bundle();
    data.putInt(MediaControlView.KEY_VIDEO_TRACK_COUNT, mVideoTrackCount);
    data.putInt(MediaControlView.KEY_AUDIO_TRACK_COUNT, mAudioTrackInfos.size());
    data.putStringArrayList(MediaControlView.KEY_SUBTITLE_TRACK_LANGUAGE_LIST, subtitleTracksLanguageList);
    return data;
}
#end_block

#method_before
@Test
public void testSubtitleSelection() throws Throwable {
    MediaController.ControllerCallback controllerCallback = new MediaController.ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (command.getCustomCommand().equals(EVENT_UPDATE_TRACK_STATUS)) {
                List<String> subtitleLangList = args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST);
                for (String lang : subtitleLangList) {
                    assertTrue("'und' should be replaced with empty string.", !lang.equals("und"));
                }
            }
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    };
    MediaController controller = new MediaController(mVideoView.getContext(), mVideoView.getSessionToken(), mMainHandlerExecutor, controllerCallback);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    mController.play();
    // Verify the subtitle track count
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_TRACK_STATUS)), argThat(new CommandArgumentListMatcher(KEY_SUBTITLE_TRACK_LANGUAGE_LIST, 2)));
    // Select the first subtitle track
    Bundle extra = new Bundle();
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 0);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 0)));
    // Select the second subtitle track
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 1);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 1)));
    // Deselect subtitle track
    mController.sendCustomCommand(new SessionCommand(COMMAND_HIDE_SUBTITLE, null), null);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_DESELECTED)), nullable(Bundle.class));
}
#method_after
@Test
public void testSubtitleSelection() throws Throwable {
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mMediaItem);
        }
    });
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onConnected(any(MediaController.class), any(SessionCommandGroup.class));
    mController.play();
    // Verify the subtitle track count
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_TRACK_STATUS)), argThat(new CommandArgumentListMatcher(KEY_SUBTITLE_TRACK_LANGUAGE_LIST, 2)));
    // Select the first subtitle track
    Bundle extra = new Bundle();
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 0);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 0)));
    // Select the second subtitle track
    extra.putInt(KEY_SELECTED_SUBTITLE_INDEX, 1);
    mController.sendCustomCommand(new SessionCommand(COMMAND_SHOW_SUBTITLE, null), extra);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_SELECTED)), argThat(new CommandArgumentMatcher(KEY_SELECTED_SUBTITLE_INDEX, 1)));
    // Deselect subtitle track
    mController.sendCustomCommand(new SessionCommand(COMMAND_HIDE_SUBTITLE, null), null);
    verify(mControllerCallback, timeout(TIME_OUT).atLeastOnce()).onCustomCommand(any(MediaController.class), argThat(new CommandMatcher(EVENT_UPDATE_SUBTITLE_DESELECTED)), nullable(Bundle.class));
}
#end_block

#method_before
public List<TestInfo> getTests(String testGroup, Set<String> disabledTests, boolean hostOnly, Set<String> keywords) {
    List<TestInfo> tests = new ArrayList<TestInfo>();
    for (TestInfo test : mTestCollection.getOrDefault(testGroup, new ArrayList<TestInfo>())) {
        if (disabledTests != null && disabledTests.contains(test.getName())) {
            CLog.d("Test is disabled: %s.", test);
            continue;
        }
        if (test.getHostOnly() != hostOnly) {
            CLog.d("Test doesn't match the host requirement: %s.", test);
            continue;
        }
        // Skip the test if no keyword is specified but the test requires certain keywords.
        if ((keywords == null || keywords.isEmpty()) && !test.getKeywords().isEmpty()) {
            CLog.d("Test %s requires keywords: %s. Skip the test.", test, test.getKeywords());
            continue;
        }
        // Skip the test if any of the required keywords is not specified by the test.
        if (keywords != null) {
            Boolean allKeywordsFound = true;
            for (String keyword : keywords) {
                if (!test.getKeywords().contains(keyword)) {
                    CLog.d("Test %s doesn't have required keyword: %s. Skip the test.", test, keyword);
                    allKeywordsFound = false;
                    break;
                }
            }
            // The test should be skipped if any keyword is missing in the test configuration.
            if (!allKeywordsFound) {
                continue;
            }
        }
        tests.add(test);
    }
    return tests;
}
#method_after
public Set<TestInfo> getTests(String testGroup, Set<String> disabledTests, boolean hostOnly, Set<String> keywords) {
    Set<TestInfo> tests = new HashSet<TestInfo>();
    for (TestInfo test : mTestCollection.getOrDefault(testGroup, new HashSet<>())) {
        if (disabledTests != null && disabledTests.contains(test.getName())) {
            CLog.d("Test is disabled: %s.", test);
            continue;
        }
        if (test.getHostOnly() != hostOnly) {
            CLog.d("Test doesn't match the host requirement: %s.", test);
            continue;
        }
        // Skip the test if no keyword is specified but the test requires certain keywords.
        if ((keywords == null || keywords.isEmpty()) && !test.getKeywords().isEmpty()) {
            CLog.d("Test %s requires keywords: %s. Skip the test.", test, test.getKeywords());
            continue;
        }
        // Skip the test if any of the required keywords is not specified by the test.
        if (keywords != null) {
            Boolean allKeywordsFound = true;
            for (String keyword : keywords) {
                if (!test.getKeywords().contains(keyword)) {
                    CLog.d("Test %s doesn't have required keyword: %s. Skip the test.", test, keyword);
                    allKeywordsFound = false;
                    break;
                }
            }
            // The test should be skipped if any keyword is missing in the test configuration.
            if (!allKeywordsFound) {
                continue;
            }
        }
        tests.add(test);
    }
    return tests;
}
#end_block

#method_before
public static Set<TestInfo> getTests(IBuildInfo buildInfo, String testGroup, boolean hostOnly, Set<String> keywords) {
    Set<TestInfo> tests = new HashSet<TestInfo>();
    File testMappingsDir = extractTestMappingsZip(buildInfo.getFile(TEST_MAPPINGS_ZIP));
    Stream<Path> stream = null;
    try {
        Path testMappingsRootPath = Paths.get(testMappingsDir.getAbsolutePath());
        Set<String> disabledTests = getDisabledTests(testMappingsRootPath, testGroup);
        stream = Files.walk(testMappingsRootPath, FileVisitOption.FOLLOW_LINKS);
        stream.filter(path -> path.getFileName().toString().equals(TEST_MAPPING)).forEach(path -> tests.addAll(new TestMapping(path, testMappingsRootPath).getTests(testGroup, disabledTests, hostOnly, keywords)));
    } catch (IOException e) {
        RuntimeException runtimeException = new RuntimeException(String.format("IO error (%s) when reading tests from TEST_MAPPING files (%s)", e.getMessage(), testMappingsDir.getAbsolutePath()), e);
        throw runtimeException;
    } finally {
        if (stream != null) {
            stream.close();
        }
        FileUtil.recursiveDelete(testMappingsDir);
    }
    return TestMapping.mergeTests(tests);
}
#method_after
public static Set<TestInfo> getTests(IBuildInfo buildInfo, String testGroup, boolean hostOnly, Set<String> keywords) {
    Set<TestInfo> tests = new HashSet<TestInfo>();
    File testMappingsDir = extractTestMappingsZip(buildInfo.getFile(TEST_MAPPINGS_ZIP));
    Stream<Path> stream = null;
    try {
        Path testMappingsRootPath = Paths.get(testMappingsDir.getAbsolutePath());
        Set<String> disabledTests = getDisabledTests(testMappingsRootPath, testGroup);
        stream = Files.walk(testMappingsRootPath, FileVisitOption.FOLLOW_LINKS);
        stream.filter(path -> path.getFileName().toString().equals(TEST_MAPPING)).forEach(path -> tests.addAll(new TestMapping(path, testMappingsRootPath).getTests(testGroup, disabledTests, hostOnly, keywords)));
    } catch (IOException e) {
        throw new RuntimeException(String.format("IO exception (%s) when reading tests from TEST_MAPPING files (%s)", e.getMessage(), testMappingsDir.getAbsolutePath()), e);
    } finally {
        if (stream != null) {
            stream.close();
        }
        FileUtil.recursiveDelete(testMappingsDir);
    }
    return TestMapping.mergeTests(tests);
}
#end_block

#method_before
public List<TestInfo> getAllTests(String testGroup, Set<String> disabledTests) {
    List<TestInfo> tests = new ArrayList<TestInfo>();
    for (TestInfo test : mTestCollection.getOrDefault(testGroup, new ArrayList<TestInfo>())) {
        if (disabledTests != null && disabledTests.contains(test.getName())) {
            CLog.d("Test is disabled: %s.", test);
            continue;
        }
        tests.add(test);
    }
    return tests;
}
#method_after
public static Map<String, Set<TestInfo>> getAllTests(File testMappingsDir) {
    Map<String, Set<TestInfo>> allTests = new HashMap<String, Set<TestInfo>>();
    Stream<Path> stream = null;
    try {
        Path testMappingsRootPath = Paths.get(testMappingsDir.getAbsolutePath());
        stream = Files.walk(testMappingsRootPath, FileVisitOption.FOLLOW_LINKS);
        stream.filter(path -> path.getFileName().toString().equals(TEST_MAPPING)).forEach(path -> getAllTests(allTests, path, testMappingsRootPath));
    } catch (IOException e) {
        throw new RuntimeException(String.format("IO exception (%s) when reading tests from TEST_MAPPING files (%s)", e.getMessage(), testMappingsDir.getAbsolutePath()), e);
    } finally {
        if (stream != null) {
            stream.close();
        }
    }
    return allTests;
}
#end_block

#method_before
public static File extractTestMappingsZip(File testMappingsZip) {
    File testMappingsDir = null;
    try {
        testMappingsDir = ZipUtil2.extractZipToTemp(testMappingsZip, TEST_MAPPINGS_ZIP);
    } catch (IOException e) {
        RuntimeException runtimeException = new RuntimeException(String.format("IO error (%s) when extracting test mappings zip (%s)", e.getMessage(), testMappingsZip.getAbsolutePath()), e);
        throw runtimeException;
    }
    return testMappingsDir;
}
#method_after
public static File extractTestMappingsZip(File testMappingsZip) {
    File testMappingsDir = null;
    try {
        testMappingsDir = ZipUtil2.extractZipToTemp(testMappingsZip, TEST_MAPPINGS_ZIP);
    } catch (IOException e) {
        throw new RuntimeException(String.format("IO exception (%s) when extracting test mappings zip (%s)", e.getMessage(), testMappingsZip.getAbsolutePath()), e);
    }
    return testMappingsDir;
}
#end_block

#method_before
@VisibleForTesting
static Set<String> getDisabledTests(Path testMappingsRootPath, String testGroup) {
    Set<String> disabledTests = new HashSet<>();
    if (testGroup.equals(PRESUBMIT)) {
        File disabledPresubmitTestsFile = new File(testMappingsRootPath.toString(), DISABLED_PRESUBMIT_TESTS);
        try {
            disabledTests.addAll(Arrays.asList(FileUtil.readStringFromFile(disabledPresubmitTestsFile).split("\\r?\\n")));
        } catch (IOException e) {
            RuntimeException runtimeException = new RuntimeException(String.format("IO error (%s) when reading disabled tests from file (%s)", e.getMessage(), disabledPresubmitTestsFile.getAbsolutePath()), e);
            throw runtimeException;
        }
    }
    return disabledTests;
}
#method_after
@VisibleForTesting
static Set<String> getDisabledTests(Path testMappingsRootPath, String testGroup) {
    Set<String> disabledTests = new HashSet<>();
    File disabledPresubmitTestsFile = new File(testMappingsRootPath.toString(), DISABLED_PRESUBMIT_TESTS_FILE);
    if (!(testGroup.equals(PRESUBMIT) && disabledPresubmitTestsFile.exists())) {
        return disabledTests;
    }
    try {
        disabledTests.addAll(Arrays.asList(FileUtil.readStringFromFile(disabledPresubmitTestsFile).split("\\r?\\n")));
    } catch (IOException e) {
        throw new RuntimeException(String.format("IO exception (%s) when reading disabled tests from file (%s)", e.getMessage(), disabledPresubmitTestsFile.getAbsolutePath()), e);
    }
    return disabledTests;
}
#end_block

#method_before
@Test
public void testparseTestMapping() throws Exception {
    File tempDir = null;
    File testMappingFile = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        String srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_1";
        InputStream resourceStream = this.getClass().getResourceAsStream(srcFile);
        File testMappingRootDir = FileUtil.createTempDir("subdir", tempDir);
        String rootDirName = testMappingRootDir.getName();
        testMappingFile = FileUtil.saveResourceFile(resourceStream, testMappingRootDir, TEST_MAPPING);
        List<TestInfo> tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("presubmit", null, true, null);
        assertEquals(1, tests.size());
        assertEquals("test1", tests.get(0).getName());
        tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("presubmit", null, false, null);
        assertEquals(1, tests.size());
        assertEquals("suite/stub1", tests.get(0).getName());
        tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("postsubmit", null, false, null);
        assertEquals(2, tests.size());
        assertEquals("test2", tests.get(0).getName());
        TestOption option = tests.get(0).getOptions().get(0);
        assertEquals("instrumentation-arg", option.getName());
        assertEquals("annotation=android.platform.test.annotations.Presubmit", option.getValue());
        assertEquals("instrument", tests.get(1).getName());
        tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("othertype", null, false, null);
        assertEquals(1, tests.size());
        assertEquals("test3", tests.get(0).getName());
        assertEquals(1, tests.get(0).getSources().size());
        assertTrue(tests.get(0).getSources().contains(rootDirName));
    } finally {
        FileUtil.recursiveDelete(tempDir);
    }
}
#method_after
@Test
public void testparseTestMapping() throws Exception {
    File tempDir = null;
    File testMappingFile = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        String srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_1";
        InputStream resourceStream = this.getClass().getResourceAsStream(srcFile);
        File testMappingRootDir = FileUtil.createTempDir("subdir", tempDir);
        String rootDirName = testMappingRootDir.getName();
        testMappingFile = FileUtil.saveResourceFile(resourceStream, testMappingRootDir, TEST_MAPPING);
        Set<TestInfo> tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("presubmit", null, true, null);
        assertEquals(1, tests.size());
        Set<String> names = new HashSet<String>();
        for (TestInfo test : tests) {
            names.add(test.getName());
        }
        assertTrue(names.contains("test1"));
        tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("presubmit", null, false, null);
        assertEquals(1, tests.size());
        names = new HashSet<String>();
        for (TestInfo test : tests) {
            names.add(test.getName());
        }
        assertTrue(names.contains("suite/stub1"));
        tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("postsubmit", null, false, null);
        assertEquals(2, tests.size());
        TestOption testOption = new TestOption("instrumentation-arg", "annotation=android.platform.test.annotations.Presubmit");
        names = new HashSet<String>();
        Set<TestOption> testOptions = new HashSet<TestOption>();
        for (TestInfo test : tests) {
            names.add(test.getName());
            testOptions.addAll(test.getOptions());
        }
        assertTrue(names.contains("test2"));
        assertTrue(names.contains("instrument"));
        assertTrue(testOptions.contains(testOption));
        tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("othertype", null, false, null);
        assertEquals(1, tests.size());
        names = new HashSet<String>();
        testOptions = new HashSet<TestOption>();
        Set<String> sources = new HashSet<String>();
        for (TestInfo test : tests) {
            names.add(test.getName());
            testOptions.addAll(test.getOptions());
            sources.addAll(test.getSources());
        }
        assertTrue(names.contains("test3"));
        assertEquals(1, testOptions.size());
        assertTrue(sources.contains(rootDirName));
    } finally {
        FileUtil.recursiveDelete(tempDir);
    }
}
#end_block

#method_before
@Test(expected = RuntimeException.class)
public void testparseTestMapping_BadJson() throws Exception {
    File tempDir = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        File testMappingFile = Paths.get(tempDir.getAbsolutePath(), TEST_MAPPING).toFile();
        FileUtil.writeToFile("bad format json file", testMappingFile);
        List<TestInfo> tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("presubmit", null, false, null);
    } finally {
        FileUtil.recursiveDelete(tempDir);
    }
}
#method_after
@Test(expected = RuntimeException.class)
public void testparseTestMapping_BadJson() throws Exception {
    File tempDir = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        File testMappingFile = Paths.get(tempDir.getAbsolutePath(), TEST_MAPPING).toFile();
        FileUtil.writeToFile("bad format json file", testMappingFile);
        Set<TestInfo> tests = new TestMapping(testMappingFile.toPath(), Paths.get(tempDir.getAbsolutePath())).getTests("presubmit", null, false, null);
    } finally {
        FileUtil.recursiveDelete(tempDir);
    }
}
#end_block

#method_before
@Test
public void testGetAllTests() throws Exception {
    File tempDir = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        File srcDir = FileUtil.createTempDir("src", tempDir);
        String srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_1";
        InputStream resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, srcDir, TEST_MAPPING);
        File subDir = FileUtil.createTempDir("sub_dir", srcDir);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_2";
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, subDir, TEST_MAPPING);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + DISABLED_PRESUBMIT_TESTS;
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, tempDir, DISABLED_PRESUBMIT_TESTS);
        Set<TestInfo> tests = TestMapping.getAllTests(tempDir, "presubmit");
        assertEquals(2, tests.size());
        tests = TestMapping.getAllTests(tempDir, "postsubmit");
        assertEquals(3, tests.size());
        tests = TestMapping.getAllTests(tempDir, "othertype");
        assertEquals(1, tests.size());
    } finally {
        FileUtil.recursiveDelete(tempDir);
    }
}
#method_after
@Test
public void testGetAllTests() throws Exception {
    File tempDir = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        File srcDir = FileUtil.createTempDir("src", tempDir);
        String srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_1";
        InputStream resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, srcDir, TEST_MAPPING);
        File subDir = FileUtil.createTempDir("sub_dir", srcDir);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_2";
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, subDir, TEST_MAPPING);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + DISABLED_PRESUBMIT_TESTS;
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, tempDir, DISABLED_PRESUBMIT_TESTS);
        Map<String, Set<TestInfo>> allTests = TestMapping.getAllTests(tempDir);
        Set<TestInfo> tests = allTests.get("presubmit");
        assertEquals(5, tests.size());
        tests = allTests.get("postsubmit");
        assertEquals(4, tests.size());
        tests = allTests.get("othertype");
        assertEquals(1, tests.size());
    } finally {
        FileUtil.recursiveDelete(tempDir);
    }
}
#end_block

#method_before
@Test
public void testExtractTestMappingsZip() throws Exception {
    File tempDir = null;
    File extractedFile = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        File srcDir = FileUtil.createTempDir("src", tempDir);
        String srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_1";
        InputStream resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, srcDir, TEST_MAPPING);
        File subDir = FileUtil.createTempDir("sub_dir", srcDir);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_2";
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, subDir, TEST_MAPPING);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + DISABLED_PRESUBMIT_TESTS;
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, tempDir, DISABLED_PRESUBMIT_TESTS);
        List<File> filesToZip = Arrays.asList(srcDir, new File(tempDir, DISABLED_PRESUBMIT_TESTS));
        File zipFile = Paths.get(tempDir.getAbsolutePath(), TEST_MAPPINGS_ZIP).toFile();
        ZipUtil.createZip(filesToZip, zipFile);
        extractedFile = TestMapping.extractTestMappingsZip(zipFile);
        Set<TestInfo> tests = TestMapping.getAllTests(extractedFile, "presubmit");
        assertEquals(2, tests.size());
        tests = TestMapping.getAllTests(extractedFile, "postsubmit");
        assertEquals(3, tests.size());
        tests = TestMapping.getAllTests(extractedFile, "othertype");
        assertEquals(1, tests.size());
    } finally {
        FileUtil.recursiveDelete(tempDir);
        FileUtil.recursiveDelete(extractedFile);
    }
}
#method_after
@Test
public void testExtractTestMappingsZip() throws Exception {
    File tempDir = null;
    File extractedFile = null;
    try {
        tempDir = FileUtil.createTempDir("test_mapping");
        File srcDir = FileUtil.createTempDir("src", tempDir);
        String srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_1";
        InputStream resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, srcDir, TEST_MAPPING);
        File subDir = FileUtil.createTempDir("sub_dir", srcDir);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + "test_mapping_2";
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, subDir, TEST_MAPPING);
        srcFile = File.separator + TEST_DATA_DIR + File.separator + DISABLED_PRESUBMIT_TESTS;
        resourceStream = this.getClass().getResourceAsStream(srcFile);
        FileUtil.saveResourceFile(resourceStream, tempDir, DISABLED_PRESUBMIT_TESTS);
        List<File> filesToZip = Arrays.asList(srcDir, new File(tempDir, DISABLED_PRESUBMIT_TESTS));
        File zipFile = Paths.get(tempDir.getAbsolutePath(), TEST_MAPPINGS_ZIP).toFile();
        ZipUtil.createZip(filesToZip, zipFile);
        extractedFile = TestMapping.extractTestMappingsZip(zipFile);
        Map<String, Set<TestInfo>> allTests = TestMapping.getAllTests(tempDir);
        Set<TestInfo> tests = allTests.get("presubmit");
        assertEquals(5, tests.size());
        tests = allTests.get("postsubmit");
        assertEquals(4, tests.size());
        tests = allTests.get("othertype");
        assertEquals(1, tests.size());
    } finally {
        FileUtil.recursiveDelete(tempDir);
        FileUtil.recursiveDelete(extractedFile);
    }
}
#end_block

#method_before
@Before
public void setUp() {
    Assume.assumeTrue(mBuild instanceof IDeviceBuildInfo);
    deviceBuildInfo = (IDeviceBuildInfo) mBuild;
    testMappingsDir = TestMapping.extractTestMappingsZip(deviceBuildInfo.getFile(TEST_MAPPINGS_ZIP));
    // Total test groups defined in the test_mappings.zip
    totalGroups = getTestGroups(testMappingsDir);
    moduleInfo = getModuleInfo(deviceBuildInfo.getFile(MODULE_INFO));
}
#method_after
@Before
public void setUp() throws IOException, JSONException {
    Assume.assumeTrue(mBuild instanceof IDeviceBuildInfo);
    deviceBuildInfo = (IDeviceBuildInfo) mBuild;
    testMappingsDir = TestMapping.extractTestMappingsZip(deviceBuildInfo.getFile(TEST_MAPPINGS_ZIP));
    File file = deviceBuildInfo.getFile(MODULE_INFO);
    moduleInfo = new JSONObject(FileUtil.readStringFromFile(file));
    allTests = TestMapping.getAllTests(testMappingsDir);
}
#end_block

#method_before
@Test
public void testTestSuiteSetting() {
    List<String> errors = new ArrayList<>();
    for (String group : totalGroups) {
        Set<TestInfo> testsToRun = TestMapping.getAllTests(testMappingsDir, group);
        for (TestInfo test : testsToRun) {
            if (!validateSuiteSetting(test.getName())) {
                errors.add(String.format("Missing test_suite setting for test: %s with group: %s", test.getName(), group));
            }
        }
    }
    // If any errors report them in a final exception.
    if (!errors.isEmpty()) {
        throw new RuntimeException(String.format("Fail test_suite setting check:\n%s", Joiner.on("\n").join(errors)));
    }
}
#method_after
@Test
public void testTestSuiteSetting() throws JSONException {
    List<String> errors = new ArrayList<>();
    for (String testGroup : allTests.keySet()) {
        for (TestInfo testInfo : allTests.get(testGroup)) {
            if (!validateSuiteSetting(testInfo.getName())) {
                errors.add(String.format("Missing test_suite setting for test: %s, test group: %s, " + "TEST_MAPPING file path: %s", testInfo.getName(), testGroup, testInfo.getSources()));
            }
        }
    }
    if (!errors.isEmpty()) {
        fail(String.format("Fail test_suite setting check:\n%s", Joiner.on("\n").join(errors)));
    }
}
#end_block

#method_before
@Test
public void testFilterOptions() {
    List<String> errors = new ArrayList<>();
    for (String group : totalGroups) {
        Set<TestInfo> testsToRun = TestMapping.getAllTests(testMappingsDir, group);
        for (TestInfo test : testsToRun) {
            errors.addAll(validateFilterOption(test, INCLUDE_FILTER));
            errors.addAll(validateFilterOption(test, EXCLUDE_FILTER));
        }
    }
    // If any errors report them in a final exception.
    if (!errors.isEmpty()) {
        throw new RuntimeException(String.format("Fail include/exclude filter setting check:\n%s", Joiner.on("\n").join(errors)));
    }
}
#method_after
@Test
public void testFilterOptions() {
    List<String> errors = new ArrayList<>();
    for (String testGroup : allTests.keySet()) {
        for (String moduleName : getModuleNames(testGroup)) {
            errors.addAll(validateFilterOption(moduleName, INCLUDE_FILTER, testGroup));
            errors.addAll(validateFilterOption(moduleName, EXCLUDE_FILTER, testGroup));
        }
    }
    if (!errors.isEmpty()) {
        fail(String.format("Fail include/exclude filter setting check:\n%s", Joiner.on("\n").join(errors)));
    }
}
#end_block

#method_before
private List<String> validateFilterOption(TestInfo test, String filterOption) {
    List<String> errors = new ArrayList<>();
    List<Boolean> results = new ArrayList<>();
    for (TestOption options : test.getOptions()) {
        if (options.getName().equals(filterOption)) {
            results.add(isClassOrMethod(options.getValue()));
        }
    }
    // the tests information.
    if (results.contains(false) && results.contains(true)) {
        errors.add(String.format("Test: %s uses %s \"%s\" for class and %s for package. Options: %s", test.getName(), Collections.frequency(results, true), filterOption, Collections.frequency(results, false), test.getOptions()));
    }
    return errors;
}
#method_after
private List<String> validateFilterOption(String moduleName, String filterOption, String testGroup) {
    List<String> errors = new ArrayList<>();
    Set<Filters> filterTypes = new HashSet<>();
    Map<Filters, Set<TestInfo>> filterTestInfos = new HashMap<>();
    for (TestInfo test : getTestInfos(moduleName, testGroup)) {
        for (TestOption options : test.getOptions()) {
            if (options.getName().equals(filterOption)) {
                Filters optionType = getOptionType(options.getValue());
                // Add optionType with each TestInfo to get the detailed information.
                filterTestInfos.computeIfAbsent(optionType, k -> new HashSet<>()).add(test);
            }
        }
    }
    filterTypes = filterTestInfos.keySet();
    // TODO(b/128947872): List the type with fewest options first.
    if (filterTypes.size() > 1) {
        errors.add(String.format("Mixed filter types found. Test: %s , TestGroup: %s, Details:\n" + "%s", moduleName, testGroup, getDetailedErrors(filterOption, filterTestInfos)));
    }
    return errors;
}
#end_block

#method_before
private boolean validateSuiteSetting(String name) {
    try {
        if (!moduleInfo.has(name)) {
            CLog.w("Test Module: %s can't be found in module-info.json.", name);
            return false;
        }
        JSONArray compatibilitySuites = moduleInfo.getJSONObject(name).getJSONArray(LOCAL_COMPATIBILITY_SUITES);
        for (int i = 0; i < compatibilitySuites.length(); i++) {
            String suite = compatibilitySuites.optString(i);
            if (suite.equals(GENERAL_TESTS) || suite.equals(DEVICE_TESTS)) {
                return true;
            }
        }
        return false;
    } catch (JSONException e) {
        throw new RuntimeException(String.format("Fail reading module-info.json by name: %s, error: %s", name, e));
    }
}
#method_after
private boolean validateSuiteSetting(String name) throws JSONException {
    if (!moduleInfo.has(name)) {
        CLog.w("Test Module: %s can't be found in module-info.json.", name);
        return false;
    }
    JSONArray compatibilitySuites = moduleInfo.getJSONObject(name).getJSONArray(LOCAL_COMPATIBILITY_SUITES);
    for (int i = 0; i < compatibilitySuites.length(); i++) {
        String suite = compatibilitySuites.optString(i);
        if (suite.equals(GENERAL_TESTS) || suite.equals(DEVICE_TESTS)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void sendTextForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) {
    if (!getSmsPermissions(subId).checkCallingCanSendText(persistMessageForNonDefaultSmsApp, callingPackage, "Sending SMS message")) {
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
        return;
    }
    long token = Binder.clearCallingIdentity();
    try {
        SubscriptionInfo info = getSubscriptionInfo(subId);
        if (isBluetoothSubscription(info)) {
            sendBluetoothText(info, destAddr, text, sentIntent, deliveryIntent);
        } else {
            sendIccText(subId, callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp);
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void sendTextForSubscriber(int subId, String callingPackage, String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent, boolean persistMessageForNonDefaultSmsApp) {
    if (!getSmsPermissions(subId).checkCallingCanSendText(persistMessageForNonDefaultSmsApp, callingPackage, "Sending SMS message")) {
        sendErrorInPendingIntent(sentIntent, SmsManager.RESULT_ERROR_GENERIC_FAILURE);
        return;
    }
    long token = Binder.clearCallingIdentity();
    SubscriptionInfo info;
    try {
        info = getSubscriptionInfo(subId);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    if (isBluetoothSubscription(info)) {
        sendBluetoothText(info, destAddr, text, sentIntent, deliveryIntent);
    } else {
        sendIccText(subId, callingPackage, destAddr, scAddr, text, sentIntent, deliveryIntent, persistMessageForNonDefaultSmsApp);
    }
}
#end_block

#method_before
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_wifi_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    mContentResolver = new MockContentResolver();
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mMockContext = new MockContext(mContext);
    mSM = new TestStateMachine();
    mEnMgr = new WrappedEntitlementManager(mMockContext, mSM, mLog, EVENT_EM_UPDATE, mSystemProperties);
    mStopTetheringCount = 0;
    mEnMgr.setStopTetheringListener((int downstream) -> {
        mStopTetheringCount++;
    });
    mEnMgr.updateConfiguration(new TetheringConfiguration(mMockContext, mLog, INVALID_SUBSCRIPTION_ID));
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_wifi_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    mContentResolver = new MockContentResolver();
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mMockContext = new MockContext(mContext);
    mSM = new TestStateMachine();
    mEnMgr = new WrappedEntitlementManager(mMockContext, mSM, mLog, EVENT_EM_UPDATE, mSystemProperties);
    mEnMgr.setOnUiEntitlementFailedListener(mEntitlementFailedListener);
    mEnMgr.updateConfiguration(new TetheringConfiguration(mMockContext, mLog, INVALID_SUBSCRIPTION_ID));
}
#end_block

#method_before
@Test
public void testCallStopTetheringWhenUiProvisioningFail() {
    setupForRequiredProvisioning();
    mEnMgr.updateConfiguration(new TetheringConfiguration(mMockContext, mLog, INVALID_SUBSCRIPTION_ID));
    assertEquals(0, mStopTetheringCount);
    mEnMgr.fakeEntitlementResult = TETHER_ERROR_PROVISION_FAILED;
    mEnMgr.notifyUpstream(true);
    mLooper.dispatchAll();
    mEnMgr.startProvisioningIfNeeded(TETHERING_WIFI, true);
    mLooper.dispatchAll();
    assertEquals(1, mEnMgr.uiProvisionCount);
    assertEquals(1, mStopTetheringCount);
}
#method_after
@Test
public void testCallStopTetheringWhenUiProvisioningFail() {
    setupForRequiredProvisioning();
    mEnMgr.updateConfiguration(new TetheringConfiguration(mMockContext, mLog, INVALID_SUBSCRIPTION_ID));
    verify(mEntitlementFailedListener, times(0)).onUiEntitlementFailed(TETHERING_WIFI);
    mEnMgr.fakeEntitlementResult = TETHER_ERROR_PROVISION_FAILED;
    mEnMgr.notifyUpstream(true);
    mLooper.dispatchAll();
    mEnMgr.startProvisioningIfNeeded(TETHERING_WIFI, true);
    mLooper.dispatchAll();
    assertEquals(1, mEnMgr.uiProvisionCount);
    verify(mEntitlementFailedListener, times(1)).onUiEntitlementFailed(TETHERING_WIFI);
}
#end_block

#method_before
protected void runSilentTetherProvisioning(int type) {
    if (DBG)
        Log.d(TAG, "runSilentTetherProvisioning: " + type);
    // For silent provisioning, settings would stop tethering when entitlement fail.
    ResultReceiver receiver = buildProxyReceiver(type, false, /* Don't stop tethering automatically */
    null);
    Intent intent = new Intent();
    intent.putExtra(EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(EXTRA_RUN_PROVISION, true);
    intent.putExtra(EXTRA_PROVISION_CALLBACK, receiver);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
protected void runSilentTetherProvisioning(int type) {
    if (DBG)
        Log.d(TAG, "runSilentTetherProvisioning: " + type);
    // For silent provisioning, settings would stop tethering when entitlement fail.
    ResultReceiver receiver = buildProxyReceiver(type, false, /* notifyFail */
    null);
    Intent intent = new Intent();
    intent.putExtra(EXTRA_ADD_TETHER_TYPE, type);
    intent.putExtra(EXTRA_RUN_PROVISION, true);
    intent.putExtra(EXTRA_PROVISION_CALLBACK, receiver);
    intent.setComponent(TETHER_SERVICE);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.startServiceAsUser(intent, UserHandle.CURRENT);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@VisibleForTesting
protected void runUiTetherProvisioning(int type) {
    ResultReceiver receiver = buildProxyReceiver(type, true, /* Stop tethering automatically */
    null);
    runUiTetherProvisioning(type, receiver);
}
#method_after
@VisibleForTesting
protected void runUiTetherProvisioning(int type) {
    ResultReceiver receiver = buildProxyReceiver(type, true, /* notifyFail */
    null);
    runUiTetherProvisioning(type, receiver);
}
#end_block

#method_before
private ResultReceiver buildProxyReceiver(int type, boolean forceStop, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(mHandler) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            int updatedCacheValue = updateEntitlementCacheValue(type, resultCode);
            if (updatedCacheValue == TETHER_ERROR_PROVISION_FAILED && forceStop) {
                mListener.stopTethering(type);
            } else {
                addDownstreamMapping(type, updatedCacheValue);
            }
            if (receiver != null)
                receiver.send(updatedCacheValue, null);
        }
    };
    return writeToParcel(rr);
}
#method_after
private ResultReceiver buildProxyReceiver(int type, boolean notifyFail, final ResultReceiver receiver) {
    ResultReceiver rr = new ResultReceiver(mHandler) {

        @Override
        protected void onReceiveResult(int resultCode, Bundle resultData) {
            int updatedCacheValue = updateEntitlementCacheValue(type, resultCode);
            addDownstreamMapping(type, updatedCacheValue);
            if (updatedCacheValue == TETHER_ERROR_PROVISION_FAILED && notifyFail) {
                mListener.onUiEntitlementFailed(type);
            }
            if (receiver != null)
                receiver.send(updatedCacheValue, null);
        }
    };
    return writeToParcel(rr);
}
#end_block

#method_before
private void handleGetLatestTetheringEntitlementValue(int downstream, ResultReceiver receiver, boolean showEntitlementUi) {
    if (!isTetherProvisioningRequired()) {
        receiver.send(TETHER_ERROR_NO_ERROR, null);
        return;
    }
    final int cacheValue = mEntitlementCacheValue.get(downstream, TETHER_ERROR_ENTITLEMENT_UNKONWN);
    if (cacheValue == TETHER_ERROR_NO_ERROR || !showEntitlementUi) {
        receiver.send(cacheValue, null);
    } else {
        ResultReceiver proxy = buildProxyReceiver(downstream, false, receiver);
        runUiTetherProvisioning(downstream, proxy);
    }
}
#method_after
private void handleGetLatestTetheringEntitlementValue(int downstream, ResultReceiver receiver, boolean showEntitlementUi) {
    if (!isTetherProvisioningRequired()) {
        receiver.send(TETHER_ERROR_NO_ERROR, null);
        return;
    }
    final int cacheValue = mEntitlementCacheValue.get(downstream, TETHER_ERROR_ENTITLEMENT_UNKONWN);
    if (cacheValue == TETHER_ERROR_NO_ERROR || !showEntitlementUi) {
        receiver.send(cacheValue, null);
    } else {
        ResultReceiver proxy = buildProxyReceiver(downstream, false, /* notifyFail */
        receiver);
        runUiTetherProvisioning(downstream, proxy);
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    // fd is null if constructor threw exception
    if (fd != null)
        close();
}
#method_after
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    // fd is null if constructor threw exception
    if (fd != null) {
        close();
    }
// END Android-changed: Integrate upstream code from DatagramChannelImpl.finalize().
}
#end_block

#method_before
@Test
public void testUpdateAndSelectSubtitleTrack() throws Throwable {
    Uri uri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.testvideo_with_2_subtitle_tracks);
    final int initialVideoTrackCount = 1;
    final int initialSubtitleTrackCount = 0;
    final int updatedVideoTrackCount = 1;
    final int updatedSubtitleTrackCount = 1;
    final int selectedSubtitleTrackIndex = 0;
    final String subtitleTrackText = "Track 1";
    final MediaItem mediaItem = createTestMediaItem2(uri);
    final CountDownLatch latchForTrackUpdate = new CountDownLatch(2);
    final CountDownLatch latchForSubtitleSelect = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (command.getCustomCommand() == MediaControlView.EVENT_UPDATE_TRACK_STATUS) {
                int videoTrackCount = (args != null) ? args.getInt(KEY_VIDEO_TRACK_COUNT) : 0;
                int subtitleTrackCount = (args != null) ? args.getInt(KEY_SUBTITLE_TRACK_COUNT) : 0;
                if (latchForTrackUpdate.getCount() == 2) {
                    assertEquals(initialVideoTrackCount, videoTrackCount);
                    assertEquals(initialSubtitleTrackCount, subtitleTrackCount);
                } else {
                    assertEquals(updatedVideoTrackCount, videoTrackCount);
                    assertEquals(updatedSubtitleTrackCount, subtitleTrackCount);
                }
                latchForTrackUpdate.countDown();
            } else if (command.getCustomCommand() == MediaControlView.EVENT_UPDATE_SUBTITLE_SELECTED) {
                int subtitleIndex = args != null ? args.getInt(MediaControlView.KEY_SELECTED_SUBTITLE_INDEX) : -1;
                assertEquals(selectedSubtitleTrackIndex, subtitleIndex);
                latchForSubtitleSelect.countDown();
            }
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mediaItem);
        }
    });
    assertTrue(latchForTrackUpdate.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.subtitle)).perform(click());
    assertFalse(latchForSubtitleSelect.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withText(subtitleTrackText)).inRoot(isPlatformPopup()).perform(click());
    assertTrue(latchForSubtitleSelect.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testUpdateAndSelectSubtitleTrack() throws Throwable {
    Uri uri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.testvideo_with_2_subtitle_tracks);
    final int subtitleTrackCount = 2;
    final int selectedSubtitleTrackIndex = 0;
    // TODO: change once aosp/932020 is merged.
    final String subtitleTrack1Text = "Track 1 - und";
    final MediaItem mediaItem = createTestMediaItem2(uri);
    final CountDownLatch latchForTrackUpdate = new CountDownLatch(1);
    final CountDownLatch latchForSubtitleSelect = new CountDownLatch(1);
    final MediaController controller = createController(new MediaController.ControllerCallback() {

        @NonNull
        @Override
        public SessionResult onCustomCommand(@NonNull MediaController controller, @NonNull SessionCommand command, @Nullable Bundle args) {
            if (TextUtils.equals(command.getCustomCommand(), MediaControlView.EVENT_UPDATE_TRACK_STATUS)) {
                List<String> list = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
                if (list != null && list.size() == subtitleTrackCount) {
                    latchForTrackUpdate.countDown();
                }
            } else if (TextUtils.equals(command.getCustomCommand(), MediaControlView.EVENT_UPDATE_SUBTITLE_SELECTED)) {
                int subtitleIndex = args != null ? args.getInt(MediaControlView.KEY_SELECTED_SUBTITLE_INDEX) : -1;
                assertEquals(selectedSubtitleTrackIndex, subtitleIndex);
                latchForSubtitleSelect.countDown();
            }
            return new SessionResult(SessionResult.RESULT_SUCCESS, null);
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem(mediaItem);
        }
    });
    controller.play();
    assertTrue(latchForTrackUpdate.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.subtitle)).check(matches(isClickable()));
    onView(withId(R.id.subtitle)).perform(click());
    onView(withText(subtitleTrack1Text)).inRoot(isPlatformPopup()).check(matches(isCompletelyDisplayed()));
    onView(withText(subtitleTrack1Text)).inRoot(isPlatformPopup()).perform(click());
    assertTrue(latchForSubtitleSelect.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
private MediaItem createTestMediaItem2(Uri uri) {
    return new UriMediaItem.Builder(mVideoView.getContext(), uri).build();
}
#method_after
private MediaItem createTestMediaItem2(Uri uri) {
    return new UriMediaItem.Builder(uri).build();
}
#end_block

#method_before
private ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled, String librarySearchPath, String libraryPermittedPath, ClassLoader parent, String cacheKey, String classLoaderName, List<ClassLoader> sharedLibraries) {
    if (mSystemLibsPreloadMap != null) {
        ClassLoader preloaded = mSystemLibsPreloadMap.get(zip);
        if (preloaded != null) {
            Log.w(TAG, "Returning preloaded lib: " + zip);
            return preloaded;
        }
    }
    /*
         * This is the parent we use if they pass "null" in.  In theory
         * this should be the "system" class loader; in practice we
         * don't use that and can happily (and more efficiently) use the
         * bootstrap class loader.
         */
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }
        /*
             * If we're one step up from the base class loader, find
             * something in our cache.  Otherwise, we create a whole
             * new ClassLoader for the zip archive.
             */
        if (parent == baseParent) {
            ClassLoader loader = mLoaders.get(cacheKey);
            if (loader != null) {
                return loader;
            }
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);
            ClassLoader classloader = ClassLoaderFactory.createClassLoader(zip, librarySearchPath, libraryPermittedPath, parent, targetSdkVersion, isBundled, classLoaderName, sharedLibraries);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "setLayerPaths");
            GraphicsEnvironment.getInstance().setLayerPaths(classloader, librarySearchPath, libraryPermittedPath);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            mLoaders.put(cacheKey, classloader);
            return classloader;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);
        ClassLoader loader = ClassLoaderFactory.createClassLoader(zip, null, parent, classLoaderName, sharedLibraries);
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        return loader;
    }
}
#method_after
private ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled, String librarySearchPath, String libraryPermittedPath, ClassLoader parent, String cacheKey, String classLoaderName, List<ClassLoader> sharedLibraries) {
    /*
         * This is the parent we use if they pass "null" in.  In theory
         * this should be the "system" class loader; in practice we
         * don't use that and can happily (and more efficiently) use the
         * bootstrap class loader.
         */
    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();
    synchronized (mLoaders) {
        if (parent == null) {
            parent = baseParent;
        }
        /*
             * If we're one step up from the base class loader, find
             * something in our cache.  Otherwise, we create a whole
             * new ClassLoader for the zip archive.
             */
        if (parent == baseParent) {
            ClassLoader loader = mLoaders.get(cacheKey);
            if (loader != null) {
                return loader;
            }
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);
            ClassLoader classloader = ClassLoaderFactory.createClassLoader(zip, librarySearchPath, libraryPermittedPath, parent, targetSdkVersion, isBundled, classLoaderName, sharedLibraries);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "setLayerPaths");
            GraphicsEnvironment.getInstance().setLayerPaths(classloader, librarySearchPath, libraryPermittedPath);
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            if (cacheKey != null) {
                mLoaders.put(cacheKey, classloader);
            }
            return classloader;
        }
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);
        ClassLoader loader = ClassLoaderFactory.createClassLoader(zip, null, parent, classLoaderName, sharedLibraries);
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        return loader;
    }
}
#end_block

#method_before
static void preload(TimingsTraceLog bootTimingsTraceLog) {
    Log.d(TAG, "begin preload");
    bootTimingsTraceLog.traceBegin("BeginPreload");
    beginPreload();
    // BeginPreload
    bootTimingsTraceLog.traceEnd();
    bootTimingsTraceLog.traceBegin("PreloadClasses");
    preloadClasses();
    // PreloadClasses
    bootTimingsTraceLog.traceEnd();
    bootTimingsTraceLog.traceBegin("PreloadNonBootclasspathLibs");
    preloadNonBootclasspathLibs();
    // PreloadNonBootclasspathLibs
    bootTimingsTraceLog.traceEnd();
    bootTimingsTraceLog.traceBegin("PreloadResources");
    preloadResources();
    // PreloadResources
    bootTimingsTraceLog.traceEnd();
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
    nativePreloadAppProcessHALs();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadOpenGL");
    preloadOpenGL();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    preloadSharedLibraries();
    preloadTextResources();
    // Ask the WebViewFactory to do any initialization that must run in the zygote process,
    // for memory sharing purposes.
    WebViewFactory.prepareWebViewInZygote();
    endPreload();
    warmUpJcaProviders();
    Log.d(TAG, "end preload");
    sPreloadComplete = true;
}
#method_after
static void preload(TimingsTraceLog bootTimingsTraceLog) {
    Log.d(TAG, "begin preload");
    bootTimingsTraceLog.traceBegin("BeginPreload");
    beginPreload();
    // BeginPreload
    bootTimingsTraceLog.traceEnd();
    bootTimingsTraceLog.traceBegin("PreloadClasses");
    preloadClasses();
    // PreloadClasses
    bootTimingsTraceLog.traceEnd();
    bootTimingsTraceLog.traceBegin("CacheNonBootClasspathClassLoaders");
    cacheNonBootClasspathClassLoaders();
    // CacheNonBootClasspathClassLoaders
    bootTimingsTraceLog.traceEnd();
    bootTimingsTraceLog.traceBegin("PreloadResources");
    preloadResources();
    // PreloadResources
    bootTimingsTraceLog.traceEnd();
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadAppProcessHALs");
    nativePreloadAppProcessHALs();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadOpenGL");
    preloadOpenGL();
    Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
    preloadSharedLibraries();
    preloadTextResources();
    // Ask the WebViewFactory to do any initialization that must run in the zygote process,
    // for memory sharing purposes.
    WebViewFactory.prepareWebViewInZygote();
    endPreload();
    warmUpJcaProviders();
    Log.d(TAG, "end preload");
    sPreloadComplete = true;
}
#end_block

#method_before
private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) {
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);
    if (parsedArgs.mNiceName != null) {
        Process.setArgV0(parsedArgs.mNiceName);
    }
    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
    if (systemServerClasspath != null) {
        performSystemServerDexOpt(systemServerClasspath);
        // Capturing profiles is only supported for debug or eng builds since selinux normally
        // prevents it.
        boolean profileSystemServer = SystemProperties.getBoolean("dalvik.vm.profilesystemserver", false);
        if (profileSystemServer && (Build.IS_USERDEBUG || Build.IS_ENG)) {
            try {
                prepareSystemServerProfile(systemServerClasspath);
            } catch (Exception e) {
                Log.wtf(TAG, "Failed to set up system server profile", e);
            }
        }
    }
    if (parsedArgs.mInvokeWith != null) {
        String[] args = parsedArgs.mRemainingArgs;
        // correctly when we exec a new process.
        if (systemServerClasspath != null) {
            String[] amendedArgs = new String[args.length + 2];
            amendedArgs[0] = "-cp";
            amendedArgs[1] = systemServerClasspath;
            System.arraycopy(args, 0, amendedArgs, 2, args.length);
            args = amendedArgs;
        }
        WrapperInit.execApplication(parsedArgs.mInvokeWith, parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args);
        throw new IllegalStateException("Unexpected return from WrapperInit.execApplication");
    } else {
        ClassLoader cl = null;
        if (systemServerClasspath != null) {
            cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion);
            Thread.currentThread().setContextClassLoader(cl);
        }
        /*
             * Pass the remaining arguments to SystemServer.
             */
        return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mRemainingArgs, cl);
    }
/* should never reach here */
}
#method_after
private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) {
    // set umask to 0077 so new files and directories will default to owner-only permissions.
    Os.umask(S_IRWXG | S_IRWXO);
    if (parsedArgs.mNiceName != null) {
        Process.setArgV0(parsedArgs.mNiceName);
    }
    final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
    if (systemServerClasspath != null) {
        if (performSystemServerDexOpt(systemServerClasspath)) {
            // Throw away the cached classloader. If we compiled here, the classloader would
            // not have had AoT-ed artifacts.
            // Note: This only works in a very special environment where selinux enforcement is
            // disabled, e.g., Mac builds.
            sCachedSystemServerClassLoader = null;
        }
        // Capturing profiles is only supported for debug or eng builds since selinux normally
        // prevents it.
        boolean profileSystemServer = SystemProperties.getBoolean("dalvik.vm.profilesystemserver", false);
        if (profileSystemServer && (Build.IS_USERDEBUG || Build.IS_ENG)) {
            try {
                prepareSystemServerProfile(systemServerClasspath);
            } catch (Exception e) {
                Log.wtf(TAG, "Failed to set up system server profile", e);
            }
        }
    }
    if (parsedArgs.mInvokeWith != null) {
        String[] args = parsedArgs.mRemainingArgs;
        // correctly when we exec a new process.
        if (systemServerClasspath != null) {
            String[] amendedArgs = new String[args.length + 2];
            amendedArgs[0] = "-cp";
            amendedArgs[1] = systemServerClasspath;
            System.arraycopy(args, 0, amendedArgs, 2, args.length);
            args = amendedArgs;
        }
        WrapperInit.execApplication(parsedArgs.mInvokeWith, parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args);
        throw new IllegalStateException("Unexpected return from WrapperInit.execApplication");
    } else {
        createSystemServerClassLoader();
        ClassLoader cl = sCachedSystemServerClassLoader;
        if (cl != null) {
            Thread.currentThread().setContextClassLoader(cl);
        }
        /*
             * Pass the remaining arguments to SystemServer.
             */
        return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mRemainingArgs, cl);
    }
/* should never reach here */
}
#end_block

#method_before
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final IInstalld installd = IInstalld.Stub.asInterface(ServiceManager.getService("installd"));
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    String classPathForElement = "";
    for (String classPathElement : classPathElements) {
        // System server is fully AOTed and never profiled
        // for profile guided compilation.
        String systemServerFilter = SystemProperties.get("dalvik.vm.systemservercompilerfilter", "speed");
        int dexoptNeeded;
        try {
            dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, systemServerFilter, null, /* classLoaderContext */
            false, /* newProfile */
            false);
        } catch (FileNotFoundException ignored) {
            // Do not add to the classpath.
            Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
            continue;
        } catch (IOException e) {
            // Not fully clear what to do here as we don't know the cause of the
            // IO exception. Add to the classpath to be conservative, but don't
            // attempt to compile it.
            Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
            dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
        }
        if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
            final String packageName = "*";
            final String outputPath = null;
            final int dexFlags = 0;
            final String compilerFilter = systemServerFilter;
            final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
            final String seInfo = null;
            final String classLoaderContext = getSystemServerClassLoaderContext(classPathForElement);
            // SystemServer targets the system's SDK version
            final int targetSdkVersion = 0;
            try {
                installd.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, classLoaderContext, seInfo, false, /* downgrade */
                targetSdkVersion, /*profileName*/
                null, /*dexMetadataPath*/
                null, "server-dexopt");
            } catch (RemoteException | ServiceSpecificException e) {
                // Ignore (but log), we need this on the classpath for fallback mode.
                Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
            }
        }
        classPathForElement = encodeSystemServerClassPath(classPathForElement, classPathElement);
    }
}
#method_after
private static boolean performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final IInstalld installd = IInstalld.Stub.asInterface(ServiceManager.getService("installd"));
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    String classPathForElement = "";
    boolean compiledSomething = false;
    for (String classPathElement : classPathElements) {
        // System server is fully AOTed and never profiled
        // for profile guided compilation.
        String systemServerFilter = SystemProperties.get("dalvik.vm.systemservercompilerfilter", "speed");
        int dexoptNeeded;
        try {
            dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, systemServerFilter, null, /* classLoaderContext */
            false, /* newProfile */
            false);
        } catch (FileNotFoundException ignored) {
            // Do not add to the classpath.
            Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
            continue;
        } catch (IOException e) {
            // Not fully clear what to do here as we don't know the cause of the
            // IO exception. Add to the classpath to be conservative, but don't
            // attempt to compile it.
            Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
            dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
        }
        if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
            final String packageName = "*";
            final String outputPath = null;
            final int dexFlags = 0;
            final String compilerFilter = systemServerFilter;
            final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
            final String seInfo = null;
            final String classLoaderContext = getSystemServerClassLoaderContext(classPathForElement);
            // SystemServer targets the system's SDK version
            final int targetSdkVersion = 0;
            try {
                installd.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, classLoaderContext, seInfo, false, /* downgrade */
                targetSdkVersion, /*profileName*/
                null, /*dexMetadataPath*/
                null, "server-dexopt");
                compiledSomething = true;
            } catch (RemoteException | ServiceSpecificException e) {
                // Ignore (but log), we need this on the classpath for fallback mode.
                Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
            }
        }
        classPathForElement = encodeSystemServerClassPath(classPathForElement, classPathElement);
    }
    return compiledSomething;
}
#end_block

#method_before
public void showNotification(int id, NotificationType notifyType, NetworkAgentInfo nai, NetworkAgentInfo switchToNai, PendingIntent intent, boolean highPriority) {
    final String tag = tagFor(id);
    final int eventId = notifyType.eventId;
    final int transportType;
    final String name;
    if (nai != null) {
        transportType = getFirstTransportType(nai);
        final String extraInfo = nai.networkInfo.getExtraInfo();
        name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
        // Only notify for Internet-capable networks.
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET))
            return;
    } else {
        // Legacy notifications.
        transportType = TRANSPORT_CELLULAR;
        name = null;
    }
    // Clear any previous notification with lower priority, otherwise return. http://b/63676954.
    // A new SIGN_IN notification with a new intent should override any existing one.
    final int previousEventId = mNotificationTypeMap.get(id);
    final NotificationType previousNotifyType = NotificationType.getFromId(previousEventId);
    if (priority(previousNotifyType) > priority(notifyType)) {
        Slog.d(TAG, String.format("ignoring notification %s for network %s with existing notification %s", notifyType, id, previousNotifyType));
        return;
    }
    clearNotification(id);
    if (DBG) {
        Slog.d(TAG, String.format("showNotification tag=%s event=%s transport=%s name=%s highPriority=%s", tag, nameOf(eventId), getTransportName(transportType), name, highPriority));
    }
    Resources r = Resources.getSystem();
    CharSequence title;
    CharSequence details;
    int icon = getIcon(transportType);
    if (notifyType == NotificationType.NO_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.PARTIAL_CONNECTIVITY && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.network_partial_connectivity, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.network_partial_connectivity_detailed);
    } else if (notifyType == NotificationType.LOST_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.SIGN_IN) {
        switch(transportType) {
            case TRANSPORT_WIFI:
                title = r.getString(R.string.wifi_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
                break;
            case TRANSPORT_CELLULAR:
                title = r.getString(R.string.network_available_sign_in, 0);
                // TODO: Change this to pull from NetworkInfo once a printable
                // name has been added to it
                NetworkSpecifier specifier = nai.networkCapabilities.getNetworkSpecifier();
                int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
                if (specifier == null && specifier instanceof StringNetworkSpecifier) {
                    try {
                        subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier);
                    } catch (NumberFormatException e) {
                        Slog.e(TAG, "NumberFormatException on " + ((StringNetworkSpecifier) specifier).specifier);
                    }
                }
                details = mTelephonyManager.getNetworkOperatorName(subId);
                break;
            default:
                title = r.getString(R.string.network_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, name);
                break;
        }
    } else if (notifyType == NotificationType.LOGGED_IN) {
        title = WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID());
        details = r.getString(R.string.captive_portal_logged_in_detailed);
    } else if (notifyType == NotificationType.NETWORK_SWITCH) {
        String fromTransport = getTransportName(transportType);
        String toTransport = getTransportName(getFirstTransportType(switchToNai));
        title = r.getString(R.string.network_switch_metered, toTransport);
        details = r.getString(R.string.network_switch_metered_detail, toTransport, fromTransport);
    } else {
        Slog.wtf(TAG, "Unknown notification type " + notifyType + " on network transport " + getTransportName(transportType));
        return;
    }
    final String channelId = highPriority ? SystemNotificationChannels.NETWORK_ALERTS : SystemNotificationChannels.NETWORK_STATUS;
    Notification.Builder builder = new Notification.Builder(mContext, channelId).setWhen(System.currentTimeMillis()).setShowWhen(notifyType == NotificationType.NETWORK_SWITCH).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentIntent(intent).setLocalOnly(true).setOnlyAlertOnce(true);
    if (notifyType == NotificationType.NETWORK_SWITCH) {
        builder.setStyle(new Notification.BigTextStyle().bigText(details));
    } else {
        builder.setContentText(details);
    }
    if (notifyType == NotificationType.SIGN_IN) {
        builder.extend(new Notification.TvExtender().setChannelId(channelId));
    }
    Notification notification = builder.build();
    mNotificationTypeMap.put(id, eventId);
    try {
        mNotificationManager.notifyAsUser(tag, eventId, notification, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, "setNotificationVisible: visible notificationManager error", npe);
    }
}
#method_after
public void showNotification(int id, NotificationType notifyType, NetworkAgentInfo nai, NetworkAgentInfo switchToNai, PendingIntent intent, boolean highPriority) {
    final String tag = tagFor(id);
    final int eventId = notifyType.eventId;
    final int transportType;
    final String name;
    if (nai != null) {
        transportType = getFirstTransportType(nai);
        final String extraInfo = nai.networkInfo.getExtraInfo();
        name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
        // Only notify for Internet-capable networks.
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET))
            return;
    } else {
        // Legacy notifications.
        transportType = TRANSPORT_CELLULAR;
        name = null;
    }
    // Clear any previous notification with lower priority, otherwise return. http://b/63676954.
    // A new SIGN_IN notification with a new intent should override any existing one.
    final int previousEventId = mNotificationTypeMap.get(id);
    final NotificationType previousNotifyType = NotificationType.getFromId(previousEventId);
    if (priority(previousNotifyType) > priority(notifyType)) {
        Slog.d(TAG, String.format("ignoring notification %s for network %s with existing notification %s", notifyType, id, previousNotifyType));
        return;
    }
    clearNotification(id);
    if (DBG) {
        Slog.d(TAG, String.format("showNotification tag=%s event=%s transport=%s name=%s highPriority=%s", tag, nameOf(eventId), getTransportName(transportType), name, highPriority));
    }
    Resources r = Resources.getSystem();
    CharSequence title;
    CharSequence details;
    int icon = getIcon(transportType);
    if (notifyType == NotificationType.NO_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.PARTIAL_CONNECTIVITY && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.network_partial_connectivity, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.network_partial_connectivity_detailed);
    } else if (notifyType == NotificationType.LOST_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.SIGN_IN) {
        switch(transportType) {
            case TRANSPORT_WIFI:
                title = r.getString(R.string.wifi_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
                break;
            case TRANSPORT_CELLULAR:
                title = r.getString(R.string.network_available_sign_in, 0);
                // TODO: Change this to pull from NetworkInfo once a printable
                // name has been added to it
                NetworkSpecifier specifier = nai.networkCapabilities.getNetworkSpecifier();
                int subId = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
                if (specifier instanceof StringNetworkSpecifier) {
                    try {
                        subId = Integer.parseInt(((StringNetworkSpecifier) specifier).specifier);
                    } catch (NumberFormatException e) {
                        Slog.e(TAG, "NumberFormatException on " + ((StringNetworkSpecifier) specifier).specifier);
                    }
                }
                details = mTelephonyManager.createForSubscriptionId(subId).getNetworkOperatorName();
                break;
            default:
                title = r.getString(R.string.network_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, name);
                break;
        }
    } else if (notifyType == NotificationType.LOGGED_IN) {
        title = WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID());
        details = r.getString(R.string.captive_portal_logged_in_detailed);
    } else if (notifyType == NotificationType.NETWORK_SWITCH) {
        String fromTransport = getTransportName(transportType);
        String toTransport = getTransportName(getFirstTransportType(switchToNai));
        title = r.getString(R.string.network_switch_metered, toTransport);
        details = r.getString(R.string.network_switch_metered_detail, toTransport, fromTransport);
    } else {
        Slog.wtf(TAG, "Unknown notification type " + notifyType + " on network transport " + getTransportName(transportType));
        return;
    }
    final String channelId = highPriority ? SystemNotificationChannels.NETWORK_ALERTS : SystemNotificationChannels.NETWORK_STATUS;
    Notification.Builder builder = new Notification.Builder(mContext, channelId).setWhen(System.currentTimeMillis()).setShowWhen(notifyType == NotificationType.NETWORK_SWITCH).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentIntent(intent).setLocalOnly(true).setOnlyAlertOnce(true);
    if (notifyType == NotificationType.NETWORK_SWITCH) {
        builder.setStyle(new Notification.BigTextStyle().bigText(details));
    } else {
        builder.setContentText(details);
    }
    if (notifyType == NotificationType.SIGN_IN) {
        builder.extend(new Notification.TvExtender().setChannelId(channelId));
    }
    Notification notification = builder.build();
    mNotificationTypeMap.put(id, eventId);
    try {
        mNotificationManager.notifyAsUser(tag, eventId, notification, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, "setNotificationVisible: visible notificationManager error", npe);
    }
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
        if (interactive) {
            // then don't pass it to the application
            if (keyCode == mPendingWakeKey && !down) {
                result = 0;
            }
            // Reset the pending key
            mPendingWakeKey = PENDING_KEY_NULL;
        }
    } else if (!interactive && shouldDispatchInputWhenNonInteractive(event)) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
        // Since we're dispatching the input, reset the pending key
        mPendingWakeKey = PENDING_KEY_NULL;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
        // Cache the wake key on down event so we can also avoid sending the up event to the app
        if (isWakeKey && down) {
            mPendingWakeKey = keyCode;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    // Enable haptics if down and virtual key without multiple repetitions. If this is a hard
    // virtual key such as a navigation bar button, only vibrate if flag is enabled.
    final boolean isNavBarVirtKey = ((event.getFlags() & KeyEvent.FLAG_VIRTUAL_HARD_KEY) != 0);
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && (!isNavBarVirtKey || mNavBarVirtualKeyHapticFeedbackEnabled) && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
            {
                if (down) {
                    interceptBackKeyDown();
                } else {
                    boolean handled = interceptBackKeyUp(event);
                    // Don't pass back press to app if we've already handled it via long press
                    if (handled) {
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        // Any activity on the vol down button stops the ringer toggle shortcut
                        cancelPendingRingerToggleChordAction();
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                            interceptAccessibilityShortcutChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mA11yShortcutChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mA11yShortcutChordVolumeUpKeyTriggered = true;
                            mA11yShortcutChordVolumeUpKeyTime = event.getDownTime();
                            mA11yShortcutChordVolumeUpKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            cancelPendingRingerToggleChordAction();
                            interceptAccessibilityShortcutChord();
                            interceptRingerToggleChord();
                        }
                    } else {
                        mA11yShortcutChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingAccessibilityShortcutAction();
                        cancelPendingRingerToggleChordAction();
                    }
                }
                if (down) {
                    sendSystemKeyToStatusBarAsync(event.getKeyCode());
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null && !mHandleVolumeKeysInWM) {
                        // should be dispatched to WM.
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                    }
                    int audioMode = AudioManager.MODE_NORMAL;
                    try {
                        audioMode = getAudioService().getMode();
                    } catch (Exception e) {
                        Log.e(TAG, "Error getting AudioService in interceptKeyBeforeQueueing.", e);
                    }
                    boolean isInCall = (telecomManager != null && telecomManager.isInCall()) || audioMode == AudioManager.MODE_IN_COMMUNICATION;
                    if (isInCall && (result & ACTION_PASS_TO_USER) == 0) {
                        // If we are in call but we decided not to pass the key to
                        // the application, just pass it to the session service.
                        MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, false);
                        break;
                    }
                }
                if (mUseTvRouting || mHandleVolumeKeysInWM) {
                    // Defer special key handlings to
                    // {@link interceptKeyBeforeDispatching()}.
                    result |= ACTION_PASS_TO_USER;
                } else if ((result & ACTION_PASS_TO_USER) == 0) {
                    // If we aren't passing to the user and no one else
                    // handled it send it to the session manager to
                    // figure out.
                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                EventLogTags.writeInterceptPower(KeyEvent.actionToString(event.getAction()), mPowerKeyHandled ? 1 : 0, mPowerKeyPressCounter);
                // Any activity on the power button stops the accessibility shortcut
                cancelPendingAccessibilityShortcutAction();
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_DOWN:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_LEFT:
        // fall through
        case KeyEvent.KEYCODE_SYSTEM_NAVIGATION_RIGHT:
            {
                result &= ~ACTION_PASS_TO_USER;
                interceptSystemNavigationKey(event);
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress();
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ASSIST:
            {
                final boolean longPressed = event.getRepeatCount() > 0;
                if (down && longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST_LONG_PRESS);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                if (!down && !longPressed) {
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_ASSIST, event.getDeviceId(), 0, /* unused */
                    null);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                if (!down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                result &= ~ACTION_PASS_TO_USER;
                break;
            }
        case KeyEvent.KEYCODE_WINDOW:
            {
                if (mShortPressOnWindowBehavior == SHORT_PRESS_WINDOW_PICTURE_IN_PICTURE) {
                    if (mPictureInPictureVisible) {
                        // activity to customize PIP key behavior.
                        if (!down) {
                            showPictureInPictureMenu(event);
                        }
                        result &= ~ACTION_PASS_TO_USER;
                    }
                }
                break;
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#end_block

#method_before
private boolean initPacketSocket() {
    try {
        mPacketSock = Os.socket(AF_PACKET, SOCK_RAW, ETH_P_IP);
        SocketAddress addr = makePacketSocketAddress((short) ETH_P_IP, mIface.index);
        SocketUtils.bindSocket(mPacketSock, addr);
        SocketUtils.attachDhcpFilter(mPacketSock);
    } catch (SocketException | ErrnoException e) {
        Log.e(TAG, "Error creating packet socket", e);
        return false;
    }
    return true;
}
#method_after
private boolean initPacketSocket() {
    try {
        mPacketSock = Os.socket(AF_PACKET, SOCK_RAW, ETH_P_IP);
        SocketAddress addr = makePacketSocketAddress((short) ETH_P_IP, mIface.index);
        Os.bind(mPacketSock, addr);
        SocketUtils.attachDhcpFilter(mPacketSock);
    } catch (SocketException | ErrnoException e) {
        Log.e(TAG, "Error creating packet socket", e);
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean transmitPacket(ByteBuffer buf, String description, int encap, Inet4Address to) {
    try {
        if (encap == DhcpPacket.ENCAP_L2) {
            if (DBG)
                Log.d(TAG, "Broadcasting " + description);
            SocketUtils.sendTo(mPacketSock, buf.array(), 0, buf.limit(), 0, mInterfaceBroadcastAddr);
        } else if (encap == DhcpPacket.ENCAP_BOOTP && to.equals(INADDR_BROADCAST)) {
            if (DBG)
                Log.d(TAG, "Broadcasting " + description);
            // We only send L3-encapped broadcasts in DhcpRebindingState,
            // where we have an IP address and an unconnected UDP socket.
            // 
            // N.B.: We only need this codepath because DhcpRequestPacket
            // hardcodes the source IP address to 0.0.0.0. We could reuse
            // the packet socket if this ever changes.
            Os.sendto(mUdpSock, buf, 0, to, DhcpPacket.DHCP_SERVER);
        } else {
            // have an IP address, and we connect the UDP socket in DhcpBoundState#enter.
            if (DBG)
                Log.d(TAG, String.format("Unicasting %s to %s", description, Os.getpeername(mUdpSock)));
            Os.write(mUdpSock, buf);
        }
    } catch (ErrnoException | IOException e) {
        Log.e(TAG, "Can't send packet: ", e);
        return false;
    }
    return true;
}
#method_after
private boolean transmitPacket(ByteBuffer buf, String description, int encap, Inet4Address to) {
    try {
        if (encap == DhcpPacket.ENCAP_L2) {
            if (DBG)
                Log.d(TAG, "Broadcasting " + description);
            Os.sendto(mPacketSock, buf.array(), 0, buf.limit(), 0, mInterfaceBroadcastAddr);
        } else if (encap == DhcpPacket.ENCAP_BOOTP && to.equals(INADDR_BROADCAST)) {
            if (DBG)
                Log.d(TAG, "Broadcasting " + description);
            // We only send L3-encapped broadcasts in DhcpRebindingState,
            // where we have an IP address and an unconnected UDP socket.
            // 
            // N.B.: We only need this codepath because DhcpRequestPacket
            // hardcodes the source IP address to 0.0.0.0. We could reuse
            // the packet socket if this ever changes.
            Os.sendto(mUdpSock, buf, 0, to, DhcpPacket.DHCP_SERVER);
        } else {
            // have an IP address, and we connect the UDP socket in DhcpBoundState#enter.
            if (DBG)
                Log.d(TAG, String.format("Unicasting %s to %s", description, Os.getpeername(mUdpSock)));
            Os.write(mUdpSock, buf);
        }
    } catch (ErrnoException | IOException e) {
        Log.e(TAG, "Can't send packet: ", e);
        return false;
    }
    return true;
}
#end_block

#method_before
private void handleNeighborLost(NeighborEvent event) {
    final LinkProperties whatIfLp = new LinkProperties(mLinkProperties);
    InetAddress ip = null;
    for (Map.Entry<InetAddress, NeighborEvent> entry : mNeighborWatchList.entrySet()) {
        // NUD_INCOMPLETE (say, during network attach).
        if (entry.getValue().nudState != StructNdMsg.NUD_FAILED)
            continue;
        ip = entry.getKey();
        for (RouteInfo route : mLinkProperties.getRoutes()) {
            if (ip.equals(route.getGateway())) {
                whatIfLp.removeRoute(route);
            }
        }
        if (avoidingBadLinks() || !(ip instanceof Inet6Address)) {
            // We should do this unconditionally, but alas we cannot: b/31827713.
            whatIfLp.removeDnsServer(ip);
        }
    }
    final boolean lostProvisioning = (mLinkProperties.isIPv4Provisioned() && !whatIfLp.isIPv4Provisioned()) || (mLinkProperties.isIPv6Provisioned() && !whatIfLp.isIPv6Provisioned());
    if (lostProvisioning) {
        final String logMsg = "FAILURE: LOST_PROVISIONING, " + event;
        Log.w(TAG, logMsg);
        if (mCallback != null) {
            // TODO: remove |ip| when the callback signature no longer has
            // an InetAddress argument.
            mCallback.notifyLost(ip, logMsg);
        }
    }
    logNudFailed(lostProvisioning);
}
#method_after
private void handleNeighborLost(NeighborEvent event) {
    final LinkProperties whatIfLp = new LinkProperties(mLinkProperties);
    InetAddress ip = null;
    for (Map.Entry<InetAddress, NeighborEvent> entry : mNeighborWatchList.entrySet()) {
        // NUD_INCOMPLETE (say, during network attach).
        if (entry.getValue().nudState != StructNdMsg.NUD_FAILED)
            continue;
        ip = entry.getKey();
        for (RouteInfo route : mLinkProperties.getRoutes()) {
            if (ip.equals(route.getGateway())) {
                whatIfLp.removeRoute(route);
            }
        }
        if (avoidingBadLinks() || !(ip instanceof Inet6Address)) {
            // We should do this unconditionally, but alas we cannot: b/31827713.
            whatIfLp.removeDnsServer(ip);
        }
    }
    final boolean lostProvisioning = (mLinkProperties.isIpv4Provisioned() && !whatIfLp.isIpv4Provisioned()) || (mLinkProperties.isIpv6Provisioned() && !whatIfLp.isIpv6Provisioned());
    if (lostProvisioning) {
        final String logMsg = "FAILURE: LOST_PROVISIONING, " + event;
        Log.w(TAG, logMsg);
        if (mCallback != null) {
            // TODO: remove |ip| when the callback signature no longer has
            // an InetAddress argument.
            mCallback.notifyLost(ip, logMsg);
        }
    }
    logNudFailed(lostProvisioning);
}
#end_block

#method_before
private boolean avoidingBadLinks() {
    return !mUsingMultinetworkPolicyTracker || mCm.getAvoidBadWifi();
}
#method_after
private boolean avoidingBadLinks() {
    return !mUsingMultinetworkPolicyTracker || mCm.shouldAvoidBadWifi();
}
#end_block

#method_before
private int getPermissionForUid(int uid) {
    int permission = 0;
    // If there are other packages remain under the same uid, check the permission of those
    // packages. We only remove the permission for a given uid when all packages for that
    // uid no longer have that permission.
    String[] packages = mPackageManager.getPackagesForUid(uid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            final PackageInfo app = getPackageInfo(name);
            if (app != null && app.requestedPermissions != null) {
                permission |= getNetdPermissionMask(app.requestedPermissions, app.requestedPermissionsFlags);
            }
        }
    }
    return permission;
}
#method_after
private int getPermissionForUid(int uid) {
    int permission = 0;
    // Check all the packages for this UID. The UID has the permission if any of the
    // packages in it has the permission.
    String[] packages = mPackageManager.getPackagesForUid(uid);
    if (packages != null && packages.length > 0) {
        for (String name : packages) {
            final PackageInfo app = getPackageInfo(name);
            if (app != null && app.requestedPermissions != null) {
                permission |= getNetdPermissionMask(app.requestedPermissions, app.requestedPermissionsFlags);
            }
        }
    }
    return permission;
}
#end_block

#method_before
void onCleared(@NonNull String backStackEntryUUID) {
    // Clear and remove the NavGraph's ViewModelStore
    ViewModelStore viewModelStore = mViewModelStores.get(backStackEntryUUID);
    if (viewModelStore != null) {
        viewModelStore.clear();
        mViewModelStores.remove(backStackEntryUUID);
    }
}
#method_after
@Override
protected void onCleared() {
    for (UUID key : mViewModelStores.keySet()) {
        clear(key);
    }
}
#end_block

#method_before
@NonNull
ViewModelStore getViewModelStore(@NonNull String backStackEntryUUID) {
    ViewModelStore viewModelStore = mViewModelStores.get(backStackEntryUUID);
    if (viewModelStore == null) {
        viewModelStore = new ViewModelStore();
        mViewModelStores.put(backStackEntryUUID, viewModelStore);
    }
    return viewModelStore;
}
#method_after
@NonNull
ViewModelStore getViewModelStore(@NonNull UUID backStackEntryUUID) {
    ViewModelStore viewModelStore = mViewModelStores.get(backStackEntryUUID);
    if (viewModelStore == null) {
        viewModelStore = new ViewModelStore();
        mViewModelStores.put(backStackEntryUUID, viewModelStore);
    }
    return viewModelStore;
}
#end_block

#method_before
@NonNull
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("NavControllerViewModel{");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("} ViewModelStores (");
    Iterator<String> viewModelStoreIterator = mViewModelStores.keySet().iterator();
    while (viewModelStoreIterator.hasNext()) {
        sb.append(viewModelStoreIterator.next());
        if (viewModelStoreIterator.hasNext()) {
            sb.append(", ");
        }
    }
    sb.append(')');
    return sb.toString();
}
#method_after
@NonNull
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("NavControllerViewModel{");
    sb.append(Integer.toHexString(System.identityHashCode(this)));
    sb.append("} ViewModelStores (");
    Iterator<UUID> viewModelStoreIterator = mViewModelStores.keySet().iterator();
    while (viewModelStoreIterator.hasNext()) {
        sb.append(viewModelStoreIterator.next());
        if (viewModelStoreIterator.hasNext()) {
            sb.append(", ");
        }
    }
    sb.append(')');
    return sb.toString();
}
#end_block

#method_before
@CallSuper
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final Context context = requireContext();
    mNavController = new NavController(context);
    mNavController.getNavigatorProvider().addNavigator(createFragmentNavigator());
    mNavController.setViewModelStore(getViewModelStore());
    Bundle navState = null;
    if (savedInstanceState != null) {
        navState = savedInstanceState.getBundle(KEY_NAV_CONTROLLER_STATE);
        if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) {
            mDefaultNavHost = true;
            requireFragmentManager().beginTransaction().setPrimaryNavigationFragment(this).commit();
        }
    }
    if (navState != null) {
        // Navigation controller state overrides arguments
        mNavController.restoreState(navState);
    }
    if (mGraphId != 0) {
        // Set from onInflate()
        mNavController.setGraph(mGraphId);
    } else {
        // See if it was set by NavHostFragment.create()
        final Bundle args = getArguments();
        final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0;
        final Bundle startDestinationArgs = args != null ? args.getBundle(KEY_START_DESTINATION_ARGS) : null;
        if (graphId != 0) {
            mNavController.setGraph(graphId, startDestinationArgs);
        }
    }
}
#method_after
@CallSuper
@Override
public void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    final Context context = requireContext();
    mNavController = new NavController(context);
    mNavController.setViewModelStore(getViewModelStore());
    mNavController.getNavigatorProvider().addNavigator(createFragmentNavigator());
    Bundle navState = null;
    if (savedInstanceState != null) {
        navState = savedInstanceState.getBundle(KEY_NAV_CONTROLLER_STATE);
        if (savedInstanceState.getBoolean(KEY_DEFAULT_NAV_HOST, false)) {
            mDefaultNavHost = true;
            requireFragmentManager().beginTransaction().setPrimaryNavigationFragment(this).commit();
        }
    }
    if (navState != null) {
        // Navigation controller state overrides arguments
        mNavController.restoreState(navState);
    }
    if (mGraphId != 0) {
        // Set from onInflate()
        mNavController.setGraph(mGraphId);
    } else {
        // See if it was set by NavHostFragment.create()
        final Bundle args = getArguments();
        final int graphId = args != null ? args.getInt(KEY_GRAPH_ID) : 0;
        final Bundle startDestinationArgs = args != null ? args.getBundle(KEY_START_DESTINATION_ARGS) : null;
        if (graphId != 0) {
            mNavController.setGraph(graphId, startDestinationArgs);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
/* synthetic access */
boolean popBackStackInternal(@IdRes int destinationId, boolean inclusive) {
    if (mBackStack.isEmpty()) {
        // Nothing to pop if the back stack is empty
        return false;
    }
    ArrayList<Navigator> popOperations = new ArrayList<>();
    Iterator<NavBackStackEntry> iterator = mBackStack.descendingIterator();
    boolean foundDestination = false;
    while (iterator.hasNext()) {
        NavDestination destination = iterator.next().getDestination();
        Navigator navigator = mNavigatorProvider.getNavigator(destination.getNavigatorName());
        if (inclusive || destination.getId() != destinationId) {
            popOperations.add(navigator);
        }
        if (destination.getId() == destinationId) {
            foundDestination = true;
            break;
        }
    }
    if (!foundDestination) {
        // We were passed a destinationId that doesn't exist on our back stack.
        // Better to ignore the popBackStack than accidentally popping the entire stack
        String destinationName = NavDestination.getDisplayName(mContext, destinationId);
        Log.i(TAG, "Ignoring popBackStack to destination " + destinationName + " as it was not found on the current back stack");
        return false;
    }
    boolean popped = false;
    for (Navigator navigator : popOperations) {
        if (navigator.popBackStack()) {
            NavBackStackEntry entry = mBackStack.removeLast();
            if (mViewModel != null && entry != null) {
                mViewModel.onCleared(entry.mWho);
            }
            popped = true;
        } else {
            // The pop did not complete successfully, so stop immediately
            break;
        }
    }
    return popped;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
boolean popBackStackInternal(@IdRes int destinationId, boolean inclusive) {
    if (mBackStack.isEmpty()) {
        // Nothing to pop if the back stack is empty
        return false;
    }
    ArrayList<Navigator> popOperations = new ArrayList<>();
    Iterator<NavBackStackEntry> iterator = mBackStack.descendingIterator();
    boolean foundDestination = false;
    while (iterator.hasNext()) {
        NavDestination destination = iterator.next().getDestination();
        Navigator navigator = mNavigatorProvider.getNavigator(destination.getNavigatorName());
        if (inclusive || destination.getId() != destinationId) {
            popOperations.add(navigator);
        }
        if (destination.getId() == destinationId) {
            foundDestination = true;
            break;
        }
    }
    if (!foundDestination) {
        // We were passed a destinationId that doesn't exist on our back stack.
        // Better to ignore the popBackStack than accidentally popping the entire stack
        String destinationName = NavDestination.getDisplayName(mContext, destinationId);
        Log.i(TAG, "Ignoring popBackStack to destination " + destinationName + " as it was not found on the current back stack");
        return false;
    }
    boolean popped = false;
    for (Navigator navigator : popOperations) {
        if (navigator.popBackStack()) {
            NavBackStackEntry entry = mBackStack.removeLast();
            if (mViewModel != null) {
                mViewModel.clear(entry.mId);
            }
            popped = true;
        } else {
            // The pop did not complete successfully, so stop immediately
            break;
        }
    }
    return popped;
}
#end_block

#method_before
@NonNull
public ViewModelStore getViewModelStore(@IdRes int navGraphId) {
    NavBackStackEntry lastFromBackStack = null;
    Iterator<NavBackStackEntry> iterator = mBackStack.descendingIterator();
    while (iterator.hasNext()) {
        NavBackStackEntry entry = iterator.next();
        NavDestination destination = entry.getDestination();
        if (destination instanceof NavGraph && destination.getId() == navGraphId) {
            lastFromBackStack = entry;
            break;
        }
    }
    if (lastFromBackStack == null) {
        throw new IllegalArgumentException("No NavGraph with Id " + navGraphId + " is on the " + "NavController back stack");
    }
    return mViewModel.getViewModelStore(lastFromBackStack.mWho);
}
#method_after
@NonNull
public ViewModelStore getViewModelStore(@IdRes int navGraphId) {
    if (mViewModel == null) {
        throw new IllegalStateException("You must call setViewModelStore() before calling " + "getViewModelStore().");
    }
    NavBackStackEntry lastFromBackStack = null;
    Iterator<NavBackStackEntry> iterator = mBackStack.descendingIterator();
    while (iterator.hasNext()) {
        NavBackStackEntry entry = iterator.next();
        NavDestination destination = entry.getDestination();
        if (destination instanceof NavGraph && destination.getId() == navGraphId) {
            lastFromBackStack = entry;
            break;
        }
    }
    if (lastFromBackStack == null) {
        throw new IllegalArgumentException("No NavGraph with ID " + navGraphId + " is on the " + "NavController's back stack");
    }
    return mViewModel.getViewModelStore(lastFromBackStack.mId);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.enhanced_call_blocking_settings);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_UNREGISTERED);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_PRIVATE);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_PAYPHONE);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_UNKNOWN);
    if (!showPayPhoneBlocking()) {
        Preference payPhoneOption = getPreferenceScreen().findPreference(BLOCK_PAY_PHONE_CALL_SETTING);
        getPreferenceScreen().removePreference(payPhoneOption);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.enhanced_call_blocking_settings);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_UNREGISTERED);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_PRIVATE);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_PAYPHONE);
    setOnPreferenceChangeListener(SystemContract.ENHANCED_SETTING_KEY_BLOCK_UNKNOWN);
    if (!showPayPhoneBlocking()) {
        Preference payPhoneOption = getPreferenceScreen().findPreference(SystemContract.ENHANCED_SETTING_KEY_BLOCK_PAYPHONE);
        getPreferenceScreen().removePreference(payPhoneOption);
    }
}
#end_block

#method_before
private boolean showPayPhoneBlocking() {
    CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        return false;
    }
    int subId = SubscriptionManager.getDefaultSubscriptionId();
    PersistableBundle b = configManager.getConfigForSubId(subId);
    if (b == null) {
        return false;
    }
    return b.getBoolean(CarrierConfigManager.KEY_SHOW_BLOCKING_PAY_PHONE_OPTION_BOOL);
}
#method_after
private boolean showPayPhoneBlocking() {
    CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager == null) {
        return false;
    }
    int subId = SubscriptionManager.getDefaultVoiceSubscriptionId();
    PersistableBundle b = configManager.getConfigForSubId(subId);
    if (b == null) {
        return false;
    }
    return b.getBoolean(CarrierConfigManager.KEY_SHOW_BLOCKING_PAY_PHONE_OPTION_BOOL);
}
#end_block

#method_before
public boolean getTetherApnRequired() {
    return getTetherApnRequired(SubscriptionManager.getDefaultDataSubscriptionId());
}
#method_after
public boolean getTetherApnRequired() {
    return getTetherApnRequired(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
}
#end_block

#method_before
public void configureTlsExtensions(SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
    // All extensions here use both public API and reflective calls, see note above.
    SSLParameters sslParams = sslSocket.getSSLParameters();
    if (hostname != null) {
        // Enable session tickets
        if (SSLSockets.isSupportedSocket(sslSocket)) {
            SSLSockets.setUseSessionTickets(sslSocket, true);
        } else {
            SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
        }
        try {
            // Enable SNI
            sslParams.setServerNames(Collections.<SNIServerName>singletonList(new SNIHostName(hostname)));
        } catch (IllegalArgumentException ignored) {
        // The hostname isn't a valid SNI value, that's fine
        }
        if (!isPlatformSocket(sslSocket)) {
            SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
        }
    }
    // Enable ALPN, if necessary
    sslParams.setApplicationProtocols(getProtocolIds(protocols));
    if (!isPlatformSocket(sslSocket) && SET_ALPN_PROTOCOLS.isSupported(sslSocket)) {
        Object[] parameters = { concatLengthPrefixed(protocols) };
        SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
    }
    sslSocket.setSSLParameters(sslParams);
}
#method_after
public void configureTlsExtensions(SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
    // All extensions here use both public API and reflective calls, see note above.
    SSLParameters sslParams = sslSocket.getSSLParameters();
    if (hostname != null) {
        // Enable session tickets
        if (SSLSockets.isSupportedSocket(sslSocket)) {
            SSLSockets.setUseSessionTickets(sslSocket, true);
        } else {
            SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
        }
        try {
            // Enable SNI
            sslParams.setServerNames(Collections.<SNIServerName>singletonList(new SNIHostName(hostname)));
        } catch (IllegalArgumentException ignored) {
        // The hostname isn't a valid SNI value, so ignore the exception and don't set
        // a server name, which results in no SNI extension being sent.
        }
        if (!isPlatformSocket(sslSocket)) {
            SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
        }
    }
    // Enable ALPN, if necessary
    sslParams.setApplicationProtocols(getProtocolIds(protocols));
    if (!isPlatformSocket(sslSocket) && SET_ALPN_PROTOCOLS.isSupported(sslSocket)) {
        Object[] parameters = { concatLengthPrefixed(protocols) };
        SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
    }
    sslSocket.setSSLParameters(sslParams);
}
#end_block

#method_before
public void configureTlsExtensions(SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
    // All extensions here use both public API and reflective calls, see note above.
    SSLParameters sslParams = sslSocket.getSSLParameters();
    if (hostname != null) {
        // Enable session tickets
        if (SSLSockets.isSupportedSocket(sslSocket)) {
            SSLSockets.setUseSessionTickets(sslSocket, true);
        } else {
            SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
        }
        try {
            // Enable SNI
            sslParams.setServerNames(Collections.<SNIServerName>singletonList(new SNIHostName(hostname)));
        } catch (IllegalArgumentException ignored) {
        // The hostname isn't a valid SNI value, that's fine
        }
        if (!isPlatformSocket(sslSocket)) {
            SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
        }
    }
    // Enable ALPN, if necessary
    sslParams.setApplicationProtocols(getProtocolIds(protocols));
    if (!isPlatformSocket(sslSocket) && SET_ALPN_PROTOCOLS.isSupported(sslSocket)) {
        Object[] parameters = { concatLengthPrefixed(protocols) };
        SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
    }
    sslSocket.setSSLParameters(sslParams);
}
#method_after
public void configureTlsExtensions(SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
    // All extensions here use both public API and reflective calls, see note above.
    SSLParameters sslParams = sslSocket.getSSLParameters();
    if (hostname != null) {
        // Enable session tickets
        if (SSLSockets.isSupportedSocket(sslSocket)) {
            SSLSockets.setUseSessionTickets(sslSocket, true);
        } else {
            SET_USE_SESSION_TICKETS.invokeOptionalWithoutCheckedException(sslSocket, true);
        }
        try {
            // Enable SNI
            sslParams.setServerNames(Collections.<SNIServerName>singletonList(new SNIHostName(hostname)));
        } catch (IllegalArgumentException ignored) {
        // The hostname isn't a valid SNI value, so ignore the exception and don't set
        // a server name, which results in no SNI extension being sent.
        }
        if (!isPlatformSocket(sslSocket)) {
            SET_HOSTNAME.invokeOptionalWithoutCheckedException(sslSocket, hostname);
        }
    }
    // Enable ALPN, if necessary
    sslParams.setApplicationProtocols(getProtocolIds(protocols));
    if (!isPlatformSocket(sslSocket) && SET_ALPN_PROTOCOLS.isSupported(sslSocket)) {
        Object[] parameters = { concatLengthPrefixed(protocols) };
        SET_ALPN_PROTOCOLS.invokeWithoutCheckedException(sslSocket, parameters);
    }
    sslSocket.setSSLParameters(sslParams);
}
#end_block

#method_before
@Override
void onParentSet() {
    super.onParentSet();
    if (getParent() != null) {
        mAppAnimationLayer = makeChildSurface(null).setName("animationLayer").build();
        mBoostedAppAnimationLayer = makeChildSurface(null).setName("boostedAnimationLayer").build();
        mHomeAppAnimationLayer = makeChildSurface(null).setName("homeAnimationLayer").build();
        mSplitScreenDividerAnchor = makeChildSurface(null).setName("splitScreenDividerAnchor").build();
        getPendingTransaction().show(mAppAnimationLayer).show(mBoostedAppAnimationLayer).show(mHomeAppAnimationLayer).show(mSplitScreenDividerAnchor);
        scheduleAnimation();
    } else {
        // BEGIN Motorola, huangjy, 2019-03-07, IKSWP-66292
        // For cts testStackFocusSwitchOnDisplayRemoved3
        // At this time mBoostedAppAnimationLayer may be used for animating,
        // and ResizeableActivity is in it. mBoostedAppAnimationLayer.destroy()
        // can also destroy the surface of ResizeableActivity, but the surface will
        // be used after. So change to use transaction to call destroy to delay it,
        // and ResizeableActivity is not in mBoostedAppAnimationLayer.
        getPendingTransaction().destroy(mAppAnimationLayer).destroy(mBoostedAppAnimationLayer).destroy(mHomeAppAnimationLayer).destroy(mSplitScreenDividerAnchor);
        // mAppAnimationLayer.destroy();
        mAppAnimationLayer = null;
        // mBoostedAppAnimationLayer.destroy();
        mBoostedAppAnimationLayer = null;
        // mHomeAppAnimationLayer.destroy();
        mHomeAppAnimationLayer = null;
        // mSplitScreenDividerAnchor.destroy();
        mSplitScreenDividerAnchor = null;
    // END Motorola, huangjy, 2019-03-07, IKSWP-66292
    }
}
#method_after
@Override
void onParentSet() {
    super.onParentSet();
    if (getParent() != null) {
        mAppAnimationLayer = makeChildSurface(null).setName("animationLayer").build();
        mBoostedAppAnimationLayer = makeChildSurface(null).setName("boostedAnimationLayer").build();
        mHomeAppAnimationLayer = makeChildSurface(null).setName("homeAnimationLayer").build();
        mSplitScreenDividerAnchor = makeChildSurface(null).setName("splitScreenDividerAnchor").build();
        getPendingTransaction().show(mAppAnimationLayer).show(mBoostedAppAnimationLayer).show(mHomeAppAnimationLayer).show(mSplitScreenDividerAnchor);
        scheduleAnimation();
    } else {
        // At this time mBoostedAppAnimationLayer may be used for animating,
        // and ResizeableActivity is in it. mBoostedAppAnimationLayer.destroy()
        // can also destroy the surface of ResizeableActivity, but the surface will
        // be used after. So change to use transaction to call destroy to delay it,
        // and ResizeableActivity is not in mBoostedAppAnimationLayer.
        getPendingTransaction().destroy(mAppAnimationLayer).destroy(mBoostedAppAnimationLayer).destroy(mHomeAppAnimationLayer).destroy(mSplitScreenDividerAnchor);
        mAppAnimationLayer = null;
        mBoostedAppAnimationLayer = null;
        mHomeAppAnimationLayer = null;
        mSplitScreenDividerAnchor = null;
    }
}
#end_block

#method_before
private static android.hardware.radio.V1_0.DataProfileInfo convertToHalDataProfile10(DataProfile dp) {
    android.hardware.radio.V1_0.DataProfileInfo dpi = new android.hardware.radio.V1_0.DataProfileInfo();
    dpi.profileId = dp.getProfileId();
    dpi.apn = dp.getApn();
    dpi.protocol = ApnSetting.getProtocolStringFromInt(dp.getProtocol());
    dpi.roamingProtocol = ApnSetting.getProtocolStringFromInt(dp.getRoamingProtocol());
    dpi.authType = dp.getAuthType();
    dpi.user = dp.getUserName();
    dpi.password = dp.getPassword();
    dpi.type = dp.getType();
    dpi.maxConnsTime = dp.getMaxConnsTime();
    dpi.maxConns = dp.getMaxConns();
    dpi.waitTime = dp.getWaitTime();
    dpi.enabled = dp.isEnabled();
    dpi.supportedApnTypesBitmap = dp.getSupportedApnTypesBitmap();
    // Shift by 1 bit due to the discrepancy between
    // android.hardware.radio.V1_0.RadioAccessFamily and the bitmask version of
    // ServiceState.RIL_RADIO_TECHNOLOGY_XXXX.
    dpi.bearerBitmap = ServiceState.convertNetworkTypeBitmaskToBearerBitmask(dp.getBearerBitmap()) << 1;
    dpi.mtu = dp.getMtu();
    dpi.mvnoType = MvnoType.NONE;
    dpi.mvnoMatchData = "";
    return dpi;
}
#method_after
private static android.hardware.radio.V1_0.DataProfileInfo convertToHalDataProfile10(DataProfile dp) {
    android.hardware.radio.V1_0.DataProfileInfo dpi = new android.hardware.radio.V1_0.DataProfileInfo();
    dpi.profileId = dp.getProfileId();
    dpi.apn = dp.getApn();
    dpi.protocol = ApnSetting.getProtocolStringFromInt(dp.getProtocolType());
    dpi.roamingProtocol = ApnSetting.getProtocolStringFromInt(dp.getRoamingProtocolType());
    dpi.authType = dp.getAuthType();
    dpi.user = dp.getUserName();
    dpi.password = dp.getPassword();
    dpi.type = dp.getType();
    dpi.maxConnsTime = dp.getMaxConnectionsTime();
    dpi.maxConns = dp.getMaxConnections();
    dpi.waitTime = dp.getWaitTime();
    dpi.enabled = dp.isEnabled();
    dpi.supportedApnTypesBitmap = dp.getSupportedApnTypesBitmask();
    // Shift by 1 bit due to the discrepancy between
    // android.hardware.radio.V1_0.RadioAccessFamily and the bitmask version of
    // ServiceState.RIL_RADIO_TECHNOLOGY_XXXX.
    dpi.bearerBitmap = ServiceState.convertNetworkTypeBitmaskToBearerBitmask(dp.getBearerBitmask()) << 1;
    dpi.mtu = dp.getMtu();
    dpi.mvnoType = MvnoType.NONE;
    dpi.mvnoMatchData = "";
    return dpi;
}
#end_block

#method_before
private static android.hardware.radio.V1_4.DataProfileInfo convertToHalDataProfile14(DataProfile dp) {
    android.hardware.radio.V1_4.DataProfileInfo dpi = new android.hardware.radio.V1_4.DataProfileInfo();
    dpi.apn = dp.getApn();
    dpi.protocol = dp.getProtocol();
    dpi.roamingProtocol = dp.getRoamingProtocol();
    dpi.authType = dp.getAuthType();
    dpi.user = dp.getUserName();
    dpi.password = dp.getPassword();
    dpi.type = dp.getType();
    dpi.maxConnsTime = dp.getMaxConnsTime();
    dpi.maxConns = dp.getMaxConns();
    dpi.waitTime = dp.getWaitTime();
    dpi.enabled = dp.isEnabled();
    dpi.supportedApnTypesBitmap = dp.getSupportedApnTypesBitmap();
    // Shift by 1 bit due to the discrepancy between
    // android.hardware.radio.V1_0.RadioAccessFamily and the bitmask version of
    // ServiceState.RIL_RADIO_TECHNOLOGY_XXXX.
    dpi.bearerBitmap = ServiceState.convertNetworkTypeBitmaskToBearerBitmask(dp.getBearerBitmap()) << 1;
    dpi.mtu = dp.getMtu();
    dpi.persistent = dp.isPersistent();
    dpi.preferred = dp.isPreferred();
    // profile id is only meaningful when it's persistent on the modem.
    dpi.profileId = (dpi.persistent) ? dp.getProfileId() : DataProfileId.INVALID;
    return dpi;
}
#method_after
private static android.hardware.radio.V1_4.DataProfileInfo convertToHalDataProfile14(DataProfile dp) {
    android.hardware.radio.V1_4.DataProfileInfo dpi = new android.hardware.radio.V1_4.DataProfileInfo();
    dpi.apn = dp.getApn();
    dpi.protocol = dp.getProtocolType();
    dpi.roamingProtocol = dp.getRoamingProtocolType();
    dpi.authType = dp.getAuthType();
    dpi.user = dp.getUserName();
    dpi.password = dp.getPassword();
    dpi.type = dp.getType();
    dpi.maxConnsTime = dp.getMaxConnectionsTime();
    dpi.maxConns = dp.getMaxConnections();
    dpi.waitTime = dp.getWaitTime();
    dpi.enabled = dp.isEnabled();
    dpi.supportedApnTypesBitmap = dp.getSupportedApnTypesBitmask();
    // Shift by 1 bit due to the discrepancy between
    // android.hardware.radio.V1_0.RadioAccessFamily and the bitmask version of
    // ServiceState.RIL_RADIO_TECHNOLOGY_XXXX.
    dpi.bearerBitmap = ServiceState.convertNetworkTypeBitmaskToBearerBitmask(dp.getBearerBitmask()) << 1;
    dpi.mtu = dp.getMtu();
    dpi.persistent = dp.isPersistent();
    dpi.preferred = dp.isPreferred();
    // profile id is only meaningful when it's persistent on the modem.
    dpi.profileId = (dpi.persistent) ? dp.getProfileId() : DataProfileId.INVALID;
    return dpi;
}
#end_block

#method_before
@UnsupportedAppUsage
static String retToString(int req, Object ret) {
    if (ret == null)
        return "";
    switch(req) {
        // Don't log these return values, for privacy's sake.
        case RIL_REQUEST_GET_IMSI:
        case RIL_REQUEST_GET_IMEI:
        case RIL_REQUEST_GET_IMEISV:
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            if (!RILJ_LOGV) {
                // If not versbose logging just return and don't display IMSI and IMEI, IMEISV
                return "";
            }
    }
    StringBuilder sb;
    String s;
    int length;
    if (req == RIL_REQUEST_DEVICE_IDENTITY && ret instanceof String[]) {
        String[] identities = (String[]) ret;
        length = identities.length;
        sb = new StringBuilder("{");
        if (length > 0) {
            int i = 0;
            // position 0 is IMEI
            sb.append(Rlog.pii(RILJ_LOG_TAG, identities[i++]));
            while (i < length) {
                sb.append(", ").append(identities[i++]);
            }
        }
        sb.append("}");
        s = sb.toString();
    } else if (ret instanceof int[]) {
        int[] intArray = (int[]) ret;
        length = intArray.length;
        sb = new StringBuilder("{");
        if (length > 0) {
            int i = 0;
            sb.append(intArray[i++]);
            while (i < length) {
                sb.append(", ").append(intArray[i++]);
            }
        }
        sb.append("}");
        s = sb.toString();
    } else if (ret instanceof String[]) {
        String[] strings = (String[]) ret;
        length = strings.length;
        sb = new StringBuilder("{");
        if (length > 0) {
            int i = 0;
            sb.append(strings[i++]);
            while (i < length) {
                sb.append(", ").append(strings[i++]);
            }
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_GET_CURRENT_CALLS) {
        ArrayList<DriverCall> calls = (ArrayList<DriverCall>) ret;
        sb = new StringBuilder("{");
        for (DriverCall dc : calls) {
            sb.append("[").append(dc).append("] ");
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_GET_NEIGHBORING_CELL_IDS) {
        ArrayList<NeighboringCellInfo> cells = (ArrayList<NeighboringCellInfo>) ret;
        sb = new StringBuilder("{");
        for (NeighboringCellInfo cell : cells) {
            sb.append("[").append(cell).append("] ");
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_QUERY_CALL_FORWARD_STATUS) {
        CallForwardInfo[] cinfo = (CallForwardInfo[]) ret;
        length = cinfo.length;
        sb = new StringBuilder("{");
        for (int i = 0; i < length; i++) {
            sb.append("[").append(cinfo[i]).append("] ");
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_GET_HARDWARE_CONFIG) {
        ArrayList<HardwareConfig> hwcfgs = (ArrayList<HardwareConfig>) ret;
        sb = new StringBuilder(" ");
        for (HardwareConfig hwcfg : hwcfgs) {
            sb.append("[").append(hwcfg).append("] ");
        }
        s = sb.toString();
    } else {
        s = ret.toString();
    }
    return s;
}
#method_after
@UnsupportedAppUsage
static String retToString(int req, Object ret) {
    if (ret == null)
        return "";
    switch(req) {
        // Don't log these return values, for privacy's sake.
        case RIL_REQUEST_GET_IMSI:
        case RIL_REQUEST_GET_IMEI:
        case RIL_REQUEST_GET_IMEISV:
        case RIL_REQUEST_SIM_OPEN_CHANNEL:
        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL:
            if (!RILJ_LOGV) {
                // If not versbose logging just return and don't display IMSI and IMEI, IMEISV
                return "";
            }
    }
    StringBuilder sb;
    String s;
    int length;
    if (ret instanceof int[]) {
        int[] intArray = (int[]) ret;
        length = intArray.length;
        sb = new StringBuilder("{");
        if (length > 0) {
            int i = 0;
            sb.append(intArray[i++]);
            while (i < length) {
                sb.append(", ").append(intArray[i++]);
            }
        }
        sb.append("}");
        s = sb.toString();
    } else if (ret instanceof String[]) {
        String[] strings = (String[]) ret;
        length = strings.length;
        sb = new StringBuilder("{");
        if (length > 0) {
            int i = 0;
            // position 0 is IMEI in RIL_REQUEST_DEVICE_IDENTITY
            if (req == RIL_REQUEST_DEVICE_IDENTITY) {
                sb.append(Rlog.pii(RILJ_LOG_TAG, strings[i++]));
            } else {
                sb.append(strings[i++]);
            }
            while (i < length) {
                sb.append(", ").append(strings[i++]);
            }
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_GET_CURRENT_CALLS) {
        ArrayList<DriverCall> calls = (ArrayList<DriverCall>) ret;
        sb = new StringBuilder("{");
        for (DriverCall dc : calls) {
            sb.append("[").append(dc).append("] ");
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_GET_NEIGHBORING_CELL_IDS) {
        ArrayList<NeighboringCellInfo> cells = (ArrayList<NeighboringCellInfo>) ret;
        sb = new StringBuilder("{");
        for (NeighboringCellInfo cell : cells) {
            sb.append("[").append(cell).append("] ");
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_QUERY_CALL_FORWARD_STATUS) {
        CallForwardInfo[] cinfo = (CallForwardInfo[]) ret;
        length = cinfo.length;
        sb = new StringBuilder("{");
        for (int i = 0; i < length; i++) {
            sb.append("[").append(cinfo[i]).append("] ");
        }
        sb.append("}");
        s = sb.toString();
    } else if (req == RIL_REQUEST_GET_HARDWARE_CONFIG) {
        ArrayList<HardwareConfig> hwcfgs = (ArrayList<HardwareConfig>) ret;
        sb = new StringBuilder(" ");
        for (HardwareConfig hwcfg : hwcfgs) {
            sb.append("[").append(hwcfg).append("] ");
        }
        s = sb.toString();
    } else {
        s = ret.toString();
    }
    return s;
}
#end_block

#method_before
@VisibleForTesting
public static DataCallResponse convertDataCallResult(Object dcResult) {
    if (dcResult == null)
        return null;
    int status, suggestedRetryTime, cid, active, mtu;
    String ifname;
    int protocolType;
    String[] addresses = null;
    String[] dnses = null;
    String[] gateways = null;
    List<String> pcscfs;
    if (dcResult instanceof android.hardware.radio.V1_0.SetupDataCallResult) {
        final android.hardware.radio.V1_0.SetupDataCallResult result = (android.hardware.radio.V1_0.SetupDataCallResult) dcResult;
        status = result.status;
        suggestedRetryTime = result.suggestedRetryTime;
        cid = result.cid;
        active = result.active;
        protocolType = ApnSetting.getProtocolIntFromString(result.type);
        ifname = result.ifname;
        if (!TextUtils.isEmpty(result.addresses)) {
            addresses = result.addresses.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.dnses)) {
            dnses = result.dnses.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.gateways)) {
            gateways = result.gateways.split("\\s+");
        }
        pcscfs = new ArrayList<>(Arrays.asList(result.pcscf.trim().split("\\s+")));
        mtu = result.mtu;
    } else if (dcResult instanceof android.hardware.radio.V1_4.SetupDataCallResult) {
        final android.hardware.radio.V1_4.SetupDataCallResult result = (android.hardware.radio.V1_4.SetupDataCallResult) dcResult;
        status = result.cause;
        suggestedRetryTime = result.suggestedRetryTime;
        cid = result.cid;
        active = result.active;
        protocolType = result.type;
        ifname = result.ifname;
        addresses = result.addresses.stream().toArray(String[]::new);
        dnses = result.dnses.stream().toArray(String[]::new);
        gateways = result.gateways.stream().toArray(String[]::new);
        pcscfs = result.pcscf;
        mtu = result.mtu;
    } else {
        Rlog.e(RILJ_LOG_TAG, "Unsupported SetupDataCallResult " + dcResult);
        return null;
    }
    // Process address
    List<LinkAddress> laList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            try {
                LinkAddress la;
                // can parse that.
                if (address.split("/").length == 2) {
                    la = new LinkAddress(address);
                } else {
                    InetAddress ia = NetworkUtils.numericToInetAddress(address);
                    la = new LinkAddress(ia, (ia instanceof Inet4Address) ? 32 : 128);
                }
                laList.add(la);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown address: " + address, e);
            }
        }
    }
    // Process dns
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns, e);
            }
        }
    }
    // Process gateway
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway, e);
            }
        }
    }
    return new DataCallResponse(status, suggestedRetryTime, cid, active, protocolType, ifname, laList, dnsList, gatewayList, pcscfs, mtu);
}
#method_after
@VisibleForTesting
public static DataCallResponse convertDataCallResult(Object dcResult) {
    if (dcResult == null)
        return null;
    int cause, suggestedRetryTime, cid, active, mtu;
    String ifname;
    int protocolType;
    String[] addresses = null;
    String[] dnses = null;
    String[] gateways = null;
    String[] pcscfs = null;
    if (dcResult instanceof android.hardware.radio.V1_0.SetupDataCallResult) {
        final android.hardware.radio.V1_0.SetupDataCallResult result = (android.hardware.radio.V1_0.SetupDataCallResult) dcResult;
        cause = result.status;
        suggestedRetryTime = result.suggestedRetryTime;
        cid = result.cid;
        active = result.active;
        protocolType = ApnSetting.getProtocolIntFromString(result.type);
        ifname = result.ifname;
        if (!TextUtils.isEmpty(result.addresses)) {
            addresses = result.addresses.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.dnses)) {
            dnses = result.dnses.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.gateways)) {
            gateways = result.gateways.split("\\s+");
        }
        if (!TextUtils.isEmpty(result.pcscf)) {
            pcscfs = result.pcscf.split("\\s+");
        }
        mtu = result.mtu;
    } else if (dcResult instanceof android.hardware.radio.V1_4.SetupDataCallResult) {
        final android.hardware.radio.V1_4.SetupDataCallResult result = (android.hardware.radio.V1_4.SetupDataCallResult) dcResult;
        cause = result.cause;
        suggestedRetryTime = result.suggestedRetryTime;
        cid = result.cid;
        active = result.active;
        protocolType = result.type;
        ifname = result.ifname;
        addresses = result.addresses.stream().toArray(String[]::new);
        dnses = result.dnses.stream().toArray(String[]::new);
        gateways = result.gateways.stream().toArray(String[]::new);
        pcscfs = result.pcscf.stream().toArray(String[]::new);
        mtu = result.mtu;
    } else {
        Rlog.e(RILJ_LOG_TAG, "Unsupported SetupDataCallResult " + dcResult);
        return null;
    }
    // Process address
    List<LinkAddress> laList = new ArrayList<>();
    if (addresses != null) {
        for (String address : addresses) {
            address = address.trim();
            if (address.isEmpty())
                continue;
            try {
                LinkAddress la;
                // can parse that.
                if (address.split("/").length == 2) {
                    la = new LinkAddress(address);
                } else {
                    InetAddress ia = NetworkUtils.numericToInetAddress(address);
                    la = new LinkAddress(ia, (ia instanceof Inet4Address) ? 32 : 128);
                }
                laList.add(la);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown address: " + address, e);
            }
        }
    }
    // Process dns
    List<InetAddress> dnsList = new ArrayList<>();
    if (dnses != null) {
        for (String dns : dnses) {
            dns = dns.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(dns);
                dnsList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown dns: " + dns, e);
            }
        }
    }
    // Process gateway
    List<InetAddress> gatewayList = new ArrayList<>();
    if (gateways != null) {
        for (String gateway : gateways) {
            gateway = gateway.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(gateway);
                gatewayList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown gateway: " + gateway, e);
            }
        }
    }
    // Process gateway
    List<InetAddress> pcscfList = new ArrayList<>();
    if (pcscfs != null) {
        for (String pcscf : pcscfs) {
            pcscf = pcscf.trim();
            InetAddress ia;
            try {
                ia = NetworkUtils.numericToInetAddress(pcscf);
                pcscfList.add(ia);
            } catch (IllegalArgumentException e) {
                Rlog.e(RILJ_LOG_TAG, "Unknown pcscf: " + pcscf, e);
            }
        }
    }
    return new DataCallResponse(cause, suggestedRetryTime, cid, active, protocolType, ifname, laList, dnsList, gatewayList, pcscfList, mtu);
}
#end_block

#method_before
@Test
@LargeTest
@RepeatRule.Repeat(times = 1)
public void testDelayMet_withUnMetConstraintShouldNotCrashOnDestroy() throws InterruptedException {
    when(mBatteryChargingTracker.getInitialState()).thenReturn(false);
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(TestWorker.class).setPeriodStartTime(System.currentTimeMillis(), TimeUnit.MILLISECONDS).setConstraints(new Constraints.Builder().setRequiresCharging(true).build()).build();
    insertWork(work);
    Intent delayMet = CommandHandler.createDelayMetIntent(mContext, work.getStringId());
    mSpyDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(mSpyDispatcher, delayMet, START_ID));
    mLatch.await(TEST_TIMEOUT, TimeUnit.SECONDS);
    List<String> intentActions = mSpyDispatcher.getIntentActions();
    WorkSpecDao workSpecDao = mDatabase.workSpecDao();
    WorkSpec workSpec = workSpecDao.getWorkSpec(work.getStringId());
    assertThat(mLatch.getCount(), is(0L));
    // Verify order of events
    assertThat(intentActions, IsIterableContainingInOrder.contains(CommandHandler.ACTION_DELAY_MET, CommandHandler.ACTION_STOP_WORK, CommandHandler.ACTION_EXECUTION_COMPLETED, CommandHandler.ACTION_CONSTRAINTS_CHANGED));
    assertThat(workSpec.state, is(WorkInfo.State.ENQUEUED));
    // Should not crash after we destroy the dispatcher
    mDispatcher.onDestroy();
    mBatteryChargingTracker.setState(true);
}
#method_after
@Test
@LargeTest
@RepeatRule.Repeat(times = 1)
public void testDelayMet_withUnMetConstraintShouldNotCrashOnDestroy() throws InterruptedException {
    when(mBatteryChargingTracker.getInitialState()).thenReturn(false);
    OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(TestWorker.class).setPeriodStartTime(System.currentTimeMillis(), TimeUnit.MILLISECONDS).setConstraints(new Constraints.Builder().setRequiresCharging(true).build()).build();
    insertWork(work);
    Intent delayMet = CommandHandler.createDelayMetIntent(mContext, work.getStringId());
    mSpyDispatcher.postOnMainThread(new SystemAlarmDispatcher.AddRunnable(mSpyDispatcher, delayMet, START_ID));
    mLatch.await(TEST_TIMEOUT, TimeUnit.SECONDS);
    assertThat(mLatch.getCount(), is(0L));
    // Should not crash after we destroy the dispatcher
    mDispatcher.onDestroy();
    mBatteryChargingTracker.setState(true);
}
#end_block

#method_before
public void setPrimaryActionIcon(@DrawableRes int iconResId) {
    setPrimaryActionIcon(Icon.createWithResource(getContext(), iconResId));
}
#method_after
public void setPrimaryActionIcon(@DrawableRes int iconResId) {
    setPrimaryActionIcon(getContext().getDrawable(iconResId));
}
#end_block

#method_before
public void setSupplementalIcon(@DrawableRes int iconResId, boolean showSupplementalIconDivider) {
    setSupplementalIcon(Icon.createWithResource(getContext(), iconResId), showSupplementalIconDivider);
}
#method_after
public void setSupplementalIcon(@DrawableRes int iconResId, boolean showSupplementalIconDivider) {
    setSupplementalIcon(getContext().getDrawable(iconResId), showSupplementalIconDivider);
}
#end_block

#method_before
@Test
public void testSetPrimaryActionIcon_SmallIconTextOffset() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon), RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_SMALL);
    item.setText("text");
    setupPagedListView(Arrays.asList(item));
    int expected = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_3);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(expected)));
}
#method_after
@Test
public void testSetPrimaryActionIcon_SmallIconTextOffset() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(android.R.drawable.sym_def_app_icon, RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_SMALL);
    item.setText("text");
    setupPagedListView(Arrays.asList(item));
    int expected = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_3);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(expected)));
}
#end_block

#method_before
@Test
public void testSetPrimaryActionIcon_MediumIconTextOffset() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon), RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_MEDIUM);
    item.setText("text");
    setupPagedListView(Arrays.asList(item));
    int expected = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_3);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(expected)));
}
#method_after
@Test
public void testSetPrimaryActionIcon_MediumIconTextOffset() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(android.R.drawable.sym_def_app_icon, RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_MEDIUM);
    item.setText("text");
    setupPagedListView(Arrays.asList(item));
    int expected = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_3);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(expected)));
}
#end_block

#method_before
@Test
public void testSetPrimaryActionIcon_LargeIconTextOffset() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon), RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_LARGE);
    item.setText("text");
    setupPagedListView(Arrays.asList(item));
    int expected = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_4);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(expected)));
}
#method_after
@Test
public void testSetPrimaryActionIcon_LargeIconTextOffset() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(android.R.drawable.sym_def_app_icon, RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_LARGE);
    item.setText("text");
    setupPagedListView(Arrays.asList(item));
    int expected = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_4);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(expected)));
}
#end_block

#method_before
@Test
public void testSetTextStartMargin_MarginPlusOffsetByIcon() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(Icon.createWithResource(mActivity, android.R.drawable.sym_def_app_icon), RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_SMALL);
    item.setText("text");
    item.setTextStartMargin(R.dimen.car_keyline_1);
    setupPagedListView(Arrays.asList(item));
    int margin = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_1);
    // Offset is determined by icon size - small icon uses keyline 3.
    int offset = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_3);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(offset + margin)));
}
#method_after
@Test
public void testSetTextStartMargin_MarginPlusOffsetByIcon() {
    RadioButtonListItem item = new RadioButtonListItem(mActivity);
    item.setPrimaryActionIcon(android.R.drawable.sym_def_app_icon, RadioButtonListItem.PRIMARY_ACTION_ICON_SIZE_SMALL);
    item.setText("text");
    item.setTextStartMargin(R.dimen.car_keyline_1);
    setupPagedListView(Arrays.asList(item));
    int margin = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_1);
    // Offset is determined by icon size - small icon uses keyline 3.
    int offset = ApplicationProvider.getApplicationContext().getResources().getDimensionPixelSize(R.dimen.car_keyline_3);
    assertThat(getViewHolderAtPosition(0).getText().getLeft(), is(equalTo(offset + margin)));
}
#end_block

#method_before
public void setPrimaryActionIcon(@DrawableRes int iconResId, @PrimaryActionIconSize int size) {
    setPrimaryActionIcon(Icon.createWithResource(getContext(), iconResId), size);
}
#method_after
public void setPrimaryActionIcon(@DrawableRes int iconResId, @PrimaryActionIconSize int size) {
    setPrimaryActionIcon(getContext().getDrawable(iconResId), size);
}
#end_block

#method_before
public void setPrimaryActionIcon(@Nullable Drawable drawable, @PrimaryActionIconSize int size) {
    mPrimaryActionType = PRIMARY_ACTION_TYPE_ICON;
    mPrimaryActionIconDrawable = drawable;
    mPrimaryActionIconSize = size;
    markDirty();
}
#method_after
public void setPrimaryActionIcon(@NonNull Drawable drawable, @PrimaryActionIconSize int size) {
    mPrimaryActionType = PRIMARY_ACTION_TYPE_ICON;
    mPrimaryActionIconDrawable = drawable;
    mPrimaryActionIconSize = size;
    markDirty();
}
#end_block

#method_before
public void setSupplementalIcon(int iconResId, boolean showDivider) {
    setSupplementalIcon(Icon.createWithResource(getContext(), iconResId), showDivider);
}
#method_after
public void setSupplementalIcon(@DrawableRes int iconResId, boolean showDivider) {
    setSupplementalIcon(getContext().getDrawable(iconResId), showDivider);
}
#end_block

#method_before
public void setSupplementalIcon(Drawable drawable, boolean showDivider) {
    setSupplementalIcon(drawable, showDivider, null);
}
#method_after
public void setSupplementalIcon(@NonNull Drawable drawable, boolean showDivider) {
    setSupplementalIcon(drawable, showDivider, null);
}
#end_block

#method_before
public void setSupplementalIcon(int iconResId, boolean showDivider, View.OnClickListener listener) {
    setSupplementalIcon(Icon.createWithResource(getContext(), iconResId), showDivider);
    setSupplementalIconOnClickListener(listener);
}
#method_after
public void setSupplementalIcon(@DrawableRes int iconResId, boolean showDivider, View.OnClickListener listener) {
    setSupplementalIcon(getContext().getDrawable(iconResId), showDivider);
    setSupplementalIconOnClickListener(listener);
}
#end_block

#method_before
@TestApi
public void setVoiceRoaming(boolean roaming) {
    setVoiceRoamingType(roaming ? ROAMING_TYPE_UNKNOWN : ROAMING_TYPE_NOT_ROAMING);
}
#method_after
@UnsupportedAppUsage
public void setVoiceRoaming(boolean roaming) {
    setVoiceRoamingType(roaming ? ROAMING_TYPE_UNKNOWN : ROAMING_TYPE_NOT_ROAMING);
}
#end_block

#method_before
@TestApi
public void setDataRoaming(boolean dataRoaming) {
    setDataRoamingType(dataRoaming ? ROAMING_TYPE_UNKNOWN : ROAMING_TYPE_NOT_ROAMING);
}
#method_after
@UnsupportedAppUsage
public void setDataRoaming(boolean dataRoaming) {
    setDataRoamingType(dataRoaming ? ROAMING_TYPE_UNKNOWN : ROAMING_TYPE_NOT_ROAMING);
}
#end_block

#method_before
private boolean isExternalStorageWritable() {
    String state = Environment.getExternalStorageState();
    if (Environment.MEDIA_MOUNTED.equals(state)) {
        return true;
    }
    return false;
}
#method_after
private boolean isExternalStorageWritable() {
    String state = Environment.getExternalStorageState();
    return Environment.MEDIA_MOUNTED.equals(state);
}
#end_block

#method_before
public void logToFile(String fileName) {
    if (isExternalStorageWritable() == false) {
        Log.w(TAG, "External storage unavailable, skipping log to file for: " + fileName);
        return;
    }
    try {
        File statsDirectory = SensorCtsHelper.getSensorTestDataDirectory("stats/");
        File logFile = new File(statsDirectory, fileName);
        final Map<String, Object> flattened = flatten();
        FileWriter fileWriter = new FileWriter(logFile, false);
        try (BufferedWriter writer = new BufferedWriter(fileWriter)) {
            for (String key : getSortedKeys(flattened)) {
                Object value = flattened.get(key);
                writer.write(String.format("%s: %s\n", key, getValueString(value)));
            }
        }
    } catch (IOException e) {
        Log.w(TAG, "Unable to write file(" + fileName + ") to external storage with exception: " + e.toString());
        return;
    }
}
#method_after
public void logToFile(String fileName) {
    if (!isExternalStorageWritable()) {
        Log.w(TAG, "External storage unavailable, skipping log to file: " + fileName);
        return;
    }
    try {
        File statsDirectory = SensorCtsHelper.getSensorTestDataDirectory("stats/");
        File logFile = new File(statsDirectory, fileName);
        final Map<String, Object> flattened = flatten();
        FileWriter fileWriter = new FileWriter(logFile, false);
        try (BufferedWriter writer = new BufferedWriter(fileWriter)) {
            for (String key : getSortedKeys(flattened)) {
                Object value = flattened.get(key);
                writer.write(String.format("%s: %s\n", key, getValueString(value)));
            }
        }
    } catch (IOException e) {
        Log.w(TAG, "Unable to write to file: " + fileName, e);
    }
}
#end_block

#method_before
private void setInitialAttachApn() {
    ApnSetting iaApnSetting = null;
    ApnSetting defaultApnSetting = null;
    ApnSetting firstNonEmergencyApnSetting = null;
    log("setInitialApn: E mPreferredApn=" + mPreferredApn);
    if (mPreferredApn != null && mPreferredApn.canHandleType(ApnSetting.TYPE_IA)) {
        iaApnSetting = mPreferredApn;
    } else if (!mAllApnSettings.isEmpty()) {
        // Search for Initial APN setting and the first apn that can handle default
        for (ApnSetting apn : mAllApnSettings) {
            if (firstNonEmergencyApnSetting == null && !apn.canHandleType(ApnSetting.TYPE_EMERGENCY)) {
                firstNonEmergencyApnSetting = apn;
                log("setInitialApn: firstNonEmergencyApnSetting=" + firstNonEmergencyApnSetting);
            }
            if (apn.canHandleType(ApnSetting.TYPE_IA)) {
                // The Initial Attach APN is highest priority so use it if there is one
                log("setInitialApn: iaApnSetting=" + apn);
                iaApnSetting = apn;
                break;
            } else if ((defaultApnSetting == null) && (apn.canHandleType(ApnSetting.TYPE_DEFAULT))) {
                // Use the first default apn if no better choice
                log("setInitialApn: defaultApnSetting=" + apn);
                defaultApnSetting = apn;
            }
        }
    }
    // The priority of apn candidates from highest to lowest is:
    // 1) APN_TYPE_IA (Initial Attach)
    // 2) mPreferredApn, i.e. the current preferred apn
    // 3) The first apn that than handle APN_TYPE_DEFAULT
    // 4) The first APN we can find.
    ApnSetting initialAttachApnSetting = null;
    if (iaApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using iaApnSetting");
        initialAttachApnSetting = iaApnSetting;
    } else if (mPreferredApn != null) {
        if (DBG)
            log("setInitialAttachApn: using mPreferredApn");
        initialAttachApnSetting = mPreferredApn;
    } else if (defaultApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using defaultApnSetting");
        initialAttachApnSetting = defaultApnSetting;
    } else if (firstNonEmergencyApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using firstApnSetting");
        initialAttachApnSetting = firstNonEmergencyApnSetting;
    }
    if (initialAttachApnSetting == null) {
        if (DBG)
            log("setInitialAttachApn: X There in no available apn");
    } else {
        if (DBG)
            log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
        mDataServiceManager.setInitialAttachApn(createDataProfile(initialAttachApnSetting, initialAttachApnSetting.equals(getPreferredApn())), mPhone.getServiceState().getDataRoamingFromRegistration(), null);
    }
}
#method_after
private void setInitialAttachApn() {
    ApnSetting iaApnSetting = null;
    ApnSetting defaultApnSetting = null;
    ApnSetting firstNonEmergencyApnSetting = null;
    log("setInitialApn: E mPreferredApn=" + mPreferredApn);
    if (mPreferredApn != null && mPreferredApn.canHandleType(ApnSetting.TYPE_IA)) {
        iaApnSetting = mPreferredApn;
    } else if (!mAllApnSettings.isEmpty()) {
        // Search for Initial APN setting and the first apn that can handle default
        for (ApnSetting apn : mAllApnSettings) {
            if (firstNonEmergencyApnSetting == null && !apn.canHandleType(ApnSetting.TYPE_EMERGENCY)) {
                firstNonEmergencyApnSetting = apn;
                log("setInitialApn: firstNonEmergencyApnSetting=" + firstNonEmergencyApnSetting);
            }
            if (apn.canHandleType(ApnSetting.TYPE_IA)) {
                // The Initial Attach APN is highest priority so use it if there is one
                log("setInitialApn: iaApnSetting=" + apn);
                iaApnSetting = apn;
                break;
            } else if ((defaultApnSetting == null) && (apn.canHandleType(ApnSetting.TYPE_DEFAULT))) {
                // Use the first default apn if no better choice
                log("setInitialApn: defaultApnSetting=" + apn);
                defaultApnSetting = apn;
            }
        }
    }
    // The priority of apn candidates from highest to lowest is:
    // 1) APN_TYPE_IA (Initial Attach)
    // 2) mPreferredApn, i.e. the current preferred apn
    // 3) The first apn that than handle APN_TYPE_DEFAULT
    // 4) The first APN we can find.
    ApnSetting initialAttachApnSetting = null;
    if (iaApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using iaApnSetting");
        initialAttachApnSetting = iaApnSetting;
    } else if (mPreferredApn != null) {
        if (DBG)
            log("setInitialAttachApn: using mPreferredApn");
        initialAttachApnSetting = mPreferredApn;
    } else if (defaultApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using defaultApnSetting");
        initialAttachApnSetting = defaultApnSetting;
    } else if (firstNonEmergencyApnSetting != null) {
        if (DBG)
            log("setInitialAttachApn: using firstNonEmergencyApnSetting");
        initialAttachApnSetting = firstNonEmergencyApnSetting;
    }
    if (initialAttachApnSetting == null) {
        if (DBG)
            log("setInitialAttachApn: X There in no available apn");
    } else {
        if (DBG)
            log("setInitialAttachApn: X selected Apn=" + initialAttachApnSetting);
        mDataServiceManager.setInitialAttachApn(createDataProfile(initialAttachApnSetting, initialAttachApnSetting.equals(getPreferredApn())), mPhone.getServiceState().getDataRoamingFromRegistration(), null);
    }
}
#end_block

#method_before
private void initialize(Context context, AttributeSet attrs) {
    final ViewConfiguration configuration = ViewConfiguration.get(context);
    mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
    mRecyclerView = new RecyclerViewImpl(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManagerImpl(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    // Create ScrollEventAdapter before attaching PagerSnapHelper to RecyclerView, because the
    // attach process calls PagerSnapHelperImpl.findSnapView, which uses the mScrollEventAdapter
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    mPagerSnapHelper = new PagerSnapHelperImpl();
    mPagerSnapHelper.attachToRecyclerView(mRecyclerView);
    // Add mScrollEventAdapter after attaching mPagerSnapHelper to mRecyclerView, because we
    // don't want to respond on the events sent out during the attach process
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mPageChangeEventDispatcher = new CompositeOnPageChangeCallback(3);
    mScrollEventAdapter.setOnPageChangeCallback(mPageChangeEventDispatcher);
    // Callback that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback() {

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }
    };
    // Add currentItemUpdater before mExternalPageChangeCallbacks, because we need to update
    // internal state first
    mPageChangeEventDispatcher.addOnPageChangeCallback(currentItemUpdater);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mExternalPageChangeCallbacks);
    // Add mPageTransformerAdapter after mExternalPageChangeCallbacks, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#method_after
private void initialize(Context context, AttributeSet attrs) {
    mRecyclerView = new RecyclerViewImpl(context);
    mRecyclerView.setId(ViewCompat.generateViewId());
    mLayoutManager = new LinearLayoutManagerImpl(context);
    mRecyclerView.setLayoutManager(mLayoutManager);
    setOrientation(context, attrs);
    mRecyclerView.setLayoutParams(new ViewGroup.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
    mRecyclerView.addOnChildAttachStateChangeListener(enforceChildFillListener());
    // Create ScrollEventAdapter before attaching PagerSnapHelper to RecyclerView, because the
    // attach process calls PagerSnapHelperImpl.findSnapView, which uses the mScrollEventAdapter
    mScrollEventAdapter = new ScrollEventAdapter(mLayoutManager);
    // Create FakeDrag before attaching PagerSnapHelper, same reason as above
    mFakeDragger = new FakeDrag(this, mScrollEventAdapter, mRecyclerView);
    mPagerSnapHelper = new PagerSnapHelperImpl();
    mPagerSnapHelper.attachToRecyclerView(mRecyclerView);
    // Add mScrollEventAdapter after attaching mPagerSnapHelper to mRecyclerView, because we
    // don't want to respond on the events sent out during the attach process
    mRecyclerView.addOnScrollListener(mScrollEventAdapter);
    mPageChangeEventDispatcher = new CompositeOnPageChangeCallback(3);
    mScrollEventAdapter.setOnPageChangeCallback(mPageChangeEventDispatcher);
    // Callback that updates mCurrentItem after swipes. Also triggered in other cases, but in
    // all those cases mCurrentItem will only be overwritten with the same value.
    final OnPageChangeCallback currentItemUpdater = new OnPageChangeCallback() {

        @Override
        public void onPageSelected(int position) {
            mCurrentItem = position;
        }
    };
    // Add currentItemUpdater before mExternalPageChangeCallbacks, because we need to update
    // internal state first
    mPageChangeEventDispatcher.addOnPageChangeCallback(currentItemUpdater);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mExternalPageChangeCallbacks);
    // Add mPageTransformerAdapter after mExternalPageChangeCallbacks, because page transform
    // events must be fired after scroll events
    mPageTransformerAdapter = new PageTransformerAdapter(mLayoutManager);
    mPageChangeEventDispatcher.addOnPageChangeCallback(mPageTransformerAdapter);
    attachViewToParent(mRecyclerView, 0, mRecyclerView.getLayoutParams());
}
#end_block

#method_before
@UiThread
public void beginFakeDrag() {
    if (mScrollEventAdapter.isFakeDragging()) {
        throw new IllegalStateException("Cannot start a fake drag during another fake drag");
    } else if (mScrollEventAdapter.isDragging()) {
        throw new IllegalStateException("Cannot start a fake drag when user is dragging");
    }
    mTotalOffset = mScrolledOffset = 0;
    mFakeDragBeginTime = SystemClock.uptimeMillis();
    beginFakeVelocityTracker();
    mScrollEventAdapter.notifyBeginFakeDrag();
    if (!mScrollEventAdapter.isIdle()) {
        // Stop potentially running settling animation
        mRecyclerView.stopScroll();
    }
    addFakeMotionEvent(mFakeDragBeginTime, MotionEvent.ACTION_DOWN, 0, 0);
}
#method_after
public boolean beginFakeDrag() {
    return mFakeDragger.beginFakeDrag();
}
#end_block

#method_before
@UiThread
public boolean fakeDragBy(float offset) {
    if (!mScrollEventAdapter.isFakeDragging()) {
        // sending fakeDragBy commands
        return false;
    }
    mTotalOffset -= offset;
    int offsetPx = Math.round(mTotalOffset - mScrolledOffset);
    mScrolledOffset += offsetPx;
    long time = SystemClock.uptimeMillis();
    boolean horizontal = getOrientation() == ORIENTATION_HORIZONTAL;
    final int offsetX = horizontal ? offsetPx : 0;
    final int offsetY = horizontal ? 0 : offsetPx;
    final float x = horizontal ? mTotalOffset : 0;
    final float y = horizontal ? 0 : mTotalOffset;
    mRecyclerView.scrollBy(offsetX, offsetY);
    addFakeMotionEvent(time, MotionEvent.ACTION_MOVE, x, y);
    return true;
}
#method_after
public boolean fakeDragBy(float offsetPxFloat) {
    return mFakeDragger.fakeDragBy(offsetPxFloat);
}
#end_block

#method_before
@UiThread
public boolean endFakeDrag() {
    if (!mScrollEventAdapter.isFakeDragging()) {
        // Happens legitimately if user started dragging during fakeDrag
        return false;
    }
    mScrollEventAdapter.notifyEndFakeDrag();
    final int pixelsPerSecond = 1000;
    final VelocityTracker velocityTracker = mVelocityTracker;
    velocityTracker.computeCurrentVelocity(pixelsPerSecond, mMaximumVelocity);
    int xVelocity = (int) velocityTracker.getXVelocity();
    int yVelocity = (int) velocityTracker.getYVelocity();
    if (!mRecyclerView.fling(xVelocity, yVelocity)) {
        // Velocity too low, trigger snap to page manually
        snapToPage();
    }
    return true;
}
#method_after
public boolean endFakeDrag() {
    return mFakeDragger.endFakeDrag();
}
#end_block

#method_before
public boolean isFakeDragging() {
    return mScrollEventAdapter.isFakeDragging();
}
#method_after
public boolean isFakeDragging() {
    return mFakeDragger.isFakeDragging();
}
#end_block

#method_before
private void snapToPage() {
    View view = mPagerSnapHelper.findSnapView(mLayoutManager);
    if (view == null) {
        return;
    }
    int[] snapDistance = mPagerSnapHelper.calculateDistanceToFinalSnap(mLayoutManager, view);
    // noinspection ConstantConditions
    if (snapDistance[0] != 0 || snapDistance[1] != 0) {
        mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]);
    }
}
#method_after
void snapToPage() {
    // Method copied from PagerSnapHelper#snapToTargetExistingView
    // When fixing something here, make sure to update that method as well
    View view = mPagerSnapHelper.findSnapView(mLayoutManager);
    if (view == null) {
        return;
    }
    int[] snapDistance = mPagerSnapHelper.calculateDistanceToFinalSnap(mLayoutManager, view);
    // noinspection ConstantConditions
    if (snapDistance[0] != 0 || snapDistance[1] != 0) {
        mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]);
    }
}
#end_block

#method_before
private void resetState() {
    mAdapterState = STATE_IDLE;
    mScrollState = SCROLL_STATE_IDLE;
    mScrollValues.reset();
    mDragStartPosition = NO_POSITION;
    mTarget = NO_POSITION;
    mDispatchSelected = false;
    mScrollHappened = false;
}
#method_after
private void resetState() {
    mAdapterState = STATE_IDLE;
    mScrollState = SCROLL_STATE_IDLE;
    mScrollValues.reset();
    mDragStartPosition = NO_POSITION;
    mTarget = NO_POSITION;
    mDispatchSelected = false;
    mScrollHappened = false;
    mFakeDragging = false;
}
#end_block

#method_before
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    // User started a drag (not dragging -> dragging)
    if (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        startDrag(false);
        return;
    }
    // Note that mAdapterState is not updated, to remember we were dragging when settling
    if (isAdapterInAnyDragginState() && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        // Only go through the settling phase if the drag actually moved the page
        if (mScrollHappened) {
            dispatchStateChanged(SCROLL_STATE_SETTLING);
            // Determine target page and dispatch onPageSelected on next scroll event
            mDispatchSelected = true;
        }
        return;
    }
    // Drag is finished (dragging || settling -> idle)
    if (isAdapterInAnyDragginState() && newState == RecyclerView.SCROLL_STATE_IDLE) {
        boolean dispatchIdle = false;
        if (!mScrollHappened) {
            // Pages didn't move during drag, so must be at the start or end of the list
            // ViewPager's contract requires at least one scroll event though
            dispatchScrolled(getPosition(), 0f, 0);
            dispatchIdle = true;
        } else if (updateScrollEventValues().mOffsetPx == 0) {
            // Normally we dispatch the selected page and go to idle in onScrolled when
            // mOffsetPx == 0, but in this case the drag was still ongoing when onScrolled was
            // called, so that didn't happen. And since mOffsetPx == 0, there will be no further
            // scroll events, so fire the onPageSelected event and go to idle now.
            // Note that if we _did_ go to idle in that last onScrolled event, this code will
            // not be executed because mAdapterState has been reset to STATE_IDLE.
            dispatchIdle = true;
            if (mDragStartPosition != mScrollValues.mPosition) {
                dispatchSelected(mScrollValues.mPosition);
            }
        }
        if (dispatchIdle) {
            // Normally idle is fired in last onScrolled call, but either onScrolled was never
            // called, or we were still dragging when the last onScrolled was called
            dispatchStateChanged(SCROLL_STATE_IDLE);
            resetState();
        }
    }
}
#method_after
@Override
public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
    // User started a drag (not dragging -> dragging)
    if (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG && newState == RecyclerView.SCROLL_STATE_DRAGGING) {
        startDrag(false);
        return;
    }
    // Note that mAdapterState is not updated, to remember we were dragging when settling
    if (isInAnyDraggingState() && newState == RecyclerView.SCROLL_STATE_SETTLING) {
        // Only go through the settling phase if the drag actually moved the page
        if (mScrollHappened) {
            dispatchStateChanged(SCROLL_STATE_SETTLING);
            // Determine target page and dispatch onPageSelected on next scroll event
            mDispatchSelected = true;
        }
        return;
    }
    // Drag is finished (dragging || settling -> idle)
    if (isInAnyDraggingState() && newState == RecyclerView.SCROLL_STATE_IDLE) {
        boolean dispatchIdle = false;
        updateScrollEventValues();
        if (!mScrollHappened) {
            // Pages didn't move during drag, so must be at the start or end of the list
            // ViewPager's contract requires at least one scroll event though
            dispatchScrolled(getPosition(), 0f, 0);
            dispatchIdle = true;
        } else if (mScrollValues.mOffsetPx == 0) {
            // Normally we dispatch the selected page and go to idle in onScrolled when
            // mOffsetPx == 0, but in this case the drag was still ongoing when onScrolled was
            // called, so that didn't happen. And since mOffsetPx == 0, there will be no further
            // scroll events, so fire the onPageSelected event and go to idle now.
            // Note that if we _did_ go to idle in that last onScrolled event, this code will
            // not be executed because mAdapterState has been reset to STATE_IDLE.
            dispatchIdle = true;
            if (mDragStartPosition != mScrollValues.mPosition) {
                dispatchSelected(mScrollValues.mPosition);
            }
        }
        if (dispatchIdle) {
            // Normally idle is fired in last onScrolled call, but either onScrolled was never
            // called, or we were still dragging when the last onScrolled was called
            dispatchStateChanged(SCROLL_STATE_IDLE);
            resetState();
        }
    }
}
#end_block

#method_before
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    ScrollEventValues values = updateScrollEventValues();
    if (mDispatchSelected) {
        // Drag started settling, need to calculate target page and dispatch onPageSelected now
        mDispatchSelected = false;
        boolean scrollingForward = dy > 0 || (dy == 0 && dx < 0 == isLayoutRTL());
        // "&& values.mOffsetPx != 0": filters special case where we're scrolling forward and
        // the first scroll event after settling already got us at the target
        mTarget = scrollingForward && values.mOffsetPx != 0 ? values.mPosition + 1 : values.mPosition;
        if (mDragStartPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(values.mPosition, values.mOffset, values.mOffsetPx);
    // doesn't send IDLE event when using setCurrentItem(x, false)
    if ((values.mPosition == mTarget || mTarget == NO_POSITION) && values.mOffsetPx == 0 && !isScrollInAnyDragginState()) {
        // When the target page is reached and the user is not dragging anymore, we're settled,
        // so go to idle.
        // Special case and a bit of a hack when mTarget == NO_POSITION: RecyclerView is being
        // initialized and fires a single scroll event. This flags mScrollHappened, so we need
        // to reset our state. However, we don't want to dispatch idle. But that won't happen;
        // because we were already idle.
        dispatchStateChanged(SCROLL_STATE_IDLE);
        resetState();
    }
}
#method_after
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    updateScrollEventValues();
    if (mDispatchSelected) {
        // Drag started settling, need to calculate target page and dispatch onPageSelected now
        mDispatchSelected = false;
        boolean scrollingForward = dy > 0 || (dy == 0 && dx < 0 == isLayoutRTL());
        // "&& values.mOffsetPx != 0": filters special case where we're scrolling forward and
        // the first scroll event after settling already got us at the target
        mTarget = scrollingForward && mScrollValues.mOffsetPx != 0 ? mScrollValues.mPosition + 1 : mScrollValues.mPosition;
        if (mDragStartPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(mScrollValues.mPosition, mScrollValues.mOffset, mScrollValues.mOffsetPx);
    // doesn't send IDLE event when using setCurrentItem(x, false)
    if ((mScrollValues.mPosition == mTarget || mTarget == NO_POSITION) && mScrollValues.mOffsetPx == 0 && !(mScrollState == SCROLL_STATE_DRAGGING)) {
        // When the target page is reached and the user is not dragging anymore, we're settled,
        // so go to idle.
        // Special case and a bit of a hack when mTarget == NO_POSITION: RecyclerView is being
        // initialized and fires a single scroll event. This flags mScrollHappened, so we need
        // to reset our state. However, we don't want to dispatch idle. But that won't happen;
        // because we were already idle.
        dispatchStateChanged(SCROLL_STATE_IDLE);
        resetState();
    }
}
#end_block

#method_before
private ScrollEventValues updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        return values.reset();
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        return values.reset();
    }
    // TODO(123350297): automated test for this
    MarginLayoutParams margin = (firstVisibleView.getLayoutParams() instanceof MarginLayoutParams) ? (MarginLayoutParams) firstVisibleView.getLayoutParams() : ZERO_MARGIN_LAYOUT_PARAMS;
    boolean isHorizontal = mLayoutManager.getOrientation() == ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        sizePx = firstVisibleView.getWidth();
        if (!isLayoutRTL()) {
            start = firstVisibleView.getLeft() - margin.leftMargin;
        } else {
            start = sizePx - firstVisibleView.getRight() + margin.rightMargin;
        }
    } else {
        sizePx = firstVisibleView.getHeight();
        start = firstVisibleView.getTop() - margin.topMargin;
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        throw new IllegalStateException(String.format(Locale.US, "Page can only be offset by a " + "positive amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
    return values;
}
#method_after
private void updateScrollEventValues() {
    ScrollEventValues values = mScrollValues;
    values.mPosition = mLayoutManager.findFirstVisibleItemPosition();
    if (values.mPosition == RecyclerView.NO_POSITION) {
        values.reset();
        return;
    }
    View firstVisibleView = mLayoutManager.findViewByPosition(values.mPosition);
    if (firstVisibleView == null) {
        values.reset();
        return;
    }
    // TODO(123350297): automated test for this
    MarginLayoutParams margin = (firstVisibleView.getLayoutParams() instanceof MarginLayoutParams) ? (MarginLayoutParams) firstVisibleView.getLayoutParams() : ZERO_MARGIN_LAYOUT_PARAMS;
    boolean isHorizontal = mLayoutManager.getOrientation() == ORIENTATION_HORIZONTAL;
    int start, sizePx;
    if (isHorizontal) {
        sizePx = firstVisibleView.getWidth() + margin.leftMargin + margin.rightMargin;
        if (!isLayoutRTL()) {
            start = firstVisibleView.getLeft() - margin.leftMargin;
        } else {
            start = sizePx - firstVisibleView.getRight() - margin.rightMargin;
        }
    } else {
        sizePx = firstVisibleView.getHeight() + margin.topMargin + margin.bottomMargin;
        start = firstVisibleView.getTop() - margin.topMargin;
    }
    values.mOffsetPx = -start;
    if (values.mOffsetPx < 0) {
        throw new IllegalStateException(String.format(Locale.US, "Page can only be offset by a " + "positive amount, not by %d", values.mOffsetPx));
    }
    values.mOffset = sizePx == 0 ? 0 : (float) values.mOffsetPx / sizePx;
}
#end_block

#method_before
private void startDrag(boolean isFakeDrag) {
    mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG;
    if (mTarget != NO_POSITION) {
        // Target was set means programmatic scroll was in progress
        // Update "drag start page" to reflect the page that ViewPager2 thinks it is at
        mDragStartPosition = mTarget;
        // Reset target because drags have no target until released
        mTarget = NO_POSITION;
    } else {
        // ViewPager2 was at rest, set "drag start page" to current page
        mDragStartPosition = getPosition();
    }
    dispatchStateChanged(isFakeDrag ? SCROLL_STATE_FAKE_DRAGGING : SCROLL_STATE_DRAGGING);
}
#method_after
private void startDrag(boolean isFakeDrag) {
    mFakeDragging = isFakeDrag;
    mAdapterState = isFakeDrag ? STATE_IN_PROGRESS_FAKE_DRAG : STATE_IN_PROGRESS_MANUAL_DRAG;
    if (mTarget != NO_POSITION) {
        // Target was set means programmatic scroll was in progress
        // Update "drag start page" to reflect the page that ViewPager2 thinks it is at
        mDragStartPosition = mTarget;
        // Reset target because drags have no target until released
        mTarget = NO_POSITION;
    } else {
        // ViewPager2 was at rest, set "drag start page" to current page
        mDragStartPosition = getPosition();
    }
    dispatchStateChanged(SCROLL_STATE_DRAGGING);
}
#end_block

#method_before
void notifyEndFakeDrag() {
    if (isDragging()) {
        // Dragging logic has taken over, no need to post process the fake drag
        return;
    }
    updateScrollEventValues();
    if (mScrollValues.mOffsetPx == 0) {
        // We're snapped, so dispatch an IDLE event
        if (mScrollValues.mPosition != mDragStartPosition) {
            dispatchSelected(mScrollValues.mPosition);
        }
        dispatchStateChanged(SCROLL_STATE_IDLE);
        resetState();
    } else {
        // We're not snapped, so dispatch a SETTLING event
        dispatchStateChanged(SCROLL_STATE_SETTLING);
    }
}
#method_after
void notifyEndFakeDrag() {
    if (isDragging() && !mFakeDragging) {
        // Real drag has already taken over, no need to post process the fake drag
        return;
    }
    mFakeDragging = false;
    updateScrollEventValues();
    if (mScrollValues.mOffsetPx == 0) {
        // We're snapped, so dispatch an IDLE event
        if (mScrollValues.mPosition != mDragStartPosition) {
            dispatchSelected(mScrollValues.mPosition);
        }
        dispatchStateChanged(SCROLL_STATE_IDLE);
        resetState();
    } else {
        // We're not snapped, so dispatch a SETTLING event
        dispatchStateChanged(SCROLL_STATE_SETTLING);
    }
}
#end_block

#method_before
boolean isFakeDragging() {
    return mScrollState == SCROLL_STATE_FAKE_DRAGGING;
}
#method_after
boolean isFakeDragging() {
    return mFakeDragging;
}
#end_block

#method_before
ScrollEventValues reset() {
    mPosition = RecyclerView.NO_POSITION;
    mOffset = 0f;
    mOffsetPx = 0;
    return this;
}
#method_after
void reset() {
    mPosition = RecyclerView.NO_POSITION;
    mOffset = 0f;
    mOffsetPx = 0;
}
#end_block

#method_before
private static void expectException(ExceptionalRunnable r, Class exClass, Integer expectedErrno, String msg) {
    try {
        r.run();
        fail(msg + " did not throw exception");
    } catch (Exception e) {
        assertEquals(msg + " threw unexpected exception", exClass.getName(), e.getClass().getName());
        if (e instanceof ErrnoException && expectedErrno != null) {
            assertEquals(msg + "threw ErrnoException with unexpected error number", (int) expectedErrno, ((ErrnoException) e).errno);
        }
    }
}
#method_after
private static void expectException(ExceptionalRunnable r, Class<? extends Exception> exClass, Integer expectedErrno, String msg) {
    try {
        r.run();
        fail(msg + " did not throw exception");
    } catch (Exception e) {
        assertEquals(msg + " threw unexpected exception", exClass, e.getClass());
        if (expectedErrno != null) {
            if (e instanceof ErrnoException) {
                assertEquals(msg + "threw ErrnoException with unexpected error number", (int) expectedErrno, ((ErrnoException) e).errno);
            } else {
                fail("Can only pass expectedErrno when expecting ErrnoException");
            }
        }
    }
}
#end_block

#method_before
private static void expectBindConnectSendtoSuccess(FileDescriptor socket, String socketDesc, SocketAddress addr) {
    String msg = socketDesc + " socket to " + addr.toString();
    try {
        try {
            // Expect that bind throws when any of its arguments are null.
            expectBindException(null, addr, ErrnoException.class, EBADF);
            // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
            // expectBindException(socket, null);
            // expectBindException(null, null);
            // Expect bind to succeed.
            Libcore.os.bind(socket, addr);
            // send() calls. We can't send to addr because that has a port of 0.
            if (addr instanceof InetSocketAddress) {
                InetSocketAddress addrISA = (InetSocketAddress) addr;
                InetSocketAddress socknameISA = (InetSocketAddress) Libcore.os.getsockname(socket);
                assertEquals(addrISA.getAddress(), socknameISA.getAddress());
                assertEquals(0, addrISA.getPort());
                assertFalse(0 == socknameISA.getPort());
                addr = socknameISA;
            }
            // Expect sendto with a null address to throw because the socket is not connected, but to
            // succeed with a non-null address.
            byte[] packet = new byte[42];
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
            // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
            // expectSendtoException(socket, null, ErrnoException.class, EDSTADDRREQ);
            // expectSendtoException(null, null, ErrnoException.class, EBADF);
            // Expect that connect throws when any of its arguments are null.
            expectConnectException(null, addr, ErrnoException.class, EBADF);
            // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
            // expectConnectException(socket, null, NullPointerException.class, 0);
            // expectConnectException(null, null, NullPointerException.class, 0);
            // Expect connect to succeed.
            Libcore.os.connect(socket, addr);
            assertEquals(Libcore.os.getsockname(socket), Libcore.os.getpeername(socket));
            // Expect sendto to succeed both when given an explicit address and a null address.
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
        // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
        // Libcore.os.sendto(socket, packet, 0, packet.length, 0, null);
        } catch (SocketException | ErrnoException e) {
            fail("Expected success for " + msg + ", but got: " + e);
        }
    } finally {
        IoUtils.closeQuietly(socket);
    }
}
#method_after
private static void expectBindConnectSendtoSuccess(FileDescriptor socket, String socketDesc, SocketAddress addr) {
    String msg = socketDesc + " socket to " + addr.toString();
    try {
        try {
            // Expect that bind throws when any of its arguments are null.
            expectBindException(null, addr, ErrnoException.class, EBADF);
            // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
            // expectBindException(socket, null, NullPointerException.class, null);
            // expectBindException(null, null, NullPointerException.class, null);
            // Expect bind to succeed.
            Libcore.os.bind(socket, addr);
            // send() calls. We can't send to addr because that has a port of 0.
            if (addr instanceof InetSocketAddress) {
                InetSocketAddress addrISA = (InetSocketAddress) addr;
                InetSocketAddress socknameISA = (InetSocketAddress) Libcore.os.getsockname(socket);
                assertEquals(addrISA.getAddress(), socknameISA.getAddress());
                assertEquals(0, addrISA.getPort());
                assertFalse(0 == socknameISA.getPort());
                addr = socknameISA;
            }
            // Expect sendto with a null address to throw because the socket is not connected, but to
            // succeed with a non-null address.
            byte[] packet = new byte[42];
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
            // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
            // expectSendtoException(socket, null, ErrnoException.class, EDSTADDRREQ);
            // expectSendtoException(null, null, ErrnoException.class, EBADF);
            // Expect that connect throws when any of its arguments are null.
            expectConnectException(null, addr, ErrnoException.class, EBADF);
            // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
            // expectConnectException(socket, null, NullPointerException.class, null);
            // expectConnectException(null, null, NullPointerException.class, null);
            // Expect connect to succeed.
            Libcore.os.connect(socket, addr);
            assertEquals(Libcore.os.getsockname(socket), Libcore.os.getpeername(socket));
            // Expect sendto to succeed both when given an explicit address and a null address.
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
        // TODO: fix JNI crash in javaInetSocketAddressToInetAddressAndPort and uncomment.
        // Libcore.os.sendto(socket, packet, 0, packet.length, 0, null);
        } catch (SocketException | ErrnoException e) {
            fail("Expected success for " + msg + ", but got: " + e);
        }
    } finally {
        IoUtils.closeQuietly(socket);
    }
}
#end_block

#method_before
public static int sendto(@NonNull FileDescriptor fd, @NonNull byte[] bytes, int byteOffset, int byteCount, int flags, @NonNull SocketAddress address) throws ErrnoException, SocketException {
    return Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, address);
}
#method_after
public static int sendto(@NonNull FileDescriptor fd, @NonNull byte[] bytes, int byteOffset, int byteCount, int flags, @Nullable SocketAddress address) throws ErrnoException, SocketException {
    return Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, address);
}
#end_block

#method_before
private static void expectException(ExceptionalRunnable r, Class exClass, Integer expectedErrno, String msg) {
    try {
        r.run();
        fail(msg + " did not throw exception");
    } catch (Exception e) {
        assertEquals(msg + " threw unexpected exception", exClass.getName(), e.getClass().getName());
        if (e instanceof ErrnoException && expectedErrno != null) {
            assertEquals(msg + "threw ErrnoException with unexpected error number", (int) expectedErrno, ((ErrnoException) e).errno);
        }
    }
}
#method_after
private static void expectException(ExceptionalRunnable r, Class<? extends Exception> exClass, Integer expectedErrno, String msg) {
    try {
        r.run();
        fail(msg + " did not throw exception");
    } catch (Exception e) {
        assertEquals(msg + " threw unexpected exception", exClass, e.getClass());
        if (expectedErrno != null) {
            if (e instanceof ErrnoException) {
                assertEquals(msg + "threw ErrnoException with unexpected error number", (int) expectedErrno, ((ErrnoException) e).errno);
            } else {
                fail("Can only pass expectedErrno when expecting ErrnoException");
            }
        }
    }
}
#end_block

#method_before
private static void expectBindConnectSendtoSuccess(FileDescriptor socket, String socketDesc, SocketAddress addr) {
    String msg = socketDesc + " socket to " + addr.toString();
    try {
        try {
            // Expect that bind throws when any of its arguments are null.
            expectBindException(null, addr, ErrnoException.class, EBADF);
            expectBindException(socket, null, NullPointerException.class, 0);
            expectBindException(null, null, NullPointerException.class, 0);
            // Expect bind to succeed.
            Libcore.os.bind(socket, addr);
            // send() calls. We can't send to addr because that has a port of 0.
            if (addr instanceof InetSocketAddress) {
                InetSocketAddress addrISA = (InetSocketAddress) addr;
                InetSocketAddress socknameISA = (InetSocketAddress) Libcore.os.getsockname(socket);
                assertEquals(addrISA.getAddress(), socknameISA.getAddress());
                assertEquals(0, addrISA.getPort());
                assertFalse(0 == socknameISA.getPort());
                addr = socknameISA;
            }
            // Expect sendto with a null address to throw because the socket is not connected, but to
            // succeed with a non-null address.
            byte[] packet = new byte[42];
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
            // UNIX and IP sockets return different errors for this operation, so we can't check errno.
            expectSendtoException(socket, null, ErrnoException.class, null);
            expectSendtoException(null, null, ErrnoException.class, EBADF);
            // Expect that connect throws when any of its arguments are null.
            expectConnectException(null, addr, ErrnoException.class, EBADF);
            expectConnectException(socket, null, NullPointerException.class, 0);
            expectConnectException(null, null, NullPointerException.class, 0);
            // Expect connect to succeed.
            Libcore.os.connect(socket, addr);
            assertEquals(Libcore.os.getsockname(socket), Libcore.os.getpeername(socket));
            // Expect sendto to succeed both when given an explicit address and a null address.
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, null);
        } catch (SocketException | ErrnoException e) {
            fail("Expected success for " + msg + ", but got: " + e);
        }
    } finally {
        IoUtils.closeQuietly(socket);
    }
}
#method_after
private static void expectBindConnectSendtoSuccess(FileDescriptor socket, String socketDesc, SocketAddress addr) {
    String msg = socketDesc + " socket to " + addr.toString();
    try {
        try {
            // Expect that bind throws when any of its arguments are null.
            expectBindException(null, addr, ErrnoException.class, EBADF);
            expectBindException(socket, null, NullPointerException.class, null);
            expectBindException(null, null, NullPointerException.class, null);
            // Expect bind to succeed.
            Libcore.os.bind(socket, addr);
            // send() calls. We can't send to addr because that has a port of 0.
            if (addr instanceof InetSocketAddress) {
                InetSocketAddress addrISA = (InetSocketAddress) addr;
                InetSocketAddress socknameISA = (InetSocketAddress) Libcore.os.getsockname(socket);
                assertEquals(addrISA.getAddress(), socknameISA.getAddress());
                assertEquals(0, addrISA.getPort());
                assertFalse(0 == socknameISA.getPort());
                addr = socknameISA;
            }
            // Expect sendto with a null address to throw because the socket is not connected, but to
            // succeed with a non-null address.
            byte[] packet = new byte[42];
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
            // UNIX and IP sockets return different errors for this operation, so we can't check errno.
            expectSendtoException(socket, null, ErrnoException.class, null);
            expectSendtoException(null, null, ErrnoException.class, EBADF);
            // Expect that connect throws when any of its arguments are null.
            expectConnectException(null, addr, ErrnoException.class, EBADF);
            expectConnectException(socket, null, NullPointerException.class, null);
            expectConnectException(null, null, NullPointerException.class, null);
            // Expect connect to succeed.
            Libcore.os.connect(socket, addr);
            assertEquals(Libcore.os.getsockname(socket), Libcore.os.getpeername(socket));
            // Expect sendto to succeed both when given an explicit address and a null address.
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, addr);
            Libcore.os.sendto(socket, packet, 0, packet.length, 0, null);
        } catch (SocketException | ErrnoException e) {
            fail("Expected success for " + msg + ", but got: " + e);
        }
    } finally {
        IoUtils.closeQuietly(socket);
    }
}
#end_block

#method_before
protected MediaPlayer2 createMediaPlayer2(Context context, Uri uri, SurfaceHolder holder, AudioAttributesCompat audioAttributes, int audioSessionId) {
    try {
        MediaPlayer2 mp = createMediaPlayer2OnUiThread();
        final AudioAttributesCompat aa = audioAttributes != null ? audioAttributes : new AudioAttributesCompat.Builder().build();
        mp.setAudioAttributes(aa);
        mp.setAudioSessionId(audioSessionId);
        mp.setMediaItem(new UriMediaItem.Builder(context, uri).build());
        if (holder != null) {
            mp.setSurface(holder.getSurface());
        }
        final Monitor onPrepareCalled = new Monitor();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem item, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    onPrepareCalled.signal();
                }
            }
        };
        mp.setEventCallback(executor, ecb);
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.clearEventCallback();
        executor.shutdown();
        return mp;
    } catch (IllegalArgumentException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (SecurityException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (InterruptedException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    }
    return null;
}
#method_after
protected MediaPlayer2 createMediaPlayer2(Context context, Uri uri, SurfaceHolder holder, AudioAttributesCompat audioAttributes, int audioSessionId) {
    try {
        MediaPlayer2 mp = createMediaPlayer2OnUiThread();
        final AudioAttributesCompat aa = audioAttributes != null ? audioAttributes : new AudioAttributesCompat.Builder().build();
        mp.setAudioAttributes(aa);
        mp.setAudioSessionId(audioSessionId);
        mp.setMediaItem(new UriMediaItem.Builder(uri).build());
        if (holder != null) {
            mp.setSurface(holder.getSurface());
        }
        final Monitor onPrepareCalled = new Monitor();
        ExecutorService executor = Executors.newFixedThreadPool(1);
        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

            @Override
            public void onInfo(MediaPlayer2 mp, MediaItem item, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    onPrepareCalled.signal();
                }
            }
        };
        mp.setEventCallback(executor, ecb);
        mp.prepare();
        onPrepareCalled.waitForSignal();
        mp.clearEventCallback();
        executor.shutdown();
        return mp;
    } catch (IllegalArgumentException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (SecurityException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    } catch (InterruptedException ex) {
        LOG.warning("create failed:" + ex);
    // fall through
    }
    return null;
}
#end_block

#method_before
protected void playVideoWithRetries(String path, Integer width, Integer height, int playTime) throws Exception {
    boolean playedSuccessfully = false;
    final Uri uri = Uri.parse(path);
    for (int i = 0; i < STREAM_RETRIES; i++) {
        try {
            mPlayer.setMediaItem(new UriMediaItem.Builder(mContext, uri).build());
            playLoadedVideo(width, height, playTime);
            playedSuccessfully = true;
            break;
        } catch (PrepareFailedException e) {
            // prepare() can fail because of network issues, so try again
            LOG.warning("prepare() failed on try " + i + ", trying playback again");
        }
    }
    assertTrue("Stream did not play successfully after all attempts", playedSuccessfully);
}
#method_after
protected void playVideoWithRetries(String path, Integer width, Integer height, int playTime) throws Exception {
    boolean playedSuccessfully = false;
    final Uri uri = Uri.parse(path);
    for (int i = 0; i < STREAM_RETRIES; i++) {
        try {
            mPlayer.setMediaItem(new UriMediaItem.Builder(uri).build());
            playLoadedVideo(width, height, playTime);
            playedSuccessfully = true;
            break;
        } catch (PrepareFailedException e) {
            // prepare() can fail because of network issues, so try again
            LOG.warning("prepare() failed on try " + i + ", trying playback again");
        }
    }
    assertTrue("Stream did not play successfully after all attempts", playedSuccessfully);
}
#end_block

#method_before
/**
 * Moves the media to specified time position.
 * Same as {@link #seekTo(long, int)} with {@code mode = SEEK_PREVIOUS_SYNC}.
 *
 * @param msec the offset in milliseconds from the start to seek to
 * @return a token which can be used to cancel the operation later with {@link #cancel}.
 */
@SuppressLint("RestrictedApi")
public Object seekTo(long msec) {
    return seekTo(msec, SEEK_PREVIOUS_SYNC);
}
#method_after
/**
 * Moves the media to specified time position.
 * Same as {@link #seekTo(long, int)} with {@code mode = SEEK_PREVIOUS_SYNC}.
 *
 * @param msec the offset in milliseconds from the start to seek to
 * @return a token which can be used to cancel the operation later with {@link #cancel}.
 */
public Object seekTo(long msec) {
    return seekTo(msec, SEEK_PREVIOUS_SYNC);
}
#end_block

#method_before
static void putRemoteActionList(@NonNull Bundle bundle, @NonNull String key, @Nullable List<RemoteActionCompat> actions) {
    if (actions == null) {
        bundle.remove(key);
        return;
    }
    final ArrayList<Parcelable> parcelables = new ArrayList<>(actions.size());
    for (RemoteActionCompat action : actions) {
        parcelables.add(ParcelUtils.toParcelable(action));
    }
    bundle.putParcelableArrayList(key, parcelables);
}
#method_after
static void putRemoteActionList(@NonNull Bundle bundle, @NonNull String key, @NonNull List<RemoteActionCompat> actions) {
    ParcelUtils.putVersionedParcelableList(bundle, key, actions);
}
#end_block

#method_before
static List<RemoteActionCompat> getRemoteActionListOrThrow(@NonNull Bundle bundle, @NonNull String key) {
    final List<Parcelable> parcelables = bundle.getParcelableArrayList(key);
    if (parcelables == null) {
        throw new IllegalArgumentException("Missing " + key);
    }
    final List<RemoteActionCompat> actions = new ArrayList<>(parcelables.size());
    for (Parcelable parcelable : parcelables) {
        actions.add((RemoteActionCompat) ParcelUtils.fromParcelable(parcelable));
    }
    return actions;
}
#method_after
static List<RemoteActionCompat> getRemoteActionListOrThrow(@NonNull Bundle bundle, @NonNull String key) {
    return ParcelUtils.getVersionedParcelableList(bundle, key);
}
#end_block

#method_before
public void resolveInterface(String interfaceName, ApiClass apiInterface) {
    if (mInterfaceMap.containsKey(interfaceName)) {
        mInterfaceMap.put(interfaceName, apiInterface);
    }
}
#method_after
public void resolveInterface(String interfaceName, ApiClass apiInterface) {
    mInterfaceMap.replace(interfaceName, apiInterface);
}
#end_block

#method_before
@Before
public void setUp() {
    mAssetLoader = (new WebViewAssetLoader.Builder(mActivityRule.getActivity())).build();
    mOnUiThread = new WebViewOnUiThread(mActivityRule.getActivity().getWebView());
    mOnUiThread.setWebViewClient(new AssetLoadingWebViewClient(mOnUiThread, mAssetLoader));
    mOnUiThread.setWebChromeClient(new WebViewOnUiThread.WaitForProgressClient(mOnUiThread));
}
#method_after
@Before
public void setUp() {
    mAssetLoader = (new WebViewAssetLoader.Builder(mActivityRule.getActivity())).build();
    mOnUiThread = new WebViewOnUiThread(mActivityRule.getActivity().getWebView());
    mOnUiThread.setWebViewClient(new AssetLoadingWebViewClient(mOnUiThread, mAssetLoader));
}
#end_block

#method_before
private void printXmlParser(CodeWriter out) throws JavaCodeGeneratorException {
    out.printf("package %s;\n", packageName);
    out.println();
    out.println("public class XmlParser {");
    boolean isMultiRootElement = xmlSchema.getElementMap().values().size() > 1;
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        JavaType javaType = parseType(element.getType(), element.getName());
        out.printf("public static %s read%s(java.io.InputStream in)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n" + "org.xmlpull.v1.XmlPullParser parser = org.xmlpull.v1.XmlPullParserFactory" + ".newInstance().newPullParser();\n" + "parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_PROCESS_NAMESPACES, " + "true);\n" + "parser.setInput(in, null);\n" + "parser.nextTag();\n" + "String tagName = parser.getName();\n" + "String raw = null;\n", javaType.getName(), isMultiRootElement ? Utils.capitalize(javaType.getName()) : "");
        out.printf("if (tagName.equals(\"%s\")) {\n", element.getName());
        if (javaType instanceof JavaSimpleType) {
            out.print("raw = XmlParser.readText(parser);\n");
        }
        out.print(javaType.getParsingExpression());
        out.print("return value;\n" + "}\n" + "return null\n" + "}\n");
        out.println();
    }
    out.print("public static java.lang.String readText(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "String result = \"\";\n" + "if (parser.next() == org.xmlpull.v1.XmlPullParser.TEXT) {\n" + "    result = parser.getText();\n" + "    parser.nextTag();\n" + "}\n" + "return result;\n" + "}\n");
    out.println();
    out.print("public static void skip(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) {\n" + "    throw new IllegalStateException();\n" + "}\n" + "int depth = 1;\n" + "while (depth != 0) {\n" + "    switch (parser.next()) {\n" + "        case org.xmlpull.v1.XmlPullParser.END_TAG:\n" + "            depth--;\n" + "            break;\n" + "        case org.xmlpull.v1.XmlPullParser.START_TAG:\n" + "            depth++;\n" + "            break;\n" + "    }\n" + "}\n" + "}\n");
    out.println("}");
}
#method_after
private void printXmlParser(CodeWriter out) throws JavaCodeGeneratorException {
    out.printf("package %s;\n", packageName);
    out.println();
    out.println("public class XmlParser {");
    boolean isMultiRootElement = xmlSchema.getElementMap().values().size() > 1;
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        JavaType javaType = parseType(element.getType(), element.getName());
        out.printf("public static %s read%s(java.io.InputStream in)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n" + "org.xmlpull.v1.XmlPullParser parser = org.xmlpull.v1.XmlPullParserFactory" + ".newInstance().newPullParser();\n" + "parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_PROCESS_NAMESPACES, " + "true);\n" + "parser.setInput(in, null);\n" + "parser.nextTag();\n" + "String tagName = parser.getName();\n" + "String raw = null;\n", javaType.getName(), isMultiRootElement ? Utils.capitalize(javaType.getName()) : "");
        out.printf("if (tagName.equals(\"%s\")) {\n", element.getName());
        if (javaType instanceof JavaSimpleType) {
            out.print("raw = XmlParser.readText(parser);\n");
        }
        out.print(javaType.getParsingExpression());
        out.print("return value;\n" + "}\n" + "return null;\n" + "}\n");
        out.println();
    }
    out.print("public static java.lang.String readText(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "String result = \"\";\n" + "if (parser.next() == org.xmlpull.v1.XmlPullParser.TEXT) {\n" + "    result = parser.getText();\n" + "    parser.nextTag();\n" + "}\n" + "return result;\n" + "}\n");
    out.println();
    out.print("public static void skip(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) {\n" + "    throw new IllegalStateException();\n" + "}\n" + "int depth = 1;\n" + "while (depth != 0) {\n" + "    switch (parser.next()) {\n" + "        case org.xmlpull.v1.XmlPullParser.END_TAG:\n" + "            depth--;\n" + "            break;\n" + "        case org.xmlpull.v1.XmlPullParser.START_TAG:\n" + "            depth++;\n" + "            break;\n" + "    }\n" + "}\n" + "}\n");
    out.println("}");
}
#end_block

#method_before
@Test
@SmallTest
public void testCustomPathHandler() throws Throwable {
    final String contents = "Some content for testing\n";
    final String encoding = "utf-8";
    WebViewAssetLoader.PathHandler assetsHandler = new WebViewAssetLoader.PathHandler("appassets.androidplatform.net", "/notused/", true) {

        @Override
        public InputStream handle(Uri url) {
            return null;
        }
    };
    WebViewAssetLoader.PathHandler resourcesHandler = new WebViewAssetLoader.PathHandler("appassets.androidplatform.net", "/test/", true) {

        @Override
        public InputStream handle(Uri url) {
            try {
                return new ByteArrayInputStream(contents.getBytes(encoding));
            } catch (UnsupportedEncodingException e) {
                Log.e(TAG, "exception when creating response", e);
            }
            return null;
        }
    };
    WebViewAssetLoader assetLoader = (new WebViewAssetLoader.Builder(new MockContext())).buildForTest(assetsHandler, resourcesHandler);
    WebResourceResponse response = assetLoader.shouldInterceptRequest("http://appassets.androidplatform.net/test/");
    Assert.assertNotNull("didn't match the exact registered URL", response);
    Assert.assertEquals(contents, readAsString(response.getData(), encoding));
    Assert.assertNull("opened \"http://foo.bar/\" that isn't registered - should return null", assetLoader.shouldInterceptRequest("http://foo.bar/"));
}
#method_after
@Test
@SmallTest
public void testCustomPathHandler() throws Throwable {
    final String contents = "Some content for testing\n";
    final String encoding = "utf-8";
    WebViewAssetLoader.PathHandler assetsHandler = new WebViewAssetLoader.PathHandler("appassets.androidplatform.net", "/notused/", true) {

        @Override
        public InputStream handle(Uri url) {
            return null;
        }
    };
    WebViewAssetLoader.PathHandler resourcesHandler = new WebViewAssetLoader.PathHandler("appassets.androidplatform.net", "/test/", true) {

        @Override
        public InputStream handle(Uri url) {
            try {
                return new ByteArrayInputStream(contents.getBytes(encoding));
            } catch (UnsupportedEncodingException e) {
                Log.e(TAG, "exception when creating response", e);
            }
            return null;
        }
    };
    WebViewAssetLoader assetLoader = (new WebViewAssetLoader.Builder(new MockContext())).buildForTest(assetsHandler, resourcesHandler);
    WebResourceResponse response = assetLoader.shouldInterceptRequest("http://appassets.androidplatform.net/test/");
    Assert.assertNotNull("didn't match the exact registered URL", response);
    Assert.assertEquals(contents, readAsString(response.getData(), encoding));
    Assert.assertNull("opened a non-registered URL - should return null", assetLoader.shouldInterceptRequest("http://foo.bar/"));
}
#end_block

#method_before
@Deprecated
@NonNull
public Builder<T> setQueryExecutor(@NonNull Executor executor) {
    mQueryExecutor = executor;
    return this;
}
#method_after
@NonNull
public Builder<T> setQueryExecutor(@NonNull Executor executor) {
    mQueryExecutor = executor;
    return this;
}
#end_block

#method_before
@SuppressLint("RestrictedApi")
@NonNull
public T build() {
    // noinspection ConstantConditions
    if (mContext == null) {
        throw new IllegalArgumentException("Cannot provide null context for the database.");
    }
    // noinspection ConstantConditions
    if (mDatabaseClass == null) {
        throw new IllegalArgumentException("Must provide an abstract class that" + " extends RoomDatabase");
    }
    if (mQueryExecutor == null) {
        mQueryExecutor = ArchTaskExecutor.getIOThreadExecutor();
    }
    if (mTransactionExecutor == null) {
        mTransactionExecutor = ArchTaskExecutor.getIOThreadExecutor();
    }
    if (mMigrationStartAndEndVersions != null && mMigrationsNotRequiredFrom != null) {
        for (Integer version : mMigrationStartAndEndVersions) {
            if (mMigrationsNotRequiredFrom.contains(version)) {
                throw new IllegalArgumentException("Inconsistency detected. A Migration was supplied to " + "addMigration(Migration... migrations) that has a start " + "or end version equal to a start version supplied to " + "fallbackToDestructiveMigrationFrom(int... " + "startVersions). Start version: " + version);
            }
        }
    }
    if (mFactory == null) {
        mFactory = new FrameworkSQLiteOpenHelperFactory();
    }
    DatabaseConfiguration configuration = new DatabaseConfiguration(mContext, mName, mFactory, mMigrationContainer, mCallbacks, mAllowMainThreadQueries, mJournalMode.resolve(mContext), mQueryExecutor, mTransactionExecutor, mMultiInstanceInvalidation, mRequireMigration, mAllowDestructiveMigrationOnDowngrade, mMigrationsNotRequiredFrom);
    T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX);
    db.init(configuration);
    return db;
}
#method_after
@SuppressLint("RestrictedApi")
@NonNull
public T build() {
    // noinspection ConstantConditions
    if (mContext == null) {
        throw new IllegalArgumentException("Cannot provide null context for the database.");
    }
    // noinspection ConstantConditions
    if (mDatabaseClass == null) {
        throw new IllegalArgumentException("Must provide an abstract class that" + " extends RoomDatabase");
    }
    if (mQueryExecutor == null && mTransactionExecutor == null) {
        mQueryExecutor = mTransactionExecutor = ArchTaskExecutor.getIOThreadExecutor();
    } else if (mQueryExecutor != null && mTransactionExecutor == null) {
        mTransactionExecutor = mQueryExecutor;
    } else if (mQueryExecutor == null && mTransactionExecutor != null) {
        mQueryExecutor = mTransactionExecutor;
    }
    if (mMigrationStartAndEndVersions != null && mMigrationsNotRequiredFrom != null) {
        for (Integer version : mMigrationStartAndEndVersions) {
            if (mMigrationsNotRequiredFrom.contains(version)) {
                throw new IllegalArgumentException("Inconsistency detected. A Migration was supplied to " + "addMigration(Migration... migrations) that has a start " + "or end version equal to a start version supplied to " + "fallbackToDestructiveMigrationFrom(int... " + "startVersions). Start version: " + version);
            }
        }
    }
    if (mFactory == null) {
        mFactory = new FrameworkSQLiteOpenHelperFactory();
    }
    DatabaseConfiguration configuration = new DatabaseConfiguration(mContext, mName, mFactory, mMigrationContainer, mCallbacks, mAllowMainThreadQueries, mJournalMode.resolve(mContext), mQueryExecutor, mTransactionExecutor, mMultiInstanceInvalidation, mRequireMigration, mAllowDestructiveMigrationOnDowngrade, mMigrationsNotRequiredFrom);
    T db = Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX);
    db.init(configuration);
    return db;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    final Context context = InstrumentationRegistry.getContext();
    mServiceContext = new BroadcastInterceptingContext(context);
    mStatsDir = context.getFilesDir();
    if (mStatsDir.exists()) {
        IoUtils.deleteContents(mStatsDir);
    }
    PowerManager powerManager = (PowerManager) mServiceContext.getSystemService(Context.POWER_SERVICE);
    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    mService = new NetworkStatsService(mServiceContext, mNetManager, mAlarmManager, wakeLock, mClock, TelephonyManager.getDefault(), mSettings, new NetworkStatsObservers(), mStatsDir, getBaseDir(mStatsDir));
    mHandlerThread = new HandlerThread("HandlerThread");
    mHandlerThread.start();
    Handler.Callback callback = new NetworkStatsService.HandlerCallback(mService);
    mHandler = new Handler(mHandlerThread.getLooper(), callback);
    mService.setHandler(mHandler, callback);
    mService.bindConnectivityManager(mConnManager);
    mElapsedRealtime = 0L;
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    mService.systemReady();
    mSession = mService.openSession();
    assertNotNull("openSession() failed", mSession);
    // catch INetworkManagementEventObserver during systemReady()
    ArgumentCaptor<INetworkManagementEventObserver> networkObserver = ArgumentCaptor.forClass(INetworkManagementEventObserver.class);
    verify(mNetManager).registerObserver(networkObserver.capture());
    mNetworkObserver = networkObserver.getValue();
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    final Context context = InstrumentationRegistry.getContext();
    mServiceContext = new BroadcastInterceptingContext(context);
    mStatsDir = context.getFilesDir();
    if (mStatsDir.exists()) {
        IoUtils.deleteContents(mStatsDir);
    }
    PowerManager powerManager = (PowerManager) mServiceContext.getSystemService(Context.POWER_SERVICE);
    PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    mService = new NetworkStatsService(mServiceContext, mNetManager, mAlarmManager, wakeLock, mClock, TelephonyManager.getDefault(), mSettings, new NetworkStatsObservers(), mStatsDir, getBaseDir(mStatsDir));
    mHandlerThread = new HandlerThread("HandlerThread");
    mHandlerThread.start();
    Handler.Callback callback = new NetworkStatsService.HandlerCallback(mService);
    mHandler = new Handler(mHandlerThread.getLooper(), callback);
    mService.setHandler(mHandler, callback);
    mElapsedRealtime = 0L;
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    mService.systemReady();
    mSession = mService.openSession();
    assertNotNull("openSession() failed", mSession);
    // catch INetworkManagementEventObserver during systemReady()
    ArgumentCaptor<INetworkManagementEventObserver> networkObserver = ArgumentCaptor.forClass(INetworkManagementEventObserver.class);
    verify(mNetManager).registerObserver(networkObserver.capture());
    mNetworkObserver = networkObserver.getValue();
}
#end_block

#method_before
@After
public void tearDown() throws Exception {
    IoUtils.deleteContents(mStatsDir);
    mServiceContext = null;
    mStatsDir = null;
    mNetManager = null;
    mSettings = null;
    mConnManager = null;
    mSession.close();
    mService = null;
}
#method_after
@After
public void tearDown() throws Exception {
    IoUtils.deleteContents(mStatsDir);
    mServiceContext = null;
    mStatsDir = null;
    mNetManager = null;
    mSettings = null;
    mSession.close();
    mService = null;
}
#end_block

#method_before
@Test
public void testNetworkStatsWifi() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // and bump forward again, with counters going higher. this is
    // important, since polling should correctly subtract last snapshot.
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096L, 4L, 8192L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096L, 4L, 8192L, 8L, 0);
}
#method_after
@Test
public void testNetworkStatsWifi() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // and bump forward again, with counters going higher. this is
    // important, since polling should correctly subtract last snapshot.
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096L, 4L, 8192L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096L, 4L, 8192L, 8L, 0);
}
#end_block

#method_before
@Test
public void testStatsRebootPersist() throws Exception {
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 8L, 2048L, 16L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 0L));
    mService.setUidForeground(UID_RED, false);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 4);
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 6);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
    // graceful shutdown system, which should trigger persist of stats, and
    // clear any values in memory.
    expectDefaultSettings();
    mServiceContext.sendBroadcast(new Intent(Intent.ACTION_SHUTDOWN));
    assertStatsFilesExist(true);
    // boot through serviceReady() again
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    mService.systemReady();
    // after systemReady(), we should have historical stats loaded again
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
}
#method_after
@Test
public void testStatsRebootPersist() throws Exception {
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 8L, 2048L, 16L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 256L, 2L, 128L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 128L, 1L, 128L, 1L, 0L));
    mService.setUidForeground(UID_RED, false);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 4);
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 6);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
    // graceful shutdown system, which should trigger persist of stats, and
    // clear any values in memory.
    expectDefaultSettings();
    mServiceContext.sendBroadcast(new Intent(Intent.ACTION_SHUTDOWN));
    assertStatsFilesExist(true);
    // boot through serviceReady() again
    expectDefaultSettings();
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectSystemReady();
    mService.systemReady();
    // after systemReady(), we should have historical stats loaded again
    assertNetworkTotal(sTemplateWifi, 1024L, 8L, 2048L, 16L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 1024L, 8L, 512L, 4L, 10);
    assertUidTotal(sTemplateWifi, UID_RED, SET_DEFAULT, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 4);
    assertUidTotal(sTemplateWifi, UID_RED, SET_FOREGROUND, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 512L, 4L, 256L, 2L, 6);
    assertUidTotal(sTemplateWifi, UID_BLUE, 128L, 1L, 128L, 1L, 0);
}
#end_block

#method_before
@Test
@Ignore
public void testStatsBucketResize() throws Exception {
    NetworkStatsHistory history = null;
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(2 * HOUR_IN_MILLIS);
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 512L, 4L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(HOUR_IN_MILLIS, history.getBucketDuration());
    assertEquals(2, history.size());
    // now change bucket duration setting and trigger another poll with
    // exact same values, which should resize existing buckets.
    expectSettings(0L, 30 * MINUTE_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify identical stats, but spread across 4 buckets now
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(30 * MINUTE_IN_MILLIS, history.getBucketDuration());
    assertEquals(4, history.size());
}
#method_after
@Test
@Ignore
public void testStatsBucketResize() throws Exception {
    NetworkStatsHistory history = null;
    assertStatsFilesExist(false);
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // modify some number on wifi, and trigger poll event
    incrementCurrentTime(2 * HOUR_IN_MILLIS);
    expectSettings(0L, HOUR_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 512L, 4L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(HOUR_IN_MILLIS, history.getBucketDuration());
    assertEquals(2, history.size());
    // now change bucket duration setting and trigger another poll with
    // exact same values, which should resize existing buckets.
    expectSettings(0L, 30 * MINUTE_IN_MILLIS, WEEK_IN_MILLIS);
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify identical stats, but spread across 4 buckets now
    history = mSession.getHistoryForNetwork(sTemplateWifi, FIELD_ALL);
    assertValues(history, Long.MIN_VALUE, Long.MAX_VALUE, 512L, 4L, 512L, 4L, 0);
    assertEquals(30 * MINUTE_IN_MILLIS, history.getBucketDuration());
    assertEquals(4, history.size());
}
#end_block

#method_before
@Test
public void testUidStatsAcrossNetworks() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // create some traffic on first network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // now switch networks; this also tests that we're okay with interfaces
    // disappearing, to verify we don't count backwards.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_2));
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2176L, 17L, 1536L, 12L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 640L, 5L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xFAAD, 128L, 1L, 1024L, 8L, 0L));
    mService.incrementOperationCount(UID_BLUE, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify original history still intact
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // and verify new history also recorded under different template, which
    // verifies that we didn't cross the streams.
    assertNetworkTotal(sTemplateImsi2, 128L, 1L, 1024L, 8L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi2, UID_BLUE, 128L, 1L, 1024L, 8L, 10);
}
#method_after
@Test
public void testUidStatsAcrossNetworks() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic on first network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // now switch networks; this also tests that we're okay with interfaces
    // disappearing, to verify we don't count backwards.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    states = new NetworkState[] { buildMobile3gState(IMSI_2) };
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2048L, 16L, 512L, 4L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 512L, 4L, 0L, 0L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 2176L, 17L, 1536L, 12L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1536L, 12L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 640L, 5L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xFAAD, 128L, 1L, 1024L, 8L, 0L));
    mService.incrementOperationCount(UID_BLUE, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify original history still intact
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 512L, 4L, 10);
    assertUidTotal(sTemplateImsi1, UID_BLUE, 512L, 4L, 0L, 0L, 0);
    // and verify new history also recorded under different template, which
    // verifies that we didn't cross the streams.
    assertNetworkTotal(sTemplateImsi2, 128L, 1L, 1024L, 8L, 0);
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateImsi2, UID_BLUE, 128L, 1L, 1024L, 8L, 10);
}
#end_block

#method_before
@Test
public void testUidRemovedIsMoved() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 16L, 1L, 16L, 1L, 10);
    assertUidTotal(sTemplateWifi, UID_BLUE, 4096L, 258L, 512L, 32L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    // now pretend two UIDs are uninstalled, which should migrate stats to
    // special "removed" bucket.
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    final Intent intent = new Intent(ACTION_UID_REMOVED);
    intent.putExtra(EXTRA_UID, UID_BLUE);
    mServiceContext.sendBroadcast(intent);
    intent.putExtra(EXTRA_UID, UID_RED);
    mServiceContext.sendBroadcast(intent);
    // existing uid and total should remain unchanged; but removed UID
    // should be gone completely.
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    assertUidTotal(sTemplateWifi, UID_REMOVED, 4112L, 259L, 528L, 33L, 10);
}
#method_after
@Test
public void testUidRemovedIsMoved() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 10);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 16L, 1L, 16L, 1L, 10);
    assertUidTotal(sTemplateWifi, UID_BLUE, 4096L, 258L, 512L, 32L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    // now pretend two UIDs are uninstalled, which should migrate stats to
    // special "removed" bucket.
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4128L, 258L, 544L, 34L));
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xFAAD, 16L, 1L, 16L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 4096L, 258L, 512L, 32L, 0L).addValues(TEST_IFACE, UID_GREEN, SET_DEFAULT, TAG_NONE, 16L, 1L, 16L, 1L, 0L));
    final Intent intent = new Intent(ACTION_UID_REMOVED);
    intent.putExtra(EXTRA_UID, UID_BLUE);
    mServiceContext.sendBroadcast(intent);
    intent.putExtra(EXTRA_UID, UID_RED);
    mServiceContext.sendBroadcast(intent);
    // existing uid and total should remain unchanged; but removed UID
    // should be gone completely.
    assertNetworkTotal(sTemplateWifi, 4128L, 258L, 544L, 34L, 0);
    assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_GREEN, 16L, 1L, 16L, 1L, 0);
    assertUidTotal(sTemplateWifi, UID_REMOVED, 4112L, 259L, 528L, 33L, 10);
}
#end_block

#method_before
@Test
public void testUid3g4gCombinedByTemplate() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 5);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 1024L, 8L, 1024L, 8L, 5);
    // now switch over to 4g network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkState(buildMobile4gState(TEST_IFACE2));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, 0xFAAD, 512L, 4L, 256L, 2L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 5);
    forcePollAndWaitForIdle();
    // verify that ALL_MOBILE template combines both
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 1280L, 10L, 10);
}
#method_after
@Test
public void testUid3g4gCombinedByTemplate() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 5);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 1024L, 8L, 1024L, 8L, 5);
    // now switch over to 4g network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    states = new NetworkState[] { buildMobile4gState(TEST_IFACE2) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L));
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    forcePollAndWaitForIdle();
    // create traffic on second network
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1024L, 8L, 1024L, 8L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 512L, 4L, 512L, 4L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, TAG_NONE, 512L, 4L, 256L, 2L, 0L).addValues(TEST_IFACE2, UID_RED, SET_DEFAULT, 0xFAAD, 512L, 4L, 256L, 2L, 0L));
    mService.incrementOperationCount(UID_RED, 0xFAAD, 5);
    forcePollAndWaitForIdle();
    // verify that ALL_MOBILE template combines both
    assertUidTotal(sTemplateImsi1, UID_RED, 1536L, 12L, 1280L, 10L, 10);
}
#end_block

#method_before
@Test
public void testSummaryForAllUid() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some traffic for two apps
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 1024L, 8L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 50L, 5L, 50L, 5L, 1);
    assertUidTotal(sTemplateWifi, UID_BLUE, 1024L, 8L, 512L, 4L, 0);
    // now create more traffic in next hour, but only for one app
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 2048L, 16L, 1024L, 8L, 0L));
    forcePollAndWaitForIdle();
    // first verify entire history present
    NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(3, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50L, 5L, 50L, 5L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 10L, 1L, 10L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 2048L, 16L, 1024L, 8L, 0);
    // now verify that recent history only contains one uid
    final long currentTime = currentTimeMillis();
    stats = mSession.getSummaryForAllUid(sTemplateWifi, currentTime - HOUR_IN_MILLIS, currentTime, true);
    assertEquals(1, stats.size());
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1024L, 8L, 512L, 4L, 0);
}
#method_after
@Test
public void testSummaryForAllUid() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some traffic for two apps
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 1024L, 8L, 512L, 4L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 50L, 5L, 50L, 5L, 1);
    assertUidTotal(sTemplateWifi, UID_BLUE, 1024L, 8L, 512L, 4L, 0);
    // now create more traffic in next hour, but only for one app
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 10L, 1L, 10L, 1L, 0L).addValues(TEST_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 2048L, 16L, 1024L, 8L, 0L));
    forcePollAndWaitForIdle();
    // first verify entire history present
    NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(3, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 50L, 5L, 50L, 5L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 10L, 1L, 10L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 2048L, 16L, 1024L, 8L, 0);
    // now verify that recent history only contains one uid
    final long currentTime = currentTimeMillis();
    stats = mSession.getSummaryForAllUid(sTemplateWifi, currentTime - HOUR_IN_MILLIS, currentTime, true);
    assertEquals(1, stats.size());
    assertValues(stats, IFACE_ALL, UID_BLUE, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1024L, 8L, 512L, 4L, 0);
}
#end_block

#method_before
@Test
public void testDetailedUidStats() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    NetworkStats.Entry entry1 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry2 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry3 = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xBEEF, 1024L, 8L, 512L, 4L, 0L);
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(entry1).addValues(entry2).addValues(entry3));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    NetworkStats stats = mService.getDetailedUidStats(INTERFACES_ALL);
    assertEquals(3, stats.size());
    entry1.operations = 1;
    assertEquals(entry1, stats.getValues(0, null));
    entry2.operations = 1;
    assertEquals(entry2, stats.getValues(1, null));
    assertEquals(entry3, stats.getValues(2, null));
}
#method_after
@Test
public void testDetailedUidStats() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    NetworkStats.Entry entry1 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry2 = new NetworkStats.Entry(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 50L, 5L, 50L, 5L, 0L);
    NetworkStats.Entry entry3 = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xBEEF, 1024L, 8L, 512L, 4L, 0L);
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(entry1).addValues(entry2).addValues(entry3));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    NetworkStats stats = mService.getDetailedUidStats(INTERFACES_ALL);
    assertEquals(3, stats.size());
    entry1.operations = 1;
    assertEquals(entry1, stats.getValues(0, null));
    entry2.operations = 1;
    assertEquals(entry2, stats.getValues(1, null));
    assertEquals(entry3, stats.getValues(2, null));
}
#end_block

#method_before
@Test
public void testDetailedUidStats_Filtered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    final String stackedIface = "stacked-test0";
    final LinkProperties stackedProp = new LinkProperties();
    stackedProp.setInterfaceName(stackedIface);
    final NetworkState wifiState = buildWifiState();
    wifiState.linkProperties.addStackedLink(stackedProp);
    expectNetworkState(wifiState);
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    NetworkStats.Entry uidStats = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Stacked on matching interface
    NetworkStats.Entry tetheredStats1 = new NetworkStats.Entry(stackedIface, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Different interface
    NetworkStats.Entry tetheredStats2 = new NetworkStats.Entry("otherif", UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    final String[] ifaceFilter = new String[] { TEST_IFACE };
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    when(mNetManager.getNetworkStatsUidDetail(eq(UID_ALL), any())).thenReturn(new NetworkStats(getElapsedRealtime(), 1).addValues(uidStats));
    when(mNetManager.getNetworkStatsTethering(STATS_PER_UID)).thenReturn(new NetworkStats(getElapsedRealtime(), 2).addValues(tetheredStats1).addValues(tetheredStats2));
    NetworkStats stats = mService.getDetailedUidStats(ifaceFilter);
    verify(mNetManager, times(1)).getNetworkStatsUidDetail(eq(UID_ALL), argThat(ifaces -> ifaces != null && ifaces.length == 2 && ArrayUtils.contains(ifaces, TEST_IFACE) && ArrayUtils.contains(ifaces, stackedIface)));
    assertEquals(2, stats.size());
    assertEquals(uidStats, stats.getValues(0, null));
    assertEquals(tetheredStats1, stats.getValues(1, null));
}
#method_after
@Test
public void testDetailedUidStats_Filtered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    final String stackedIface = "stacked-test0";
    final LinkProperties stackedProp = new LinkProperties();
    stackedProp.setInterfaceName(stackedIface);
    final NetworkState wifiState = buildWifiState();
    wifiState.linkProperties.addStackedLink(stackedProp);
    NetworkState[] states = new NetworkState[] { wifiState };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    NetworkStats.Entry uidStats = new NetworkStats.Entry(TEST_IFACE, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Stacked on matching interface
    NetworkStats.Entry tetheredStats1 = new NetworkStats.Entry(stackedIface, UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    // Different interface
    NetworkStats.Entry tetheredStats2 = new NetworkStats.Entry("otherif", UID_BLUE, SET_DEFAULT, 0xF00D, 1024L, 8L, 512L, 4L, 0L);
    final String[] ifaceFilter = new String[] { TEST_IFACE };
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    when(mNetManager.getNetworkStatsUidDetail(eq(UID_ALL), any())).thenReturn(new NetworkStats(getElapsedRealtime(), 1).addValues(uidStats));
    when(mNetManager.getNetworkStatsTethering(STATS_PER_UID)).thenReturn(new NetworkStats(getElapsedRealtime(), 2).addValues(tetheredStats1).addValues(tetheredStats2));
    NetworkStats stats = mService.getDetailedUidStats(ifaceFilter);
    verify(mNetManager, times(1)).getNetworkStatsUidDetail(eq(UID_ALL), argThat(ifaces -> ifaces != null && ifaces.length == 2 && ArrayUtils.contains(ifaces, TEST_IFACE) && ArrayUtils.contains(ifaces, stackedIface)));
    assertEquals(2, stats.size());
    assertEquals(uidStats, stats.getValues(0, null));
    assertEquals(tetheredStats1, stats.getValues(1, null));
}
#end_block

#method_before
@Test
public void testForegroundBackground() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // now switch to foreground
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 32L, 2L, 32L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 1L, 1L, 1L, 1L, 0L));
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 1);
    forcePollAndWaitForIdle();
    // test that we combined correctly
    assertUidTotal(sTemplateWifi, UID_RED, 160L, 4L, 160L, 4L, 2);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(4, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 32L, 2L, 32L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, 0xFAAD, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1L, 1L, 1L, 1L, 1);
}
#method_after
@Test
public void testForegroundBackground() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // now switch to foreground
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, 64L, 1L, 64L, 1L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, TAG_NONE, 32L, 2L, 32L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_FOREGROUND, 0xFAAD, 1L, 1L, 1L, 1L, 0L));
    mService.setUidForeground(UID_RED, true);
    mService.incrementOperationCount(UID_RED, 0xFAAD, 1);
    forcePollAndWaitForIdle();
    // test that we combined correctly
    assertUidTotal(sTemplateWifi, UID_RED, 160L, 4L, 160L, 4L, 2);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(4, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 32L, 2L, 32L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_FOREGROUND, 0xFAAD, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 1L, 1L, 1L, 1L, 1);
}
#end_block

#method_before
@Test
public void testMetered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildWifiState(true));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO, ROAMING_NO
    // and DEFAULT_NETWORK_YES, because these three properties aren't tracked at that layer.
    // We layer them on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
}
#method_after
@Test
public void testMetered() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState(true) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // create some initial traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO, ROAMING_NO
    // and DEFAULT_NETWORK_YES, because these three properties aren't tracked at that layer.
    // We layer them on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_NO, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    mService.incrementOperationCount(UID_RED, 0xF00D, 1);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateWifi, UID_RED, 128L, 2L, 128L, 2L, 1);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateWifi, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 1);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_YES, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 1);
}
#end_block

#method_before
@Test
public void testRoaming() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1, true));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // Create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO and
    // ROAMING_NO, because metered and roaming isn't tracked at that layer. We layer it
    // on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateImsi1, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0);
}
#method_after
@Test
public void testRoaming() throws Exception {
    // pretend that network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1, true) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // Create some traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    // Note that all traffic from NetworkManagementService is tagged as METERED_NO and
    // ROAMING_NO, because metered and roaming isn't tracked at that layer. We layer it
    // on top by inspecting the iface properties.
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0L).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_NO, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0L));
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    // verify entire history present
    final NetworkStats stats = mSession.getSummaryForAllUid(sTemplateImsi1, Long.MIN_VALUE, Long.MAX_VALUE, true);
    assertEquals(2, stats.size());
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, TAG_NONE, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 128L, 2L, 128L, 2L, 0);
    assertValues(stats, IFACE_ALL, UID_RED, SET_DEFAULT, 0xF00D, METERED_ALL, ROAMING_YES, DEFAULT_NETWORK_YES, 64L, 1L, 64L, 1L, 0);
}
#end_block

#method_before
@Test
public void testTethering() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    expectNetworkState(buildMobile3gState(IMSI_1));
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE);
    // create some tethering traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    // Traffic seen by kernel counters (includes software tethering).
    final NetworkStats ifaceStats = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1536L, 12L, 384L, 3L);
    // Hardware tethering traffic, not seen by kernel counters.
    final NetworkStats tetherStatsHardware = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 128L, 1L);
    // Traffic for UID_RED.
    final NetworkStats uidStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L);
    // All tethering traffic, both hardware and software.
    final NetworkStats tetherStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_TETHERING, SET_DEFAULT, TAG_NONE, 1920L, 14L, 384L, 2L, 0L);
    expectNetworkStatsSummary(ifaceStats, tetherStatsHardware);
    expectNetworkStatsUidDetail(uidStats, tetherStats);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    assertUidTotal(sTemplateImsi1, UID_TETHERING, 1920L, 14L, 384L, 2L, 0);
}
#method_after
@Test
public void testTethering() throws Exception {
    // pretend first mobile network comes online
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildMobile3gState(IMSI_1) };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_MOBILE, new VpnInfo[0], states, getActiveIface(states));
    // create some tethering traffic
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    // Traffic seen by kernel counters (includes software tethering).
    final NetworkStats ifaceStats = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1536L, 12L, 384L, 3L);
    // Hardware tethering traffic, not seen by kernel counters.
    final NetworkStats tetherStatsHardware = new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 512L, 4L, 128L, 1L);
    // Traffic for UID_RED.
    final NetworkStats uidStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 128L, 2L, 128L, 2L, 0L);
    // All tethering traffic, both hardware and software.
    final NetworkStats tetherStats = new NetworkStats(getElapsedRealtime(), 1).addValues(TEST_IFACE, UID_TETHERING, SET_DEFAULT, TAG_NONE, 1920L, 14L, 384L, 2L, 0L);
    expectNetworkStatsSummary(ifaceStats, tetherStatsHardware);
    expectNetworkStatsUidDetail(uidStats, tetherStats);
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateImsi1, 2048L, 16L, 512L, 4L, 0);
    assertUidTotal(sTemplateImsi1, UID_RED, 128L, 2L, 128L, 2L, 0);
    assertUidTotal(sTemplateImsi1, UID_TETHERING, 1920L, 14L, 384L, 2L, 0);
}
#end_block

#method_before
@Test
public void vpnWithOneUnderlyingIface() throws Exception {
    // We have WiFi and VPN network, and VPN is using WiFi (which has TEST_IFACE).
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildVpnState() };
    expectNetworkState(networkStates);
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(TEST_IFACE) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK });
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // 500 bytes (50 packets) were downloaded by UID_BLUE over VPN.
    // VPN received 1650 bytes (150 packets) over WiFi.
    // Of 1650 bytes over WiFi, expect 1000 bytes attributed to UID_RED, 500 bytes attributed to
    // UID_BLUE, and 150 bytes attributed to UID_VPN.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TUN_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 500L, 50L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1650L, 150L, 0L, 0L, 0L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 1000L, 100L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 500L, 50L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_VPN, 150L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void vpnWithOneUnderlyingIface() throws Exception {
    // WiFi network is connected and VPN is using WiFi (which has TEST_IFACE).
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildVpnState() };
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(TEST_IFACE) };
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK }, vpnInfos, networkStates, getActiveIface(networkStates));
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were sent/received by UID_RED over VPN.
    // 500 bytes (50 packets) were sent/received by UID_BLUE over VPN.
    // VPN sent/received 1650 bytes (150 packets) over WiFi.
    // Of 1650 bytes over WiFi, expect 1000 bytes attributed to UID_RED, 500 bytes attributed to
    // UID_BLUE, and 150 bytes attributed to UID_VPN for both rx/tx traffic.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 1000L, 100L, 1L).addValues(TUN_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 500L, 50L, 500L, 50L, 1L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1650L, 150L, 1650L, 150L, 2L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 1000L, 100L, 1000L, 100L, 1);
    assertUidTotal(sTemplateWifi, UID_BLUE, 500L, 50L, 500L, 50L, 1);
    assertUidTotal(sTemplateWifi, UID_VPN, 150L, 0L, 150L, 0L, 2);
}
#end_block

#method_before
@Test
public void vpnWithOneUnderlyingIface_withCompression() throws Exception {
    // We have WiFi and VPN network, and VPN is using WiFi (which has TEST_IFACE).
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildVpnState() };
    expectNetworkState(networkStates);
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(TEST_IFACE) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK });
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // 1000 bytes (100 packets) were downloaded by UID_BLUE over VPN.
    // VPN received 1000 bytes (100 packets) over WiFi.
    // Of 1000 bytes over WiFi, expect 500 bytes attributed to each UID_RED and UID_BLUE, with
    // nothing attributed to UID_VPN.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TUN_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 500L, 50L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 500L, 50L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_VPN, 0L, 0L, 0L, 0L, 0);
}
#method_after
@Test
public void vpnWithOneUnderlyingIface_withCompression() throws Exception {
    // WiFi network is connected and VPN is using WiFi (which has TEST_IFACE).
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildVpnState() };
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(TEST_IFACE) };
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK }, vpnInfos, networkStates, getActiveIface(networkStates));
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were sent/received by UID_RED over VPN.
    // 3000 bytes (300 packets) were sent/received by UID_BLUE over VPN.
    // VPN sent/received 1000 bytes (100 packets) over WiFi.
    // Of 1000 bytes over WiFi, expect 250 bytes attributed UID_RED and 750 bytes to UID_BLUE,
    // with nothing attributed to UID_VPN for both rx/tx traffic.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 1000L, 100L, 1L).addValues(TUN_IFACE, UID_BLUE, SET_DEFAULT, TAG_NONE, 3000L, 300L, 3000L, 300L, 1L).addValues(TEST_IFACE, UID_VPN, SET_DEFAULT, TAG_NONE, 1000L, 100L, 1000L, 100L, 0L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 250L, 25L, 250L, 25L, 0);
    assertUidTotal(sTemplateWifi, UID_BLUE, 750L, 75L, 750L, 75L, 0);
    assertUidTotal(sTemplateWifi, UID_VPN, 0L, 0L, 0L, 0L, 0);
}
#end_block

#method_before
@Test
public void vpnWithIncorrectUnderlyingIface() throws Exception {
    // We have WiFi, Cell, and VPN network, and VPN is using Cell (which has TEST_IFACE2),
    // but has declared WiFi (TEST_IFACE) in its underlying network set.
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildMobile4gState(TEST_IFACE2), buildVpnState() };
    expectNetworkState(networkStates);
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(TEST_IFACE) };
    when(mConnManager.getAllVpnInfo()).thenReturn(vpnInfos);
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK });
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were downloaded by UID_RED over VPN.
    // VPN received 1100 bytes (100 packets) over Cell.
    // Of 1100 bytes over Cell, expect all of it attributed to UID_VPN.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 3).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 0L, 0L, 0L).addValues(TEST_IFACE2, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 0L, 0L, 0L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_VPN, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(buildTemplateMobileWildcard(), UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(buildTemplateMobileWildcard(), UID_VPN, 1100L, 100L, 0L, 0L, 0);
}
#method_after
@Test
public void vpnWithIncorrectUnderlyingIface() throws Exception {
    // WiFi and Cell networks are connected and VPN is using Cell (which has TEST_IFACE2),
    // but has declared only WiFi (TEST_IFACE) in its underlying network set.
    expectDefaultSettings();
    NetworkState[] networkStates = new NetworkState[] { buildWifiState(), buildMobile4gState(TEST_IFACE2), buildVpnState() };
    VpnInfo[] vpnInfos = new VpnInfo[] { createVpnInfo(TEST_IFACE) };
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(new Network[] { WIFI_NETWORK, VPN_NETWORK }, vpnInfos, networkStates, getActiveIface(networkStates));
    // create some traffic (assume 10 bytes of MTU for VPN interface and 1 byte encryption
    // overhead per packet):
    // 1000 bytes (100 packets) were sent/received by UID_RED over VPN.
    // VPN sent/received 1100 bytes (100 packets) over Cell.
    // Of 1100 bytes over Cell, expect all of it attributed to UID_VPN for both rx/tx traffic.
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectNetworkStatsUidDetail(new NetworkStats(getElapsedRealtime(), 2).addValues(TUN_IFACE, UID_RED, SET_DEFAULT, TAG_NONE, 1000L, 100L, 1000L, 100L, 1L).addValues(TEST_IFACE2, UID_VPN, SET_DEFAULT, TAG_NONE, 1100L, 100L, 1100L, 100L, 1L));
    forcePollAndWaitForIdle();
    assertUidTotal(sTemplateWifi, UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(sTemplateWifi, UID_VPN, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(buildTemplateMobileWildcard(), UID_RED, 0L, 0L, 0L, 0L, 0);
    assertUidTotal(buildTemplateMobileWildcard(), UID_VPN, 1100L, 100L, 1100L, 100L, 1);
}
#end_block

#method_before
@Test
public void testRegisterUsageCallback() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    expectNetworkState(buildWifiState());
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI);
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // very small; should be overriden by framework
    long thresholdInBytes = 1L;
    DataUsageRequest inputRequest = new DataUsageRequest(DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, thresholdInBytes);
    // Create a messenger that waits for callback activity
    ConditionVariable cv = new ConditionVariable(false);
    LatchedHandler latchedHandler = new LatchedHandler(Looper.getMainLooper(), cv);
    Messenger messenger = new Messenger(latchedHandler);
    // Force poll
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    // Register and verify request and that binder was called
    DataUsageRequest request = mService.registerUsageCallback(mServiceContext.getOpPackageName(), inputRequest, messenger, mBinder);
    assertTrue(request.requestId > 0);
    assertTrue(Objects.equals(sTemplateWifi, request.template));
    // 2 MB
    long minThresholdInBytes = 2 * 1024 * 1024;
    assertEquals(minThresholdInBytes, request.thresholdInBytes);
    // Send dummy message to make sure that any previous message has been handled
    mHandler.sendMessage(mHandler.obtainMessage(-1));
    waitForIdleHandler(mHandler, WAIT_TIMEOUT);
    // Make sure that the caller binder gets connected
    verify(mBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
    // modify some number on wifi, and trigger poll event
    // not enough traffic to call data usage callback
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // make sure callback has not being called
    assertEquals(INVALID_TYPE, latchedHandler.lastMessageType);
    // and bump forward again, with counters going higher. this is
    // important, since it will trigger the data usage callback
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096000L, 4L, 8192000L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096000L, 4L, 8192000L, 8L, 0);
    // Wait for the caller to ack receipt of CALLBACK_LIMIT_REACHED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, latchedHandler.lastMessageType);
    cv.close();
    // Allow binder to disconnect
    when(mBinder.unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt())).thenReturn(true);
    // Unregister request
    mService.unregisterUsageRequest(request);
    // Wait for the caller to ack receipt of CALLBACK_RELEASED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_RELEASED, latchedHandler.lastMessageType);
    // Make sure that the caller binder gets disconnected
    verify(mBinder).unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt());
}
#method_after
@Test
public void testRegisterUsageCallback() throws Exception {
    // pretend that wifi network comes online; service should ask about full
    // network state, and poll any existing interfaces before updating.
    expectDefaultSettings();
    NetworkState[] states = new NetworkState[] { buildWifiState() };
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    expectBandwidthControlCheck();
    mService.forceUpdateIfaces(NETWORKS_WIFI, new VpnInfo[0], states, getActiveIface(states));
    // verify service has empty history for wifi
    assertNetworkTotal(sTemplateWifi, 0L, 0L, 0L, 0L, 0);
    // very small; should be overriden by framework
    long thresholdInBytes = 1L;
    DataUsageRequest inputRequest = new DataUsageRequest(DataUsageRequest.REQUEST_ID_UNSET, sTemplateWifi, thresholdInBytes);
    // Create a messenger that waits for callback activity
    ConditionVariable cv = new ConditionVariable(false);
    LatchedHandler latchedHandler = new LatchedHandler(Looper.getMainLooper(), cv);
    Messenger messenger = new Messenger(latchedHandler);
    // Force poll
    expectDefaultSettings();
    expectNetworkStatsSummary(buildEmptyStats());
    expectNetworkStatsUidDetail(buildEmptyStats());
    // Register and verify request and that binder was called
    DataUsageRequest request = mService.registerUsageCallback(mServiceContext.getOpPackageName(), inputRequest, messenger, mBinder);
    assertTrue(request.requestId > 0);
    assertTrue(Objects.equals(sTemplateWifi, request.template));
    // 2 MB
    long minThresholdInBytes = 2 * 1024 * 1024;
    assertEquals(minThresholdInBytes, request.thresholdInBytes);
    // Send dummy message to make sure that any previous message has been handled
    mHandler.sendMessage(mHandler.obtainMessage(-1));
    waitForIdleHandler(mHandler, WAIT_TIMEOUT);
    // Make sure that the caller binder gets connected
    verify(mBinder).linkToDeath(any(IBinder.DeathRecipient.class), anyInt());
    // modify some number on wifi, and trigger poll event
    // not enough traffic to call data usage callback
    incrementCurrentTime(HOUR_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 1024L, 1L, 2048L, 2L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 1024L, 1L, 2048L, 2L, 0);
    // make sure callback has not being called
    assertEquals(INVALID_TYPE, latchedHandler.lastMessageType);
    // and bump forward again, with counters going higher. this is
    // important, since it will trigger the data usage callback
    incrementCurrentTime(DAY_IN_MILLIS);
    expectDefaultSettings();
    expectNetworkStatsSummary(new NetworkStats(getElapsedRealtime(), 1).addIfaceValues(TEST_IFACE, 4096000L, 4L, 8192000L, 8L));
    expectNetworkStatsUidDetail(buildEmptyStats());
    forcePollAndWaitForIdle();
    // verify service recorded history
    assertNetworkTotal(sTemplateWifi, 4096000L, 4L, 8192000L, 8L, 0);
    // Wait for the caller to ack receipt of CALLBACK_LIMIT_REACHED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_LIMIT_REACHED, latchedHandler.lastMessageType);
    cv.close();
    // Allow binder to disconnect
    when(mBinder.unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt())).thenReturn(true);
    // Unregister request
    mService.unregisterUsageRequest(request);
    // Wait for the caller to ack receipt of CALLBACK_RELEASED
    assertTrue(cv.block(WAIT_TIMEOUT));
    assertEquals(NetworkStatsManager.CALLBACK_RELEASED, latchedHandler.lastMessageType);
    // Make sure that the caller binder gets disconnected
    verify(mBinder).unlinkToDeath(any(IBinder.DeathRecipient.class), anyInt());
}
#end_block

#method_before
private void expectNetworkStatsSummary(NetworkStats summary, NetworkStats tetherStats) throws Exception {
    when(mConnManager.getAllVpnInfo()).thenReturn(new VpnInfo[0]);
    expectNetworkStatsTethering(STATS_PER_IFACE, tetherStats);
    expectNetworkStatsSummaryDev(summary.clone());
    expectNetworkStatsSummaryXt(summary.clone());
}
#method_after
private void expectNetworkStatsSummary(NetworkStats summary, NetworkStats tetherStats) throws Exception {
    expectNetworkStatsTethering(STATS_PER_IFACE, tetherStats);
    expectNetworkStatsSummaryDev(summary.clone());
    expectNetworkStatsSummaryXt(summary.clone());
}
#end_block

#method_before
public static void forceAllNetworkTypes() {
    sForceAllNetworkTypes = true;
}
#method_after
@VisibleForTesting
public static void forceAllNetworkTypes() {
    sForceAllNetworkTypes = true;
}
#end_block

#method_before
public static void resetForceAllNetworkTypes() {
    sForceAllNetworkTypes = false;
}
#method_after
@VisibleForTesting
public static void resetForceAllNetworkTypes() {
    sForceAllNetworkTypes = false;
}
#end_block

#method_before
Bundle extractTrackInfoData() {
    List<MediaPlayer.TrackInfo> trackInfos = mMediaPlayer.getTrackInfo();
    mVideoTrackIndices = new ArrayList<>();
    mAudioTrackIndices = new ArrayList<>();
    mSubtitleTracks = new SparseArray<>();
    ArrayList<String> subtitleTracksLanguageList = new ArrayList<>();
    for (int i = 0; i < trackInfos.size(); ++i) {
        int trackType = trackInfos.get(i).getTrackType();
        if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
            mVideoTrackIndices.add(i);
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_AUDIO) {
            mAudioTrackIndices.add(i);
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
            SubtitleTrack track = mSubtitleController.addTrack(trackInfos.get(i).getFormat());
            if (track != null) {
                mSubtitleTracks.put(i, track);
                String language = (trackInfos.get(i).getLanguage().equals(SUBTITLE_TRACK_LANG_UNDEFINED)) ? "" : trackInfos.get(i).getLanguage();
                subtitleTracksLanguageList.add(language);
            }
        }
    }
    // Select first tracks as default
    if (mAudioTrackIndices.size() > 0) {
        mSelectedAudioTrackIndex = 0;
    }
    Bundle data = new Bundle();
    data.putInt(MediaControlView.KEY_VIDEO_TRACK_COUNT, mVideoTrackIndices.size());
    data.putInt(MediaControlView.KEY_AUDIO_TRACK_COUNT, mAudioTrackIndices.size());
    data.putInt(MediaControlView.KEY_SUBTITLE_TRACK_COUNT, mSubtitleTracks.size());
    data.putStringArrayList(MediaControlView.KEY_SUBTITLE_TRACK_LANGUAGE_LIST, subtitleTracksLanguageList);
    return data;
}
#method_after
Bundle extractTrackInfoData() {
    List<MediaPlayer.TrackInfo> trackInfos = mMediaPlayer.getTrackInfo();
    mVideoTrackIndices = new ArrayList<>();
    mAudioTrackIndices = new ArrayList<>();
    mSubtitleTracks = new SparseArray<>();
    ArrayList<String> subtitleTracksLanguageList = new ArrayList<>();
    mSubtitleController.reset();
    for (int i = 0; i < trackInfos.size(); ++i) {
        int trackType = trackInfos.get(i).getTrackType();
        if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_VIDEO) {
            mVideoTrackIndices.add(i);
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_AUDIO) {
            mAudioTrackIndices.add(i);
        } else if (trackType == MediaPlayer.TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE) {
            SubtitleTrack track = mSubtitleController.addTrack(trackInfos.get(i).getFormat());
            if (track != null) {
                mSubtitleTracks.put(i, track);
                String language = (trackInfos.get(i).getLanguage().equals(SUBTITLE_TRACK_LANG_UNDEFINED)) ? "" : trackInfos.get(i).getLanguage();
                subtitleTracksLanguageList.add(language);
            }
        }
    }
    // Select first tracks as default
    if (mAudioTrackIndices.size() > 0) {
        mSelectedAudioTrackIndex = 0;
    }
    // Re-select originally selected subtitle track since SubtitleController has been reset.
    if (mSelectedSubtitleTrackIndex != INVALID_TRACK_INDEX) {
        selectSubtitleTrack(mSelectedSubtitleTrackIndex);
    }
    Bundle data = new Bundle();
    data.putInt(MediaControlView.KEY_VIDEO_TRACK_COUNT, mVideoTrackIndices.size());
    data.putInt(MediaControlView.KEY_AUDIO_TRACK_COUNT, mAudioTrackIndices.size());
    data.putInt(MediaControlView.KEY_SUBTITLE_TRACK_COUNT, mSubtitleTracks.size());
    data.putStringArrayList(MediaControlView.KEY_SUBTITLE_TRACK_LANGUAGE_LIST, subtitleTracksLanguageList);
    return data;
}
#end_block

#method_before
private void createOrUpdateClassLoaderLocked(List<String> addedPaths) {
    if (mPackageName.equals("android")) {
        // jit profiling support.
        if (mClassLoader != null) {
            // nothing to update
            return;
        }
        if (mBaseClassLoader != null) {
            mDefaultClassLoader = mBaseClassLoader;
        } else {
            mDefaultClassLoader = ClassLoader.getSystemClassLoader();
        }
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader, new ApplicationInfo(mApplicationInfo));
        return;
    }
    // spinning up the process.
    if (!Objects.equals(mPackageName, ActivityThread.currentPackageName()) && mIncludeCode) {
        try {
            ActivityThread.getPackageManager().notifyPackageUse(mPackageName, PackageManager.NOTIFY_PACKAGE_USE_CROSS_PACKAGE);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    if (mRegisterPackage) {
        try {
            ActivityManager.getService().addPackageDependency(mPackageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    // Lists for the elements of zip/code and native libraries.
    // 
    // Both lists are usually not empty. We expect on average one APK for the zip component,
    // but shared libraries and splits are not uncommon. We expect at least three elements
    // for native libraries (app-based, system, vendor). As such, give both some breathing
    // space and initialize to a small value (instead of incurring growth code).
    final List<String> zipPaths = new ArrayList<>(10);
    final List<String> libPaths = new ArrayList<>(10);
    boolean isBundledApp = mApplicationInfo.isSystemApp() && !mApplicationInfo.isUpdatedSystemApp();
    // Vendor apks are treated as bundled only when /vendor/lib is in the default search
    // paths. If not, they are treated as unbundled; access to system libs is limited.
    // Having /vendor/lib in the default search paths means that all system processes
    // are allowed to use any vendor library, which in turn means that system is dependent
    // on vendor partition. In the contrary, not having /vendor/lib in the default search
    // paths mean that the two partitions are separated and thus we can treat vendor apks
    // as unbundled.
    final String defaultSearchPaths = System.getProperty("java.library.path");
    final boolean treatVendorApkAsUnbundled = !defaultSearchPaths.contains("/vendor/lib");
    if (mApplicationInfo.getCodePath() != null && mApplicationInfo.isVendor() && treatVendorApkAsUnbundled) {
        isBundledApp = false;
    }
    // Similar to vendor apks, we should add /product/lib for apks from product partition
    // and not having /product/lib in the default search path
    final boolean treatProductApkAsUnbundled = !defaultSearchPaths.contains("/product/lib");
    if (mApplicationInfo.getCodePath() != null && mApplicationInfo.isProduct() && treatProductApkAsUnbundled && getTargetSdkVersion() > Build.VERSION_CODES.Q) {
        isBundledApp = false;
    }
    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
    String libraryPermittedPath = mDataDir;
    if (isBundledApp) {
        // For bundled apps, add the base directory of the app (e.g.,
        // /system/app/Foo/) to the permitted paths so that it can load libraries
        // embedded in module apks under the directory. For now, GmsCore is relying
        // on this, but this isn't specific to the app. Also note that, we don't
        // need to do this for unbundled apps as entire /data is already set to
        // the permitted paths for them.
        libraryPermittedPath += File.pathSeparator + Paths.get(getAppDir()).getParent().toString();
        // This is necessary to grant bundled apps access to
        // libraries located in subdirectories of /system/lib
        libraryPermittedPath += File.pathSeparator + defaultSearchPaths;
    }
    final String librarySearchPath = TextUtils.join(File.pathSeparator, libPaths);
    // mIncludeCode == false).
    if (!mIncludeCode) {
        if (mDefaultClassLoader == null) {
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoader("", /* codePath */
            mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath, libraryPermittedPath, mBaseClassLoader, null);
            StrictMode.setThreadPolicy(oldPolicy);
            mAppComponentFactory = AppComponentFactory.DEFAULT;
        }
        if (mClassLoader == null) {
            mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader, new ApplicationInfo(mApplicationInfo));
        }
        return;
    }
    /*
         * With all the combination done (if necessary, actually create the java class
         * loader and set up JIT profiling support if necessary.
         *
         * In many cases this is a single APK, so try to avoid the StringBuilder in TextUtils.
         */
    final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) : TextUtils.join(File.pathSeparator, zipPaths);
    if (DEBUG)
        Slog.v(ActivityThread.TAG, "Class path: " + zip + ", JNI path: " + librarySearchPath);
    boolean needToSetupJitProfiles = false;
    if (mDefaultClassLoader == null) {
        // Temporarily disable logging of disk reads on the Looper thread
        // as this is early and necessary.
        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
        List<ClassLoader> sharedLibraries = createSharedLibrariesLoaders(mApplicationInfo.sharedLibraryInfos, isBundledApp, librarySearchPath, libraryPermittedPath);
        mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath, libraryPermittedPath, mBaseClassLoader, mApplicationInfo.classLoaderName, sharedLibraries);
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        StrictMode.setThreadPolicy(oldPolicy);
        // Setup the class loader paths for profiling.
        needToSetupJitProfiles = true;
    }
    if (!libPaths.isEmpty() && SystemProperties.getBoolean(PROPERTY_NAME_APPEND_NATIVE, true)) {
        // Temporarily disable logging of disk reads on the Looper thread as this is necessary
        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, libPaths);
        } finally {
            StrictMode.setThreadPolicy(oldPolicy);
        }
    }
    // /aepx/com.android.runtime/lib, /vendor/lib, /odm/lib and /product/lib
    // are added to the native lib search paths of the classloader.
    // Note that this is done AFTER the classloader is
    // created by ApplicationLoaders.getDefault().getClassLoader(...). The
    // reason is because if we have added the paths when creating the classloader
    // above, the paths are also added to the search path of the linker namespace
    // 'classloader-namespace', which will allow ALL libs in the paths to apps.
    // Since only the libs listed in <partition>/etc/public.libraries.txt can be
    // available to apps, we shouldn't add the paths then.
    // 
    // However, we need to add the paths to the classloader (Java) though. This
    // is because when a native lib is requested via System.loadLibrary(), the
    // classloader first tries to find the requested lib in its own native libs
    // search paths. If a lib is not found in one of the paths, dlopen() is not
    // called at all. This can cause a problem that a vendor public native lib
    // is accessible when directly opened via dlopen(), but inaccesible via
    // System.loadLibrary(). In order to prevent the problem, we explicitly
    // add the paths only to the classloader, and not to the native loader
    // (linker namespace).
    List<String> extraLibPaths = new ArrayList<>(4);
    String abiSuffix = VMRuntime.getRuntime().is64Bit() ? "64" : "";
    if (!defaultSearchPaths.contains("/apex/com.android.runtime/lib")) {
        extraLibPaths.add("/apex/com.android.runtime/lib" + abiSuffix);
    }
    if (!defaultSearchPaths.contains("/vendor/lib")) {
        extraLibPaths.add("/vendor/lib" + abiSuffix);
    }
    if (!defaultSearchPaths.contains("/odm/lib")) {
        extraLibPaths.add("/odm/lib" + abiSuffix);
    }
    if (!defaultSearchPaths.contains("/product/lib")) {
        extraLibPaths.add("/product/lib" + abiSuffix);
    }
    if (!extraLibPaths.isEmpty()) {
        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, extraLibPaths);
        } finally {
            StrictMode.setThreadPolicy(oldPolicy);
        }
    }
    if (addedPaths != null && addedPaths.size() > 0) {
        final String add = TextUtils.join(File.pathSeparator, addedPaths);
        ApplicationLoaders.getDefault().addPath(mDefaultClassLoader, add);
        // Setup the new code paths for profiling.
        needToSetupJitProfiles = true;
    }
    // loads code from) so we explicitly disallow it there.
    if (needToSetupJitProfiles && !ActivityThread.isSystem()) {
        setupJitProfileSupport();
    }
    // Invoke with a copy of ApplicationInfo to protect against the app changing it.
    if (mClassLoader == null) {
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader, new ApplicationInfo(mApplicationInfo));
    }
}
#method_after
private void createOrUpdateClassLoaderLocked(List<String> addedPaths) {
    if (mPackageName.equals("android")) {
        // jit profiling support.
        if (mClassLoader != null) {
            // nothing to update
            return;
        }
        if (mBaseClassLoader != null) {
            mDefaultClassLoader = mBaseClassLoader;
        } else {
            mDefaultClassLoader = ClassLoader.getSystemClassLoader();
        }
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader, new ApplicationInfo(mApplicationInfo));
        return;
    }
    // spinning up the process.
    if (!Objects.equals(mPackageName, ActivityThread.currentPackageName()) && mIncludeCode) {
        try {
            ActivityThread.getPackageManager().notifyPackageUse(mPackageName, PackageManager.NOTIFY_PACKAGE_USE_CROSS_PACKAGE);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }
    if (mRegisterPackage) {
        try {
            ActivityManager.getService().addPackageDependency(mPackageName);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    // Lists for the elements of zip/code and native libraries.
    // 
    // Both lists are usually not empty. We expect on average one APK for the zip component,
    // but shared libraries and splits are not uncommon. We expect at least three elements
    // for native libraries (app-based, system, vendor). As such, give both some breathing
    // space and initialize to a small value (instead of incurring growth code).
    final List<String> zipPaths = new ArrayList<>(10);
    final List<String> libPaths = new ArrayList<>(10);
    boolean isBundledApp = mApplicationInfo.isSystemApp() && !mApplicationInfo.isUpdatedSystemApp();
    // Vendor apks are treated as bundled only when /vendor/lib is in the default search
    // paths. If not, they are treated as unbundled; access to system libs is limited.
    // Having /vendor/lib in the default search paths means that all system processes
    // are allowed to use any vendor library, which in turn means that system is dependent
    // on vendor partition. In the contrary, not having /vendor/lib in the default search
    // paths mean that the two partitions are separated and thus we can treat vendor apks
    // as unbundled.
    final String defaultSearchPaths = System.getProperty("java.library.path");
    final boolean treatVendorApkAsUnbundled = !defaultSearchPaths.contains("/vendor/lib");
    if (mApplicationInfo.getCodePath() != null && mApplicationInfo.isVendor() && treatVendorApkAsUnbundled) {
        isBundledApp = false;
    }
    // Similar to vendor apks, we should add /product/lib for apks from product partition
    // and not having /product/lib in the default search path
    final boolean treatProductApkAsUnbundled = !defaultSearchPaths.contains("/product/lib");
    if (mApplicationInfo.getCodePath() != null && mApplicationInfo.isProduct() && treatProductApkAsUnbundled && // TODO(b/128557860): Change target SDK version when version code R is available.
    getTargetSdkVersion() == Build.VERSION_CODES.CUR_DEVELOPMENT) {
        isBundledApp = false;
    }
    makePaths(mActivityThread, isBundledApp, mApplicationInfo, zipPaths, libPaths);
    String libraryPermittedPath = mDataDir;
    if (isBundledApp) {
        // For bundled apps, add the base directory of the app (e.g.,
        // /system/app/Foo/) to the permitted paths so that it can load libraries
        // embedded in module apks under the directory. For now, GmsCore is relying
        // on this, but this isn't specific to the app. Also note that, we don't
        // need to do this for unbundled apps as entire /data is already set to
        // the permitted paths for them.
        libraryPermittedPath += File.pathSeparator + Paths.get(getAppDir()).getParent().toString();
        // This is necessary to grant bundled apps access to
        // libraries located in subdirectories of /system/lib
        libraryPermittedPath += File.pathSeparator + defaultSearchPaths;
    }
    final String librarySearchPath = TextUtils.join(File.pathSeparator, libPaths);
    // mIncludeCode == false).
    if (!mIncludeCode) {
        if (mDefaultClassLoader == null) {
            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
            mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoader("", /* codePath */
            mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath, libraryPermittedPath, mBaseClassLoader, null);
            StrictMode.setThreadPolicy(oldPolicy);
            mAppComponentFactory = AppComponentFactory.DEFAULT;
        }
        if (mClassLoader == null) {
            mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader, new ApplicationInfo(mApplicationInfo));
        }
        return;
    }
    /*
         * With all the combination done (if necessary, actually create the java class
         * loader and set up JIT profiling support if necessary.
         *
         * In many cases this is a single APK, so try to avoid the StringBuilder in TextUtils.
         */
    final String zip = (zipPaths.size() == 1) ? zipPaths.get(0) : TextUtils.join(File.pathSeparator, zipPaths);
    if (DEBUG)
        Slog.v(ActivityThread.TAG, "Class path: " + zip + ", JNI path: " + librarySearchPath);
    boolean needToSetupJitProfiles = false;
    if (mDefaultClassLoader == null) {
        // Temporarily disable logging of disk reads on the Looper thread
        // as this is early and necessary.
        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
        List<ClassLoader> sharedLibraries = createSharedLibrariesLoaders(mApplicationInfo.sharedLibraryInfos, isBundledApp, librarySearchPath, libraryPermittedPath);
        mDefaultClassLoader = ApplicationLoaders.getDefault().getClassLoaderWithSharedLibraries(zip, mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath, libraryPermittedPath, mBaseClassLoader, mApplicationInfo.classLoaderName, sharedLibraries);
        mAppComponentFactory = createAppFactory(mApplicationInfo, mDefaultClassLoader);
        StrictMode.setThreadPolicy(oldPolicy);
        // Setup the class loader paths for profiling.
        needToSetupJitProfiles = true;
    }
    if (!libPaths.isEmpty() && SystemProperties.getBoolean(PROPERTY_NAME_APPEND_NATIVE, true)) {
        // Temporarily disable logging of disk reads on the Looper thread as this is necessary
        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, libPaths);
        } finally {
            StrictMode.setThreadPolicy(oldPolicy);
        }
    }
    // /aepx/com.android.runtime/lib, /vendor/lib, /odm/lib and /product/lib
    // are added to the native lib search paths of the classloader.
    // Note that this is done AFTER the classloader is
    // created by ApplicationLoaders.getDefault().getClassLoader(...). The
    // reason is because if we have added the paths when creating the classloader
    // above, the paths are also added to the search path of the linker namespace
    // 'classloader-namespace', which will allow ALL libs in the paths to apps.
    // Since only the libs listed in <partition>/etc/public.libraries.txt can be
    // available to apps, we shouldn't add the paths then.
    // 
    // However, we need to add the paths to the classloader (Java) though. This
    // is because when a native lib is requested via System.loadLibrary(), the
    // classloader first tries to find the requested lib in its own native libs
    // search paths. If a lib is not found in one of the paths, dlopen() is not
    // called at all. This can cause a problem that a vendor public native lib
    // is accessible when directly opened via dlopen(), but inaccesible via
    // System.loadLibrary(). In order to prevent the problem, we explicitly
    // add the paths only to the classloader, and not to the native loader
    // (linker namespace).
    List<String> extraLibPaths = new ArrayList<>(4);
    String abiSuffix = VMRuntime.getRuntime().is64Bit() ? "64" : "";
    if (!defaultSearchPaths.contains("/apex/com.android.runtime/lib")) {
        extraLibPaths.add("/apex/com.android.runtime/lib" + abiSuffix);
    }
    if (!defaultSearchPaths.contains("/vendor/lib")) {
        extraLibPaths.add("/vendor/lib" + abiSuffix);
    }
    if (!defaultSearchPaths.contains("/odm/lib")) {
        extraLibPaths.add("/odm/lib" + abiSuffix);
    }
    if (!defaultSearchPaths.contains("/product/lib")) {
        extraLibPaths.add("/product/lib" + abiSuffix);
    }
    if (!extraLibPaths.isEmpty()) {
        StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();
        try {
            ApplicationLoaders.getDefault().addNative(mDefaultClassLoader, extraLibPaths);
        } finally {
            StrictMode.setThreadPolicy(oldPolicy);
        }
    }
    if (addedPaths != null && addedPaths.size() > 0) {
        final String add = TextUtils.join(File.pathSeparator, addedPaths);
        ApplicationLoaders.getDefault().addPath(mDefaultClassLoader, add);
        // Setup the new code paths for profiling.
        needToSetupJitProfiles = true;
    }
    // loads code from) so we explicitly disallow it there.
    if (needToSetupJitProfiles && !ActivityThread.isSystem()) {
        setupJitProfileSupport();
    }
    // Invoke with a copy of ApplicationInfo to protect against the app changing it.
    if (mClassLoader == null) {
        mClassLoader = mAppComponentFactory.instantiateClassLoader(mDefaultClassLoader, new ApplicationInfo(mApplicationInfo));
    }
}
#end_block

#method_before
public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
    Bundle rootExtras = null;
    int clientPid = RemoteUserInfo.UNKNOWN_PID;
    if (rootHints != null && rootHints.getInt(EXTRA_CLIENT_VERSION, 0) != 0) {
        rootHints.remove(EXTRA_CLIENT_VERSION);
        mMessenger = new Messenger(mHandler);
        rootExtras = new Bundle();
        rootExtras.putInt(EXTRA_SERVICE_VERSION, SERVICE_VERSION_CURRENT);
        BundleCompat.putBinder(rootExtras, EXTRA_MESSENGER_BINDER, mMessenger.getBinder());
        if (mSession != null) {
            IMediaSession extraBinder = mSession.getExtraBinder();
            BundleCompat.putBinder(rootExtras, EXTRA_SESSION_BINDER, extraBinder == null ? null : extraBinder.asBinder());
        } else {
            mRootExtrasList.add(rootExtras);
        }
        clientPid = rootHints.getInt(EXTRA_CALLING_PID, RemoteUserInfo.UNKNOWN_PID);
        rootHints.remove(EXTRA_CALLING_PID);
    }
    ConnectionRecord connection = new ConnectionRecord(clientPackageName, clientPid, clientUid, rootHints, null);
    // We aren't sure whether this connection request would be accepted.
    // Temporarily set mCurConnection just to make getCurrentBrowserInfo() working.
    mCurConnection = connection;
    BrowserRoot root = MediaBrowserServiceCompat.this.onGetRoot(clientPackageName, clientUid, rootHints);
    mCurConnection = null;
    if (root == null) {
        return null;
    }
    if (mMessenger != null) {
        // Keeps the connection request from the MediaBrowserCompat to reuse the package
        // name here.
        mPendingConnections.add(connection);
    }
    if (rootExtras == null) {
        rootExtras = root.getExtras();
    } else if (root.getExtras() != null) {
        rootExtras.putAll(root.getExtras());
    }
    return new BrowserRoot(root.getRootId(), rootExtras);
}
#method_after
public BrowserRoot onGetRoot(String clientPackageName, int clientUid, Bundle rootHints) {
    Bundle rootExtras = null;
    int clientPid = UNKNOWN_PID;
    if (rootHints != null && rootHints.getInt(EXTRA_CLIENT_VERSION, 0) != 0) {
        rootHints.remove(EXTRA_CLIENT_VERSION);
        mMessenger = new Messenger(mHandler);
        rootExtras = new Bundle();
        rootExtras.putInt(EXTRA_SERVICE_VERSION, SERVICE_VERSION_CURRENT);
        BundleCompat.putBinder(rootExtras, EXTRA_MESSENGER_BINDER, mMessenger.getBinder());
        if (mSession != null) {
            IMediaSession extraBinder = mSession.getExtraBinder();
            BundleCompat.putBinder(rootExtras, EXTRA_SESSION_BINDER, extraBinder == null ? null : extraBinder.asBinder());
        } else {
            mRootExtrasList.add(rootExtras);
        }
        clientPid = rootHints.getInt(EXTRA_CALLING_PID, UNKNOWN_PID);
        rootHints.remove(EXTRA_CALLING_PID);
    }
    ConnectionRecord connection = new ConnectionRecord(clientPackageName, clientPid, clientUid, rootHints, null);
    // We aren't sure whether this connection request would be accepted.
    // Temporarily set mCurConnection just to make getCurrentBrowserInfo() working.
    mCurConnection = connection;
    BrowserRoot root = MediaBrowserServiceCompat.this.onGetRoot(clientPackageName, clientUid, rootHints);
    mCurConnection = null;
    if (root == null) {
        return null;
    }
    if (mMessenger != null) {
        // Keeps the connection request from the MediaBrowserCompat to reuse the package
        // name here.
        // Note: Connection will be completed after it gets extra binder call with
        // CLIENT_MSG_REGISTER_CALLBACK_MESSENGER.
        mPendingConnections.add(connection);
    }
    if (rootExtras == null) {
        rootExtras = root.getExtras();
    } else if (root.getExtras() != null) {
        rootExtras.putAll(root.getExtras());
    }
    return new BrowserRoot(root.getRootId(), rootExtras);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    Bundle data = msg.getData();
    switch(msg.what) {
        case CLIENT_MSG_CONNECT:
            {
                Bundle rootHints = data.getBundle(DATA_ROOT_HINTS);
                MediaSessionCompat.ensureClassLoader(rootHints);
                mServiceBinderImpl.connect(data.getString(DATA_PACKAGE_NAME), data.getInt(DATA_CALLING_PID, UNKNOWN_PID), data.getInt(DATA_CALLING_UID), rootHints, new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        case CLIENT_MSG_DISCONNECT:
            mServiceBinderImpl.disconnect(new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_ADD_SUBSCRIPTION:
            {
                Bundle options = data.getBundle(DATA_OPTIONS);
                MediaSessionCompat.ensureClassLoader(options);
                mServiceBinderImpl.addSubscription(data.getString(DATA_MEDIA_ITEM_ID), BundleCompat.getBinder(data, DATA_CALLBACK_TOKEN), options, new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        case CLIENT_MSG_REMOVE_SUBSCRIPTION:
            mServiceBinderImpl.removeSubscription(data.getString(DATA_MEDIA_ITEM_ID), BundleCompat.getBinder(data, DATA_CALLBACK_TOKEN), new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_GET_MEDIA_ITEM:
            mServiceBinderImpl.getMediaItem(data.getString(DATA_MEDIA_ITEM_ID), (ResultReceiver) data.getParcelable(DATA_RESULT_RECEIVER), new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_REGISTER_CALLBACK_MESSENGER:
            {
                Bundle rootHints = data.getBundle(DATA_ROOT_HINTS);
                MediaSessionCompat.ensureClassLoader(rootHints);
                mServiceBinderImpl.registerCallbacks(new ServiceCallbacksCompat(msg.replyTo), data.getString(DATA_PACKAGE_NAME), data.getInt(DATA_CALLING_PID, UNKNOWN_PID), data.getInt(DATA_CALLING_UID), rootHints);
                break;
            }
        case CLIENT_MSG_UNREGISTER_CALLBACK_MESSENGER:
            mServiceBinderImpl.unregisterCallbacks(new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_SEARCH:
            {
                Bundle searchExtras = data.getBundle(DATA_SEARCH_EXTRAS);
                MediaSessionCompat.ensureClassLoader(searchExtras);
                mServiceBinderImpl.search(data.getString(DATA_SEARCH_QUERY), searchExtras, (ResultReceiver) data.getParcelable(DATA_RESULT_RECEIVER), new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        case CLIENT_MSG_SEND_CUSTOM_ACTION:
            {
                Bundle customActionExtras = data.getBundle(DATA_CUSTOM_ACTION_EXTRAS);
                MediaSessionCompat.ensureClassLoader(customActionExtras);
                mServiceBinderImpl.sendCustomAction(data.getString(DATA_CUSTOM_ACTION), customActionExtras, (ResultReceiver) data.getParcelable(DATA_RESULT_RECEIVER), new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        default:
            Log.w(TAG, "Unhandled message: " + msg + "\n  Service version: " + SERVICE_VERSION_CURRENT + "\n  Client version: " + msg.arg1);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    Bundle data = msg.getData();
    switch(msg.what) {
        case CLIENT_MSG_CONNECT:
            {
                Bundle rootHints = data.getBundle(DATA_ROOT_HINTS);
                MediaSessionCompat.ensureClassLoader(rootHints);
                mServiceBinderImpl.connect(data.getString(DATA_PACKAGE_NAME), data.getInt(DATA_CALLING_PID), data.getInt(DATA_CALLING_UID), rootHints, new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        case CLIENT_MSG_DISCONNECT:
            mServiceBinderImpl.disconnect(new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_ADD_SUBSCRIPTION:
            {
                Bundle options = data.getBundle(DATA_OPTIONS);
                MediaSessionCompat.ensureClassLoader(options);
                mServiceBinderImpl.addSubscription(data.getString(DATA_MEDIA_ITEM_ID), BundleCompat.getBinder(data, DATA_CALLBACK_TOKEN), options, new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        case CLIENT_MSG_REMOVE_SUBSCRIPTION:
            mServiceBinderImpl.removeSubscription(data.getString(DATA_MEDIA_ITEM_ID), BundleCompat.getBinder(data, DATA_CALLBACK_TOKEN), new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_GET_MEDIA_ITEM:
            mServiceBinderImpl.getMediaItem(data.getString(DATA_MEDIA_ITEM_ID), (ResultReceiver) data.getParcelable(DATA_RESULT_RECEIVER), new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_REGISTER_CALLBACK_MESSENGER:
            {
                Bundle rootHints = data.getBundle(DATA_ROOT_HINTS);
                MediaSessionCompat.ensureClassLoader(rootHints);
                mServiceBinderImpl.registerCallbacks(new ServiceCallbacksCompat(msg.replyTo), data.getString(DATA_PACKAGE_NAME), data.getInt(DATA_CALLING_PID), data.getInt(DATA_CALLING_UID), rootHints);
                break;
            }
        case CLIENT_MSG_UNREGISTER_CALLBACK_MESSENGER:
            mServiceBinderImpl.unregisterCallbacks(new ServiceCallbacksCompat(msg.replyTo));
            break;
        case CLIENT_MSG_SEARCH:
            {
                Bundle searchExtras = data.getBundle(DATA_SEARCH_EXTRAS);
                MediaSessionCompat.ensureClassLoader(searchExtras);
                mServiceBinderImpl.search(data.getString(DATA_SEARCH_QUERY), searchExtras, (ResultReceiver) data.getParcelable(DATA_RESULT_RECEIVER), new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        case CLIENT_MSG_SEND_CUSTOM_ACTION:
            {
                Bundle customActionExtras = data.getBundle(DATA_CUSTOM_ACTION_EXTRAS);
                MediaSessionCompat.ensureClassLoader(customActionExtras);
                mServiceBinderImpl.sendCustomAction(data.getString(DATA_CUSTOM_ACTION), customActionExtras, (ResultReceiver) data.getParcelable(DATA_RESULT_RECEIVER), new ServiceCallbacksCompat(msg.replyTo));
                break;
            }
        default:
            Log.w(TAG, "Unhandled message: " + msg + "\n  Service version: " + SERVICE_VERSION_CURRENT + "\n  Client version: " + msg.arg1);
    }
}
#end_block

#method_before
@Override
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    // Binder.getCallingUid() in handleMessage will return the uid of this process.
    // In order to get the right calling uid, Binder.getCallingUid() should be called here.
    Bundle data = msg.getData();
    data.setClassLoader(MediaBrowserCompat.class.getClassLoader());
    data.putInt(DATA_CALLING_UID, Binder.getCallingUid());
    int pid = Binder.getCallingPid();
    // So trust PID from the incoming data if it's the case.
    if (pid != 0) {
        data.putInt(DATA_CALLING_PID, pid);
    }
    return super.sendMessageAtTime(msg, uptimeMillis);
}
#method_after
@Override
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    // Binder.getCallingUid() in handleMessage will return the uid of this process.
    // In order to get the right calling uid, Binder.getCallingUid() should be called here.
    Bundle data = msg.getData();
    data.setClassLoader(MediaBrowserCompat.class.getClassLoader());
    data.putInt(DATA_CALLING_UID, Binder.getCallingUid());
    int pid = Binder.getCallingPid();
    if (pid > 0) {
        data.putInt(DATA_CALLING_PID, pid);
    } else if (data.getLong(DATA_CALLING_PID, UNKNOWN_PID) == UNKNOWN_PID) {
        data.putInt(DATA_CALLING_PID, UNKNOWN_PID);
    }
    return super.sendMessageAtTime(msg, uptimeMillis);
}
#end_block

#method_before
public void registerCallbacks(final ServiceCallbacks callbacks, final String pkg, final int pid, final int uid, final Bundle rootHints) {
    mHandler.postOrRun(new Runnable() {

        @Override
        public void run() {
            final IBinder b = callbacks.asBinder();
            // Clear out the old subscriptions. We are getting new ones.
            mConnections.remove(b);
            ConnectionRecord connection = null;
            // the older version. Do the best effort to guess.
            if (TextUtils.isEmpty(pkg) || pid <= 0) {
                // Use heuristic to pick
                for (ConnectionRecord pendingConnection : mPendingConnections) {
                    if (pendingConnection.uid == uid) {
                        // Do not assign pendingConnection directly because it doesn't have
                        // callback information.
                        connection = new ConnectionRecord(pendingConnection.pkg, pendingConnection.pid, pendingConnection.uid, rootHints, callbacks);
                        mPendingConnections.remove(pendingConnection);
                        break;
                    }
                }
            }
            if (connection == null) {
                connection = new ConnectionRecord(pkg, pid, uid, rootHints, callbacks);
            }
            mConnections.put(b, connection);
            try {
                b.linkToDeath(connection, 0);
            } catch (RemoteException e) {
                Log.w(TAG, "IBinder is already dead.");
            }
        }
    });
}
#method_after
public void registerCallbacks(final ServiceCallbacks callbacks, final String pkg, final int pid, final int uid, final Bundle rootHints) {
    mHandler.postOrRun(new Runnable() {

        @Override
        public void run() {
            final IBinder b = callbacks.asBinder();
            // Clear out the old subscriptions. We are getting new ones.
            mConnections.remove(b);
            ConnectionRecord connection = null;
            for (ConnectionRecord pendingConnection : mPendingConnections) {
                // multiple MediaBrowserCompats with the same UID can request connect.
                if (pendingConnection.uid == uid) {
                    // If caller hasn't set pkg and pid, do the best effort to get it.
                    if (TextUtils.isEmpty(pkg) || pid <= 0) {
                        // Note: Do not assign pendingConnection directly because it doesn't
                        // have callback information.
                        connection = new ConnectionRecord(pendingConnection.pkg, pendingConnection.pid, pendingConnection.uid, rootHints, callbacks);
                    }
                    mPendingConnections.remove(pendingConnection);
                }
            }
            if (connection == null) {
                connection = new ConnectionRecord(pkg, pid, uid, rootHints, callbacks);
            }
            mConnections.put(b, connection);
            try {
                b.linkToDeath(connection, 0);
            } catch (RemoteException e) {
                Log.w(TAG, "IBinder is already dead.");
            }
        }
    });
}
#end_block

#method_before
@Override
public int hashCode() {
    if (mPid == UNKNOWN_PID) {
        return ObjectsCompat.hash(mPackageName, mUid);
    }
    return ObjectsCompat.hash(mPackageName, mPid, mUid);
}
#method_after
@Override
public int hashCode() {
    return ObjectsCompat.hash(mPackageName, mUid);
}
#end_block

#method_before
@Override
public Certificate[] engineGetCertificateChain(String alias) {
    if (alias == null) {
        throw new NullPointerException("alias == null");
    }
    final X509Certificate leaf = (X509Certificate) engineGetCertificate(alias);
    if (leaf == null) {
        return null;
    }
    final Certificate[] caList;
    // Suppress the key not found warning for this call. It seems that this error is exclusively
    // being thrown when there is a self signed certificate chain, so when the keystore service
    // attempts to query for the CA details, it obviously fails to find them and returns a
    // key not found exception. This is WAI, and throwing a stack trace here can be very
    // misleading since the trace is not clear.
    final byte[] caBytes = mKeyStore.get(Credentials.CA_CERTIFICATE + alias, mUid, true);
    if (caBytes != null) {
        final Collection<X509Certificate> caChain = toCertificates(caBytes);
        caList = new Certificate[caChain.size() + 1];
        final Iterator<X509Certificate> it = caChain.iterator();
        int i = 1;
        while (it.hasNext()) {
            caList[i++] = it.next();
        }
    } else {
        caList = new Certificate[0];
    }
    caList[0] = leaf;
    return caList;
}
#method_after
@Override
public Certificate[] engineGetCertificateChain(String alias) {
    if (alias == null) {
        throw new NullPointerException("alias == null");
    }
    final X509Certificate leaf = (X509Certificate) engineGetCertificate(alias);
    if (leaf == null) {
        return null;
    }
    final Certificate[] caList;
    // Suppress the key not found warning for this call. It seems that this error is exclusively
    // being thrown when there is a self signed certificate chain, so when the keystore service
    // attempts to query for the CA details, it obviously fails to find them and returns a
    // key not found exception. This is WAI, and throwing a stack trace here can be very
    // misleading since the trace is not clear.
    final byte[] caBytes = mKeyStore.get(Credentials.CA_CERTIFICATE + alias, mUid, true);
    if (caBytes != null) {
        final Collection<X509Certificate> caChain = toCertificates(caBytes);
        caList = new Certificate[caChain.size() + 1];
        final Iterator<X509Certificate> it = caChain.iterator();
        int i = 1;
        while (it.hasNext()) {
            caList[i++] = it.next();
        }
    } else {
        caList = new Certificate[1];
    }
    caList[0] = leaf;
    return caList;
}
#end_block

#method_before
private void makeInjectedInstance() {
    String validatedPath = getValidatedPath();
    Rlog.d(TAG, "validated path: " + validatedPath);
    if (!TextUtils.isEmpty(validatedPath)) {
        try {
            PathClassLoader classLoader = new PathClassLoader(validatedPath, ClassLoader.getSystemClassLoader());
            Class<?> cls = classLoader.loadClass(mPackageName);
            mInjectedInstance = (TelephonyComponentFactory) cls.newInstance();
        } catch (ClassNotFoundException e) {
            Rlog.e(TAG, "failed: " + e.getMessage());
        } catch (IllegalAccessException | InstantiationException e) {
            Rlog.e(TAG, "injection failed: " + e.getMessage());
        }
    }
}
#method_after
private void makeInjectedInstance() {
    String validatedPaths = getValidatedPaths();
    Rlog.d(TAG, "validated paths: " + validatedPaths);
    if (!TextUtils.isEmpty(validatedPaths)) {
        try {
            PathClassLoader classLoader = new PathClassLoader(validatedPaths, ClassLoader.getSystemClassLoader());
            Class<?> cls = classLoader.loadClass(mPackageName);
            mInjectedInstance = (TelephonyComponentFactory) cls.newInstance();
        } catch (ClassNotFoundException e) {
            Rlog.e(TAG, "failed: " + e.getMessage());
        } catch (IllegalAccessException | InstantiationException e) {
            Rlog.e(TAG, "injection failed: " + e.getMessage());
        }
    }
}
#end_block

#method_before
public void injectTheComponentFactory(XmlResourceParser parser) {
    if (mInjectedComponents != null) {
        Rlog.d(TAG, "Already injected.");
        return;
    }
    if (parser != null) {
        mInjectedComponents = new InjectedComponents();
        mInjectedComponents.parseXml(parser);
        mInjectedComponents.makeInjectedInstance();
        boolean injectSuccessful = !TextUtils.isEmpty(mInjectedComponents.getValidatedPath());
        Rlog.d(TAG, "Total components injected: " + (injectSuccessful ? mInjectedComponents.mComponentNames.size() : 0));
    }
}
#method_after
public void injectTheComponentFactory(XmlResourceParser parser) {
    if (mInjectedComponents != null) {
        Rlog.d(TAG, "Already injected.");
        return;
    }
    if (parser != null) {
        mInjectedComponents = new InjectedComponents();
        mInjectedComponents.parseXml(parser);
        mInjectedComponents.makeInjectedInstance();
        boolean injectSuccessful = !TextUtils.isEmpty(mInjectedComponents.getValidatedPaths());
        Rlog.d(TAG, "Total components injected: " + (injectSuccessful ? mInjectedComponents.mComponentNames.size() : 0));
    }
}
#end_block

#method_before
public static void main(String... args) {
    JUnitCore core = new JUnitCore();
    Result result = null;
    try {
        Class[] as = Stream.of(args).map(test -> {
            try {
                return Class.forName(test);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }).toArray(Class[]::new);
        TextListener textListener = new TextListener(System.out);
        core.addListener(textListener);
        XmlRunListener xmlListener = getRunListener();
        if (xmlListener != null) {
            core.addListener(xmlListener);
        }
        // Add SubprocessRunListener to communicate with ATest.
        SubprocessRunListener procRunListener = getSubprocessResultListener(calcTestCount(as));
        // Send start event tag to atest.
        if (procRunListener != null) {
            core.addListener(procRunListener);
            procRunListener.testModuleStart();
            procRunListener.testRunStart();
        }
        result = core.run(as);
        if (xmlListener != null) {
            xmlListener.endTestSuite();
        }
        // Send end event tag to atest.
        if (procRunListener != null) {
            procRunListener.testRunEnd();
            procRunListener.testModuleEnd();
        }
        System.exit(result.wasSuccessful() ? 0 : 1);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
public static void main(String... args) {
    JUnitCore core = new JUnitCore();
    try {
        Class[] as = Stream.of(args).map(test -> {
            try {
                return Class.forName(test);
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }).toArray(Class[]::new);
        TextListener textListener = new TextListener(System.out);
        core.addListener(textListener);
        XmlRunListener xmlListener = getRunListener();
        if (xmlListener != null) {
            core.addListener(xmlListener);
        }
        // Add AtestRunListener to communicate with ATest.
        AtestRunListener atestRunListener = getAtestRunListener(calcTestCount(as));
        if (atestRunListener != null) {
            core.addListener(atestRunListener);
        }
        Result result = core.run(as);
        if (xmlListener != null) {
            xmlListener.endTestSuite();
        }
        System.exit(result.wasSuccessful() ? 0 : 1);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private static int calcTestCount(Class[] as) {
    int count = 0;
    for (Class cls : as) {
        Method[] declaredMethods = cls.getMethods();
        for (Method method : declaredMethods) {
            Annotation[] annotations = method.getAnnotations();
            for (Annotation anno : annotations) {
                if (anno.annotationType().equals(org.junit.Test.class)) {
                    count++;
                }
            }
        }
    }
    return count;
}
#method_after
private static int calcTestCount(Class[] as) {
    int count = 0;
    for (Class cls : as) {
        Method[] declaredMethods = cls.getMethods();
        for (Method method : declaredMethods) {
            if (method.isAnnotationPresent(Test.class)) {
                count++;
            }
        }
    }
    return count;
}
#end_block

#method_before
@Override
public boolean isLocationEnabledForUser(int userId) {
    // Check INTERACT_ACROSS_USERS permission if userId is not current user id.
    checkInteractAcrossUsersPermission(userId);
    long identity = Binder.clearCallingIdentity();
    try {
        synchronized (mLock) {
            final String allowedProviders = Settings.Secure.getStringForUser(mContext.getContentResolver(), Settings.Secure.LOCATION_PROVIDERS_ALLOWED, userId);
            if (allowedProviders == null) {
                return isLocationEnabledForUserWithPFallback(userId);
            }
            final List<String> providerList = Arrays.asList(allowedProviders.split(","));
            for (String provider : mRealProviders.keySet()) {
                if (provider.equals(LocationManager.PASSIVE_PROVIDER) || provider.equals(LocationManager.FUSED_PROVIDER)) {
                    continue;
                }
                if (providerList.contains(provider)) {
                    return true;
                }
            }
            return isLocationEnabledForUserWithPFallback(userId);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#method_after
@Override
public boolean isLocationEnabledForUser(int userId) {
    // Check INTERACT_ACROSS_USERS permission if userId is not current user id.
    checkInteractAcrossUsersPermission(userId);
    long identity = Binder.clearCallingIdentity();
    try {
        synchronized (mLock) {
            return Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF, userId) != Settings.Secure.LOCATION_MODE_OFF;
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Override
public void setLocationEnabledForUser(boolean enabled, int userId) {
    mContext.enforceCallingPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS, "Requires WRITE_SECURE_SETTINGS permission");
    // Check INTERACT_ACROSS_USERS permission if userId is not current user id.
    checkInteractAcrossUsersPermission(userId);
    long identity = Binder.clearCallingIdentity();
    try {
        synchronized (mLock) {
            final Set<String> allRealProviders = mRealProviders.keySet();
            // Update all providers on device plus gps and network provider when disabling
            // location
            Set<String> allProvidersSet = new ArraySet<>(allRealProviders.size() + 2);
            allProvidersSet.addAll(allRealProviders);
            // enabled by location mode api.
            if (enabled == false) {
                allProvidersSet.add(LocationManager.GPS_PROVIDER);
                allProvidersSet.add(LocationManager.NETWORK_PROVIDER);
            }
            if (allProvidersSet.isEmpty()) {
                return;
            }
            // to ensure thread safety, we write the provider name with a '+' or '-'
            // and let the SettingsProvider handle it rather than reading and modifying
            // the list of enabled providers.
            final String prefix = enabled ? "+" : "-";
            StringBuilder locationProvidersAllowed = new StringBuilder();
            for (String provider : allProvidersSet) {
                if (provider.equals(LocationManager.PASSIVE_PROVIDER) || provider.equals(LocationManager.FUSED_PROVIDER)) {
                    continue;
                }
                locationProvidersAllowed.append(prefix);
                locationProvidersAllowed.append(provider);
                locationProvidersAllowed.append(",");
            }
            // Remove the trailing comma
            locationProvidersAllowed.setLength(locationProvidersAllowed.length() - 1);
            Settings.Secure.putStringForUser(mContext.getContentResolver(), Settings.Secure.LOCATION_PROVIDERS_ALLOWED, locationProvidersAllowed.toString(), userId);
            Settings.Secure.putStringForUser(mContext.getContentResolver(), Settings.Secure.LOCATION_MODE, Integer.toString(enabled ? Settings.Secure.LOCATION_MODE_HIGH_ACCURACY : Settings.Secure.LOCATION_MODE_OFF), userId);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#method_after
@Override
public void setLocationEnabledForUser(boolean enabled, int userId) {
    mContext.enforceCallingPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS, "Requires WRITE_SECURE_SETTINGS permission");
    // Check INTERACT_ACROSS_USERS permission if userId is not current user id.
    checkInteractAcrossUsersPermission(userId);
    long identity = Binder.clearCallingIdentity();
    try {
        synchronized (mLock) {
            int locationMode = enabled ? Settings.Secure.LOCATION_MODE_HIGH_ACCURACY : Settings.Secure.LOCATION_MODE_OFF;
            Settings.Secure.putIntForUser(mContext.getContentResolver(), Settings.Secure.LOCATION_MODE, locationMode, userId);
        }
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@NonNull
public static View.OnClickListener createNavigateOnClickListener(@NonNull final NavDirections directions) {
    return createNavigateOnClickListener(directions.getActionId(), directions.getArguments());
}
#method_after
@NonNull
public static View.OnClickListener createNavigateOnClickListener(@NonNull final NavDirections directions) {
    return new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            findNavController(view).navigate(directions);
        }
    };
}
#end_block

#method_before
private static void appendTriggerName(StringBuilder builder, String tableName, String tableId, String triggerType) {
    builder.append("`").append("room_table_modification_trigger_").append(tableName).append("_").append(tableId).append("_").append(triggerType).append("`");
}
#method_after
private static void appendTriggerName(StringBuilder builder, String tableName, String triggerType) {
    builder.append("`").append("room_table_modification_trigger_").append(tableName).append("_").append(triggerType).append("`");
}
#end_block

#method_before
private void stopTrackingTable(SupportSQLiteDatabase writableDb, int tableId) {
    final String tableName = mShadowTableLookup.get(tableId, mTableNames[tableId]);
    StringBuilder stringBuilder = new StringBuilder();
    for (String trigger : TRIGGERS) {
        stringBuilder.setLength(0);
        stringBuilder.append("DROP TRIGGER IF EXISTS ");
        appendTriggerName(stringBuilder, tableName, Integer.toString(tableId), trigger);
        writableDb.execSQL(stringBuilder.toString());
    }
}
#method_after
private void stopTrackingTable(SupportSQLiteDatabase writableDb, int tableId) {
    final String tableName = mTableNames[tableId];
    StringBuilder stringBuilder = new StringBuilder();
    for (String trigger : TRIGGERS) {
        stringBuilder.setLength(0);
        stringBuilder.append("DROP TRIGGER IF EXISTS ");
        appendTriggerName(stringBuilder, tableName, trigger);
        writableDb.execSQL(stringBuilder.toString());
    }
}
#end_block

#method_before
private void startTrackingTable(SupportSQLiteDatabase writableDb, int tableId) {
    writableDb.execSQL("INSERT OR IGNORE INTO " + UPDATE_TABLE_NAME + " VALUES(" + tableId + ", 0)");
    final String tableName = mShadowTableLookup.get(tableId, mTableNames[tableId]);
    StringBuilder stringBuilder = new StringBuilder();
    for (String trigger : TRIGGERS) {
        stringBuilder.setLength(0);
        stringBuilder.append("CREATE TEMP TRIGGER IF NOT EXISTS ");
        appendTriggerName(stringBuilder, tableName, Integer.toString(tableId), trigger);
        stringBuilder.append(" AFTER ").append(trigger).append(" ON `").append(tableName).append("` BEGIN UPDATE ").append(UPDATE_TABLE_NAME).append(" SET ").append(INVALIDATED_COLUMN_NAME).append(" = 1").append(" WHERE ").append(TABLE_ID_COLUMN_NAME).append(" = ").append(tableId).append(" AND ").append(INVALIDATED_COLUMN_NAME).append(" = 0").append("; END");
        writableDb.execSQL(stringBuilder.toString());
    }
}
#method_after
private void startTrackingTable(SupportSQLiteDatabase writableDb, int tableId) {
    writableDb.execSQL("INSERT OR IGNORE INTO " + UPDATE_TABLE_NAME + " VALUES(" + tableId + ", 0)");
    final String tableName = mTableNames[tableId];
    StringBuilder stringBuilder = new StringBuilder();
    for (String trigger : TRIGGERS) {
        stringBuilder.setLength(0);
        stringBuilder.append("CREATE TEMP TRIGGER IF NOT EXISTS ");
        appendTriggerName(stringBuilder, tableName, trigger);
        stringBuilder.append(" AFTER ").append(trigger).append(" ON `").append(tableName).append("` BEGIN UPDATE ").append(UPDATE_TABLE_NAME).append(" SET ").append(INVALIDATED_COLUMN_NAME).append(" = 1").append(" WHERE ").append(TABLE_ID_COLUMN_NAME).append(" = ").append(tableId).append(" AND ").append(INVALIDATED_COLUMN_NAME).append(" = 0").append("; END");
        writableDb.execSQL(stringBuilder.toString());
    }
}
#end_block

#method_before
@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    final SupportSQLiteStatement statement = mock(SupportSQLiteStatement.class);
    doReturn(statement).when(mSqliteDb).compileStatement(eq(InvalidationTracker.RESET_UPDATED_TABLES_SQL));
    doReturn(mSqliteDb).when(mOpenHelper).getWritableDatabase();
    doReturn(true).when(mRoomDatabase).isOpen();
    doReturn(ArchTaskExecutor.getIOThreadExecutor()).when(mRoomDatabase).getQueryExecutor();
    ReentrantLock closeLock = new ReentrantLock();
    doReturn(closeLock).when(mRoomDatabase).getCloseLock();
    // noinspection ResultOfMethodCallIgnored
    doReturn(mOpenHelper).when(mRoomDatabase).getOpenHelper();
    HashMap<String, String> shadowTables = new HashMap<>();
    shadowTables.put("C", "D");
    HashMap<String, Set<String>> viewTables = new HashMap<>();
    HashSet<String> tableSet = new HashSet<>();
    tableSet.add("a");
    viewTables.put("e", tableSet);
    mTracker = new InvalidationTracker(mRoomDatabase, shadowTables, viewTables, "a", "B", "i", "C");
    mTracker.internalInit(mSqliteDb);
    reset(mSqliteDb);
}
#method_after
@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    final SupportSQLiteStatement statement = mock(SupportSQLiteStatement.class);
    doReturn(statement).when(mSqliteDb).compileStatement(eq(InvalidationTracker.RESET_UPDATED_TABLES_SQL));
    doReturn(mSqliteDb).when(mOpenHelper).getWritableDatabase();
    doReturn(true).when(mRoomDatabase).isOpen();
    doReturn(ArchTaskExecutor.getIOThreadExecutor()).when(mRoomDatabase).getQueryExecutor();
    ReentrantLock closeLock = new ReentrantLock();
    doReturn(closeLock).when(mRoomDatabase).getCloseLock();
    // noinspection ResultOfMethodCallIgnored
    doReturn(mOpenHelper).when(mRoomDatabase).getOpenHelper();
    HashMap<String, String> shadowTables = new HashMap<>();
    shadowTables.put("C", "C_content");
    shadowTables.put("d", "a");
    HashMap<String, Set<String>> viewTables = new HashMap<>();
    HashSet<String> tableSet = new HashSet<>();
    tableSet.add("a");
    viewTables.put("e", tableSet);
    mTracker = new InvalidationTracker(mRoomDatabase, shadowTables, viewTables, "a", "B", "i", "C", "d");
    mTracker.internalInit(mSqliteDb);
    reset(mSqliteDb);
}
#end_block

#method_before
@Test
public void tableIds() {
    assertThat(mTracker.mTableIdLookup.get("a"), is(0));
    assertThat(mTracker.mTableIdLookup.get("b"), is(1));
    assertThat(mTracker.mTableIdLookup.get("i"), is(2));
    assertThat(mTracker.mTableIdLookup.get("c"), is(3));
}
#method_after
@Test
public void tableIds() {
    assertThat(mTracker.mTableIdLookup.size(), is(5));
    assertThat(mTracker.mTableIdLookup.get("a"), is(0));
    assertThat(mTracker.mTableIdLookup.get("b"), is(1));
    assertThat(mTracker.mTableIdLookup.get("i"), is(2));
    // fts
    assertThat(mTracker.mTableIdLookup.get("c"), is(3));
    // external content fts
    assertThat(mTracker.mTableIdLookup.get("d"), is(0));
}
#end_block

#method_before
@Test
public void createTriggerOnShadowTable() {
    LatchObserver observer = new LatchObserver(1, "C");
    String[] triggers = new String[] { "UPDATE", "DELETE", "INSERT" };
    ArgumentCaptor<String> sqlArgCaptor;
    List<String> sqlCaptorValues;
    mTracker.addObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(4)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    assertThat(sqlCaptorValues.get(0), is("INSERT OR IGNORE INTO room_table_modification_log VALUES(3, 0)"));
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i + 1), is("CREATE TEMP TRIGGER IF NOT EXISTS " + "`room_table_modification_trigger_d_3_" + triggers[i] + "` AFTER " + triggers[i] + " ON `d` BEGIN UPDATE room_table_modification_log " + "SET invalidated = 1 WHERE table_id = 3 AND invalidated = 0; END"));
    }
    reset(mSqliteDb);
    mTracker.removeObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(3)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i), is("DROP TRIGGER IF EXISTS `room_table_modification_trigger_d_3_" + triggers[i] + "`"));
    }
}
#method_after
@Test
public void createTriggerOnShadowTable() {
    LatchObserver observer = new LatchObserver(1, "C");
    String[] triggers = new String[] { "UPDATE", "DELETE", "INSERT" };
    ArgumentCaptor<String> sqlArgCaptor;
    List<String> sqlCaptorValues;
    mTracker.addObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(4)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    assertThat(sqlCaptorValues.get(0), is("INSERT OR IGNORE INTO room_table_modification_log VALUES(3, 0)"));
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i + 1), is("CREATE TEMP TRIGGER IF NOT EXISTS " + "`room_table_modification_trigger_c_content_" + triggers[i] + "` AFTER " + triggers[i] + " ON `c_content` BEGIN UPDATE " + "room_table_modification_log SET invalidated = 1 WHERE table_id = 3 " + "AND invalidated = 0; END"));
    }
    reset(mSqliteDb);
    mTracker.removeObserver(observer);
    sqlArgCaptor = ArgumentCaptor.forClass(String.class);
    verify(mSqliteDb, times(3)).execSQL(sqlArgCaptor.capture());
    sqlCaptorValues = sqlArgCaptor.getAllValues();
    for (int i = 0; i < triggers.length; i++) {
        assertThat(sqlCaptorValues.get(i), is("DROP TRIGGER IF EXISTS `room_table_modification_trigger_c_content_" + triggers[i] + "`"));
    }
}
#end_block

#method_before
private Cursor createCursorWithValues(final int... tableIds) {
    Cursor cursor = mock(Cursor.class);
    final AtomicInteger index = new AtomicInteger(-1);
    when(cursor.moveToNext()).thenAnswer(new Answer<Boolean>() {

        @Override
        public Boolean answer(InvocationOnMock invocation) throws Throwable {
            return index.addAndGet(1) < tableIds.length;
        }
    });
    Answer<Integer> intAnswer = new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) throws Throwable {
            return tableIds[index.intValue() + (Integer) invocation.getArguments()[0]];
        }
    };
    when(cursor.getInt(anyInt())).thenAnswer(intAnswer);
    return cursor;
}
#method_after
private Cursor createCursorWithValues(final int... tableIds) {
    Cursor cursor = mock(Cursor.class);
    final AtomicInteger index = new AtomicInteger(-1);
    when(cursor.moveToNext()).thenAnswer(new Answer<Boolean>() {

        @Override
        public Boolean answer(InvocationOnMock invocation) throws Throwable {
            return index.addAndGet(1) < tableIds.length;
        }
    });
    Answer<Integer> intAnswer = new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) throws Throwable {
            // checkUpdatedTable only checks for column 0 (invalidated table id)
            assert ((Integer) invocation.getArguments()[0]) == 0;
            return tableIds[index.intValue()];
        }
    };
    when(cursor.getInt(anyInt())).thenAnswer(intAnswer);
    return cursor;
}
#end_block

#method_before
@Nullable
private ExifAttribute getExifAttribute(@NonNull String tag) {
    if (TAG_ISO_SPEED_RATINGS.equals(tag)) {
        if (DEBUG) {
            Log.d(TAG, "getExifAttribute: Replacing TAG_ISO_SPEED_RATINGS with " + "TAG_PHOTOGRAPHIC_SENSITIVITY.");
        }
        tag = TAG_PHOTOGRAPHIC_SENSITIVITY;
    }
    // than the value from the thumbnail tag group if there are more than one candidates.
    for (int i = 0; i < EXIF_TAGS.length; ++i) {
        ExifAttribute value = mAttributes[i].get(tag);
        if (value != null) {
            return value;
        }
    }
    return null;
}
#method_after
@Nullable
private ExifAttribute getExifAttribute(@NonNull String tag) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    if (TAG_ISO_SPEED_RATINGS.equals(tag)) {
        if (DEBUG) {
            Log.d(TAG, "getExifAttribute: Replacing TAG_ISO_SPEED_RATINGS with " + "TAG_PHOTOGRAPHIC_SENSITIVITY.");
        }
        tag = TAG_PHOTOGRAPHIC_SENSITIVITY;
    }
    // than the value from the thumbnail tag group if there are more than one candidates.
    for (int i = 0; i < EXIF_TAGS.length; ++i) {
        ExifAttribute value = mAttributes[i].get(tag);
        if (value != null) {
            return value;
        }
    }
    return null;
}
#end_block

#method_before
@Nullable
public String getAttribute(@NonNull String tag) {
    ExifAttribute attribute = getExifAttribute(tag);
    if (attribute != null) {
        if (!sTagSetForCompatibility.contains(tag)) {
            return attribute.getStringValue(mExifByteOrder);
        }
        if (tag.equals(TAG_GPS_TIMESTAMP)) {
            // Convert the rational values to the custom formats for backwards compatibility.
            if (attribute.format != IFD_FORMAT_URATIONAL && attribute.format != IFD_FORMAT_SRATIONAL) {
                Log.w(TAG, "GPS Timestamp format is not rational. format=" + attribute.format);
                return null;
            }
            Rational[] array = (Rational[]) attribute.getValue(mExifByteOrder);
            if (array == null || array.length != 3) {
                Log.w(TAG, "Invalid GPS Timestamp array. array=" + Arrays.toString(array));
                return null;
            }
            return String.format("%02d:%02d:%02d", (int) ((float) array[0].numerator / array[0].denominator), (int) ((float) array[1].numerator / array[1].denominator), (int) ((float) array[2].numerator / array[2].denominator));
        }
        try {
            return Double.toString(attribute.getDoubleValue(mExifByteOrder));
        } catch (NumberFormatException e) {
            return null;
        }
    }
    return null;
}
#method_after
@Nullable
public String getAttribute(@NonNull String tag) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    ExifAttribute attribute = getExifAttribute(tag);
    if (attribute != null) {
        if (!sTagSetForCompatibility.contains(tag)) {
            return attribute.getStringValue(mExifByteOrder);
        }
        if (tag.equals(TAG_GPS_TIMESTAMP)) {
            // Convert the rational values to the custom formats for backwards compatibility.
            if (attribute.format != IFD_FORMAT_URATIONAL && attribute.format != IFD_FORMAT_SRATIONAL) {
                Log.w(TAG, "GPS Timestamp format is not rational. format=" + attribute.format);
                return null;
            }
            Rational[] array = (Rational[]) attribute.getValue(mExifByteOrder);
            if (array == null || array.length != 3) {
                Log.w(TAG, "Invalid GPS Timestamp array. array=" + Arrays.toString(array));
                return null;
            }
            return String.format("%02d:%02d:%02d", (int) ((float) array[0].numerator / array[0].denominator), (int) ((float) array[1].numerator / array[1].denominator), (int) ((float) array[2].numerator / array[2].denominator));
        }
        try {
            return Double.toString(attribute.getDoubleValue(mExifByteOrder));
        } catch (NumberFormatException e) {
            return null;
        }
    }
    return null;
}
#end_block

#method_before
public int getAttributeInt(@NonNull String tag, int defaultValue) {
    ExifAttribute exifAttribute = getExifAttribute(tag);
    if (exifAttribute == null) {
        return defaultValue;
    }
    try {
        return exifAttribute.getIntValue(mExifByteOrder);
    } catch (NumberFormatException e) {
        return defaultValue;
    }
}
#method_after
public int getAttributeInt(@NonNull String tag, int defaultValue) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    ExifAttribute exifAttribute = getExifAttribute(tag);
    if (exifAttribute == null) {
        return defaultValue;
    }
    try {
        return exifAttribute.getIntValue(mExifByteOrder);
    } catch (NumberFormatException e) {
        return defaultValue;
    }
}
#end_block

#method_before
public double getAttributeDouble(@NonNull String tag, double defaultValue) {
    ExifAttribute exifAttribute = getExifAttribute(tag);
    if (exifAttribute == null) {
        return defaultValue;
    }
    try {
        return exifAttribute.getDoubleValue(mExifByteOrder);
    } catch (NumberFormatException e) {
        return defaultValue;
    }
}
#method_after
public double getAttributeDouble(@NonNull String tag, double defaultValue) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    ExifAttribute exifAttribute = getExifAttribute(tag);
    if (exifAttribute == null) {
        return defaultValue;
    }
    try {
        return exifAttribute.getDoubleValue(mExifByteOrder);
    } catch (NumberFormatException e) {
        return defaultValue;
    }
}
#end_block

#method_before
public void setAttribute(@NonNull String tag, @Nullable String value) {
    if (TAG_ISO_SPEED_RATINGS.equals(tag)) {
        if (DEBUG) {
            Log.d(TAG, "setAttribute: Replacing TAG_ISO_SPEED_RATINGS with " + "TAG_PHOTOGRAPHIC_SENSITIVITY.");
        }
        tag = TAG_PHOTOGRAPHIC_SENSITIVITY;
    }
    // Convert the given value to rational values for backwards compatibility.
    if (value != null && sTagSetForCompatibility.contains(tag)) {
        if (tag.equals(TAG_GPS_TIMESTAMP)) {
            Matcher m = sGpsTimestampPattern.matcher(value);
            if (!m.find()) {
                Log.w(TAG, "Invalid value for " + tag + " : " + value);
                return;
            }
            value = Integer.parseInt(m.group(1)) + "/1," + Integer.parseInt(m.group(2)) + "/1," + Integer.parseInt(m.group(3)) + "/1";
        } else {
            try {
                double doubleValue = Double.parseDouble(value);
                value = new Rational(doubleValue).toString();
            } catch (NumberFormatException e) {
                Log.w(TAG, "Invalid value for " + tag + " : " + value);
                return;
            }
        }
    }
    for (int i = 0; i < EXIF_TAGS.length; ++i) {
        if (i == IFD_TYPE_THUMBNAIL && !mHasThumbnail) {
            continue;
        }
        final ExifTag exifTag = sExifTagMapsForWriting[i].get(tag);
        if (exifTag != null) {
            if (value == null) {
                mAttributes[i].remove(tag);
                continue;
            }
            Pair<Integer, Integer> guess = guessDataFormat(value);
            int dataFormat;
            if (exifTag.primaryFormat == guess.first || exifTag.primaryFormat == guess.second) {
                dataFormat = exifTag.primaryFormat;
            } else if (exifTag.secondaryFormat != -1 && (exifTag.secondaryFormat == guess.first || exifTag.secondaryFormat == guess.second)) {
                dataFormat = exifTag.secondaryFormat;
            } else if (exifTag.primaryFormat == IFD_FORMAT_BYTE || exifTag.primaryFormat == IFD_FORMAT_UNDEFINED || exifTag.primaryFormat == IFD_FORMAT_STRING) {
                dataFormat = exifTag.primaryFormat;
            } else {
                Log.w(TAG, "Given tag (" + tag + ") value didn't match with one of expected " + "formats: " + IFD_FORMAT_NAMES[exifTag.primaryFormat] + (exifTag.secondaryFormat == -1 ? "" : ", " + IFD_FORMAT_NAMES[exifTag.secondaryFormat]) + " (guess: " + IFD_FORMAT_NAMES[guess.first] + (guess.second == -1 ? "" : ", " + IFD_FORMAT_NAMES[guess.second]) + ")");
                continue;
            }
            switch(dataFormat) {
                case IFD_FORMAT_BYTE:
                    {
                        mAttributes[i].put(tag, ExifAttribute.createByte(value));
                        break;
                    }
                case IFD_FORMAT_UNDEFINED:
                case IFD_FORMAT_STRING:
                    {
                        mAttributes[i].put(tag, ExifAttribute.createString(value));
                        break;
                    }
                case IFD_FORMAT_USHORT:
                    {
                        final String[] values = value.split(",", -1);
                        final int[] intArray = new int[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            intArray[j] = Integer.parseInt(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createUShort(intArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_SLONG:
                    {
                        final String[] values = value.split(",", -1);
                        final int[] intArray = new int[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            intArray[j] = Integer.parseInt(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createSLong(intArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_ULONG:
                    {
                        final String[] values = value.split(",", -1);
                        final long[] longArray = new long[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            longArray[j] = Long.parseLong(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createULong(longArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_URATIONAL:
                    {
                        final String[] values = value.split(",", -1);
                        final Rational[] rationalArray = new Rational[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            final String[] numbers = values[j].split("/", -1);
                            rationalArray[j] = new Rational((long) Double.parseDouble(numbers[0]), (long) Double.parseDouble(numbers[1]));
                        }
                        mAttributes[i].put(tag, ExifAttribute.createURational(rationalArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_SRATIONAL:
                    {
                        final String[] values = value.split(",", -1);
                        final Rational[] rationalArray = new Rational[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            final String[] numbers = values[j].split("/", -1);
                            rationalArray[j] = new Rational((long) Double.parseDouble(numbers[0]), (long) Double.parseDouble(numbers[1]));
                        }
                        mAttributes[i].put(tag, ExifAttribute.createSRational(rationalArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_DOUBLE:
                    {
                        final String[] values = value.split(",", -1);
                        final double[] doubleArray = new double[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            doubleArray[j] = Double.parseDouble(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createDouble(doubleArray, mExifByteOrder));
                        break;
                    }
                default:
                    Log.w(TAG, "Data format isn't one of expected formats: " + dataFormat);
                    continue;
            }
        }
    }
}
#method_after
public void setAttribute(@NonNull String tag, @Nullable String value) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    if (TAG_ISO_SPEED_RATINGS.equals(tag)) {
        if (DEBUG) {
            Log.d(TAG, "setAttribute: Replacing TAG_ISO_SPEED_RATINGS with " + "TAG_PHOTOGRAPHIC_SENSITIVITY.");
        }
        tag = TAG_PHOTOGRAPHIC_SENSITIVITY;
    }
    // Convert the given value to rational values for backwards compatibility.
    if (value != null && sTagSetForCompatibility.contains(tag)) {
        if (tag.equals(TAG_GPS_TIMESTAMP)) {
            Matcher m = sGpsTimestampPattern.matcher(value);
            if (!m.find()) {
                Log.w(TAG, "Invalid value for " + tag + " : " + value);
                return;
            }
            value = Integer.parseInt(m.group(1)) + "/1," + Integer.parseInt(m.group(2)) + "/1," + Integer.parseInt(m.group(3)) + "/1";
        } else {
            try {
                double doubleValue = Double.parseDouble(value);
                value = new Rational(doubleValue).toString();
            } catch (NumberFormatException e) {
                Log.w(TAG, "Invalid value for " + tag + " : " + value);
                return;
            }
        }
    }
    for (int i = 0; i < EXIF_TAGS.length; ++i) {
        if (i == IFD_TYPE_THUMBNAIL && !mHasThumbnail) {
            continue;
        }
        final ExifTag exifTag = sExifTagMapsForWriting[i].get(tag);
        if (exifTag != null) {
            if (value == null) {
                mAttributes[i].remove(tag);
                continue;
            }
            Pair<Integer, Integer> guess = guessDataFormat(value);
            int dataFormat;
            if (exifTag.primaryFormat == guess.first || exifTag.primaryFormat == guess.second) {
                dataFormat = exifTag.primaryFormat;
            } else if (exifTag.secondaryFormat != -1 && (exifTag.secondaryFormat == guess.first || exifTag.secondaryFormat == guess.second)) {
                dataFormat = exifTag.secondaryFormat;
            } else if (exifTag.primaryFormat == IFD_FORMAT_BYTE || exifTag.primaryFormat == IFD_FORMAT_UNDEFINED || exifTag.primaryFormat == IFD_FORMAT_STRING) {
                dataFormat = exifTag.primaryFormat;
            } else {
                Log.w(TAG, "Given tag (" + tag + ") value didn't match with one of expected " + "formats: " + IFD_FORMAT_NAMES[exifTag.primaryFormat] + (exifTag.secondaryFormat == -1 ? "" : ", " + IFD_FORMAT_NAMES[exifTag.secondaryFormat]) + " (guess: " + IFD_FORMAT_NAMES[guess.first] + (guess.second == -1 ? "" : ", " + IFD_FORMAT_NAMES[guess.second]) + ")");
                continue;
            }
            switch(dataFormat) {
                case IFD_FORMAT_BYTE:
                    {
                        mAttributes[i].put(tag, ExifAttribute.createByte(value));
                        break;
                    }
                case IFD_FORMAT_UNDEFINED:
                case IFD_FORMAT_STRING:
                    {
                        mAttributes[i].put(tag, ExifAttribute.createString(value));
                        break;
                    }
                case IFD_FORMAT_USHORT:
                    {
                        final String[] values = value.split(",", -1);
                        final int[] intArray = new int[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            intArray[j] = Integer.parseInt(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createUShort(intArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_SLONG:
                    {
                        final String[] values = value.split(",", -1);
                        final int[] intArray = new int[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            intArray[j] = Integer.parseInt(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createSLong(intArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_ULONG:
                    {
                        final String[] values = value.split(",", -1);
                        final long[] longArray = new long[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            longArray[j] = Long.parseLong(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createULong(longArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_URATIONAL:
                    {
                        final String[] values = value.split(",", -1);
                        final Rational[] rationalArray = new Rational[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            final String[] numbers = values[j].split("/", -1);
                            rationalArray[j] = new Rational((long) Double.parseDouble(numbers[0]), (long) Double.parseDouble(numbers[1]));
                        }
                        mAttributes[i].put(tag, ExifAttribute.createURational(rationalArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_SRATIONAL:
                    {
                        final String[] values = value.split(",", -1);
                        final Rational[] rationalArray = new Rational[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            final String[] numbers = values[j].split("/", -1);
                            rationalArray[j] = new Rational((long) Double.parseDouble(numbers[0]), (long) Double.parseDouble(numbers[1]));
                        }
                        mAttributes[i].put(tag, ExifAttribute.createSRational(rationalArray, mExifByteOrder));
                        break;
                    }
                case IFD_FORMAT_DOUBLE:
                    {
                        final String[] values = value.split(",", -1);
                        final double[] doubleArray = new double[values.length];
                        for (int j = 0; j < values.length; ++j) {
                            doubleArray[j] = Double.parseDouble(values[j]);
                        }
                        mAttributes[i].put(tag, ExifAttribute.createDouble(doubleArray, mExifByteOrder));
                        break;
                    }
                default:
                    Log.w(TAG, "Data format isn't one of expected formats: " + dataFormat);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void loadAttributes(@NonNull InputStream in) throws IOException {
    try {
        // Initialize mAttributes.
        for (int i = 0; i < EXIF_TAGS.length; ++i) {
            mAttributes[i] = new HashMap<>();
        }
        // Check file type
        in = new BufferedInputStream(in, SIGNATURE_CHECK_SIZE);
        mMimeType = getMimeType((BufferedInputStream) in);
        // Create byte-ordered input stream
        ByteOrderedDataInputStream inputStream = new ByteOrderedDataInputStream(in);
        switch(mMimeType) {
            case IMAGE_TYPE_JPEG:
                {
                    // 0 is offset
                    getJpegAttributes(inputStream, 0, IFD_TYPE_PRIMARY);
                    break;
                }
            case IMAGE_TYPE_RAF:
                {
                    getRafAttributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_ORF:
                {
                    getOrfAttributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_RW2:
                {
                    getRw2Attributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_ARW:
            case IMAGE_TYPE_CR2:
            case IMAGE_TYPE_DNG:
            case IMAGE_TYPE_NEF:
            case IMAGE_TYPE_NRW:
            case IMAGE_TYPE_PEF:
            case IMAGE_TYPE_SRW:
            case IMAGE_TYPE_UNKNOWN:
                {
                    getRawAttributes(inputStream);
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Set thumbnail image offset and length
        setThumbnailData(inputStream);
        mIsSupportedFile = true;
    } catch (IOException e) {
        // Ignore exceptions in order to keep the compatibility with the old versions of
        // ExifInterface.
        mIsSupportedFile = false;
        if (DEBUG) {
            Log.w(TAG, "Invalid image: ExifInterface got an unsupported image format file" + "(ExifInterface supports JPEG and some RAW image formats only) " + "or a corrupted JPEG file to ExifInterface.", e);
        }
    } finally {
        addDefaultValuesForCompatibility();
        if (DEBUG) {
            printAttributes();
        }
    }
}
#method_after
private void loadAttributes(@NonNull InputStream in) throws IOException {
    if (in == null) {
        throw new NullPointerException("inputstream shouldn't be null");
    }
    try {
        // Initialize mAttributes.
        for (int i = 0; i < EXIF_TAGS.length; ++i) {
            mAttributes[i] = new HashMap<>();
        }
        // Check file type
        in = new BufferedInputStream(in, SIGNATURE_CHECK_SIZE);
        mMimeType = getMimeType((BufferedInputStream) in);
        // Create byte-ordered input stream
        ByteOrderedDataInputStream inputStream = new ByteOrderedDataInputStream(in);
        switch(mMimeType) {
            case IMAGE_TYPE_JPEG:
                {
                    // 0 is offset
                    getJpegAttributes(inputStream, 0, IFD_TYPE_PRIMARY);
                    break;
                }
            case IMAGE_TYPE_RAF:
                {
                    getRafAttributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_HEIF:
                {
                    getHeifAttributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_ORF:
                {
                    getOrfAttributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_RW2:
                {
                    getRw2Attributes(inputStream);
                    break;
                }
            case IMAGE_TYPE_ARW:
            case IMAGE_TYPE_CR2:
            case IMAGE_TYPE_DNG:
            case IMAGE_TYPE_NEF:
            case IMAGE_TYPE_NRW:
            case IMAGE_TYPE_PEF:
            case IMAGE_TYPE_SRW:
            case IMAGE_TYPE_UNKNOWN:
                {
                    getRawAttributes(inputStream);
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Set thumbnail image offset and length
        setThumbnailData(inputStream);
        mIsSupportedFile = true;
    } catch (IOException e) {
        // Ignore exceptions in order to keep the compatibility with the old versions of
        // ExifInterface.
        mIsSupportedFile = false;
        if (DEBUG) {
            Log.w(TAG, "Invalid image: ExifInterface got an unsupported image format file" + "(ExifInterface supports JPEG and some RAW image formats only) " + "or a corrupted JPEG file to ExifInterface.", e);
        }
    } finally {
        addDefaultValuesForCompatibility();
        if (DEBUG) {
            printAttributes();
        }
    }
}
#end_block

#method_before
public boolean hasAttribute(String tag) {
    return (getExifAttribute(tag) != null);
}
#method_after
public boolean hasAttribute(@NonNull String tag) {
    return getExifAttribute(tag) != null;
}
#end_block

#method_before
@Nullable
public long[] getAttributeRange(@NonNull String tag) {
    if (mModified) {
        throw new IllegalStateException("The underlying file has been modified since being parsed");
    }
    final ExifAttribute attribute = getExifAttribute(tag);
    if (attribute != null) {
        return new long[] { attribute.bytesOffset, attribute.bytes.length };
    } else {
        return null;
    }
}
#method_after
@Nullable
public long[] getAttributeRange(@NonNull String tag) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    if (mModified) {
        throw new IllegalStateException("The underlying file has been modified since being parsed");
    }
    final ExifAttribute attribute = getExifAttribute(tag);
    if (attribute != null) {
        return new long[] { attribute.bytesOffset, attribute.bytes.length };
    } else {
        return null;
    }
}
#end_block

#method_before
@Nullable
public byte[] getAttributeBytes(@NonNull String tag) {
    final ExifAttribute attribute = getExifAttribute(tag);
    if (attribute != null) {
        return attribute.bytes;
    } else {
        return null;
    }
}
#method_after
@Nullable
public byte[] getAttributeBytes(@NonNull String tag) {
    if (tag == null) {
        throw new NullPointerException("tag shouldn't be null");
    }
    final ExifAttribute attribute = getExifAttribute(tag);
    if (attribute != null) {
        return attribute.bytes;
    } else {
        return null;
    }
}
#end_block

#method_before
private void initForFilename(String filename) throws IOException {
    FileInputStream in = null;
    mAssetInputStream = null;
    mFilename = filename;
    try {
        in = new FileInputStream(filename);
        if (isSeekableFD(in.getFD())) {
            mSeekableFileDescriptor = in.getFD();
        } else {
            mSeekableFileDescriptor = null;
        }
        loadAttributes(in);
    } finally {
        closeQuietly(in);
    }
}
#method_after
private void initForFilename(String filename) throws IOException {
    if (filename == null) {
        throw new NullPointerException("filename cannot be null");
    }
    FileInputStream in = null;
    mAssetInputStream = null;
    mFilename = filename;
    try {
        in = new FileInputStream(filename);
        if (isSeekableFD(in.getFD())) {
            mSeekableFileDescriptor = in.getFD();
        } else {
            mSeekableFileDescriptor = null;
        }
        loadAttributes(in);
    } finally {
        closeQuietly(in);
    }
}
#end_block

#method_before
private int getMimeType(BufferedInputStream in) throws IOException {
    in.mark(SIGNATURE_CHECK_SIZE);
    byte[] signatureCheckBytes = new byte[SIGNATURE_CHECK_SIZE];
    in.read(signatureCheckBytes);
    in.reset();
    if (isJpegFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_JPEG;
    } else if (isRafFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_RAF;
    } else if (isOrfFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_ORF;
    } else if (isRw2Format(signatureCheckBytes)) {
        return IMAGE_TYPE_RW2;
    }
    // Certain file formats (PEF) are identified in readImageFileDirectory()
    return IMAGE_TYPE_UNKNOWN;
}
#method_after
private int getMimeType(BufferedInputStream in) throws IOException {
    in.mark(SIGNATURE_CHECK_SIZE);
    byte[] signatureCheckBytes = new byte[SIGNATURE_CHECK_SIZE];
    in.read(signatureCheckBytes);
    in.reset();
    if (isJpegFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_JPEG;
    } else if (isRafFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_RAF;
    } else if (isHeifFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_HEIF;
    } else if (isOrfFormat(signatureCheckBytes)) {
        return IMAGE_TYPE_ORF;
    } else if (isRw2Format(signatureCheckBytes)) {
        return IMAGE_TYPE_RW2;
    }
    // Certain file formats (PEF) are identified in readImageFileDirectory()
    return IMAGE_TYPE_UNKNOWN;
}
#end_block

#method_before
private void getJpegAttributes(ByteOrderedDataInputStream in, int jpegOffset, int imageType) throws IOException {
    // See JPEG File Interchange Format Specification, "JFIF Specification"
    if (DEBUG) {
        Log.d(TAG, "getJpegAttributes starting with: " + in);
    }
    // JPEG uses Big Endian by default. See https://people.cs.umass.edu/~verts/cs32/endian.html
    in.setByteOrder(ByteOrder.BIG_ENDIAN);
    // Skip to JPEG data
    in.seek(jpegOffset);
    int bytesRead = jpegOffset;
    byte marker;
    if ((marker = in.readByte()) != MARKER) {
        throw new IOException("Invalid marker: " + Integer.toHexString(marker & 0xff));
    }
    ++bytesRead;
    if (in.readByte() != MARKER_SOI) {
        throw new IOException("Invalid marker: " + Integer.toHexString(marker & 0xff));
    }
    ++bytesRead;
    while (true) {
        marker = in.readByte();
        if (marker != MARKER) {
            throw new IOException("Invalid marker:" + Integer.toHexString(marker & 0xff));
        }
        ++bytesRead;
        marker = in.readByte();
        if (DEBUG) {
            Log.d(TAG, "Found JPEG segment indicator: " + Integer.toHexString(marker & 0xff));
        }
        ++bytesRead;
        // the image data will terminate right after.
        if (marker == MARKER_EOI || marker == MARKER_SOS) {
            break;
        }
        int length = in.readUnsignedShort() - 2;
        bytesRead += 2;
        if (DEBUG) {
            Log.d(TAG, "JPEG segment: " + Integer.toHexString(marker & 0xff) + " (length: " + (length + 2) + ")");
        }
        if (length < 0) {
            throw new IOException("Invalid length");
        }
        switch(marker) {
            case MARKER_APP1:
                {
                    final int start = bytesRead;
                    final byte[] bytes = new byte[length];
                    in.readFully(bytes);
                    bytesRead += length;
                    length = 0;
                    if (startsWith(bytes, IDENTIFIER_EXIF_APP1)) {
                        final long offset = start + IDENTIFIER_EXIF_APP1.length;
                        final byte[] value = copyOfRange(bytes, IDENTIFIER_EXIF_APP1.length, bytes.length);
                        readExifSegment(value, imageType);
                        // Save offset values for createJpegThumbnailBitmap() function
                        mExifOffset = (int) offset;
                    } else if (startsWith(bytes, IDENTIFIER_XMP_APP1)) {
                        // See XMP Specification Part 3: Storage in Files, 1.1.3 JPEG, Table 6
                        final long offset = start + IDENTIFIER_XMP_APP1.length;
                        final byte[] value = Arrays.copyOfRange(bytes, IDENTIFIER_XMP_APP1.length, bytes.length);
                        if (getAttribute(TAG_XMP) == null) {
                            mAttributes[IFD_TYPE_PRIMARY].put(TAG_XMP, new ExifAttribute(IFD_FORMAT_BYTE, value.length, offset, value));
                        }
                    }
                }
            case MARKER_COM:
                {
                    byte[] bytes = new byte[length];
                    if (in.read(bytes) != length) {
                        throw new IOException("Invalid exif");
                    }
                    length = 0;
                    if (getAttribute(TAG_USER_COMMENT) == null) {
                        mAttributes[IFD_TYPE_EXIF].put(TAG_USER_COMMENT, ExifAttribute.createString(new String(bytes, ASCII)));
                    }
                    break;
                }
            case MARKER_SOF0:
            case MARKER_SOF1:
            case MARKER_SOF2:
            case MARKER_SOF3:
            case MARKER_SOF5:
            case MARKER_SOF6:
            case MARKER_SOF7:
            case MARKER_SOF9:
            case MARKER_SOF10:
            case MARKER_SOF11:
            case MARKER_SOF13:
            case MARKER_SOF14:
            case MARKER_SOF15:
                {
                    if (in.skipBytes(1) != 1) {
                        throw new IOException("Invalid SOFx");
                    }
                    mAttributes[imageType].put(TAG_IMAGE_LENGTH, ExifAttribute.createULong(in.readUnsignedShort(), mExifByteOrder));
                    mAttributes[imageType].put(TAG_IMAGE_WIDTH, ExifAttribute.createULong(in.readUnsignedShort(), mExifByteOrder));
                    length -= 5;
                    break;
                }
            default:
                {
                    break;
                }
        }
        if (length < 0) {
            throw new IOException("Invalid length");
        }
        if (in.skipBytes(length) != length) {
            throw new IOException("Invalid JPEG segment");
        }
        bytesRead += length;
    }
    // Restore original byte order
    in.setByteOrder(mExifByteOrder);
}
#method_after
private void getJpegAttributes(ByteOrderedDataInputStream in, int jpegOffset, int imageType) throws IOException {
    // See JPEG File Interchange Format Specification, "JFIF Specification"
    if (DEBUG) {
        Log.d(TAG, "getJpegAttributes starting with: " + in);
    }
    // JPEG uses Big Endian by default. See https://people.cs.umass.edu/~verts/cs32/endian.html
    in.setByteOrder(ByteOrder.BIG_ENDIAN);
    // Skip to JPEG data
    in.seek(jpegOffset);
    int bytesRead = jpegOffset;
    byte marker;
    if ((marker = in.readByte()) != MARKER) {
        throw new IOException("Invalid marker: " + Integer.toHexString(marker & 0xff));
    }
    ++bytesRead;
    if (in.readByte() != MARKER_SOI) {
        throw new IOException("Invalid marker: " + Integer.toHexString(marker & 0xff));
    }
    ++bytesRead;
    while (true) {
        marker = in.readByte();
        if (marker != MARKER) {
            throw new IOException("Invalid marker:" + Integer.toHexString(marker & 0xff));
        }
        ++bytesRead;
        marker = in.readByte();
        if (DEBUG) {
            Log.d(TAG, "Found JPEG segment indicator: " + Integer.toHexString(marker & 0xff));
        }
        ++bytesRead;
        // the image data will terminate right after.
        if (marker == MARKER_EOI || marker == MARKER_SOS) {
            break;
        }
        int length = in.readUnsignedShort() - 2;
        bytesRead += 2;
        if (DEBUG) {
            Log.d(TAG, "JPEG segment: " + Integer.toHexString(marker & 0xff) + " (length: " + (length + 2) + ")");
        }
        if (length < 0) {
            throw new IOException("Invalid length");
        }
        switch(marker) {
            case MARKER_APP1:
                {
                    final int start = bytesRead;
                    final byte[] bytes = new byte[length];
                    in.readFully(bytes);
                    bytesRead += length;
                    length = 0;
                    if (startsWith(bytes, IDENTIFIER_EXIF_APP1)) {
                        final long offset = start + IDENTIFIER_EXIF_APP1.length;
                        final byte[] value = Arrays.copyOfRange(bytes, IDENTIFIER_EXIF_APP1.length, bytes.length);
                        readExifSegment(value, imageType);
                        // Save offset values for createJpegThumbnailBitmap() function
                        mExifOffset = (int) offset;
                    } else if (startsWith(bytes, IDENTIFIER_XMP_APP1)) {
                        // See XMP Specification Part 3: Storage in Files, 1.1.3 JPEG, Table 6
                        final long offset = start + IDENTIFIER_XMP_APP1.length;
                        final byte[] value = Arrays.copyOfRange(bytes, IDENTIFIER_XMP_APP1.length, bytes.length);
                        if (getAttribute(TAG_XMP) == null) {
                            mAttributes[IFD_TYPE_PRIMARY].put(TAG_XMP, new ExifAttribute(IFD_FORMAT_BYTE, value.length, offset, value));
                        }
                    }
                }
            case MARKER_COM:
                {
                    byte[] bytes = new byte[length];
                    if (in.read(bytes) != length) {
                        throw new IOException("Invalid exif");
                    }
                    length = 0;
                    if (getAttribute(TAG_USER_COMMENT) == null) {
                        mAttributes[IFD_TYPE_EXIF].put(TAG_USER_COMMENT, ExifAttribute.createString(new String(bytes, ASCII)));
                    }
                    break;
                }
            case MARKER_SOF0:
            case MARKER_SOF1:
            case MARKER_SOF2:
            case MARKER_SOF3:
            case MARKER_SOF5:
            case MARKER_SOF6:
            case MARKER_SOF7:
            case MARKER_SOF9:
            case MARKER_SOF10:
            case MARKER_SOF11:
            case MARKER_SOF13:
            case MARKER_SOF14:
            case MARKER_SOF15:
                {
                    if (in.skipBytes(1) != 1) {
                        throw new IOException("Invalid SOFx");
                    }
                    mAttributes[imageType].put(TAG_IMAGE_LENGTH, ExifAttribute.createULong(in.readUnsignedShort(), mExifByteOrder));
                    mAttributes[imageType].put(TAG_IMAGE_WIDTH, ExifAttribute.createULong(in.readUnsignedShort(), mExifByteOrder));
                    length -= 5;
                    break;
                }
            default:
                {
                    break;
                }
        }
        if (length < 0) {
            throw new IOException("Invalid length");
        }
        if (in.skipBytes(length) != length) {
            throw new IOException("Invalid JPEG segment");
        }
        bytesRead += length;
    }
    // Restore original byte order
    in.setByteOrder(mExifByteOrder);
}
#end_block

#method_before
private void compareWithExpectedValue(ExifInterface exifInterface, ExpectedValue expectedValue, String verboseTag, boolean assertRanges) {
    if (VERBOSE) {
        printExifTagsAndValues(verboseTag, exifInterface);
    }
    // Checks a thumbnail image.
    assertEquals(expectedValue.hasThumbnail, exifInterface.hasThumbnail());
    if (expectedValue.hasThumbnail) {
        assertNotNull(exifInterface.getThumbnailRange());
        if (assertRanges) {
            final long[] thumbnailRange = exifInterface.getThumbnailRange();
            assertEquals(expectedValue.thumbnailOffset, thumbnailRange[0]);
            assertEquals(expectedValue.thumbnailLength, thumbnailRange[1]);
        }
        byte[] thumbnailBytes = exifInterface.getThumbnailBytes();
        assertNotNull(thumbnailBytes);
        Bitmap thumbnailBitmap = exifInterface.getThumbnailBitmap();
        assertNotNull(thumbnailBitmap);
        assertEquals(expectedValue.thumbnailWidth, thumbnailBitmap.getWidth());
        assertEquals(expectedValue.thumbnailHeight, thumbnailBitmap.getHeight());
        assertEquals(expectedValue.isThumbnailCompressed, exifInterface.isThumbnailCompressed());
    } else {
        assertNull(exifInterface.getThumbnailRange());
        assertNull(exifInterface.getThumbnail());
    }
    // Checks GPS information.
    double[] latLong = exifInterface.getLatLong();
    assertEquals(expectedValue.hasLatLong, latLong != null);
    if (expectedValue.hasLatLong) {
        assertNotNull(exifInterface.getAttributeRange(ExifInterface.TAG_GPS_LATITUDE));
        if (assertRanges) {
            final long[] latitudeRange = exifInterface.getAttributeRange(ExifInterface.TAG_GPS_LATITUDE);
            assertEquals(expectedValue.latitudeOffset, latitudeRange[0]);
            assertEquals(expectedValue.latitudeLength, latitudeRange[1]);
        }
        assertEquals(expectedValue.latitude, latLong[0], DIFFERENCE_TOLERANCE);
        assertEquals(expectedValue.longitude, latLong[1], DIFFERENCE_TOLERANCE);
        assertTrue(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LATITUDE));
        assertTrue(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LONGITUDE));
    } else {
        assertNull(exifInterface.getAttributeRange(ExifInterface.TAG_GPS_LATITUDE));
        assertFalse(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LATITUDE));
        assertFalse(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LONGITUDE));
    }
    assertEquals(expectedValue.altitude, exifInterface.getAltitude(.0), DIFFERENCE_TOLERANCE);
    // Checks values.
    assertStringTag(exifInterface, ExifInterface.TAG_MAKE, expectedValue.make);
    assertStringTag(exifInterface, ExifInterface.TAG_MODEL, expectedValue.model);
    assertFloatTag(exifInterface, ExifInterface.TAG_F_NUMBER, expectedValue.aperture);
    assertStringTag(exifInterface, ExifInterface.TAG_DATETIME_ORIGINAL, expectedValue.dateTimeOriginal);
    assertFloatTag(exifInterface, ExifInterface.TAG_EXPOSURE_TIME, expectedValue.exposureTime);
    assertFloatTag(exifInterface, ExifInterface.TAG_FLASH, expectedValue.flash);
    assertStringTag(exifInterface, ExifInterface.TAG_FOCAL_LENGTH, expectedValue.focalLength);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_ALTITUDE, expectedValue.gpsAltitude);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_ALTITUDE_REF, expectedValue.gpsAltitudeRef);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_DATESTAMP, expectedValue.gpsDatestamp);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LATITUDE, expectedValue.gpsLatitude);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LATITUDE_REF, expectedValue.gpsLatitudeRef);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LONGITUDE, expectedValue.gpsLongitude);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LONGITUDE_REF, expectedValue.gpsLongitudeRef);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_PROCESSING_METHOD, expectedValue.gpsProcessingMethod);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_TIMESTAMP, expectedValue.gpsTimestamp);
    assertIntTag(exifInterface, ExifInterface.TAG_IMAGE_LENGTH, expectedValue.imageLength);
    assertIntTag(exifInterface, ExifInterface.TAG_IMAGE_WIDTH, expectedValue.imageWidth);
    assertStringTag(exifInterface, ExifInterface.TAG_PHOTOGRAPHIC_SENSITIVITY, expectedValue.iso);
    assertIntTag(exifInterface, ExifInterface.TAG_ORIENTATION, expectedValue.orientation);
    assertIntTag(exifInterface, ExifInterface.TAG_WHITE_BALANCE, expectedValue.whiteBalance);
    if (expectedValue.hasXmp) {
        assertNotNull(exifInterface.getAttributeRange(ExifInterface.TAG_XMP));
        if (assertRanges) {
            final long[] xmpRange = exifInterface.getAttributeRange(ExifInterface.TAG_XMP);
            assertEquals(expectedValue.xmpOffset, xmpRange[0]);
            assertEquals(expectedValue.xmpLength, xmpRange[1]);
        }
        final String xmp = new String(exifInterface.getAttributeBytes(ExifInterface.TAG_XMP), StandardCharsets.UTF_8);
        // Specification Part 1, Section C.2.2 for additional details.
        if (!xmp.contains("<rdf:RDF")) {
            fail("Invalid XMP: " + xmp);
        }
    } else {
        assertNull(exifInterface.getAttributeRange(ExifInterface.TAG_XMP));
    }
}
#method_after
private void compareWithExpectedValue(ExifInterface exifInterface, ExpectedValue expectedValue, String verboseTag, boolean assertRanges) {
    if (VERBOSE) {
        printExifTagsAndValues(verboseTag, exifInterface);
    }
    // Checks a thumbnail image.
    assertEquals(expectedValue.hasThumbnail, exifInterface.hasThumbnail());
    if (expectedValue.hasThumbnail) {
        assertNotNull(exifInterface.getThumbnailRange());
        if (assertRanges) {
            final long[] thumbnailRange = exifInterface.getThumbnailRange();
            assertEquals(expectedValue.thumbnailOffset, thumbnailRange[0]);
            assertEquals(expectedValue.thumbnailLength, thumbnailRange[1]);
        }
        byte[] thumbnailBytes = exifInterface.getThumbnailBytes();
        assertNotNull(thumbnailBytes);
        Bitmap thumbnailBitmap = exifInterface.getThumbnailBitmap();
        assertNotNull(thumbnailBitmap);
        assertEquals(expectedValue.thumbnailWidth, thumbnailBitmap.getWidth());
        assertEquals(expectedValue.thumbnailHeight, thumbnailBitmap.getHeight());
        assertEquals(expectedValue.isThumbnailCompressed, exifInterface.isThumbnailCompressed());
    } else {
        assertNull(exifInterface.getThumbnailRange());
        assertNull(exifInterface.getThumbnail());
    }
    // Checks GPS information.
    double[] latLong = exifInterface.getLatLong();
    assertEquals(expectedValue.hasLatLong, latLong != null);
    if (expectedValue.hasLatLong) {
        assertNotNull(exifInterface.getAttributeRange(ExifInterface.TAG_GPS_LATITUDE));
        if (assertRanges) {
            final long[] latitudeRange = exifInterface.getAttributeRange(ExifInterface.TAG_GPS_LATITUDE);
            assertEquals(expectedValue.latitudeOffset, latitudeRange[0]);
            assertEquals(expectedValue.latitudeLength, latitudeRange[1]);
        }
        assertEquals(expectedValue.latitude, latLong[0], DIFFERENCE_TOLERANCE);
        assertEquals(expectedValue.longitude, latLong[1], DIFFERENCE_TOLERANCE);
        assertTrue(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LATITUDE));
        assertTrue(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LONGITUDE));
    } else {
        assertNull(exifInterface.getAttributeRange(ExifInterface.TAG_GPS_LATITUDE));
        assertFalse(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LATITUDE));
        assertFalse(exifInterface.hasAttribute(ExifInterface.TAG_GPS_LONGITUDE));
    }
    assertEquals(expectedValue.altitude, exifInterface.getAltitude(.0), DIFFERENCE_TOLERANCE);
    // Checks values.
    assertStringTag(exifInterface, ExifInterface.TAG_MAKE, expectedValue.make);
    assertStringTag(exifInterface, ExifInterface.TAG_MODEL, expectedValue.model);
    assertFloatTag(exifInterface, ExifInterface.TAG_F_NUMBER, expectedValue.aperture);
    assertStringTag(exifInterface, ExifInterface.TAG_DATETIME_ORIGINAL, expectedValue.dateTimeOriginal);
    assertFloatTag(exifInterface, ExifInterface.TAG_EXPOSURE_TIME, expectedValue.exposureTime);
    assertFloatTag(exifInterface, ExifInterface.TAG_FLASH, expectedValue.flash);
    assertStringTag(exifInterface, ExifInterface.TAG_FOCAL_LENGTH, expectedValue.focalLength);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_ALTITUDE, expectedValue.gpsAltitude);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_ALTITUDE_REF, expectedValue.gpsAltitudeRef);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_DATESTAMP, expectedValue.gpsDatestamp);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LATITUDE, expectedValue.gpsLatitude);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LATITUDE_REF, expectedValue.gpsLatitudeRef);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LONGITUDE, expectedValue.gpsLongitude);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_LONGITUDE_REF, expectedValue.gpsLongitudeRef);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_PROCESSING_METHOD, expectedValue.gpsProcessingMethod);
    assertStringTag(exifInterface, ExifInterface.TAG_GPS_TIMESTAMP, expectedValue.gpsTimestamp);
    assertIntTag(exifInterface, ExifInterface.TAG_IMAGE_LENGTH, expectedValue.imageLength);
    assertIntTag(exifInterface, ExifInterface.TAG_IMAGE_WIDTH, expectedValue.imageWidth);
    assertStringTag(exifInterface, ExifInterface.TAG_PHOTOGRAPHIC_SENSITIVITY, expectedValue.iso);
    assertIntTag(exifInterface, ExifInterface.TAG_ORIENTATION, expectedValue.orientation);
    assertIntTag(exifInterface, ExifInterface.TAG_WHITE_BALANCE, expectedValue.whiteBalance);
    if (expectedValue.hasXmp) {
        assertNotNull(exifInterface.getAttributeRange(ExifInterface.TAG_XMP));
        if (assertRanges) {
            final long[] xmpRange = exifInterface.getAttributeRange(ExifInterface.TAG_XMP);
            assertEquals(expectedValue.xmpOffset, xmpRange[0]);
            assertEquals(expectedValue.xmpLength, xmpRange[1]);
        }
        final String xmp = new String(exifInterface.getAttributeBytes(ExifInterface.TAG_XMP), Charset.forName("UTF-8"));
        // Specification Part 1, Section C.2.2 for additional details.
        if (!xmp.contains("<rdf:RDF")) {
            fail("Invalid XMP: " + xmp);
        }
    } else {
        assertNull(exifInterface.getAttributeRange(ExifInterface.TAG_XMP));
    }
}
#end_block

#method_before
@Override
@NonNull
public final IBinder onBind(@NonNull Intent intent) {
    return new CallRedirectionBinder();
}
#method_after
@Override
@Nullable
public final IBinder onBind(@NonNull Intent intent) {
    return new CallRedirectionBinder();
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int width = MeasureSpec.getSize(widthMeasureSpec);
    if (MODE_SHORTCUT == getMode()) {
        // TODO: consider scaling the shortcut to fit if too small
        width = mShortcutSize + getPaddingLeft() + getPaddingRight();
    }
    final int actionHeight = mActionRow.getVisibility() != View.GONE ? mActionRowHeight : 0;
    final int heightAvailable = MeasureSpec.getSize(heightMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    LayoutParams lp = getLayoutParams();
    final int maxHeight = (lp != null && lp.height == LayoutParams.WRAP_CONTENT) || heightMode == MeasureSpec.UNSPECIFIED ? // no max, be default sizes
    -1 : heightAvailable;
    final int sliceHeight = getHeightForMode(maxHeight);
    // Remove the padding from our available height
    int height = heightAvailable - getPaddingTop() - getPaddingBottom();
    // never change the height if set to exactly
    if (heightMode != EXACTLY) {
        int requiredHeight = sliceHeight + actionHeight;
        if (height > requiredHeight || heightMode == MeasureSpec.UNSPECIFIED) {
            // Available space is larger than what the slice wants
            height = requiredHeight;
        } else {
            // Not enough space available for slice in current mode
            if (getMode() == MODE_LARGE && heightAvailable >= mLargeHeight + actionHeight) {
                height = mLargeHeight + actionHeight;
            } else if (getMode() == MODE_SHORTCUT) {
                // TODO: consider scaling the shortcut to fit if too small
                height = mShortcutSize;
            } else if (height <= mMinTemplateHeight) {
                height = mMinTemplateHeight;
            }
        }
    }
    // Measure directly instead of calling measureChild as the later substracts padding
    // from the provided size
    int childWidthSpec = makeMeasureSpec(width, EXACTLY);
    int actionRowHeight = actionHeight > 0 ? (actionHeight + getPaddingBottom()) : 0;
    mActionRow.measure(childWidthSpec, makeMeasureSpec(actionRowHeight, EXACTLY));
    // Include the bottom padding for currentView only if action row is invisible
    int currentViewHeight = height + getPaddingTop() + (actionHeight > 0 ? 0 : getPaddingBottom());
    mCurrentView.measure(childWidthSpec, makeMeasureSpec(currentViewHeight, EXACTLY));
    setMeasuredDimension(width, mCurrentView.getMeasuredHeight() + mActionRow.getMeasuredHeight());
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int width = MeasureSpec.getSize(widthMeasureSpec);
    if (MODE_SHORTCUT == getMode()) {
        // TODO: consider scaling the shortcut to fit if too small
        width = mShortcutSize + getPaddingLeft() + getPaddingRight();
    }
    final int actionHeight = mActionRow.getVisibility() != View.GONE ? mActionRowHeight : 0;
    final int heightAvailable = MeasureSpec.getSize(heightMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    LayoutParams lp = getLayoutParams();
    final int maxHeight = (lp != null && lp.height == LayoutParams.WRAP_CONTENT) || heightMode == UNSPECIFIED ? // no max, be default sizes
    -1 : heightAvailable;
    configureViewPolicy(maxHeight);
    // Remove the padding from our available height
    int childrenHeight = heightAvailable - getPaddingTop() - getPaddingBottom();
    // never change the height if set to exactly
    if (heightMode != EXACTLY) {
        if (mListContent == null || !mListContent.isValid()) {
            childrenHeight = actionHeight;
        } else if (getMode() == MODE_SHORTCUT) {
            // No compromise in case of shortcut
            childrenHeight = mShortcutSize + actionHeight;
        } else {
            int requiredHeight = mListContent.getHeight(mSliceStyle, mViewPolicy) + actionHeight;
            if (childrenHeight > requiredHeight || heightMode == UNSPECIFIED) {
                // Available space is larger than what the slice wants
                childrenHeight = requiredHeight;
            } else {
                // Not enough space available for slice in current mode
                if (getMode() == MODE_LARGE && childrenHeight >= mLargeHeight + actionHeight) {
                    childrenHeight = mLargeHeight + actionHeight;
                } else if (childrenHeight <= mMinTemplateHeight) {
                    childrenHeight = mMinTemplateHeight;
                }
            }
        }
    }
    // Measure directly instead of calling measureChild as the later substracts padding
    // from the provided size
    int childWidthSpec = makeMeasureSpec(width, EXACTLY);
    int actionRowHeight = actionHeight > 0 ? (actionHeight + getPaddingBottom()) : 0;
    mActionRow.measure(childWidthSpec, makeMeasureSpec(actionRowHeight, EXACTLY));
    // Include the bottom padding for currentView only if action row is invisible
    int currentViewHeight = childrenHeight + getPaddingTop() + (actionHeight > 0 ? 0 : getPaddingBottom());
    mCurrentView.measure(childWidthSpec, makeMeasureSpec(currentViewHeight, EXACTLY));
    setMeasuredDimension(width, mCurrentView.getMeasuredHeight() + mActionRow.getMeasuredHeight());
}
#end_block

#method_before
@Override
public void binderDied() {
    synchronized (mLock) {
        if (!mDone) {
            // If we have not gotten a "done" callback this must be a crash.
            Slog.e(TAG, "IDumpstate likely crashed. Notifying listener");
            try {
                mListener.onError(IDumpstateListener.BUGREPORT_ERROR_RUNTIME_ERROR);
            } catch (RemoteException ignored) {
            // If listener is not around, there ins't anything to do here.
            }
        }
    }
    mDs.asBinder().unlinkToDeath(this, 0);
}
#method_after
@Override
public void binderDied() {
    synchronized (mLock) {
        if (!mDone) {
            // If we have not gotten a "done" callback this must be a crash.
            Slog.e(TAG, "IDumpstate likely crashed. Notifying listener");
            try {
                mListener.onError(IDumpstateListener.BUGREPORT_ERROR_RUNTIME_ERROR);
            } catch (RemoteException ignored) {
            // If listener is not around, there isn't anything to do here.
            }
        }
    }
    mDs.asBinder().unlinkToDeath(this, 0);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(@NonNull ParcelFileDescriptor bugreportFd, @Nullable ParcelFileDescriptor screenshotFd, @NonNull BugreportParams params, @NonNull @CallbackExecutor Executor executor, @NonNull BugreportCallback callback) {
    Preconditions.checkNotNull(bugreportFd);
    Preconditions.checkNotNull(params);
    Preconditions.checkNotNull(executor);
    Preconditions.checkNotNull(callback);
    DumpstateListener dsListener = new DumpstateListener(executor, callback, bugreportFd, screenshotFd);
    try {
        // Note: mBinder can get callingUid from the binder transaction.
        mBinder.startBugreport(-1, /* callingUid */
        mContext.getOpPackageName(), bugreportFd.getFileDescriptor(), (screenshotFd != null ? screenshotFd.getFileDescriptor() : new FileDescriptor()), params.getMode(), dsListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.DUMP)
public void startBugreport(@NonNull ParcelFileDescriptor bugreportFd, @Nullable ParcelFileDescriptor screenshotFd, @NonNull BugreportParams params, @NonNull @CallbackExecutor Executor executor, @NonNull BugreportCallback callback) {
    try {
        Preconditions.checkNotNull(bugreportFd);
        Preconditions.checkNotNull(params);
        Preconditions.checkNotNull(executor);
        Preconditions.checkNotNull(callback);
        DumpstateListener dsListener = new DumpstateListener(executor, callback);
        // Note: mBinder can get callingUid from the binder transaction.
        mBinder.startBugreport(-1, /* callingUid */
        mContext.getOpPackageName(), bugreportFd.getFileDescriptor(), (screenshotFd != null ? screenshotFd.getFileDescriptor() : new FileDescriptor()), params.getMode(), dsListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } finally {
        // We can close the file descriptors here because binder would have duped them.
        IoUtils.closeQuietly(bugreportFd);
        if (screenshotFd != null) {
            IoUtils.closeQuietly(screenshotFd);
        }
    }
}
#end_block

#method_before
@Override
public void onError(int errorCode) throws RemoteException {
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onError(errorCode);
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
        closeFds();
    }
}
#method_after
@Override
public void onError(int errorCode) throws RemoteException {
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onError(errorCode);
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
@Override
public void onFinished() throws RemoteException {
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onFinished();
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
        closeFds();
    }
}
#method_after
@Override
public void onFinished() throws RemoteException {
    final long identity = Binder.clearCallingIdentity();
    try {
        mExecutor.execute(() -> {
            mCallback.onFinished();
        });
    } finally {
        Binder.restoreCallingIdentity(identity);
    }
}
#end_block

#method_before
void start(int slot) {
    mSlot = slot;
    int error = isValid();
    if (error == SUCCESS) {
        Log.d(TAG, "Starting keepalive " + mSlot + " on " + mNai.name());
        switch(mType) {
            case TYPE_NATT:
                mNai.asyncChannel.sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket);
                break;
            case TYPE_TCP:
                try {
                    mTcpController.startSocketMonitor(mFd, this, mSlot);
                } catch (IllegalArgumentException e) {
                    handleStopKeepalive(mNai, mSlot, ERROR_INVALID_SOCKET);
                    return;
                }
                mNai.asyncChannel.sendMessage(CMD_ADD_KEEPALIVE_PACKET_FILTER, slot, 0, /* Unused */
                mPacket);
                // TODO: check result from apf and notify of failure as needed.
                mNai.asyncChannel.sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket);
                break;
            default:
                Log.wtf(TAG, "Starting keepalive with unknown type: " + mType);
                handleStopKeepalive(mNai, mSlot, error);
                return;
        }
        mStartedState = STARTING;
    } else {
        handleStopKeepalive(mNai, mSlot, error);
        return;
    }
}
#method_after
void start(int slot) {
    mSlot = slot;
    int error = isValid();
    if (error == SUCCESS) {
        Log.d(TAG, "Starting keepalive " + mSlot + " on " + mNai.name());
        switch(mType) {
            case TYPE_NATT:
                mNai.asyncChannel.sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket);
                break;
            case TYPE_TCP:
                try {
                    mTcpController.startSocketMonitor(mFd, this, mSlot);
                } catch (InvalidSocketException e) {
                    handleStopKeepalive(mNai, mSlot, ERROR_INVALID_SOCKET);
                    return;
                }
                mNai.asyncChannel.sendMessage(CMD_ADD_KEEPALIVE_PACKET_FILTER, slot, 0, /* Unused */
                mPacket);
                // TODO: check result from apf and notify of failure as needed.
                mNai.asyncChannel.sendMessage(CMD_START_SOCKET_KEEPALIVE, slot, mInterval, mPacket);
                break;
            default:
                Log.wtf(TAG, "Starting keepalive with unknown type: " + mType);
                handleStopKeepalive(mNai, mSlot, error);
                return;
        }
        mStartedState = STARTING;
    } else {
        handleStopKeepalive(mNai, mSlot, error);
        return;
    }
}
#end_block

#method_before
protected SmsTracker getSmsTracker(String callingPackage, HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent, String format, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, SmsHeader smsHeader, boolean expectMore, String fullMessageText, boolean isText, boolean persistMessage, int priority, int validityPeriod) {
    // Get calling app package name via UID from Binder call
    PackageManager pm = mContext.getPackageManager();
    // Get package info via packagemanager
    final int userId = UserHandle.getCallingUserId();
    PackageInfo appInfo = null;
    try {
        // XXX this is lossy- apps can share a UID
        appInfo = pm.getPackageInfoAsUser(callingPackage, PackageManager.GET_SIGNATURES, userId);
    } catch (PackageManager.NameNotFoundException e) {
    // error will be logged in sendRawPdu
    }
    // Strip non-digits from destination phone number before checking for short codes
    // and before displaying the number to the user if confirmation is required.
    String destAddr = PhoneNumberUtils.extractNetworkPortion((String) data.get("destAddr"));
    return new SmsTracker(data, sentIntent, deliveryIntent, appInfo, destAddr, format, unsentPartCount, anyPartFailed, messageUri, smsHeader, expectMore, fullMessageText, getSubId(), isText, persistMessage, userId, priority, validityPeriod);
}
#method_after
protected SmsTracker getSmsTracker(String callingPackage, HashMap<String, Object> data, PendingIntent sentIntent, PendingIntent deliveryIntent, String format, AtomicInteger unsentPartCount, AtomicBoolean anyPartFailed, Uri messageUri, SmsHeader smsHeader, boolean expectMore, String fullMessageText, boolean isText, boolean persistMessage, int priority, int validityPeriod) {
    // Get calling app package name via UID from Binder call
    PackageManager pm = mContext.getPackageManager();
    // Get package info via packagemanager
    final int userId = UserHandle.getCallingUserId();
    PackageInfo appInfo = null;
    try {
        appInfo = pm.getPackageInfoAsUser(callingPackage, PackageManager.GET_SIGNATURES, userId);
    } catch (PackageManager.NameNotFoundException e) {
    // error will be logged in sendRawPdu
    }
    // Strip non-digits from destination phone number before checking for short codes
    // and before displaying the number to the user if confirmation is required.
    String destAddr = PhoneNumberUtils.extractNetworkPortion((String) data.get("destAddr"));
    return new SmsTracker(data, sentIntent, deliveryIntent, appInfo, destAddr, format, unsentPartCount, anyPartFailed, messageUri, smsHeader, expectMore, fullMessageText, getSubId(), isText, persistMessage, userId, priority, validityPeriod);
}
#end_block

#method_before
/**
 * Send a data based SMS to a specific application port.
 *
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *  the current default SMSC
 * @param destPort the port to deliver the message to
 * @param data the body of the message to send
 * @param sentIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is successfully sent, or failed.
 *  The result code will be <code>Activity.RESULT_OK<code> for success,
 *  or one of these errors:<br>
 *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
 *  <code>RESULT_ERROR_RADIO_OFF</code><br>
 *  <code>RESULT_ERROR_NULL_PDU</code><br>
 *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
 *  the extra "errorCode" containing a radio technology specific value,
 *  generally only useful for troubleshooting.<br>
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is delivered to the recipient.  The
 *  raw pdu of the status report is in the extended data ("pdu").
 */
private void sendDataInternal(String callingPackage, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendData: destAddr=" + destAddr + " scAddr=" + scAddr + " destPort=" + destPort + " data='" + HexDump.toHexString(data) + "' sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent);
    }
    destAddr = filterDestAddress(destAddr);
    mDispatchersController.sendData(callingPackage, destAddr, scAddr, destPort, data, sentIntent, deliveryIntent);
}
#method_after
/**
 * Send a data based SMS to a specific application port.
 *
 * @param callingPackage the package name of the calling app
 * @param destAddr the address to send the message to
 * @param scAddr is the service center address or null to use
 *  the current default SMSC
 * @param destPort the port to deliver the message to
 * @param data the body of the message to send
 * @param sentIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is successfully sent, or failed.
 *  The result code will be <code>Activity.RESULT_OK<code> for success,
 *  or one of these errors:<br>
 *  <code>RESULT_ERROR_GENERIC_FAILURE</code><br>
 *  <code>RESULT_ERROR_RADIO_OFF</code><br>
 *  <code>RESULT_ERROR_NULL_PDU</code><br>
 *  For <code>RESULT_ERROR_GENERIC_FAILURE</code> the sentIntent may include
 *  the extra "errorCode" containing a radio technology specific value,
 *  generally only useful for troubleshooting.<br>
 *  The per-application based SMS control checks sentIntent. If sentIntent
 *  is NULL the caller will be checked against all unknown applications,
 *  which cause smaller number of SMS to be sent in checking period.
 * @param deliveryIntent if not NULL this <code>PendingIntent</code> is
 *  broadcast when the message is delivered to the recipient.  The
 *  raw pdu of the status report is in the extended data ("pdu").
 */
private void sendDataInternal(String callingPackage, String destAddr, String scAddr, int destPort, byte[] data, PendingIntent sentIntent, PendingIntent deliveryIntent) {
    if (Rlog.isLoggable("SMS", Log.VERBOSE)) {
        log("sendData: destAddr=" + destAddr + " scAddr=" + scAddr + " destPort=" + destPort + " data='" + HexDump.toHexString(data) + "' sentIntent=" + sentIntent + " deliveryIntent=" + deliveryIntent);
    }
    destAddr = filterDestAddress(destAddr);
    mDispatchersController.sendData(callingPackage, destAddr, scAddr, destPort, data, sentIntent, deliveryIntent);
}
#end_block

#method_before
private String getElementName(XsdElement element) {
    if (element instanceof XsdChoice) {
        return element.getName() + "_optional";
    }
    return element.getName();
}
#method_after
private String getElementName(XsdElement element) {
    if (element instanceof XsdChoice) {
        return element.getName() + "_optional";
    } else if (element instanceof XsdAll) {
        return element.getName() + "_all";
    }
    return element.getName();
}
#end_block

#method_before
@NonNull
public Config build() {
    if (mPrefetchDistance < 0) {
        mPrefetchDistance = mPageSize;
    }
    if (mInitialLoadSizeHint < 0) {
        mInitialLoadSizeHint = mPageSize * DEFAULT_INITIAL_PAGE_MULTIPLIER;
    }
    if (!mEnablePlaceholders && mPrefetchDistance == 0) {
        throw new IllegalArgumentException("Placeholders and prefetch are the only ways" + " to trigger loading of more data in the PagedList, so either" + " placeholders must be enabled, or prefetch distance must be > 0.");
    }
    if (mMaxSize != MAX_SIZE_UNBOUNDED) {
        if (mMaxSize < mPageSize + mPrefetchDistance * 2) {
            throw new IllegalArgumentException("Maximum size must be at least" + " pageSize + 2*prefetchDist, pageSize=" + mPageSize + ", prefetchDist=" + mPrefetchDistance + ", maxSize=" + mMaxSize);
        }
    }
    return new Config(mPageSize, mPrefetchDistance, mEnablePlaceholders, mInitialLoadSizeHint, mMaxSize);
}
#method_after
@Deprecated
@WorkerThread
@NonNull
public PagedList<Value> build() {
    // TODO: define defaults, once they can be used in module without android dependency
    if (mNotifyExecutor == null) {
        throw new IllegalArgumentException("MainThreadExecutor required");
    }
    if (mFetchExecutor == null) {
        throw new IllegalArgumentException("BackgroundThreadExecutor required");
    }
    try {
        return create(DirectExecutor.INSTANCE).get();
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    } catch (ExecutionException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private synchronized ChannelAccess internal_setUpChannelAccess(byte[] aid, String packageName, boolean checkRefreshTag) throws IOException, MissingResourceException {
    if (packageName == null || packageName.isEmpty()) {
        throw new AccessControlException("package names must be specified");
    }
    try {
        // estimate SHA-1 hash value of the device application's certificate.
        ArrayList<byte[]> appCertHashes = getAPPCertHashes(packageName);
        // APP certificates must be available => otherwise Exception
        if (appCertHashes == null || appCertHashes.size() == 0) {
            throw new AccessControlException("Application certificates are invalid or do not exist.");
        }
        if (checkRefreshTag) {
            updateAccessRuleIfNeed();
        }
        return getAccessRule(aid, appCertHashes);
    } catch (IOException | MissingResourceException e) {
        throw e;
    } catch (Throwable exp) {
        throw new AccessControlException(exp.getMessage());
    }
}
#method_after
private synchronized ChannelAccess internal_setUpChannelAccess(byte[] aid, String packageName, boolean checkRefreshTag) throws IOException, MissingResourceException {
    if (packageName == null || packageName.isEmpty()) {
        throw new AccessControlException("package names must be specified");
    }
    try {
        // estimate SHA-1 and SHA-256 hash values of the device application's certificate.
        List<byte[]> appCertHashes = getAppCertHashes(packageName);
        // APP certificates must be available => otherwise Exception
        if (appCertHashes == null || appCertHashes.size() == 0) {
            throw new AccessControlException("Application certificates are invalid or do not exist.");
        }
        if (checkRefreshTag) {
            updateAccessRuleIfNeed();
        }
        return getAccessRule(aid, appCertHashes);
    } catch (IOException | MissingResourceException e) {
        throw e;
    } catch (Throwable exp) {
        throw new AccessControlException(exp.getMessage());
    }
}
#end_block

#method_before
public ChannelAccess getAccessRule(byte[] aid, ArrayList<byte[]> appCertHashes) throws AccessControlException {
    ChannelAccess channelAccess = null;
    // if read all is true get rule from cache.
    if (mRulesRead) {
        // get rules from internal storage
        channelAccess = mAccessRuleCache.findAccessRule(aid, appCertHashes);
    }
    // with all access denied.
    if (channelAccess == null) {
        channelAccess = new ChannelAccess();
        channelAccess.setAccess(ChannelAccess.ACCESS.DENIED, "no access rule found!");
        channelAccess.setApduAccess(ChannelAccess.ACCESS.DENIED);
        channelAccess.setNFCEventAccess(ChannelAccess.ACCESS.DENIED);
    }
    return channelAccess;
}
#method_after
public ChannelAccess getAccessRule(byte[] aid, List<byte[]> appCertHashes) throws AccessControlException {
    ChannelAccess channelAccess = null;
    // if read all is true get rule from cache.
    if (mRulesRead) {
        // get rules from internal storage
        channelAccess = mAccessRuleCache.findAccessRule(aid, appCertHashes);
    }
    // with all access denied.
    if (channelAccess == null) {
        channelAccess = new ChannelAccess();
        channelAccess.setAccess(ChannelAccess.ACCESS.DENIED, "no access rule found!");
        channelAccess.setApduAccess(ChannelAccess.ACCESS.DENIED);
        channelAccess.setNFCEventAccess(ChannelAccess.ACCESS.DENIED);
    }
    return channelAccess;
}
#end_block

#method_before
private synchronized boolean[] internal_isNfcEventAllowed(byte[] aid, String[] packageNames) {
    int i = 0;
    boolean[] nfcEventFlags = new boolean[packageNames.length];
    for (String packageName : packageNames) {
        // estimate hash value of the device application's certificate.
        try {
            ArrayList<byte[]> appCertHashes = getAPPCertHashes(packageName);
            // APP certificates must be available => otherwise Exception
            if (appCertHashes == null || appCertHashes.size() == 0) {
                nfcEventFlags[i] = false;
            } else {
                ChannelAccess channelAccess = getAccessRule(aid, appCertHashes);
                nfcEventFlags[i] = (channelAccess.getNFCEventAccess() == ChannelAccess.ACCESS.ALLOWED);
            }
        } catch (Exception e) {
            Log.w(mTag, " Access Rules for NFC: " + e.getLocalizedMessage());
            nfcEventFlags[i] = false;
        }
        i++;
    }
    return nfcEventFlags;
}
#method_after
private synchronized boolean[] internal_isNfcEventAllowed(byte[] aid, String[] packageNames) {
    int i = 0;
    boolean[] nfcEventFlags = new boolean[packageNames.length];
    for (String packageName : packageNames) {
        // estimate hash value of the device application's certificate.
        try {
            List<byte[]> appCertHashes = getAppCertHashes(packageName);
            // APP certificates must be available => otherwise Exception
            if (appCertHashes == null || appCertHashes.size() == 0) {
                nfcEventFlags[i] = false;
            } else {
                ChannelAccess channelAccess = getAccessRule(aid, appCertHashes);
                nfcEventFlags[i] = (channelAccess.getNFCEventAccess() == ChannelAccess.ACCESS.ALLOWED);
            }
        } catch (Exception e) {
            Log.w(mTag, " Access Rules for NFC: " + e.getLocalizedMessage());
            nfcEventFlags[i] = false;
        }
        i++;
    }
    return nfcEventFlags;
}
#end_block

#method_before
@Override
public void interpret() throws ParserException {
    mHash = new byte[0];
    byte[] data = getRawData();
    int index = getValueIndex();
    // sanity checks
    if (getValueLength() != 0 && getValueLength() != SHA1_LEN && getValueLength() != SHA256_LEN) {
        throw new ParserException("Invalid value length for Hash-REF-DO!");
    }
    if (getValueLength() != 0) {
        if (index + getValueLength() > data.length) {
            throw new ParserException("Not enough data for Hash-REF-DO!");
        }
        mHash = new byte[getValueLength()];
        System.arraycopy(data, index, mHash, 0, getValueLength());
    }
}
#method_after
@Override
public void interpret() throws ParserException {
    mHash = new byte[0];
    byte[] data = getRawData();
    int index = getValueIndex();
    int length = getValueLength();
    // sanity checks
    if (length != 0 && length != SHA1_LEN && length != SHA256_LEN) {
        throw new ParserException("Invalid value length for Hash-REF-DO!");
    }
    if (length != 0) {
        if (index + length > data.length) {
            throw new ParserException("Not enough data for Hash-REF-DO!");
        }
        mHash = new byte[length];
        System.arraycopy(data, index, mHash, 0, length);
    }
}
#end_block

#method_before
public ChannelAccess findAccessRule(byte[] aid, ArrayList<byte[]> appCertHashes) throws AccessControlException {
    // TODO: check difference between DeviceCertHash and Certificate Chain (EndEntityCertHash,
    // IntermediateCertHash (1..n), RootCertHash)
    // The DeviceCertificate is equal to the EndEntityCertificate.
    // The android systems seems always to deliver only the EndEntityCertificate, but this
    // seems not
    // to be sure.
    // thats why we implement the whole chain.
    /* Search Rule A ( Certificate(s); AID ) */
    AID_REF_DO aid_ref_do = getAidRefDo(aid);
    REF_DO ref_do;
    Hash_REF_DO hash_ref_do;
    for (byte[] appCertHash : appCertHashes) {
        hash_ref_do = new Hash_REF_DO(appCertHash);
        ref_do = new REF_DO(aid_ref_do, hash_ref_do);
        if (mRuleCache.containsKey(ref_do)) {
            // let's take care about the undefined rules, according to the GP specification:
            ChannelAccess ca = mRuleCache.get(ref_do);
            if (ca.getApduAccess() == ChannelAccess.ACCESS.UNDEFINED) {
                ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
            }
            if ((ca.getNFCEventAccess() == ChannelAccess.ACCESS.UNDEFINED) && (ca.getApduAccess() != ChannelAccess.ACCESS.UNDEFINED)) {
                ca.setNFCEventAccess(ca.getApduAccess());
            }
            if (DEBUG) {
                Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
            }
            return mRuleCache.get(ref_do);
        }
    }
    // is used together with another specific hash value (another device application)
    if (searchForRulesWithSpecificAidButOtherHash(aid_ref_do) != null) {
        if (DEBUG) {
            Log.i(mTag, "Conflict Resolution Case A returning access rule \'NEVER\'.");
        }
        ChannelAccess ca = new ChannelAccess();
        ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
        ca.setAccess(ChannelAccess.ACCESS.DENIED, "AID has a specific access rule with a different hash. (Case A)");
        ca.setNFCEventAccess(ChannelAccess.ACCESS.DENIED);
        return ca;
    }
    // SearchRule B ( <AllDeviceApplications>; AID)
    aid_ref_do = getAidRefDo(aid);
    // empty hash ref
    hash_ref_do = new Hash_REF_DO();
    ref_do = new REF_DO(aid_ref_do, hash_ref_do);
    if (mRuleCache.containsKey(ref_do)) {
        if (DEBUG) {
            Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
        }
        return mRuleCache.get(ref_do);
    }
    // Search Rule C ( Certificate(s); <AllSEApplications> )
    aid_ref_do = new AID_REF_DO(AID_REF_DO.TAG);
    for (byte[] appCertHash : appCertHashes) {
        hash_ref_do = new Hash_REF_DO(appCertHash);
        ref_do = new REF_DO(aid_ref_do, hash_ref_do);
        if (mRuleCache.containsKey(ref_do)) {
            // let's take care about the undefined rules, according to the GP specification:
            ChannelAccess ca = mRuleCache.get(ref_do);
            if (ca.getApduAccess() == ChannelAccess.ACCESS.UNDEFINED) {
                ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
            }
            if ((ca.getNFCEventAccess() == ChannelAccess.ACCESS.UNDEFINED) && (ca.getApduAccess() != ChannelAccess.ACCESS.UNDEFINED)) {
                ca.setNFCEventAccess(ca.getApduAccess());
            }
            if (DEBUG) {
                Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
            }
            return mRuleCache.get(ref_do);
        }
    }
    // is used together with another Hash
    if (searchForRulesWithAllAidButOtherHash() != null) {
        if (DEBUG) {
            Log.i(mTag, "Conflict Resolution Case C returning access rule \'NEVER\'.");
        }
        ChannelAccess ca = new ChannelAccess();
        ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
        ca.setAccess(ChannelAccess.ACCESS.DENIED, "An access rule with a different hash and all AIDs was found. (Case C)");
        ca.setNFCEventAccess(ChannelAccess.ACCESS.DENIED);
        return ca;
    }
    // SearchRule D ( <AllDeviceApplications>; <AllSEApplications>)
    aid_ref_do = new AID_REF_DO(AID_REF_DO.TAG);
    hash_ref_do = new Hash_REF_DO();
    ref_do = new REF_DO(aid_ref_do, hash_ref_do);
    if (mRuleCache.containsKey(ref_do)) {
        if (DEBUG) {
            Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
        }
        return mRuleCache.get(ref_do);
    }
    if (DEBUG)
        Log.i(mTag, "findAccessRule() not found");
    return null;
}
#method_after
public ChannelAccess findAccessRule(byte[] aid, List<byte[]> appCertHashes) throws AccessControlException {
    // TODO: check difference between DeviceCertHash and Certificate Chain (EndEntityCertHash,
    // IntermediateCertHash (1..n), RootCertHash)
    // The DeviceCertificate is equal to the EndEntityCertificate.
    // The android systems seems always to deliver only the EndEntityCertificate, but this
    // seems not
    // to be sure.
    // thats why we implement the whole chain.
    /* Search Rule A ( Certificate(s); AID ) */
    AID_REF_DO aid_ref_do = getAidRefDo(aid);
    REF_DO ref_do;
    Hash_REF_DO hash_ref_do;
    for (byte[] appCertHash : appCertHashes) {
        hash_ref_do = new Hash_REF_DO(appCertHash);
        ref_do = new REF_DO(aid_ref_do, hash_ref_do);
        if (mRuleCache.containsKey(ref_do)) {
            // let's take care about the undefined rules, according to the GP specification:
            ChannelAccess ca = mRuleCache.get(ref_do);
            if (ca.getApduAccess() == ChannelAccess.ACCESS.UNDEFINED) {
                ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
            }
            if ((ca.getNFCEventAccess() == ChannelAccess.ACCESS.UNDEFINED) && (ca.getApduAccess() != ChannelAccess.ACCESS.UNDEFINED)) {
                ca.setNFCEventAccess(ca.getApduAccess());
            }
            if (DEBUG) {
                Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
            }
            return mRuleCache.get(ref_do);
        }
    }
    // is used together with another specific hash value (another device application)
    if (searchForRulesWithSpecificAidButOtherHash(aid_ref_do) != null) {
        if (DEBUG) {
            Log.i(mTag, "Conflict Resolution Case A returning access rule \'NEVER\'.");
        }
        ChannelAccess ca = new ChannelAccess();
        ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
        ca.setAccess(ChannelAccess.ACCESS.DENIED, "AID has a specific access rule with a different hash. (Case A)");
        ca.setNFCEventAccess(ChannelAccess.ACCESS.DENIED);
        return ca;
    }
    // SearchRule B ( <AllDeviceApplications>; AID)
    aid_ref_do = getAidRefDo(aid);
    // empty hash ref
    hash_ref_do = new Hash_REF_DO();
    ref_do = new REF_DO(aid_ref_do, hash_ref_do);
    if (mRuleCache.containsKey(ref_do)) {
        // let's take care about the undefined rules, according to the GP specification:
        ChannelAccess ca = mRuleCache.get(ref_do);
        if (ca.getApduAccess() == ChannelAccess.ACCESS.UNDEFINED) {
            ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
        }
        if ((ca.getNFCEventAccess() == ChannelAccess.ACCESS.UNDEFINED) && (ca.getApduAccess() != ChannelAccess.ACCESS.UNDEFINED)) {
            ca.setNFCEventAccess(ca.getApduAccess());
        }
        if (DEBUG) {
            Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
        }
        return mRuleCache.get(ref_do);
    }
    // Search Rule C ( Certificate(s); <AllSEApplications> )
    aid_ref_do = new AID_REF_DO(AID_REF_DO.TAG);
    for (byte[] appCertHash : appCertHashes) {
        hash_ref_do = new Hash_REF_DO(appCertHash);
        ref_do = new REF_DO(aid_ref_do, hash_ref_do);
        if (mRuleCache.containsKey(ref_do)) {
            // let's take care about the undefined rules, according to the GP specification:
            ChannelAccess ca = mRuleCache.get(ref_do);
            if (ca.getApduAccess() == ChannelAccess.ACCESS.UNDEFINED) {
                ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
            }
            if ((ca.getNFCEventAccess() == ChannelAccess.ACCESS.UNDEFINED) && (ca.getApduAccess() != ChannelAccess.ACCESS.UNDEFINED)) {
                ca.setNFCEventAccess(ca.getApduAccess());
            }
            if (DEBUG) {
                Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
            }
            return mRuleCache.get(ref_do);
        }
    }
    // is used together with another Hash
    if (searchForRulesWithAllAidButOtherHash() != null) {
        if (DEBUG) {
            Log.i(mTag, "Conflict Resolution Case C returning access rule \'NEVER\'.");
        }
        ChannelAccess ca = new ChannelAccess();
        ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
        ca.setAccess(ChannelAccess.ACCESS.DENIED, "An access rule with a different hash and all AIDs was found. (Case C)");
        ca.setNFCEventAccess(ChannelAccess.ACCESS.DENIED);
        return ca;
    }
    // SearchRule D ( <AllDeviceApplications>; <AllSEApplications>)
    aid_ref_do = new AID_REF_DO(AID_REF_DO.TAG);
    hash_ref_do = new Hash_REF_DO();
    ref_do = new REF_DO(aid_ref_do, hash_ref_do);
    if (mRuleCache.containsKey(ref_do)) {
        // let's take care about the undefined rules, according to the GP specification:
        ChannelAccess ca = mRuleCache.get(ref_do);
        if (ca.getApduAccess() == ChannelAccess.ACCESS.UNDEFINED) {
            ca.setApduAccess(ChannelAccess.ACCESS.DENIED);
        }
        if ((ca.getNFCEventAccess() == ChannelAccess.ACCESS.UNDEFINED) && (ca.getApduAccess() != ChannelAccess.ACCESS.UNDEFINED)) {
            ca.setNFCEventAccess(ca.getApduAccess());
        }
        if (DEBUG) {
            Log.i(mTag, "findAccessRule() " + ref_do.toString() + ", " + mRuleCache.get(ref_do).toString());
        }
        return mRuleCache.get(ref_do);
    }
    if (DEBUG)
        Log.i(mTag, "findAccessRule() not found");
    return null;
}
#end_block

#method_before
@Test
public void testSuppressedErrorPage() throws Throwable {
    WebkitUtils.checkFeature(WebViewFeature.SUPPRESS_ERROR_PAGE);
    WebSettingsCompat.setWillSuppressErrorPage(mWebViewOnUiThread.getSettings(), true);
    assertTrue(WebSettingsCompat.willSuppressErrorPage(mWebViewOnUiThread.getSettings()));
// TODO(cricke): Consider testing that error page suppression actually also happens in
// Chromium. In other words, recreating testWillSuppressErrorPage in
// org.chromium.android_webview.test.AwSettingsTest using only public WebView APIs
}
#method_after
@Test
public void testSuppressedErrorPage() throws Throwable {
    WebkitUtils.checkFeature(WebViewFeature.SUPPRESS_ERROR_PAGE);
    // default value should be false
    assertFalse(WebSettingsCompat.willSuppressErrorPage(mWebViewOnUiThread.getSettings()));
    WebSettingsCompat.setWillSuppressErrorPage(mWebViewOnUiThread.getSettings(), true);
    assertTrue(WebSettingsCompat.willSuppressErrorPage(mWebViewOnUiThread.getSettings()));
// We could test that suppression actually happens, similar to #testWillSuppressErrorPage in
// org.chromium.android_webview.test.AwSettingsTest using only public WebView APIs.
// However, at the time of writing, that test is potentially flaky (waits 1000ms after a
// bad navigation and then checks).
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@SuppressLint("NewApi")
@RequiresFeature(name = WebViewFeature.SUPPRESS_ERROR_PAGE, enforcement = "androidx.webkit.WebViewFeature#isFeatureSupported")
public static void setWillSuppressErrorPage(WebSettings webSettings, boolean suppressed) {
    WebViewFeatureInternal webviewFeature = WebViewFeatureInternal.getFeature(WebViewFeature.SUPPRESS_ERROR_PAGE);
    if (webviewFeature.isSupportedByWebView()) {
        getAdapter(webSettings).setWillSuppressErrorPage(suppressed);
    } else {
        throw WebViewFeatureInternal.getUnsupportedOperationException();
    }
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY)
@SuppressLint("NewApi")
@RequiresFeature(name = WebViewFeature.SUPPRESS_ERROR_PAGE, enforcement = "androidx.webkit.WebViewFeature#isFeatureSupported")
public static void setWillSuppressErrorPage(WebSettings webSettings, boolean suppressed) {
    WebViewFeatureInternal webviewFeature = WebViewFeatureInternal.getFeature(WebViewFeature.SUPPRESS_ERROR_PAGE);
    if (webviewFeature.isSupportedByWebView()) {
        getAdapter(webSettings).setWillSuppressErrorPage(suppressed);
    } else {
        throw WebViewFeatureInternal.getUnsupportedOperationException();
    }
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@SuppressLint("NewApi")
@RequiresFeature(name = WebViewFeature.SUPPRESS_ERROR_PAGE, enforcement = "androidx.webkit.WebViewFeature#isFeatureSupported")
public static boolean willSuppressErrorPage(WebSettings webSettings) {
    WebViewFeatureInternal webviewFeature = WebViewFeatureInternal.getFeature(WebViewFeature.SUPPRESS_ERROR_PAGE);
    if (webviewFeature.isSupportedByWebView()) {
        return getAdapter(webSettings).willSuppressErrorPage();
    } else {
        throw WebViewFeatureInternal.getUnsupportedOperationException();
    }
}
#method_after
@RestrictTo(RestrictTo.Scope.LIBRARY)
@SuppressLint("NewApi")
@RequiresFeature(name = WebViewFeature.SUPPRESS_ERROR_PAGE, enforcement = "androidx.webkit.WebViewFeature#isFeatureSupported")
public static boolean willSuppressErrorPage(WebSettings webSettings) {
    WebViewFeatureInternal webviewFeature = WebViewFeatureInternal.getFeature(WebViewFeature.SUPPRESS_ERROR_PAGE);
    if (webviewFeature.isSupportedByWebView()) {
        return getAdapter(webSettings).willSuppressErrorPage();
    } else {
        throw WebViewFeatureInternal.getUnsupportedOperationException();
    }
}
#end_block

#method_before
private static String readFirstLineFromFile(String path) throws IOException {
    BufferedReader reader = new BufferedReader(new FileReader(path));
    String line = reader.readLine();
    reader.close();
    return line;
}
#method_after
private static String readFirstLineFromFile(String path) throws IOException {
    if (!new File(path).exists()) {
        return null;
    }
    final BufferedReader reader = new BufferedReader(new FileReader(path));
    final String line = reader.readLine();
    reader.close();
    return line;
}
#end_block

#method_before
public String toString() {
    return "NetworkAgentInfo{ ni{" + networkInfo + "}  " + "network{" + network + "}  nethandle{" + network.getNetworkHandle() + "}  " + "lp{" + linkProperties + "}  " + "nc{" + networkCapabilities + "}  Score{" + getCurrentScore() + "}  " + "everValidated{" + everValidated + "}  lastValidated{" + lastValidated + "}  " + "created{" + created + "} lingering{" + isLingering() + "} " + "explicitlySelected{" + networkMisc.explicitlySelected + "} " + "acceptUnvalidated{" + networkMisc.acceptUnvalidated + "} " + "everCaptivePortalDetected{" + everCaptivePortalDetected + "} " + "lastCaptivePortalDetected{" + lastCaptivePortalDetected + "} " + "partialConnectivity{" + partialConnectivity + "} " + "clat{" + clatd + "} " + "}";
}
#method_after
// TODO: Print shorter members first and only print the boolean variable which value is true
public String toString() {
    return "NetworkAgentInfo{ ni{" + networkInfo + "}  " + "network{" + network + "}  nethandle{" + network.getNetworkHandle() + "}  " + "lp{" + linkProperties + "}  " + "nc{" + networkCapabilities + "}  Score{" + getCurrentScore() + "}  " + "everValidated{" + everValidated + "}  lastValidated{" + lastValidated + "}  " + "created{" + created + "} lingering{" + isLingering() + "} " + "explicitlySelected{" + networkMisc.explicitlySelected + "} " + "acceptUnvalidated{" + networkMisc.acceptUnvalidated + "} " + "everCaptivePortalDetected{" + everCaptivePortalDetected + "} " + "lastCaptivePortalDetected{" + lastCaptivePortalDetected + "} " + "captivePortalLoginNotified{" + captivePortalLoginNotified + "} " + "partialConnectivity{" + partialConnectivity + "} " + "acceptPartialConnectivity{" + networkMisc.acceptPartialConnectivity + "} " + "clat{" + clatd + "} " + "}";
}
#end_block

#method_before
public void clearAll() {
    mNetworkCapabilities = mTransportTypes = mUnwantedNetworkCapabilities = 0;
    mLinkUpBandwidthKbps = mLinkDownBandwidthKbps = LINK_BANDWIDTH_UNSPECIFIED;
    mNetworkSpecifier = null;
    mSignalStrength = SIGNAL_STRENGTH_UNSPECIFIED;
    mUids = null;
    mEstablishingVpnAppUid = INVALID_UID;
    mSSID = null;
}
#method_after
public void clearAll() {
    mNetworkCapabilities = mTransportTypes = mUnwantedNetworkCapabilities = 0;
    mLinkUpBandwidthKbps = mLinkDownBandwidthKbps = LINK_BANDWIDTH_UNSPECIFIED;
    mNetworkSpecifier = null;
    mTransportInfo = null;
    mSignalStrength = SIGNAL_STRENGTH_UNSPECIFIED;
    mUids = null;
    mEstablishingVpnAppUid = INVALID_UID;
    mSSID = null;
}
#end_block

#method_before
public void set(NetworkCapabilities nc) {
    mNetworkCapabilities = nc.mNetworkCapabilities;
    mTransportTypes = nc.mTransportTypes;
    mLinkUpBandwidthKbps = nc.mLinkUpBandwidthKbps;
    mLinkDownBandwidthKbps = nc.mLinkDownBandwidthKbps;
    mNetworkSpecifier = nc.mNetworkSpecifier;
    mSignalStrength = nc.mSignalStrength;
    // Will make the defensive copy
    setUids(nc.mUids);
    mEstablishingVpnAppUid = nc.mEstablishingVpnAppUid;
    mUnwantedNetworkCapabilities = nc.mUnwantedNetworkCapabilities;
    mSSID = nc.mSSID;
}
#method_after
public void set(NetworkCapabilities nc) {
    mNetworkCapabilities = nc.mNetworkCapabilities;
    mTransportTypes = nc.mTransportTypes;
    mLinkUpBandwidthKbps = nc.mLinkUpBandwidthKbps;
    mLinkDownBandwidthKbps = nc.mLinkDownBandwidthKbps;
    mNetworkSpecifier = nc.mNetworkSpecifier;
    mTransportInfo = nc.mTransportInfo;
    mSignalStrength = nc.mSignalStrength;
    // Will make the defensive copy
    setUids(nc.mUids);
    mEstablishingVpnAppUid = nc.mEstablishingVpnAppUid;
    mUnwantedNetworkCapabilities = nc.mUnwantedNetworkCapabilities;
    mSSID = nc.mSSID;
}
#end_block

#method_before
@TestApi
@Transport
public int[] getTransportTypes() {
    return BitUtils.unpackBits(mTransportTypes);
}
#method_after
@TestApi
@SystemApi
@Transport
public int[] getTransportTypes() {
    return BitUtils.unpackBits(mTransportTypes);
}
#end_block

#method_before
@UnsupportedAppUsage
public int getSignalStrength() {
    return mSignalStrength;
}
#method_after
@SystemApi
public int getSignalStrength() {
    return mSignalStrength;
}
#end_block

#method_before
public void combineCapabilities(NetworkCapabilities nc) {
    combineNetCapabilities(nc);
    combineTransportTypes(nc);
    combineLinkBandwidths(nc);
    combineSpecifiers(nc);
    combineSignalStrength(nc);
    combineUids(nc);
    combineSSIDs(nc);
}
#method_after
public void combineCapabilities(NetworkCapabilities nc) {
    combineNetCapabilities(nc);
    combineTransportTypes(nc);
    combineLinkBandwidths(nc);
    combineSpecifiers(nc);
    combineTransportInfos(nc);
    combineSignalStrength(nc);
    combineUids(nc);
    combineSSIDs(nc);
}
#end_block

#method_before
public boolean satisfiedByNetworkCapabilities(NetworkCapabilities nc) {
    return satisfiedByNetworkCapabilities(nc, false);
}
#method_after
@TestApi
@SystemApi
public boolean satisfiedByNetworkCapabilities(NetworkCapabilities nc) {
    return satisfiedByNetworkCapabilities(nc, false);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsUids(that) && equalsSSID(that));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null || (obj instanceof NetworkCapabilities == false))
        return false;
    NetworkCapabilities that = (NetworkCapabilities) obj;
    return (equalsNetCapabilities(that) && equalsTransportTypes(that) && equalsLinkBandwidths(that) && equalsSignalStrength(that) && equalsSpecifier(that) && equalsTransportInfo(that) && equalsUids(that) && equalsSSID(that));
}
#end_block

#method_before
@Override
public int hashCode() {
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37;
}
#method_after
@Override
public int hashCode() {
    return (int) (mNetworkCapabilities & 0xFFFFFFFF) + ((int) (mNetworkCapabilities >> 32) * 3) + ((int) (mUnwantedNetworkCapabilities & 0xFFFFFFFF) * 5) + ((int) (mUnwantedNetworkCapabilities >> 32) * 7) + ((int) (mTransportTypes & 0xFFFFFFFF) * 11) + ((int) (mTransportTypes >> 32) * 13) + (mLinkUpBandwidthKbps * 17) + (mLinkDownBandwidthKbps * 19) + Objects.hashCode(mNetworkSpecifier) * 23 + (mSignalStrength * 29) + Objects.hashCode(mUids) * 31 + Objects.hashCode(mSSID) * 37 + Objects.hashCode(mTransportInfo) * 41;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mUnwantedNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeInt(mSignalStrength);
    dest.writeArraySet(mUids);
    dest.writeString(mSSID);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(mNetworkCapabilities);
    dest.writeLong(mUnwantedNetworkCapabilities);
    dest.writeLong(mTransportTypes);
    dest.writeInt(mLinkUpBandwidthKbps);
    dest.writeInt(mLinkDownBandwidthKbps);
    dest.writeParcelable((Parcelable) mNetworkSpecifier, flags);
    dest.writeParcelable((Parcelable) mTransportInfo, flags);
    dest.writeInt(mSignalStrength);
    dest.writeArraySet(mUids);
    dest.writeString(mSSID);
}
#end_block

#method_before
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("[");
    if (0 != mTransportTypes) {
        sb.append(" Transports: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, "|");
    }
    if (0 != mNetworkCapabilities) {
        sb.append(" Capabilities: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, "&");
    }
    if (0 != mNetworkCapabilities) {
        sb.append(" Unwanted: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, "&");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append(" LinkUpBandwidth>=").append(mLinkUpBandwidthKbps).append("Kbps");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append(" LinkDnBandwidth>=").append(mLinkDownBandwidthKbps).append("Kbps");
    }
    if (mNetworkSpecifier != null) {
        sb.append(" Specifier: <").append(mNetworkSpecifier).append(">");
    }
    if (hasSignalStrength()) {
        sb.append(" SignalStrength: ").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append(" Uid: ").append(mUids.valueAt(0).start);
        } else {
            sb.append(" Uids: <").append(mUids).append(">");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append(" EstablishingAppUid: ").append(mEstablishingVpnAppUid);
    }
    if (null != mSSID) {
        sb.append(" SSID: ").append(mSSID);
    }
    sb.append("]");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    final StringBuilder sb = new StringBuilder("[");
    if (0 != mTransportTypes) {
        sb.append(" Transports: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mTransportTypes, NetworkCapabilities::transportNameOf, "|");
    }
    if (0 != mNetworkCapabilities) {
        sb.append(" Capabilities: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mNetworkCapabilities, NetworkCapabilities::capabilityNameOf, "&");
    }
    if (0 != mUnwantedNetworkCapabilities) {
        sb.append(" Unwanted: ");
        appendStringRepresentationOfBitMaskToStringBuilder(sb, mUnwantedNetworkCapabilities, NetworkCapabilities::capabilityNameOf, "&");
    }
    if (mLinkUpBandwidthKbps > 0) {
        sb.append(" LinkUpBandwidth>=").append(mLinkUpBandwidthKbps).append("Kbps");
    }
    if (mLinkDownBandwidthKbps > 0) {
        sb.append(" LinkDnBandwidth>=").append(mLinkDownBandwidthKbps).append("Kbps");
    }
    if (mNetworkSpecifier != null) {
        sb.append(" Specifier: <").append(mNetworkSpecifier).append(">");
    }
    if (mTransportInfo != null) {
        sb.append(" TransportInfo: <").append(mTransportInfo).append(">");
    }
    if (hasSignalStrength()) {
        sb.append(" SignalStrength: ").append(mSignalStrength);
    }
    if (null != mUids) {
        if ((1 == mUids.size()) && (mUids.valueAt(0).count() == 1)) {
            sb.append(" Uid: ").append(mUids.valueAt(0).start);
        } else {
            sb.append(" Uids: <").append(mUids).append(">");
        }
    }
    if (mEstablishingVpnAppUid != INVALID_UID) {
        sb.append(" EstablishingAppUid: ").append(mEstablishingVpnAppUid);
    }
    if (null != mSSID) {
        sb.append(" SSID: ").append(mSSID);
    }
    sb.append("]");
    return sb.toString();
}
#end_block

#method_before
public void writeToProto(ProtoOutputStream proto, long fieldId) {
    final long token = proto.start(fieldId);
    for (int transport : getTransportTypes()) {
        proto.write(NetworkCapabilitiesProto.TRANSPORTS, transport);
    }
    for (int capability : getCapabilities()) {
        proto.write(NetworkCapabilitiesProto.CAPABILITIES, capability);
    }
    proto.write(NetworkCapabilitiesProto.LINK_UP_BANDWIDTH_KBPS, mLinkUpBandwidthKbps);
    proto.write(NetworkCapabilitiesProto.LINK_DOWN_BANDWIDTH_KBPS, mLinkDownBandwidthKbps);
    if (mNetworkSpecifier != null) {
        proto.write(NetworkCapabilitiesProto.NETWORK_SPECIFIER, mNetworkSpecifier.toString());
    }
    proto.write(NetworkCapabilitiesProto.CAN_REPORT_SIGNAL_STRENGTH, hasSignalStrength());
    proto.write(NetworkCapabilitiesProto.SIGNAL_STRENGTH, mSignalStrength);
    proto.end(token);
}
#method_after
public void writeToProto(ProtoOutputStream proto, long fieldId) {
    final long token = proto.start(fieldId);
    for (int transport : getTransportTypes()) {
        proto.write(NetworkCapabilitiesProto.TRANSPORTS, transport);
    }
    for (int capability : getCapabilities()) {
        proto.write(NetworkCapabilitiesProto.CAPABILITIES, capability);
    }
    proto.write(NetworkCapabilitiesProto.LINK_UP_BANDWIDTH_KBPS, mLinkUpBandwidthKbps);
    proto.write(NetworkCapabilitiesProto.LINK_DOWN_BANDWIDTH_KBPS, mLinkDownBandwidthKbps);
    if (mNetworkSpecifier != null) {
        proto.write(NetworkCapabilitiesProto.NETWORK_SPECIFIER, mNetworkSpecifier.toString());
    }
    if (mTransportInfo != null) {
    // TODO b/120653863: write transport-specific info to proto?
    }
    proto.write(NetworkCapabilitiesProto.CAN_REPORT_SIGNAL_STRENGTH, hasSignalStrength());
    proto.write(NetworkCapabilitiesProto.SIGNAL_STRENGTH, mSignalStrength);
    proto.end(token);
}
#end_block

#method_before
public static String capabilityNameOf(@NetCapability int capability) {
    switch(capability) {
        case NET_CAPABILITY_MMS:
            return "MMS";
        case NET_CAPABILITY_SUPL:
            return "SUPL";
        case NET_CAPABILITY_DUN:
            return "DUN";
        case NET_CAPABILITY_FOTA:
            return "FOTA";
        case NET_CAPABILITY_IMS:
            return "IMS";
        case NET_CAPABILITY_CBS:
            return "CBS";
        case NET_CAPABILITY_WIFI_P2P:
            return "WIFI_P2P";
        case NET_CAPABILITY_IA:
            return "IA";
        case NET_CAPABILITY_RCS:
            return "RCS";
        case NET_CAPABILITY_XCAP:
            return "XCAP";
        case NET_CAPABILITY_EIMS:
            return "EIMS";
        case NET_CAPABILITY_NOT_METERED:
            return "NOT_METERED";
        case NET_CAPABILITY_INTERNET:
            return "INTERNET";
        case NET_CAPABILITY_NOT_RESTRICTED:
            return "NOT_RESTRICTED";
        case NET_CAPABILITY_TRUSTED:
            return "TRUSTED";
        case NET_CAPABILITY_NOT_VPN:
            return "NOT_VPN";
        case NET_CAPABILITY_VALIDATED:
            return "VALIDATED";
        case NET_CAPABILITY_CAPTIVE_PORTAL:
            return "CAPTIVE_PORTAL";
        case NET_CAPABILITY_NOT_ROAMING:
            return "NOT_ROAMING";
        case NET_CAPABILITY_FOREGROUND:
            return "FOREGROUND";
        case NET_CAPABILITY_NOT_CONGESTED:
            return "NOT_CONGESTED";
        case NET_CAPABILITY_NOT_SUSPENDED:
            return "NOT_SUSPENDED";
        case NET_CAPABILITY_OEM_PAID:
            return "OEM_PAID";
        default:
            return Integer.toString(capability);
    }
}
#method_after
public static String capabilityNameOf(@NetCapability int capability) {
    switch(capability) {
        case NET_CAPABILITY_MMS:
            return "MMS";
        case NET_CAPABILITY_SUPL:
            return "SUPL";
        case NET_CAPABILITY_DUN:
            return "DUN";
        case NET_CAPABILITY_FOTA:
            return "FOTA";
        case NET_CAPABILITY_IMS:
            return "IMS";
        case NET_CAPABILITY_CBS:
            return "CBS";
        case NET_CAPABILITY_WIFI_P2P:
            return "WIFI_P2P";
        case NET_CAPABILITY_IA:
            return "IA";
        case NET_CAPABILITY_RCS:
            return "RCS";
        case NET_CAPABILITY_XCAP:
            return "XCAP";
        case NET_CAPABILITY_EIMS:
            return "EIMS";
        case NET_CAPABILITY_NOT_METERED:
            return "NOT_METERED";
        case NET_CAPABILITY_INTERNET:
            return "INTERNET";
        case NET_CAPABILITY_NOT_RESTRICTED:
            return "NOT_RESTRICTED";
        case NET_CAPABILITY_TRUSTED:
            return "TRUSTED";
        case NET_CAPABILITY_NOT_VPN:
            return "NOT_VPN";
        case NET_CAPABILITY_VALIDATED:
            return "VALIDATED";
        case NET_CAPABILITY_CAPTIVE_PORTAL:
            return "CAPTIVE_PORTAL";
        case NET_CAPABILITY_NOT_ROAMING:
            return "NOT_ROAMING";
        case NET_CAPABILITY_FOREGROUND:
            return "FOREGROUND";
        case NET_CAPABILITY_NOT_CONGESTED:
            return "NOT_CONGESTED";
        case NET_CAPABILITY_NOT_SUSPENDED:
            return "NOT_SUSPENDED";
        case NET_CAPABILITY_OEM_PAID:
            return "OEM_PAID";
        case NET_CAPABILITY_MCX:
            return "MCX";
        case NET_CAPABILITY_PARTIAL_CONNECTIVITY:
            return "PARTIAL_CONNECTIVITY";
        default:
            return Integer.toString(capability);
    }
}
#end_block

#method_before
private NetworkCapabilities networkCapabilitiesRestrictedForCallerPermissions(NetworkCapabilities nc, int callerPid, int callerUid) {
    final NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (!checkSettingsPermission(callerPid, callerUid)) {
        newNc.setUids(null);
        newNc.setSSID(null);
    }
    return newNc;
}
#method_after
private NetworkCapabilities networkCapabilitiesRestrictedForCallerPermissions(NetworkCapabilities nc, int callerPid, int callerUid) {
    final NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (!checkSettingsPermission(callerPid, callerUid)) {
        newNc.setUids(null);
        newNc.setSSID(null);
    }
    if (newNc.getNetworkSpecifier() != null) {
        newNc.setNetworkSpecifier(newNc.getNetworkSpecifier().redact());
    }
    return newNc;
}
#end_block

#method_before
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final int uid = Binder.getCallingUid();
    final NetworkCapabilities caps = getUnfilteredActiveNetworkState(uid).networkCapabilities;
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#method_after
@Override
public boolean isActiveNetworkMetered() {
    enforceAccessPermission();
    final NetworkCapabilities caps = getNetworkCapabilities(getActiveNetwork());
    if (caps != null) {
        return !caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else {
        // Always return the most conservative value
        return true;
    }
}
#end_block

#method_before
private void enforceAnyPermissionOf(String... permissions) {
    for (String permission : permissions) {
        if (mContext.checkCallingOrSelfPermission(permission) == PERMISSION_GRANTED) {
            return;
        }
    }
    throw new SecurityException("Requires one of the following permissions: " + String.join(", ", permissions) + ".");
}
#method_after
private void enforceAnyPermissionOf(String... permissions) {
    if (!checkAnyPermissionOf(permissions)) {
        throw new SecurityException("Requires one of the following permissions: " + String.join(", ", permissions) + ".");
    }
}
#end_block

#method_before
private void enforceSettingsPermission() {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.NETWORK_SETTINGS, "ConnectivityService");
}
#method_after
private void enforceSettingsPermission() {
    enforceAnyPermissionOf(android.Manifest.permission.NETWORK_SETTINGS, NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
}
#end_block

#method_before
private boolean checkSettingsPermission() {
    return PERMISSION_GRANTED == mContext.checkCallingOrSelfPermission(android.Manifest.permission.NETWORK_SETTINGS);
}
#method_after
private boolean checkSettingsPermission() {
    return checkAnyPermissionOf(android.Manifest.permission.NETWORK_SETTINGS, NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
}
#end_block

#method_before
private boolean checkSettingsPermission(int pid, int uid) {
    return PERMISSION_GRANTED == mContext.checkPermission(android.Manifest.permission.NETWORK_SETTINGS, pid, uid);
}
#method_after
private boolean checkSettingsPermission(int pid, int uid) {
    return PERMISSION_GRANTED == mContext.checkPermission(android.Manifest.permission.NETWORK_SETTINGS, pid, uid) || PERMISSION_GRANTED == mContext.checkPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK, pid, uid);
}
#end_block

#method_before
private void enforceConnectivityInternalPermission() {
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "ConnectivityService");
}
#method_after
private void enforceConnectivityInternalPermission() {
    enforceAnyPermissionOf(android.Manifest.permission.CONNECTIVITY_INTERNAL, NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
}
#end_block

#method_before
private void enforceNetworkStackSettingsOrSetup() {
    enforceAnyPermissionOf(android.Manifest.permission.NETWORK_SETTINGS, android.Manifest.permission.NETWORK_SETUP_WIZARD, android.Manifest.permission.NETWORK_STACK);
}
#method_after
private void enforceNetworkStackSettingsOrSetup() {
    enforceAnyPermissionOf(android.Manifest.permission.NETWORK_SETTINGS, android.Manifest.permission.NETWORK_SETUP_WIZARD, android.Manifest.permission.NETWORK_STACK, NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
}
#end_block

#method_before
private boolean checkNetworkStackPermission() {
    return PERMISSION_GRANTED == mContext.checkCallingOrSelfPermission(android.Manifest.permission.NETWORK_STACK);
}
#method_after
private boolean checkNetworkStackPermission() {
    return checkAnyPermissionOf(android.Manifest.permission.NETWORK_STACK, NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK);
}
#end_block

#method_before
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#method_after
void systemReady() {
    mProxyTracker.loadGlobalProxy();
    registerNetdEventCallback();
    mTethering.systemReady();
    synchronized (this) {
        mSystemReady = true;
        if (mInitialBroadcast != null) {
            mContext.sendStickyBroadcastAsUser(mInitialBroadcast, UserHandle.ALL);
            mInitialBroadcast = null;
        }
    }
    // Try bringing up tracker, but KeyStore won't be ready yet for secondary users so wait
    // for user to unlock device too.
    updateLockdownVpn();
    // Create network requests for always-on networks.
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_CONFIGURE_ALWAYS_ON_NETWORKS));
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SYSTEM_READY));
    mPermissionMonitor.startMonitoring();
}
#end_block

#method_before
private void updateTcpBufferSizes(String tcpBufferSizes) {
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        final String prefix = "/sys/kernel/ipv4/tcp_";
        FileUtils.stringToFile(prefix + "rmem_min", values[0]);
        FileUtils.stringToFile(prefix + "rmem_def", values[1]);
        FileUtils.stringToFile(prefix + "rmem_max", values[2]);
        FileUtils.stringToFile(prefix + "wmem_min", values[3]);
        FileUtils.stringToFile(prefix + "wmem_def", values[4]);
        FileUtils.stringToFile(prefix + "wmem_max", values[5]);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (IOException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#method_after
private void updateTcpBufferSizes(String tcpBufferSizes) {
    String[] values = null;
    if (tcpBufferSizes != null) {
        values = tcpBufferSizes.split(",");
    }
    if (values == null || values.length != 6) {
        if (DBG)
            log("Invalid tcpBufferSizes string: " + tcpBufferSizes + ", using defaults");
        tcpBufferSizes = DEFAULT_TCP_BUFFER_SIZES;
        values = tcpBufferSizes.split(",");
    }
    if (tcpBufferSizes.equals(mCurrentTcpBufferSizes))
        return;
    try {
        if (VDBG || DDBG)
            Slog.d(TAG, "Setting tx/rx TCP buffers to " + tcpBufferSizes);
        String rmemValues = String.join(" ", values[0], values[1], values[2]);
        String wmemValues = String.join(" ", values[3], values[4], values[5]);
        mNetd.setTcpRWmemorySize(rmemValues, wmemValues);
        mCurrentTcpBufferSizes = tcpBufferSizes;
    } catch (RemoteException | ServiceSpecificException e) {
        loge("Can't set TCP buffer sizes:" + e);
    }
    Integer rwndValue = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.TCP_DEFAULT_INIT_RWND, mSystemProperties.getInt("net.tcp.default_init_rwnd", 0));
    final String sysctlKey = "sys.sysctl.tcp_def_init_rwnd";
    if (rwndValue != 0) {
        mSystemProperties.set(sysctlKey, rwndValue.toString());
    }
}
#end_block

#method_before
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mName);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
}
#method_after
private void doDump(FileDescriptor fd, PrintWriter writer, String[] args, boolean asProto) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (!DumpUtils.checkDumpPermission(mContext, TAG, pw))
        return;
    if (asProto)
        return;
    if (ArrayUtils.contains(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    } else if (ArrayUtils.contains(args, TETHERING_ARG)) {
        mTethering.dump(fd, pw, args);
        return;
    } else if (ArrayUtils.contains(args, NETWORK_ARG)) {
        dumpNetworks(pw);
        return;
    } else if (ArrayUtils.contains(args, REQUEST_ARG)) {
        dumpNetworkRequests(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    dumpNetworks(pw);
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        // Don't crash if the array is modified while dumping in bugreports.
        try {
            final int uid = mUidRules.keyAt(i);
            final int uidRules = mUidRules.get(uid, RULE_NONE);
            pw.println("UID=" + uid + " rules=" + uidRulesToString(uidRules));
        } catch (ArrayIndexOutOfBoundsException e) {
            pw.println("  ArrayIndexOutOfBoundsException");
        } catch (ConcurrentModificationException e) {
            pw.println("  ConcurrentModificationException");
        }
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    dumpNetworkRequests(pw);
    pw.decreaseIndent();
    pw.println();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    pw.println();
    mMultipathPolicyTracker.dump(pw);
    if (ArrayUtils.contains(args, SHORT_ARG) == false) {
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        pw.println("total acquisitions: " + mTotalWakelockAcquisitions);
        pw.println("total releases: " + mTotalWakelockReleases);
        pw.println("cumulative duration: " + (mTotalWakelockDurationMs / 1000) + "s");
        pw.println("longest duration: " + (mMaxWakelockDurationMs / 1000) + "s");
        if (mTotalWakelockAcquisitions > mTotalWakelockReleases) {
            long duration = SystemClock.elapsedRealtime() - mLastWakeLockAcquireTimestamp;
            pw.println("currently holding WakeLock for: " + (duration / 1000) + "s");
        }
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.println();
        pw.println("bandwidth update requests (by uid):");
        pw.increaseIndent();
        synchronized (mBandwidthRequests) {
            for (int i = 0; i < mBandwidthRequests.size(); i++) {
                pw.println("[" + mBandwidthRequests.keyAt(i) + "]: " + mBandwidthRequests.valueAt(i));
            }
        }
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.println();
    pw.println("NetworkStackClient logs:");
    pw.increaseIndent();
    NetworkStackClient.getInstance().dump(pw);
}
#end_block

#method_before
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL) || networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) || networkCapabilities.hasCapability(NET_CAPABILITY_FOREGROUND) || networkCapabilities.hasCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY)) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                updateNetworkScore(nai, msg.arg1);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = msg.arg1 == 1;
                break;
            }
        case NetworkAgent.EVENT_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventPacketKeepalive(nai, msg);
                break;
            }
    }
}
#method_after
private void maybeHandleNetworkAgentMessage(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai == null) {
        if (VDBG) {
            log(String.format("%s from unknown NetworkAgent", eventName(msg.what)));
        }
        return;
    }
    switch(msg.what) {
        case NetworkAgent.EVENT_NETWORK_CAPABILITIES_CHANGED:
            {
                final NetworkCapabilities networkCapabilities = (NetworkCapabilities) msg.obj;
                if (networkCapabilities.hasConnectivityManagedCapability()) {
                    Slog.wtf(TAG, "BUG: " + nai + " has CS-managed capability.");
                }
                updateCapabilities(nai.getCurrentScore(), nai, networkCapabilities);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_PROPERTIES_CHANGED:
            {
                handleUpdateLinkProperties(nai, (LinkProperties) msg.obj);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_INFO_CHANGED:
            {
                NetworkInfo info = (NetworkInfo) msg.obj;
                updateNetworkInfo(nai, info);
                break;
            }
        case NetworkAgent.EVENT_NETWORK_SCORE_CHANGED:
            {
                updateNetworkScore(nai, msg.arg1);
                break;
            }
        case NetworkAgent.EVENT_SET_EXPLICITLY_SELECTED:
            {
                if (nai.everConnected && !nai.networkMisc.explicitlySelected) {
                    loge("ERROR: already-connected network explicitly selected.");
                }
                nai.networkMisc.explicitlySelected = true;
                nai.networkMisc.acceptUnvalidated = msg.arg1 == 1;
                // Mark the network as temporarily accepting partial connectivity so that it
                // will be validated (and possibly become default) even if it only provides
                // partial internet access. Note that if user connects to partial connectivity
                // and choose "don't ask again", then wifi disconnected by some reasons(maybe
                // out of wifi coverage) and if the same wifi is available again, the device
                // will auto connect to this wifi even though the wifi has "no internet".
                // TODO: Evaluate using a separate setting in IpMemoryStore.
                nai.networkMisc.acceptPartialConnectivity = msg.arg1 == 1;
                break;
            }
        case NetworkAgent.EVENT_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleEventSocketKeepalive(nai, msg);
                break;
            }
    }
}
#end_block

#method_before
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case NetworkMonitor.EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean valid = (msg.arg1 == NetworkMonitor.NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                final CaptivePortalProbeResult probeResult = (CaptivePortalProbeResult) msg.obj;
                final String redirectUrl = (probeResult != null && probeResult.redirectUrl != null) ? probeResult.redirectUrl : "";
                nai.partialConnectivity = (probeResult != null) ? probeResult.isPartialConnectivity() : false;
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid)
                        handleFreshlyValidatedNetwork(nai);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case NetworkMonitor.EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    mNotifier.clearNotification(netId);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case NetworkMonitor.EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#method_after
private boolean maybeHandleNetworkMonitorMessage(Message msg) {
    switch(msg.what) {
        default:
            return false;
        case EVENT_NETWORK_TESTED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                final boolean partialConnectivity = (msg.arg1 == NETWORK_TEST_RESULT_PARTIAL_CONNECTIVITY) || // in the settings.
                (nai.networkMisc.acceptPartialConnectivity && nai.partialConnectivity);
                // Once a network is determined to have partial connectivity, it cannot
                // go back to full connectivity without a disconnect.
                final boolean partialConnectivityChange = (partialConnectivity && !nai.partialConnectivity);
                final boolean valid = (msg.arg1 == NETWORK_TEST_RESULT_VALID);
                final boolean wasValidated = nai.lastValidated;
                final boolean wasDefault = isDefaultNetwork(nai);
                if (nai.everCaptivePortalDetected && !nai.captivePortalLoginNotified && valid) {
                    nai.captivePortalLoginNotified = true;
                    showNetworkNotification(nai, NotificationType.LOGGED_IN);
                }
                // previous connect.
                if ((msg.arg1 == NETWORK_TEST_RESULT_PARTIAL_CONNECTIVITY) && nai.networkMisc.acceptPartialConnectivity) {
                    try {
                        nai.networkMonitor().notifyAcceptPartialConnectivity();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                final String redirectUrl = (msg.obj instanceof String) ? (String) msg.obj : "";
                if (DBG) {
                    final String logMsg = !TextUtils.isEmpty(redirectUrl) ? " with redirect to " + redirectUrl : "";
                    log(nai.name() + " validation " + (valid ? "passed" : "failed") + logMsg);
                }
                if (valid != nai.lastValidated) {
                    if (wasDefault) {
                        metricsLogger().defaultNetworkMetrics().logDefaultNetworkValidity(SystemClock.elapsedRealtime(), valid);
                    }
                    final int oldScore = nai.getCurrentScore();
                    nai.lastValidated = valid;
                    nai.everValidated |= valid;
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                    // If score has changed, rebroadcast to NetworkFactories. b/17726566
                    if (oldScore != nai.getCurrentScore())
                        sendUpdatedScoreToFactories(nai);
                    if (valid) {
                        handleFreshlyValidatedNetwork(nai);
                        // Clear NO_INTERNET and LOST_INTERNET notifications if network becomes
                        // valid.
                        mNotifier.clearNotification(nai.network.netId, NotificationType.NO_INTERNET);
                        mNotifier.clearNotification(nai.network.netId, NotificationType.LOST_INTERNET);
                    }
                } else if (partialConnectivityChange) {
                    nai.partialConnectivity = partialConnectivity;
                    updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
                }
                updateInetCondition(nai);
                // Let the NetworkAgent know the state of its network
                Bundle redirectUrlBundle = new Bundle();
                redirectUrlBundle.putString(NetworkAgent.REDIRECT_URL_KEY, redirectUrl);
                nai.asyncChannel.sendMessage(NetworkAgent.CMD_REPORT_NETWORK_STATUS, (valid ? NetworkAgent.VALID_NETWORK : NetworkAgent.INVALID_NETWORK), 0, redirectUrlBundle);
                if (wasValidated && !nai.lastValidated) {
                    handleNetworkUnvalidated(nai);
                }
                break;
            }
        case EVENT_PROVISIONING_NOTIFICATION:
            {
                final int netId = msg.arg2;
                final boolean visible = toBool(msg.arg1);
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(netId);
                // If captive portal status has changed, update capabilities or disconnect.
                if (nai != null && (visible != nai.lastCaptivePortalDetected)) {
                    final int oldScore = nai.getCurrentScore();
                    nai.lastCaptivePortalDetected = visible;
                    nai.everCaptivePortalDetected |= visible;
                    if (visible) {
                        nai.captivePortalLoginNotified = false;
                    }
                    if (nai.lastCaptivePortalDetected && Settings.Global.CAPTIVE_PORTAL_MODE_AVOID == getCaptivePortalMode()) {
                        if (DBG)
                            log("Avoiding captive portal network: " + nai.name());
                        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
                        teardownUnneededNetwork(nai);
                        break;
                    }
                    updateCapabilities(oldScore, nai, nai.networkCapabilities);
                }
                if (!visible) {
                    // Only clear SIGN_IN and NETWORK_SWITCH notifications here, or else other
                    // notifications belong to the same network may be cleared unexpectedly.
                    mNotifier.clearNotification(netId, NotificationType.SIGN_IN);
                    mNotifier.clearNotification(netId, NotificationType.NETWORK_SWITCH);
                } else {
                    if (nai == null) {
                        loge("EVENT_PROVISIONING_NOTIFICATION from unknown NetworkMonitor");
                        break;
                    }
                    if (!nai.networkMisc.provisioningNotificationDisabled) {
                        mNotifier.showNotification(netId, NotificationType.SIGN_IN, nai, null, (PendingIntent) msg.obj, nai.networkMisc.explicitlySelected);
                    }
                }
                break;
            }
        case EVENT_PRIVATE_DNS_CONFIG_RESOLVED:
            {
                final NetworkAgentInfo nai = getNetworkAgentInfoForNetId(msg.arg2);
                if (nai == null)
                    break;
                updatePrivateDns(nai, (PrivateDnsConfig) msg.obj);
                break;
            }
    }
    return true;
}
#end_block

#method_before
private boolean networkRequiresValidation(NetworkAgentInfo nai) {
    return NetworkMonitor.isValidationRequired(mDefaultRequest.networkCapabilities, nai.networkCapabilities);
}
#method_after
private boolean networkRequiresValidation(NetworkAgentInfo nai) {
    return isValidationRequired(nai.networkCapabilities);
}
#end_block

#method_before
private void handlePerNetworkPrivateDnsConfig(NetworkAgentInfo nai, PrivateDnsConfig cfg) {
    // Internet access and therefore also require validation.
    if (!networkRequiresValidation(nai))
        return;
    // Notify the NetworkMonitor thread in case it needs to cancel or
    // schedule DNS resolutions. If a DNS resolution is required the
    // result will be sent back to us.
    nai.networkMonitor.notifyPrivateDnsSettingsChanged(cfg);
    // With Private DNS bypass support, we can proceed to update the
    // Private DNS config immediately, even if we're in strict mode
    // and have not yet resolved the provider name into a set of IPs.
    updatePrivateDns(nai, cfg);
}
#method_after
private void handlePerNetworkPrivateDnsConfig(NetworkAgentInfo nai, PrivateDnsConfig cfg) {
    // Internet access and therefore also require validation.
    if (!networkRequiresValidation(nai))
        return;
    // result will be sent back to us.
    try {
        nai.networkMonitor().notifyPrivateDnsChanged(cfg.toParcel());
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    // With Private DNS bypass support, we can proceed to update the
    // Private DNS config immediately, even if we're in strict mode
    // and have not yet resolved the provider name into a set of IPs.
    updatePrivateDns(nai, cfg);
}
#end_block

#method_before
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
    mNetworkAgentInfos.remove(nai.messenger);
    nai.maybeStopClat();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#method_after
// Destroys a network, remove references to it from the internal state managed by
// ConnectivityService, free its interfaces and clean up.
private void disconnectAndDestroyNetwork(NetworkAgentInfo nai) {
    if (DBG) {
        log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
    }
    // Clear all notifications of this network.
    mNotifier.clearNotification(nai.network.netId);
    // disconnect the channel.
    if (nai.networkInfo.isConnected()) {
        nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
    }
    final boolean wasDefault = isDefaultNetwork(nai);
    if (wasDefault) {
        mDefaultInetConditionPublished = 0;
        // Log default network disconnection before required book-keeping.
        // Let rematchAllNetworksAndRequests() below record a new default network event
        // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
        // whose timestamps tell how long it takes to recover a default network.
        long now = SystemClock.elapsedRealtime();
        metricsLogger().defaultNetworkMetrics().logDefaultNetworkEvent(now, null, nai);
    }
    notifyIfacesChangedForNetworkStats();
    // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
    // by other networks that are already connected. Perhaps that can be done by
    // sending all CALLBACK_LOST messages (for requests, not listens) at the end
    // of rematchAllNetworksAndRequests
    notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
    mKeepaliveTracker.handleStopAllKeepalives(nai, SocketKeepalive.ERROR_INVALID_NETWORK);
    for (String iface : nai.linkProperties.getAllInterfaceNames()) {
        // Disable wakeup packet monitoring for each interface.
        wakeupModifyInterface(iface, nai.networkCapabilities, false);
    }
    try {
        nai.networkMonitor().notifyNetworkDisconnected();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    mNetworkAgentInfos.remove(nai.messenger);
    nai.clatd.update();
    synchronized (mNetworkForNetId) {
        // Remove the NetworkAgent, but don't mark the netId as
        // available until we've told netd to delete it below.
        mNetworkForNetId.remove(nai.network.netId);
    }
    // Remove all previously satisfied requests.
    for (int i = 0; i < nai.numNetworkRequests(); i++) {
        NetworkRequest request = nai.requestAt(i);
        NetworkAgentInfo currentNetwork = getNetworkForRequest(request.requestId);
        if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
            clearNetworkForRequest(request.requestId);
            sendUpdatedScoreToFactories(request, 0);
        }
    }
    nai.clearLingerState();
    if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
        updateDataActivityTracking(null, /* newNetwork */
        nai);
        notifyLockdownVpn(nai);
        ensureNetworkTransitionWakelock(nai.name());
    }
    mLegacyTypeTracker.remove(nai, wasDefault);
    if (!nai.networkCapabilities.hasTransport(TRANSPORT_VPN)) {
        updateAllVpnsCapabilities();
    }
    rematchAllNetworksAndRequests(null, 0);
    mLingerMonitor.noteDisconnect(nai);
    if (nai.created) {
        // long time.
        try {
            mNMS.removeNetwork(nai.network.netId);
        } catch (Exception e) {
            loge("Exception removing network: " + e);
        }
        mDnsManager.removeNetwork(nai.network);
    }
    synchronized (mNetworkForNetId) {
        mNetIdInUse.delete(nai.network.netId);
    }
}
#end_block

#method_before
@Override
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    enforceConnectivityInternalPermission();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_ACCEPT_UNVALIDATED, encodeBool(accept), encodeBool(always), network));
}
#method_after
@Override
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    enforceNetworkStackSettingsOrSetup();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_ACCEPT_UNVALIDATED, encodeBool(accept), encodeBool(always), network));
}
#end_block

#method_before
@Override
public void setAvoidUnvalidated(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_AVOID_UNVALIDATED, network));
}
#method_after
@Override
public void setAvoidUnvalidated(Network network) {
    enforceNetworkStackSettingsOrSetup();
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_SET_AVOID_UNVALIDATED, network));
}
#end_block

#method_before
private void handleSetAcceptUnvalidated(Network network, boolean accept, boolean always) {
    if (DBG)
        log("handleSetAcceptUnvalidated network=" + network + " accept=" + accept + " always=" + always);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null) {
        // Nothing to do.
        return;
    }
    if (nai.everValidated) {
        // The network validated while the dialog box was up. Take no action.
        return;
    }
    if (!nai.networkMisc.explicitlySelected) {
        Slog.wtf(TAG, "BUG: setAcceptUnvalidated non non-explicitly selected network");
    }
    if (accept != nai.networkMisc.acceptUnvalidated) {
        int oldScore = nai.getCurrentScore();
        nai.networkMisc.acceptUnvalidated = accept;
        rematchAllNetworksAndRequests(nai, oldScore);
        sendUpdatedScoreToFactories(nai);
    }
    if (always) {
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_SAVE_ACCEPT_UNVALIDATED, encodeBool(accept));
    }
    if (!accept) {
        // Tell the NetworkAgent to not automatically reconnect to the network.
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
        // Teardown the network.
        teardownUnneededNetwork(nai);
    } else {
        if (nai.partialConnectivity) {
            mKeepPartialConnectivityNetwork = true;
            updateCapabilities(nai.getCurrentScore(), nai, nai.networkCapabilities);
        }
    }
}
#method_after
private void handleSetAcceptUnvalidated(Network network, boolean accept, boolean always) {
    if (DBG)
        log("handleSetAcceptUnvalidated network=" + network + " accept=" + accept + " always=" + always);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null) {
        // Nothing to do.
        return;
    }
    if (nai.everValidated) {
        // The network validated while the dialog box was up. Take no action.
        return;
    }
    if (!nai.networkMisc.explicitlySelected) {
        Slog.wtf(TAG, "BUG: setAcceptUnvalidated non non-explicitly selected network");
    }
    if (accept != nai.networkMisc.acceptUnvalidated) {
        int oldScore = nai.getCurrentScore();
        nai.networkMisc.acceptUnvalidated = accept;
        // If network becomes partial connectivity and user already accepted to use this
        // network, we should respect the user's option and don't need to popup the
        // PARTIAL_CONNECTIVITY notification to user again.
        nai.networkMisc.acceptPartialConnectivity = accept;
        rematchAllNetworksAndRequests(nai, oldScore);
        sendUpdatedScoreToFactories(nai);
    }
    if (always) {
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_SAVE_ACCEPT_UNVALIDATED, encodeBool(accept));
    }
    if (!accept) {
        // Tell the NetworkAgent to not automatically reconnect to the network.
        nai.asyncChannel.sendMessage(NetworkAgent.CMD_PREVENT_AUTOMATIC_RECONNECT);
        // Teardown the network.
        teardownUnneededNetwork(nai);
    }
}
#end_block

#method_before
@Override
public void startCaptivePortalApp(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.post(() -> {
        NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai == null)
            return;
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
            return;
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_LAUNCH_CAPTIVE_PORTAL_APP);
    });
}
#method_after
@Override
public void startCaptivePortalApp(Network network) {
    enforceConnectivityInternalPermission();
    mHandler.post(() -> {
        NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
        if (nai == null)
            return;
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_CAPTIVE_PORTAL))
            return;
        try {
            nai.networkMonitor().launchCaptivePortalApp();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    });
}
#end_block

#method_before
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated) {
        return;
    }
    if (nai.partialConnectivity) {
        showValidationNotification(nai, NotificationType.PARTIAL_CONNECTIVITY);
    } else {
        showValidationNotification(nai, NotificationType.NO_INTERNET);
    }
}
#method_after
private void handlePromptUnvalidated(Network network) {
    if (VDBG || DDBG)
        log("handlePromptUnvalidated " + network);
    NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    // because we're already prompting the user to sign in.
    if (nai == null || nai.everValidated || nai.everCaptivePortalDetected || !nai.networkMisc.explicitlySelected || nai.networkMisc.acceptUnvalidated || nai.networkMisc.acceptPartialConnectivity) {
        return;
    }
    // popup the notification immediately when the network is partial connectivity.
    if (nai.partialConnectivity) {
        // Treat PARTIAL_CONNECTIVITY as NO_INTERNET temporary until Settings has been updated.
        // TODO: Need to change back to PARTIAL_CONNECTIVITY when Settings part is merged.
        showNetworkNotification(nai, NotificationType.NO_INTERNET);
    } else {
        showNetworkNotification(nai, NotificationType.NO_INTERNET);
    }
}
#end_block

#method_before
private void handleNetworkUnvalidated(NetworkAgentInfo nai) {
    NetworkCapabilities nc = nai.networkCapabilities;
    if (DBG)
        log("handleNetworkUnvalidated " + nai.name() + " cap=" + nc);
    if (nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) && mMultinetworkPolicyTracker.shouldNotifyWifiUnvalidated()) {
        showValidationNotification(nai, NotificationType.LOST_INTERNET);
    }
}
#method_after
private void handleNetworkUnvalidated(NetworkAgentInfo nai) {
    NetworkCapabilities nc = nai.networkCapabilities;
    if (DBG)
        log("handleNetworkUnvalidated " + nai.name() + " cap=" + nc);
    if (!nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    if (mMultinetworkPolicyTracker.shouldNotifyWifiUnvalidated()) {
        showNetworkNotification(nai, NotificationType.LOST_INTERNET);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                handleRegisterNetworkAgent((NetworkAgentInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_PACKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_PACKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    nai.networkMonitor.systemReady = true;
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case EVENT_EXPIRE_NET_TRANSITION_WAKELOCK:
        case EVENT_CLEAR_NET_TRANSITION_WAKELOCK:
            {
                handleReleaseNetworkTransitionWakelock(msg.what);
                break;
            }
        case EVENT_APPLY_GLOBAL_HTTP_PROXY:
            {
                mProxyTracker.loadDeprecatedGlobalHttpProxy();
                break;
            }
        case EVENT_PROXY_HAS_CHANGED:
            {
                handleApplyDefaultProxy((ProxyInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_FACTORY:
            {
                handleRegisterNetworkFactory((NetworkFactoryInfo) msg.obj);
                break;
            }
        case EVENT_UNREGISTER_NETWORK_FACTORY:
            {
                handleUnregisterNetworkFactory((Messenger) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_AGENT:
            {
                final Pair<NetworkAgentInfo, INetworkMonitor> arg = (Pair<NetworkAgentInfo, INetworkMonitor>) msg.obj;
                handleRegisterNetworkAgent(arg.first, arg.second);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST:
        case EVENT_REGISTER_NETWORK_LISTENER:
            {
                handleRegisterNetworkRequest((NetworkRequestInfo) msg.obj);
                break;
            }
        case EVENT_REGISTER_NETWORK_REQUEST_WITH_INTENT:
        case EVENT_REGISTER_NETWORK_LISTENER_WITH_INTENT:
            {
                handleRegisterNetworkRequestWithIntent(msg);
                break;
            }
        case EVENT_TIMEOUT_NETWORK_REQUEST:
            {
                NetworkRequestInfo nri = (NetworkRequestInfo) msg.obj;
                handleTimedOutNetworkRequest(nri);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST_WITH_INTENT:
            {
                handleReleaseNetworkRequestWithIntent((PendingIntent) msg.obj, msg.arg1);
                break;
            }
        case EVENT_RELEASE_NETWORK_REQUEST:
            {
                handleReleaseNetworkRequest((NetworkRequest) msg.obj, msg.arg1);
                break;
            }
        case EVENT_SET_ACCEPT_UNVALIDATED:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptUnvalidated(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_ACCEPT_PARTIAL_CONNECTIVITY:
            {
                Network network = (Network) msg.obj;
                handleSetAcceptPartialConnectivity(network, toBool(msg.arg1), toBool(msg.arg2));
                break;
            }
        case EVENT_SET_AVOID_UNVALIDATED:
            {
                handleSetAvoidUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_PROMPT_UNVALIDATED:
            {
                handlePromptUnvalidated((Network) msg.obj);
                break;
            }
        case EVENT_CONFIGURE_ALWAYS_ON_NETWORKS:
            {
                handleConfigureAlwaysOnNetworks();
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_START_SOCKET_KEEPALIVE:
            {
                mKeepaliveTracker.handleStartKeepalive(msg);
                break;
            }
        // Sent by KeepaliveTracker to process an app request on the state machine thread.
        case NetworkAgent.CMD_STOP_SOCKET_KEEPALIVE:
            {
                NetworkAgentInfo nai = getNetworkAgentInfoForNetwork((Network) msg.obj);
                int slot = msg.arg1;
                int reason = msg.arg2;
                mKeepaliveTracker.handleStopKeepalive(nai, slot, reason);
                break;
            }
        case EVENT_SYSTEM_READY:
            {
                for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
                    // this several times is fine.
                    try {
                        nai.networkMonitor().notifySystemReady();
                    } catch (RemoteException e) {
                        e.rethrowFromSystemServer();
                    }
                }
                mMultipathPolicyTracker.start();
                break;
            }
        case EVENT_REVALIDATE_NETWORK:
            {
                handleReportNetworkConnectivity((Network) msg.obj, msg.arg1, toBool(msg.arg2));
                break;
            }
        case EVENT_PRIVATE_DNS_SETTINGS_CHANGED:
            handlePrivateDnsSettingsChanged();
            break;
        case EVENT_PRIVATE_DNS_VALIDATION_UPDATE:
            handlePrivateDnsValidationUpdate((PrivateDnsValidationUpdate) msg.obj);
            break;
        case EVENT_UID_RULES_CHANGED:
            handleUidRulesChanged(msg.arg1, msg.arg2);
            break;
        case EVENT_DATA_SAVER_CHANGED:
            handleRestrictBackgroundChanged(toBool(msg.arg1));
            break;
        case EVENT_TIMEOUT_NOTIFICATION:
            mNotifier.clearNotification(msg.arg1, NotificationType.LOGGED_IN);
            break;
    }
}
#end_block

#method_before
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    nai.networkMonitor.forceReevaluation(uid);
}
#method_after
private void handleReportNetworkConnectivity(Network network, int uid, boolean hasConnectivity) {
    final NetworkAgentInfo nai;
    if (network == null) {
        nai = getDefaultNetwork();
    } else {
        nai = getNetworkAgentInfoForNetwork(network);
    }
    if (nai == null || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTING || nai.networkInfo.getState() == NetworkInfo.State.DISCONNECTED) {
        return;
    }
    // Revalidate if the app report does not match our current validated state.
    if (hasConnectivity == nai.lastValidated) {
        return;
    }
    if (DBG) {
        int netid = nai.network.netId;
        log("reportNetworkConnectivity(" + netid + ", " + hasConnectivity + ") by " + uid);
    }
    // rematchNetworkAndRequests() which is not meant to work on such networks.
    if (!nai.everConnected) {
        return;
    }
    LinkProperties lp = getLinkProperties(nai);
    if (isNetworkWithLinkPropertiesBlocked(lp, uid, false)) {
        return;
    }
    try {
        nai.networkMonitor().forceReevaluation(uid);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Override
public ProxyInfo getProxyForNetwork(Network network) {
    if (network == null)
        return mProxyTracker.getDefaultProxy();
    final ProxyInfo globalProxy = mProxyTracker.getGlobalProxy();
    if (globalProxy != null)
        return globalProxy;
    if (!NetworkUtils.queryUserAccess(Binder.getCallingUid(), network.netId))
        return null;
    // Don't call getLinkProperties() as it requires ACCESS_NETWORK_STATE permission, which
    // caller may not have.
    final NetworkAgentInfo nai = getNetworkAgentInfoForNetwork(network);
    if (nai == null)
        return null;
    synchronized (nai) {
        final ProxyInfo proxyInfo = nai.linkProperties.getHttpProxy();
        if (proxyInfo == null)
            return null;
        return new ProxyInfo(proxyInfo);
    }
}
#method_after
@Override
public ProxyInfo getProxyForNetwork(Network network) {
    final ProxyInfo globalProxy = mProxyTracker.getGlobalProxy();
    if (globalProxy != null)
        return globalProxy;
    if (network == null) {
        // Get the network associated with the calling UID.
        final Network activeNetwork = getActiveNetworkForUidInternal(Binder.getCallingUid(), true);
        if (activeNetwork == null) {
            return null;
        }
        return getLinkPropertiesProxyInfo(activeNetwork);
    } else if (queryUserAccess(Binder.getCallingUid(), network.netId)) {
        // caller may not have.
        return getLinkPropertiesProxyInfo(network);
    }
    // No proxy info available if the calling UID does not have network access.
    return null;
}
#end_block

#method_before
// If the proxy has changed from oldLp to newLp, resend proxy broadcast with default proxy.
// This method gets called when any network changes proxy, but the broadcast only ever contains
// the default proxy (even if it hasn't changed).
// TODO: Deprecate the broadcast extras as they aren't necessarily applicable in a multi-network
private void updateProxy(LinkProperties newLp, LinkProperties oldLp) {
    ProxyInfo newProxyInfo = newLp == null ? null : newLp.getHttpProxy();
    ProxyInfo oldProxyInfo = oldLp == null ? null : oldLp.getHttpProxy();
    if (!ProxyTracker.proxyInfoEqual(newProxyInfo, oldProxyInfo)) {
        mProxyTracker.sendProxyBroadcast();
    }
}
#method_after
// If the proxy has changed from oldLp to newLp, resend proxy broadcast. This method gets called
// when any network changes proxy.
// TODO: Remove usage of broadcast extras as they are deprecated and not applicable in a
private void updateProxy(LinkProperties newLp, LinkProperties oldLp) {
    ProxyInfo newProxyInfo = newLp == null ? null : newLp.getHttpProxy();
    ProxyInfo oldProxyInfo = oldLp == null ? null : oldLp.getHttpProxy();
    if (!ProxyTracker.proxyInfoEqual(newProxyInfo, oldProxyInfo)) {
        mProxyTracker.sendProxyBroadcast();
    }
}
#end_block

#method_before
@Override
public VpnInfo[] getAllVpnInfo() {
    enforceConnectivityInternalPermission();
    synchronized (mVpns) {
        if (mLockdownEnabled) {
            return new VpnInfo[0];
        }
        List<VpnInfo> infoList = new ArrayList<>();
        for (int i = 0; i < mVpns.size(); i++) {
            VpnInfo info = createVpnInfo(mVpns.valueAt(i));
            if (info != null) {
                infoList.add(info);
            }
        }
        return infoList.toArray(new VpnInfo[infoList.size()]);
    }
}
#method_after
private VpnInfo[] getAllVpnInfo() {
    ensureRunningOnConnectivityServiceThread();
    synchronized (mVpns) {
        if (mLockdownEnabled) {
            return new VpnInfo[0];
        }
        List<VpnInfo> infoList = new ArrayList<>();
        for (int i = 0; i < mVpns.size(); i++) {
            VpnInfo info = createVpnInfo(mVpns.valueAt(i));
            if (info != null) {
                infoList.add(info);
            }
        }
        return infoList.toArray(new VpnInfo[infoList.size()]);
    }
}
#end_block

#method_before
private void updateAllVpnsCapabilities() {
    synchronized (mVpns) {
        for (int i = 0; i < mVpns.size(); i++) {
            final Vpn vpn = mVpns.valueAt(i);
            vpn.updateCapabilities();
        }
    }
}
#method_after
private void updateAllVpnsCapabilities() {
    Network defaultNetwork = getNetwork(getDefaultNetwork());
    synchronized (mVpns) {
        for (int i = 0; i < mVpns.size(); i++) {
            final Vpn vpn = mVpns.valueAt(i);
            NetworkCapabilities nc = vpn.updateCapabilities(defaultNetwork);
            updateVpnCapabilities(vpn, nc);
        }
    }
}
#end_block

#method_before
@Override
public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown) {
    enforceConnectivityInternalPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        // Can't set always-on VPN if legacy VPN is already in lockdown mode.
        if (LockdownVpnTracker.isEnabled()) {
            return false;
        }
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return false;
        }
        if (!vpn.setAlwaysOnPackage(packageName, lockdown)) {
            return false;
        }
        if (!startAlwaysOnVpn(userId)) {
            vpn.setAlwaysOnPackage(null, false);
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean setAlwaysOnVpnPackage(int userId, String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    enforceControlAlwaysOnVpnPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        // Can't set always-on VPN if legacy VPN is already in lockdown mode.
        if (LockdownVpnTracker.isEnabled()) {
            return false;
        }
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return false;
        }
        if (!vpn.setAlwaysOnPackage(packageName, lockdown, lockdownWhitelist)) {
            return false;
        }
        if (!startAlwaysOnVpn(userId)) {
            vpn.setAlwaysOnPackage(null, false, null);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public String getAlwaysOnVpnPackage(int userId) {
    enforceConnectivityInternalPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return null;
        }
        return vpn.getAlwaysOnPackage();
    }
}
#method_after
@Override
public String getAlwaysOnVpnPackage(int userId) {
    enforceControlAlwaysOnVpnPermission();
    enforceCrossUserPermission(userId);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            Slog.w(TAG, "User " + userId + " has no Vpn configuration");
            return null;
        }
        return vpn.getAlwaysOnPackage();
    }
}
#end_block

#method_before
private void onUserAdded(int userId) {
    mPermissionMonitor.onUserAdded(userId);
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserAdded(userId);
        }
    }
}
#method_after
private void onUserAdded(int userId) {
    mPermissionMonitor.onUserAdded(userId);
    Network defaultNetwork = getNetwork(getDefaultNetwork());
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserAdded(userId);
            NetworkCapabilities nc = vpn.updateCapabilities(defaultNetwork);
            updateVpnCapabilities(vpn, nc);
        }
    }
}
#end_block

#method_before
private void onUserRemoved(int userId) {
    mPermissionMonitor.onUserRemoved(userId);
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserRemoved(userId);
        }
    }
}
#method_after
private void onUserRemoved(int userId) {
    mPermissionMonitor.onUserRemoved(userId);
    Network defaultNetwork = getNetwork(getDefaultNetwork());
    synchronized (mVpns) {
        final int vpnsSize = mVpns.size();
        for (int i = 0; i < vpnsSize; i++) {
            Vpn vpn = mVpns.valueAt(i);
            vpn.onUserRemoved(userId);
            NetworkCapabilities nc = vpn.updateCapabilities(defaultNetwork);
            updateVpnCapabilities(vpn, nc);
        }
    }
}
#end_block

#method_before
private void onPackageRemoved(String packageName, int uid) {
    if (TextUtils.isEmpty(packageName) || uid < 0) {
        Slog.wtf(TAG, "Invalid package in onPackageRemoved: " + packageName + " | " + uid);
        return;
    }
    mPermissionMonitor.onPackageRemoved(uid);
}
#method_after
private void onPackageRemoved(String packageName, int uid, boolean isReplacing) {
    if (TextUtils.isEmpty(packageName) || uid < 0) {
        Slog.wtf(TAG, "Invalid package in onPackageRemoved: " + packageName + " | " + uid);
        return;
    }
    mPermissionMonitor.onPackageRemoved(uid);
    final int userId = UserHandle.getUserId(uid);
    synchronized (mVpns) {
        final Vpn vpn = mVpns.get(userId);
        if (vpn == null) {
            return;
        }
        // Legacy always-on VPN won't be affected since the package name is not set.
        if (TextUtils.equals(vpn.getAlwaysOnPackage(), packageName) && !isReplacing) {
            Slog.d(TAG, "Removing always-on VPN package " + packageName + " for user " + userId);
            vpn.setAlwaysOnPackage(null, false, null);
        }
    }
}
#end_block

#method_before
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), mDefaultRequest, this);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    synchronized (this) {
        nai.networkMonitor.systemReady = mSystemReady;
    }
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    addValidationLogs(nai.networkMonitor.getValidationLogs(), nai.network, name);
    if (DBG)
        log("registerNetworkAgent " + nai);
    mHandler.sendMessage(mHandler.obtainMessage(EVENT_REGISTER_NETWORK_AGENT, nai));
    return nai.network.netId;
}
#method_after
public int registerNetworkAgent(Messenger messenger, NetworkInfo networkInfo, LinkProperties linkProperties, NetworkCapabilities networkCapabilities, int currentScore, NetworkMisc networkMisc) {
    enforceConnectivityInternalPermission();
    LinkProperties lp = new LinkProperties(linkProperties);
    lp.ensureDirectlyConnectedRoutes();
    // TODO: Instead of passing mDefaultRequest, provide an API to determine whether a Network
    // satisfies mDefaultRequest.
    final NetworkCapabilities nc = new NetworkCapabilities(networkCapabilities);
    final NetworkAgentInfo nai = new NetworkAgentInfo(messenger, new AsyncChannel(), new Network(reserveNetId()), new NetworkInfo(networkInfo), lp, nc, currentScore, mContext, mTrackerHandler, new NetworkMisc(networkMisc), this, mNetd, mNMS);
    // Make sure the network capabilities reflect what the agent info says.
    nai.networkCapabilities = mixInCapabilities(nai, nc);
    final String extraInfo = networkInfo.getExtraInfo();
    final String name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
    if (DBG)
        log("registerNetworkAgent " + nai);
    final long token = Binder.clearCallingIdentity();
    try {
        getNetworkStack().makeNetworkMonitor(toStableParcelable(nai.network), name, new NetworkMonitorCallbacks(nai));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // registration.
    return nai.network.netId;
}
#end_block

#method_before
private void handleRegisterNetworkAgent(NetworkAgentInfo nai) {
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#method_after
private void handleRegisterNetworkAgent(NetworkAgentInfo nai, INetworkMonitor networkMonitor) {
    nai.onNetworkMonitorCreated(networkMonitor);
    if (VDBG)
        log("Got NetworkAgent Messenger");
    mNetworkAgentInfos.put(nai.messenger, nai);
    synchronized (mNetworkForNetId) {
        mNetworkForNetId.put(nai.network.netId, nai);
    }
    synchronized (this) {
        if (mSystemReady) {
            try {
                networkMonitor.notifySystemReady();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
        }
    }
    try {
        networkMonitor.start();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
    nai.asyncChannel.connect(mContext, mTrackerHandler, nai.messenger);
    NetworkInfo networkInfo = nai.networkInfo;
    nai.networkInfo = null;
    updateNetworkInfo(nai, networkInfo);
    updateUids(nai, null, nai.networkCapabilities);
}
#end_block

#method_before
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // we do anything else, make sure its LinkProperties are accurate.
    if (networkAgent.clatd != null) {
        networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    }
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop clat accordingly to network state.
        networkAgent.updateClat(mNMS);
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#method_after
private void updateLinkProperties(NetworkAgentInfo networkAgent, LinkProperties newLp, LinkProperties oldLp) {
    int netId = networkAgent.network.netId;
    // The NetworkAgentInfo does not know whether clatd is running on its network or not, or
    // whether there is a NAT64 prefix. Before we do anything else, make sure its LinkProperties
    // are accurate.
    networkAgent.clatd.fixupLinkProperties(oldLp, newLp);
    updateInterfaces(newLp, oldLp, netId, networkAgent.networkCapabilities);
    updateMtu(newLp, oldLp);
    // }
    if (isDefaultNetwork(networkAgent)) {
        updateTcpBufferSizes(newLp.getTcpBufferSizes());
    }
    updateRoutes(newLp, oldLp, netId);
    updateDnses(newLp, oldLp, netId);
    // Make sure LinkProperties represents the latest private DNS status.
    // This does not need to be done before updateDnses because the
    // LinkProperties are not the source of the private DNS configuration.
    // updateDnses will fetch the private DNS configuration from DnsManager.
    mDnsManager.updatePrivateDnsStatus(netId, newLp);
    if (isDefaultNetwork(networkAgent)) {
        handleApplyDefaultProxy(newLp.getHttpProxy());
    } else {
        updateProxy(newLp, oldLp);
    }
    // TODO - move this check to cover the whole function
    if (!Objects.equals(newLp, oldLp)) {
        synchronized (networkAgent) {
            networkAgent.linkProperties = newLp;
        }
        // Start or stop DNS64 detection and 464xlat according to network state.
        networkAgent.clatd.update();
        notifyIfacesChangedForNetworkStats();
        if (networkAgent.everConnected) {
            try {
                networkAgent.networkMonitor().notifyLinkPropertiesChanged();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
            }
            notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_IP_CHANGED);
        }
    }
    mKeepaliveTracker.handleCheckKeepalivesStillValid(networkAgent);
}
#end_block

#method_before
private NetworkCapabilities mixInCapabilities(NetworkAgentInfo nai, NetworkCapabilities nc) {
    // avoid connect/teardown loops.
    if (nai.everConnected && !nai.isVPN() && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(nc)) {
        // TODO: consider not complaining when a network agent degrades its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(nc);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (nai.lastValidated) {
        newNc.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        newNc.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        newNc.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        newNc.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        newNc.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        newNc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (nai.isSuspended()) {
        newNc.removeCapability(NET_CAPABILITY_NOT_SUSPENDED);
    } else {
        newNc.addCapability(NET_CAPABILITY_NOT_SUSPENDED);
    }
    if (nai.partialConnectivity && mKeepPartialConnectivityNetwork) {
        newNc.addCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    } else {
        newNc.removeCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    }
    return newNc;
}
#method_after
private NetworkCapabilities mixInCapabilities(NetworkAgentInfo nai, NetworkCapabilities nc) {
    // avoid connect/teardown loops.
    if (nai.everConnected && !nai.isVPN() && !nai.networkCapabilities.satisfiedByImmutableNetworkCapabilities(nc)) {
        // TODO: consider not complaining when a network agent degrades its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(nc);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    NetworkCapabilities newNc = new NetworkCapabilities(nc);
    if (nai.lastValidated) {
        newNc.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        newNc.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        newNc.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        newNc.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        newNc.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        newNc.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (nai.isSuspended()) {
        newNc.removeCapability(NET_CAPABILITY_NOT_SUSPENDED);
    } else {
        newNc.addCapability(NET_CAPABILITY_NOT_SUSPENDED);
    }
    if (nai.partialConnectivity) {
        newNc.addCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    } else {
        newNc.removeCapability(NET_CAPABILITY_PARTIAL_CONNECTIVITY);
    }
    return newNc;
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities nc) {
    NetworkCapabilities newNc = mixInCapabilities(nai, nc);
    if (Objects.equals(nai.networkCapabilities, newNc))
        return;
    final int oldPermission = getNetworkPermission(nai.networkCapabilities);
    final int newPermission = getNetworkPermission(newNc);
    if (oldPermission != newPermission && nai.created && !nai.isVPN()) {
        try {
            mNMS.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc;
    synchronized (nai) {
        prevNc = nai.networkCapabilities;
        nai.networkCapabilities = newNc;
    }
    updateUids(nai, prevNc, newNc);
    if (nai.getCurrentScore() == oldScore && newNc.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    if (prevNc != null) {
        final boolean oldMetered = prevNc.isMetered();
        final boolean newMetered = newNc.isMetered();
        final boolean meteredChanged = oldMetered != newMetered;
        if (meteredChanged) {
            maybeNotifyNetworkBlocked(nai, oldMetered, newMetered, mRestrictBackground, mRestrictBackground);
        }
        final boolean roamingChanged = prevNc.hasCapability(NET_CAPABILITY_NOT_ROAMING) != newNc.hasCapability(NET_CAPABILITY_NOT_ROAMING);
        // Report changes that are interesting for network statistics tracking.
        if (meteredChanged || roamingChanged) {
            notifyIfacesChangedForNetworkStats();
        }
    }
    if (!newNc.hasTransport(TRANSPORT_VPN)) {
        // Tell VPNs about updated capabilities, since they may need to
        // bubble those changes through.
        updateAllVpnsCapabilities();
    }
}
#end_block

#method_before
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    updateLinkProperties(nai, newLp, new LinkProperties(nai.linkProperties));
}
#method_after
public void handleUpdateLinkProperties(NetworkAgentInfo nai, LinkProperties newLp) {
    ensureRunningOnConnectivityServiceThread();
    if (getNetworkAgentInfoForNetId(nai.network.netId) != nai) {
        // Ignore updates for disconnected networks
        return;
    }
    // newLp is already a defensive copy.
    newLp.ensureDirectlyConnectedRoutes();
    if (VDBG || DDBG) {
        log("Update of LinkProperties for " + nai.name() + "; created=" + nai.created + "; everConnected=" + nai.everConnected);
    }
    updateLinkProperties(nai, newLp, new LinkProperties(nai.linkProperties));
}
#end_block

#method_before
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, new NetworkCapabilities(networkAgent.networkCapabilities));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                maybeLogBlockedStatusChanged(nri, networkAgent.network, arg1 != 0);
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#method_after
private void callCallbackForRequest(NetworkRequestInfo nri, NetworkAgentInfo networkAgent, int notificationType, int arg1) {
    if (nri.messenger == null) {
        // Default request has no msgr
        return;
    }
    Bundle bundle = new Bundle();
    // TODO: check if defensive copies of data is needed.
    putParcelable(bundle, new NetworkRequest(nri.request));
    Message msg = Message.obtain();
    if (notificationType != ConnectivityManager.CALLBACK_UNAVAIL) {
        putParcelable(bundle, networkAgent.network);
    }
    switch(notificationType) {
        case ConnectivityManager.CALLBACK_AVAILABLE:
            {
                putParcelable(bundle, networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid));
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                // For this notification, arg1 contains the blocked status.
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_LOSING:
            {
                msg.arg1 = arg1;
                break;
            }
        case ConnectivityManager.CALLBACK_CAP_CHANGED:
            {
                // networkAgent can't be null as it has been accessed a few lines above.
                final NetworkCapabilities nc = networkCapabilitiesRestrictedForCallerPermissions(networkAgent.networkCapabilities, nri.mPid, nri.mUid);
                putParcelable(bundle, nc);
                break;
            }
        case ConnectivityManager.CALLBACK_IP_CHANGED:
            {
                putParcelable(bundle, new LinkProperties(networkAgent.linkProperties));
                break;
            }
        case ConnectivityManager.CALLBACK_BLK_CHANGED:
            {
                maybeLogBlockedStatusChanged(nri, networkAgent.network, arg1 != 0);
                msg.arg1 = arg1;
                break;
            }
    }
    msg.what = notificationType;
    msg.setData(bundle);
    try {
        if (VDBG) {
            String notification = ConnectivityManager.getCallbackName(notificationType);
            log("sending notification " + notification + " for " + nri.request);
        }
        nri.messenger.send(msg);
    } catch (RemoteException e) {
        // may occur naturally in the race of binder death.
        loge("RemoteException caught trying to send a callback msg for " + nri.request);
    }
}
#end_block

#method_before
private void makeDefault(NetworkAgentInfo newNetwork) {
    if (DBG)
        log("Switching to new default network: " + newNetwork);
    try {
        mNMS.setDefaultNetId(newNetwork.network.netId);
    } catch (Exception e) {
        loge("Exception setting default network :" + e);
    }
    notifyLockdownVpn(newNetwork);
    handleApplyDefaultProxy(newNetwork.linkProperties.getHttpProxy());
    updateTcpBufferSizes(newNetwork.linkProperties.getTcpBufferSizes());
    mDnsManager.setDefaultDnsSystemProperties(newNetwork.linkProperties.getDnsServers());
    notifyIfacesChangedForNetworkStats();
}
#method_after
private void makeDefault(NetworkAgentInfo newNetwork) {
    if (DBG)
        log("Switching to new default network: " + newNetwork);
    try {
        mNMS.setDefaultNetId(newNetwork.network.netId);
    } catch (Exception e) {
        loge("Exception setting default network :" + e);
    }
    notifyLockdownVpn(newNetwork);
    handleApplyDefaultProxy(newNetwork.linkProperties.getHttpProxy());
    updateTcpBufferSizes(newNetwork.linkProperties.getTcpBufferSizes());
    mDnsManager.setDefaultDnsSystemProperties(newNetwork.linkProperties.getDnsServers());
    notifyIfacesChangedForNetworkStats();
    // Fix up the NetworkCapabilities of any VPNs that don't specify underlying networks.
    updateAllVpnsCapabilities();
}
#end_block

#method_before
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#method_after
private void processListenRequests(NetworkAgentInfo nai, boolean capabilitiesChanged) {
    // For consistency with previous behaviour, send onLost callbacks before onAvailable.
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.isSatisfyingRequest(nr.requestId) && !nai.satisfies(nr)) {
            nai.removeRequest(nri.request.requestId);
            callCallbackForRequest(nri, nai, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (capabilitiesChanged) {
        try {
            nai.networkMonitor().notifyNetworkCapabilitiesChanged();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        NetworkRequest nr = nri.request;
        if (!nr.isListen())
            continue;
        if (nai.satisfies(nr) && !nai.isSatisfyingRequest(nr.requestId)) {
            nai.addRequest(nr);
            notifyNetworkAvailable(nai, nri);
        }
    }
}
#end_block

#method_before
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, !networkAgent.linkProperties.getDnsServers().isEmpty(), (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        networkAgent.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_CONNECTED);
        mKeepPartialConnectivityNetwork = false;
        scheduleUnvalidatedPrompt(networkAgent);
        if (networkAgent.isVPN()) {
            // Temporarily disable the default proxy (not global).
            mProxyTracker.setDefaultProxyEnabled(false);
        // TODO: support proxy per network.
        }
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            mProxyTracker.setDefaultProxyEnabled(true);
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#method_after
private void updateNetworkInfo(NetworkAgentInfo networkAgent, NetworkInfo newInfo) {
    final NetworkInfo.State state = newInfo.getState();
    NetworkInfo oldInfo = null;
    final int oldScore = networkAgent.getCurrentScore();
    synchronized (networkAgent) {
        oldInfo = networkAgent.networkInfo;
        networkAgent.networkInfo = newInfo;
    }
    notifyLockdownVpn(networkAgent);
    if (DBG) {
        log(networkAgent.name() + " EVENT_NETWORK_INFO_CHANGED, going from " + (oldInfo == null ? "null" : oldInfo.getState()) + " to " + state);
    }
    if (!networkAgent.created && (state == NetworkInfo.State.CONNECTED || (state == NetworkInfo.State.CONNECTING && networkAgent.isVPN()))) {
        // A network that has just connected has zero requests and is thus a foreground network.
        networkAgent.networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
        try {
            // This should never fail.  Specifying an already in use NetID will cause failure.
            if (networkAgent.isVPN()) {
                mNMS.createVirtualNetwork(networkAgent.network.netId, (networkAgent.networkMisc == null || !networkAgent.networkMisc.allowBypass));
            } else {
                mNMS.createPhysicalNetwork(networkAgent.network.netId, getNetworkPermission(networkAgent.networkCapabilities));
            }
        } catch (Exception e) {
            loge("Error creating network " + networkAgent.network.netId + ": " + e.getMessage());
            return;
        }
        networkAgent.created = true;
    }
    if (!networkAgent.everConnected && state == NetworkInfo.State.CONNECTED) {
        networkAgent.everConnected = true;
        if (networkAgent.linkProperties == null) {
            Slog.wtf(TAG, networkAgent.name() + " connected with null LinkProperties");
        }
        handlePerNetworkPrivateDnsConfig(networkAgent, mDnsManager.getPrivateDnsConfig());
        updateLinkProperties(networkAgent, new LinkProperties(networkAgent.linkProperties), null);
        // TODO: pass LinkProperties to the NetworkMonitor in the notifyNetworkConnected call.
        try {
            networkAgent.networkMonitor().notifyNetworkConnected();
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
        scheduleUnvalidatedPrompt(networkAgent);
        // Whether a particular NetworkRequest listen should cause signal strength thresholds to
        // be communicated to a particular NetworkAgent depends only on the network's immutable,
        // capabilities, so it only needs to be done once on initial connect, not every time the
        // network's capabilities change. Note that we do this before rematching the network,
        // so we could decide to tear it down immediately afterwards. That's fine though - on
        // disconnection NetworkAgents should stop any signal strength monitoring they have been
        // doing.
        updateSignalStrengthThresholds(networkAgent, "CONNECT", null);
        if (networkAgent.isVPN()) {
            updateAllVpnsCapabilities();
        }
        // Consider network even though it is not yet validated.
        final long now = SystemClock.elapsedRealtime();
        rematchNetworkAndRequests(networkAgent, ReapUnvalidatedNetworks.REAP, now);
        // This has to happen after matching the requests, because callbacks are just requests.
        notifyNetworkCallbacks(networkAgent, ConnectivityManager.CALLBACK_PRECHECK);
    } else if (state == NetworkInfo.State.DISCONNECTED) {
        networkAgent.asyncChannel.disconnect();
        if (networkAgent.isVPN()) {
            updateUids(networkAgent, networkAgent.networkCapabilities, null);
        }
        disconnectAndDestroyNetwork(networkAgent);
        if (networkAgent.isVPN()) {
            // As the active or bound network changes for apps, broadcast the default proxy, as
            // apps may need to update their proxy data. This is called after disconnecting from
            // VPN to make sure we do not broadcast the old proxy data.
            // TODO(b/122649188): send the broadcast only to VPN users.
            mProxyTracker.sendProxyBroadcast();
        }
    } else if ((oldInfo != null && oldInfo.getState() == NetworkInfo.State.SUSPENDED) || state == NetworkInfo.State.SUSPENDED) {
        // going into or coming out of SUSPEND: re-score and notify
        if (networkAgent.getCurrentScore() != oldScore) {
            rematchAllNetworksAndRequests(networkAgent, oldScore);
        }
        updateCapabilities(networkAgent.getCurrentScore(), networkAgent, networkAgent.networkCapabilities);
        // TODO (b/73132094) : remove this call once the few users of onSuspended and
        // onResumed have been removed.
        notifyNetworkCallbacks(networkAgent, (state == NetworkInfo.State.SUSPENDED ? ConnectivityManager.CALLBACK_SUSPENDED : ConnectivityManager.CALLBACK_RESUMED));
        mLegacyTypeTracker.update(networkAgent);
    }
}
#end_block

#method_before
private Network[] getDefaultNetworks() {
    ArrayList<Network> defaultNetworks = new ArrayList<>();
    NetworkAgentInfo defaultNetwork = getDefaultNetwork();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.everConnected && (nai == defaultNetwork || nai.isVPN())) {
            defaultNetworks.add(nai.network);
        }
    }
    return defaultNetworks.toArray(new Network[0]);
}
#method_after
private Network[] getDefaultNetworks() {
    ensureRunningOnConnectivityServiceThread();
    ArrayList<Network> defaultNetworks = new ArrayList<>();
    NetworkAgentInfo defaultNetwork = getDefaultNetwork();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        if (nai.everConnected && (nai == defaultNetwork || nai.isVPN())) {
            defaultNetworks.add(nai.network);
        }
    }
    return defaultNetworks.toArray(new Network[0]);
}
#end_block

#method_before
private void notifyIfacesChangedForNetworkStats() {
    try {
        mStatsService.forceUpdateIfaces(getDefaultNetworks());
    } catch (Exception ignored) {
    }
}
#method_after
private void notifyIfacesChangedForNetworkStats() {
    ensureRunningOnConnectivityServiceThread();
    String activeIface = null;
    LinkProperties activeLinkProperties = getActiveLinkProperties();
    if (activeLinkProperties != null) {
        activeIface = activeLinkProperties.getInterfaceName();
    }
    try {
        mStatsService.forceUpdateIfaces(getDefaultNetworks(), getAllVpnInfo(), getAllNetworkState(), activeIface);
    } catch (Exception ignored) {
    }
}
#end_block

#method_before
@Override
public boolean setUnderlyingNetworksForVpn(Network[] networks) {
    int user = UserHandle.getUserId(Binder.getCallingUid());
    final boolean success;
    synchronized (mVpns) {
        throwIfLockdownEnabled();
        success = mVpns.get(user).setUnderlyingNetworks(networks);
    }
    if (success) {
        mHandler.post(() -> notifyIfacesChangedForNetworkStats());
    }
    return success;
}
#method_after
@Override
public boolean setUnderlyingNetworksForVpn(Network[] networks) {
    int user = UserHandle.getUserId(Binder.getCallingUid());
    final boolean success;
    synchronized (mVpns) {
        throwIfLockdownEnabled();
        success = mVpns.get(user).setUnderlyingNetworks(networks);
    }
    if (success) {
        mHandler.post(() -> {
            // Update VPN's capabilities based on updated underlying network set.
            updateAllVpnsCapabilities();
            notifyIfacesChangedForNetworkStats();
        });
    }
    return success;
}
#end_block

#method_before
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitor.getCaptivePortalServerHttpUrl(mContext);
}
#method_after
@Override
public String getCaptivePortalServerUrl() {
    enforceConnectivityInternalPermission();
    return NetworkMonitorUtils.getCaptivePortalServerHttpUrl(mContext);
}
#end_block

#method_before
@Override
public void startNattKeepalive(Network network, int intervalSeconds, Messenger messenger, IBinder binder, String srcAddr, int srcPort, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), intervalSeconds, messenger, binder, srcAddr, srcPort, dstAddr, ConnectivityManager.PacketKeepalive.NATT_PORT);
}
#method_after
@Override
public void startNattKeepalive(Network network, int intervalSeconds, Messenger messenger, IBinder binder, String srcAddr, int srcPort, String dstAddr) {
    enforceKeepalivePermission();
    mKeepaliveTracker.startNattKeepalive(getNetworkAgentInfoForNetwork(network), intervalSeconds, messenger, binder, srcAddr, srcPort, dstAddr, NattSocketKeepalive.NATT_PORT);
}
#end_block

#method_before
@Override
public void stopKeepalive(Network network, int slot) {
    mHandler.sendMessage(mHandler.obtainMessage(NetworkAgent.CMD_STOP_PACKET_KEEPALIVE, slot, PacketKeepalive.SUCCESS, network));
}
#method_after
@Override
public void stopKeepalive(Network network, int slot) {
    mHandler.sendMessage(mHandler.obtainMessage(NetworkAgent.CMD_STOP_SOCKET_KEEPALIVE, slot, SocketKeepalive.SUCCESS, network));
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        String pkgName = mContext.getOpPackageName();
        for (String tether : getTetheredIfaces()) {
            untether(tether, pkgName);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
            // Turn Always-on VPN off
            if (mLockdownEnabled && userId == UserHandle.USER_SYSTEM) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    mKeyStore.delete(Credentials.LOCKDOWN_VPN);
                    mLockdownEnabled = false;
                    setLockdownTracker(null);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            }
            // Turn VPN off
            VpnConfig vpnConfig = getVpnConfig(userId);
            if (vpnConfig != null) {
                if (vpnConfig.legacy) {
                    prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
                } else {
                    // Prevent this app (packagename = vpnConfig.user) from initiating
                    // VPN connections in the future without user intervention.
                    setVpnPackageAuthorization(vpnConfig.user, userId, false);
                    prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
                }
            }
        }
    }
    Settings.Global.putString(mContext.getContentResolver(), Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    final int userId = UserHandle.getCallingUserId();
    // Turn airplane mode off
    setAirplaneMode(false);
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Untether
        String pkgName = mContext.getOpPackageName();
        for (String tether : getTetheredIfaces()) {
            untether(tether, pkgName);
        }
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN)) {
        // Remove always-on package
        synchronized (mVpns) {
            final String alwaysOnPackage = getAlwaysOnVpnPackage(userId);
            if (alwaysOnPackage != null) {
                setAlwaysOnVpnPackage(userId, null, false, null);
                setVpnPackageAuthorization(alwaysOnPackage, userId, false);
            }
            // Turn Always-on VPN off
            if (mLockdownEnabled && userId == UserHandle.USER_SYSTEM) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    mKeyStore.delete(Credentials.LOCKDOWN_VPN);
                    mLockdownEnabled = false;
                    setLockdownTracker(null);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            }
            // Turn VPN off
            VpnConfig vpnConfig = getVpnConfig(userId);
            if (vpnConfig != null) {
                if (vpnConfig.legacy) {
                    prepareVpn(VpnConfig.LEGACY_VPN, VpnConfig.LEGACY_VPN, userId);
                } else {
                    // Prevent this app (packagename = vpnConfig.user) from initiating
                    // VPN connections in the future without user intervention.
                    setVpnPackageAuthorization(vpnConfig.user, userId, false);
                    prepareVpn(null, VpnConfig.LEGACY_VPN, userId);
                }
            }
        }
    }
    Settings.Global.putString(mContext.getContentResolver(), Settings.Global.NETWORK_AVOID_BAD_WIFI, null);
}
#end_block

#method_before
private Vpn enforceActiveVpnOrNetworkStackPermission() {
    if (checkNetworkStackPermission()) {
        return null;
    }
    final int uid = Binder.getCallingUid();
    final int user = UserHandle.getUserId(uid);
    synchronized (mVpns) {
        Vpn vpn = mVpns.get(user);
        try {
            if (vpn.getVpnInfo().ownerUid == uid)
                return vpn;
        } catch (NullPointerException e) {
        /* vpn is null, or VPN is not connected and getVpnInfo() is null. */
        }
    }
    throw new SecurityException("App must either be an active VPN or have the NETWORK_STACK " + "permission");
}
#method_after
private Vpn enforceActiveVpnOrNetworkStackPermission() {
    if (checkNetworkStackPermission()) {
        return null;
    }
    synchronized (mVpns) {
        Vpn vpn = getVpnIfOwner();
        if (vpn != null) {
            return vpn;
        }
    }
    throw new SecurityException("App must either be an active VPN or have the NETWORK_STACK " + "permission");
}
#end_block

#method_before
public void showNotification(int id, NotificationType notifyType, NetworkAgentInfo nai, NetworkAgentInfo switchToNai, PendingIntent intent, boolean highPriority) {
    final String tag = tagFor(id);
    final int eventId = notifyType.eventId;
    final int transportType;
    final String name;
    if (nai != null) {
        transportType = getFirstTransportType(nai);
        final String extraInfo = nai.networkInfo.getExtraInfo();
        name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
        // Only notify for Internet-capable networks.
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET))
            return;
    } else {
        // Legacy notifications.
        transportType = TRANSPORT_CELLULAR;
        name = null;
    }
    // Clear any previous notification with lower priority, otherwise return. http://b/63676954.
    // A new SIGN_IN notification with a new intent should override any existing one.
    final int previousEventId = mNotificationTypeMap.get(id);
    final NotificationType previousNotifyType = NotificationType.getFromId(previousEventId);
    if (priority(previousNotifyType) > priority(notifyType)) {
        Slog.d(TAG, String.format("ignoring notification %s for network %s with existing notification %s", notifyType, id, previousNotifyType));
        return;
    }
    clearNotification(id);
    if (DBG) {
        Slog.d(TAG, String.format("showNotification tag=%s event=%s transport=%s name=%s highPriority=%s", tag, nameOf(eventId), getTransportName(transportType), name, highPriority));
    }
    Resources r = Resources.getSystem();
    CharSequence title;
    CharSequence details;
    int icon = getIcon(transportType);
    if (notifyType == NotificationType.NO_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, 0);
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.PARTIAL_CONNECTIVITY) {
        title = r.getString(R.string.partial_connectivity, 0);
        details = r.getString(R.string.partial_connectivity_detailed);
    } else if (notifyType == NotificationType.LOST_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, 0);
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.SIGN_IN) {
        switch(transportType) {
            case TRANSPORT_WIFI:
                title = r.getString(R.string.wifi_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
                break;
            case TRANSPORT_CELLULAR:
                title = r.getString(R.string.network_available_sign_in, 0);
                // TODO: Change this to pull from NetworkInfo once a printable
                // name has been added to it
                details = mTelephonyManager.getNetworkOperatorName();
                break;
            default:
                title = r.getString(R.string.network_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, name);
                break;
        }
    } else if (notifyType == NotificationType.NETWORK_SWITCH) {
        String fromTransport = getTransportName(transportType);
        String toTransport = getTransportName(getFirstTransportType(switchToNai));
        title = r.getString(R.string.network_switch_metered, toTransport);
        details = r.getString(R.string.network_switch_metered_detail, toTransport, fromTransport);
    } else {
        Slog.wtf(TAG, "Unknown notification type " + notifyType + " on network transport " + getTransportName(transportType));
        return;
    }
    final String channelId = highPriority ? SystemNotificationChannels.NETWORK_ALERTS : SystemNotificationChannels.NETWORK_STATUS;
    Notification.Builder builder = new Notification.Builder(mContext, channelId).setWhen(System.currentTimeMillis()).setShowWhen(notifyType == NotificationType.NETWORK_SWITCH).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentIntent(intent).setLocalOnly(true).setOnlyAlertOnce(true);
    if (notifyType == NotificationType.NETWORK_SWITCH) {
        builder.setStyle(new Notification.BigTextStyle().bigText(details));
    } else {
        builder.setContentText(details);
    }
    if (notifyType == NotificationType.SIGN_IN) {
        builder.extend(new Notification.TvExtender().setChannelId(channelId));
    }
    Notification notification = builder.build();
    mNotificationTypeMap.put(id, eventId);
    try {
        mNotificationManager.notifyAsUser(tag, eventId, notification, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, "setNotificationVisible: visible notificationManager error", npe);
    }
}
#method_after
public void showNotification(int id, NotificationType notifyType, NetworkAgentInfo nai, NetworkAgentInfo switchToNai, PendingIntent intent, boolean highPriority) {
    final String tag = tagFor(id);
    final int eventId = notifyType.eventId;
    final int transportType;
    final String name;
    if (nai != null) {
        transportType = getFirstTransportType(nai);
        final String extraInfo = nai.networkInfo.getExtraInfo();
        name = TextUtils.isEmpty(extraInfo) ? nai.networkCapabilities.getSSID() : extraInfo;
        // Only notify for Internet-capable networks.
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET))
            return;
    } else {
        // Legacy notifications.
        transportType = TRANSPORT_CELLULAR;
        name = null;
    }
    // Clear any previous notification with lower priority, otherwise return. http://b/63676954.
    // A new SIGN_IN notification with a new intent should override any existing one.
    final int previousEventId = mNotificationTypeMap.get(id);
    final NotificationType previousNotifyType = NotificationType.getFromId(previousEventId);
    if (priority(previousNotifyType) > priority(notifyType)) {
        Slog.d(TAG, String.format("ignoring notification %s for network %s with existing notification %s", notifyType, id, previousNotifyType));
        return;
    }
    clearNotification(id);
    if (DBG) {
        Slog.d(TAG, String.format("showNotification tag=%s event=%s transport=%s name=%s highPriority=%s", tag, nameOf(eventId), getTransportName(transportType), name, highPriority));
    }
    Resources r = Resources.getSystem();
    CharSequence title;
    CharSequence details;
    int icon = getIcon(transportType);
    if (notifyType == NotificationType.NO_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.PARTIAL_CONNECTIVITY && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.network_partial_connectivity, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.network_partial_connectivity_detailed);
    } else if (notifyType == NotificationType.LOST_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.SIGN_IN) {
        switch(transportType) {
            case TRANSPORT_WIFI:
                title = r.getString(R.string.wifi_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID()));
                break;
            case TRANSPORT_CELLULAR:
                title = r.getString(R.string.network_available_sign_in, 0);
                // TODO: Change this to pull from NetworkInfo once a printable
                // name has been added to it
                details = mTelephonyManager.getNetworkOperatorName();
                break;
            default:
                title = r.getString(R.string.network_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, name);
                break;
        }
    } else if (notifyType == NotificationType.LOGGED_IN) {
        title = WifiInfo.removeDoubleQuotes(nai.networkCapabilities.getSSID());
        details = r.getString(R.string.captive_portal_logged_in_detailed);
    } else if (notifyType == NotificationType.NETWORK_SWITCH) {
        String fromTransport = getTransportName(transportType);
        String toTransport = getTransportName(getFirstTransportType(switchToNai));
        title = r.getString(R.string.network_switch_metered, toTransport);
        details = r.getString(R.string.network_switch_metered_detail, toTransport, fromTransport);
    } else {
        Slog.wtf(TAG, "Unknown notification type " + notifyType + " on network transport " + getTransportName(transportType));
        return;
    }
    final String channelId = highPriority ? SystemNotificationChannels.NETWORK_ALERTS : SystemNotificationChannels.NETWORK_STATUS;
    Notification.Builder builder = new Notification.Builder(mContext, channelId).setWhen(System.currentTimeMillis()).setShowWhen(notifyType == NotificationType.NETWORK_SWITCH).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentIntent(intent).setLocalOnly(true).setOnlyAlertOnce(true);
    if (notifyType == NotificationType.NETWORK_SWITCH) {
        builder.setStyle(new Notification.BigTextStyle().bigText(details));
    } else {
        builder.setContentText(details);
    }
    if (notifyType == NotificationType.SIGN_IN) {
        builder.extend(new Notification.TvExtender().setChannelId(channelId));
    }
    Notification notification = builder.build();
    mNotificationTypeMap.put(id, eventId);
    try {
        mNotificationManager.notifyAsUser(tag, eventId, notification, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, "setNotificationVisible: visible notificationManager error", npe);
    }
}
#end_block

#method_before
public void clearNotification(int id) {
    if (mNotificationTypeMap.indexOfKey(id) < 0) {
        return;
    }
    final String tag = tagFor(id);
    final int eventId = mNotificationTypeMap.get(id);
    if (DBG) {
        Slog.d(TAG, String.format("clearing notification tag=%s event=%s", tag, nameOf(eventId)));
    }
    try {
        mNotificationManager.cancelAsUser(tag, eventId, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, String.format("failed to clear notification tag=%s event=%s", tag, nameOf(eventId)), npe);
    }
    mNotificationTypeMap.delete(id);
}
#method_after
public void clearNotification(int id, NotificationType notifyType) {
    final int previousEventId = mNotificationTypeMap.get(id);
    final NotificationType previousNotifyType = NotificationType.getFromId(previousEventId);
    if (notifyType != previousNotifyType) {
        return;
    }
    clearNotification(id);
}
#end_block

#method_before
private static int priority(NotificationType t) {
    if (t == null) {
        return 0;
    }
    switch(t) {
        case SIGN_IN:
            return 5;
        case PARTIAL_CONNECTIVITY:
            return 4;
        case NO_INTERNET:
            return 3;
        case NETWORK_SWITCH:
            return 2;
        case LOST_INTERNET:
            return 1;
        default:
            return 0;
    }
}
#method_after
private static int priority(NotificationType t) {
    if (t == null) {
        return 0;
    }
    switch(t) {
        case SIGN_IN:
            return 5;
        case PARTIAL_CONNECTIVITY:
            return 4;
        case NO_INTERNET:
            return 3;
        case NETWORK_SWITCH:
            return 2;
        case LOST_INTERNET:
        case LOGGED_IN:
            return 1;
        default:
            return 0;
    }
}
#end_block

#method_before
public boolean isPartialConnectivity() {
    return mPartialConnectivity;
}
#method_after
public boolean isPartialConnectivity() {
    return mHttpResponseCode == PARTIAL_CODE;
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo getActiveNetworkInfo() {
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkInfo getActiveNetworkInfo() {
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public Network getActiveNetwork() {
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public Network getActiveNetwork() {
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public Network getActiveNetworkForUid(int uid) {
    return getActiveNetworkForUid(uid, false);
}
#method_after
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
@Nullable
public Network getActiveNetworkForUid(int uid) {
    return getActiveNetworkForUid(uid, false);
}
#end_block

#method_before
public boolean setAlwaysOnVpnPackageForUser(int userId, @Nullable String vpnPackage, boolean lockdownEnabled) {
    try {
        return mService.setAlwaysOnVpnPackage(userId, vpnPackage, lockdownEnabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.CONTROL_ALWAYS_ON_VPN)
public boolean setAlwaysOnVpnPackageForUser(int userId, @Nullable String vpnPackage, boolean lockdownEnabled, @Nullable List<String> lockdownWhitelist) {
    try {
        return mService.setAlwaysOnVpnPackage(userId, vpnPackage, lockdownEnabled, lockdownWhitelist);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public String getAlwaysOnVpnPackageForUser(int userId) {
    try {
        return mService.getAlwaysOnVpnPackage(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.CONTROL_ALWAYS_ON_VPN)
public String getAlwaysOnVpnPackageForUser(int userId) {
    try {
        return mService.getAlwaysOnVpnPackage(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo getNetworkInfo(int networkType) {
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkInfo getNetworkInfo(int networkType) {
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo getNetworkInfo(Network network) {
    return getNetworkInfoForUid(network, Process.myUid(), false);
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkInfo getNetworkInfo(@Nullable Network network) {
    return getNetworkInfoForUid(network, Process.myUid(), false);
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkInfo[] getAllNetworkInfo() {
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@NonNull
public NetworkInfo[] getAllNetworkInfo() {
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public Network[] getAllNetworks() {
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@NonNull
public Network[] getAllNetworks() {
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public LinkProperties getActiveLinkProperties() {
    try {
        return mService.getActiveLinkProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 109783091)
public LinkProperties getActiveLinkProperties() {
    try {
        return mService.getActiveLinkProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public LinkProperties getLinkProperties(Network network) {
    try {
        return mService.getLinkProperties(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public LinkProperties getLinkProperties(@Nullable Network network) {
    try {
        return mService.getLinkProperties(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public NetworkCapabilities getNetworkCapabilities(Network network) {
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@Nullable
public NetworkCapabilities getNetworkCapabilities(@Nullable Network network) {
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void removeDefaultNetworkActiveListener(OnNetworkActiveListener l) {
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    Preconditions.checkArgument(rl != null, "Listener was not registered.");
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void removeDefaultNetworkActiveListener(@NonNull OnNetworkActiveListener l) {
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    Preconditions.checkArgument(rl != null, "Listener was not registered.");
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
public void reportBadNetwork(Network network) {
    printStackTrace();
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
public void reportBadNetwork(@Nullable Network network) {
    printStackTrace();
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void reportNetworkConnectivity(Network network, boolean hasConnectivity) {
    printStackTrace();
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void reportNetworkConnectivity(@Nullable Network network, boolean hasConnectivity) {
    printStackTrace();
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public ProxyInfo getDefaultProxy() {
    return getProxyForNetwork(getBoundNetworkForProcess());
}
#method_after
@Nullable
public ProxyInfo getDefaultProxy() {
    return getProxyForNetwork(getBoundNetworkForProcess());
}
#end_block

#method_before
@UnsupportedAppUsage
public void unregisterNetworkFactory(Messenger messenger) {
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
public void unregisterNetworkFactory(Messenger messenger) {
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, int timeoutMs, int legacyType, Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, timeoutMs, REQUEST, legacyType, cbHandler);
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs, int legacyType, @NonNull Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, timeoutMs, REQUEST, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback) {
    requestNetwork(request, networkCallback, getDefaultHandler());
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback) {
    requestNetwork(request, networkCallback, getDefaultHandler());
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, Handler handler) {
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, 0, legacyType, cbHandler);
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler) {
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, 0, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, NetworkCallback networkCallback, Handler handler, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler, int timeoutMs) {
    checkTimeout(timeoutMs);
    int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
    CallbackHandler cbHandler = new CallbackHandler(handler);
    requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
}
#end_block

#method_before
public void requestNetwork(NetworkRequest request, PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
public void requestNetwork(@NonNull NetworkRequest request, @NonNull PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingRequestForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
public void releaseNetworkRequest(PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public void releaseNetworkRequest(@NonNull PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.releasePendingNetworkRequest(operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(NetworkRequest request, NetworkCallback networkCallback) {
    registerNetworkCallback(request, networkCallback, getDefaultHandler());
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback) {
    registerNetworkCallback(request, networkCallback, getDefaultHandler());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(NetworkRequest request, NetworkCallback networkCallback, Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, 0, LISTEN, TYPE_NONE, cbHandler);
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull NetworkCallback networkCallback, @NonNull Handler handler) {
    CallbackHandler cbHandler = new CallbackHandler(handler);
    NetworkCapabilities nc = request.networkCapabilities;
    sendRequestForNetwork(nc, networkCallback, 0, LISTEN, TYPE_NONE, cbHandler);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(NetworkRequest request, PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerNetworkCallback(@NonNull NetworkRequest request, @NonNull PendingIntent operation) {
    printStackTrace();
    checkPendingIntentNotNull(operation);
    try {
        mService.pendingListenForNetwork(request.networkCapabilities, operation);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (ServiceSpecificException e) {
        throw convertServiceException(e);
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback) {
    registerDefaultNetworkCallback(networkCallback, getDefaultHandler());
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback) {
    registerDefaultNetworkCallback(networkCallback, getDefaultHandler());
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback, Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, /* NetworkCapabilities need */
    networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(@NonNull NetworkCallback networkCallback, @NonNull Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, /* NetworkCapabilities need */
    networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#end_block

#method_before
public boolean requestBandwidthUpdate(Network network) {
    try {
        return mService.requestBandwidthUpdate(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public boolean requestBandwidthUpdate(@NonNull Network network) {
    try {
        return mService.requestBandwidthUpdate(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(NetworkCallback networkCallback) {
    printStackTrace();
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, "NetworkCallback was not registered");
        Preconditions.checkArgument(networkCallback.networkRequest != ALREADY_UNREGISTERED, "NetworkCallback was already unregistered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}
#method_after
public void unregisterNetworkCallback(@NonNull NetworkCallback networkCallback) {
    printStackTrace();
    checkCallbackNotNull(networkCallback);
    final List<NetworkRequest> reqs = new ArrayList<>();
    // Callback is reusable immediately. http://b/20701525, http://b/35921499.
    synchronized (sCallbacks) {
        Preconditions.checkArgument(networkCallback.networkRequest != null, "NetworkCallback was not registered");
        Preconditions.checkArgument(networkCallback.networkRequest != ALREADY_UNREGISTERED, "NetworkCallback was already unregistered");
        for (Map.Entry<NetworkRequest, NetworkCallback> e : sCallbacks.entrySet()) {
            if (e.getValue() == networkCallback) {
                reqs.add(e.getKey());
            }
        }
        // TODO: throw exception if callback was registered more than once (http://b/20701525).
        for (NetworkRequest r : reqs) {
            try {
                mService.releaseNetworkRequest(r);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            // Only remove mapping if rpc was successful.
            sCallbacks.remove(r);
        }
        networkCallback.networkRequest = ALREADY_UNREGISTERED;
    }
}
#end_block

#method_before
public void unregisterNetworkCallback(PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    releaseNetworkRequest(operation);
}
#method_after
public void unregisterNetworkCallback(@NonNull PendingIntent operation) {
    checkPendingIntentNotNull(operation);
    releaseNetworkRequest(operation);
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    try {
        mService.setAcceptUnvalidated(network, accept, always);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.NETWORK_SETTINGS)
public void setAcceptUnvalidated(Network network, boolean accept, boolean always) {
    try {
        mService.setAcceptUnvalidated(network, accept, always);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public void setAvoidUnvalidated(Network network) {
    try {
        mService.setAvoidUnvalidated(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.NETWORK_SETTINGS)
public void setAvoidUnvalidated(Network network) {
    try {
        mService.setAvoidUnvalidated(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public void startCaptivePortalApp(Network network) {
    try {
        mService.startCaptivePortalApp(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@SystemApi
@TestApi
@RequiresPermission(NetworkStack.PERMISSION_MAINLINE_NETWORK_STACK)
public void startCaptivePortalApp(Network network, Bundle appExtras) {
    try {
        mService.startCaptivePortalAppInternal(network, appExtras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@MultipathPreference
public int getMultipathPreference(Network network) {
    try {
        return mService.getMultipathPreference(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@MultipathPreference
public int getMultipathPreference(@Nullable Network network) {
    try {
        return mService.getMultipathPreference(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public boolean bindProcessToNetwork(Network network) {
    // instantiated.
    return setProcessDefaultNetwork(network);
}
#method_after
public boolean bindProcessToNetwork(@Nullable Network network) {
    // instantiated.
    return setProcessDefaultNetwork(network);
}
#end_block

#method_before
@Deprecated
public static boolean setProcessDefaultNetwork(Network network) {
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getBoundNetworkForProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, "Can't set proxy properties", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
#method_after
@Deprecated
public static boolean setProcessDefaultNetwork(@Nullable Network network) {
    int netId = (network == null) ? NETID_UNSET : network.netId;
    boolean isSameNetId = (netId == NetworkUtils.getBoundNetworkForProcess());
    if (netId != NETID_UNSET) {
        netId = network.getNetIdForResolv();
    }
    if (!NetworkUtils.bindProcessToNetwork(netId)) {
        return false;
    }
    if (!isSameNetId) {
        // TODO: Deprecate this static method and replace it with a non-static version.
        try {
            Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        } catch (SecurityException e) {
            // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
            Log.e(TAG, "Can't set proxy properties", e);
        }
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
    }
    return true;
}
#end_block

#method_before
public Network getBoundNetworkForProcess() {
    // instantiated.
    return getProcessDefaultNetwork();
}
#method_after
@Nullable
public Network getBoundNetworkForProcess() {
    // instantiated.
    return getProcessDefaultNetwork();
}
#end_block

#method_before
@Deprecated
public static Network getProcessDefaultNetwork() {
    int netId = NetworkUtils.getBoundNetworkForProcess();
    if (netId == NETID_UNSET)
        return null;
    return new Network(netId);
}
#method_after
@Deprecated
@Nullable
public static Network getProcessDefaultNetwork() {
    int netId = NetworkUtils.getBoundNetworkForProcess();
    if (netId == NETID_UNSET)
        return null;
    return new Network(netId);
}
#end_block

#method_before
public byte[] getNetworkWatchlistConfigHash() {
    try {
        return mService.getNetworkWatchlistConfigHash();
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to get watchlist config hash");
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Nullable
public byte[] getNetworkWatchlistConfigHash() {
    try {
        return mService.getNetworkWatchlistConfigHash();
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to get watchlist config hash");
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int getConnectionOwnerUid(int protocol, InetSocketAddress local, InetSocketAddress remote) {
    ConnectionInfo connectionInfo = new ConnectionInfo(protocol, local, remote);
    try {
        return mService.getConnectionOwnerUid(connectionInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
public int getConnectionOwnerUid(int protocol, @NonNull InetSocketAddress local, @NonNull InetSocketAddress remote) {
    ConnectionInfo connectionInfo = new ConnectionInfo(protocol, local, remote);
    try {
        return mService.getConnectionOwnerUid(connectionInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void setEntrySummaries(int summariesResId) {
    mSummaries = getContext().getResources().getTextArray(summariesResId);
}
#method_after
public void setEntrySummaries(CharSequence[] summaries) {
    mSummaries = summaries;
}
#end_block

#method_before
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    if (!SubscriptionManager.isValidSubscriptionId(mSubId)) {
        // notifications are posted per-sub-id, so return if current sub-id is invalid
        loge("cannot setNotification on invalid subid mSubId=" + mSubId);
        return;
    }
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    boolean autoCancelCsRejectNotification = false;
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfigForSubId(mPhone.getSubId());
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
            autoCancelCsRejectNotification = bundle.getBoolean(CarrierConfigManager.KEY_AUTO_CANCEL_CS_REJECT_NOTIFICATION, false);
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    final boolean multipleSubscriptions = (((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getPhoneCount() > 1);
    final int simNumber = mSubscriptionController.getSlotIndex(mSubId) + 1;
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode, multipleSubscriptions);
            if (0 == resId) {
                if (autoCancelCsRejectNotification) {
                    if (DBG)
                        log("Cancel the previous notification");
                    notificationManager.cancel(Integer.toString(mSubId), notificationId);
                }
                loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                return;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                // if using the single SIM resource, simNumber will be ignored
                title = context.getString(resId, simNumber);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details + ", subId: " + mSubId);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(Integer.toString(mSubId), notificationId);
    } else {
        boolean show = false;
        if (mSS.isEmergencyOnly() && notifyType == CS_EMERGENCY_ENABLED) {
            // if reg state is emergency only, always show restricted emergency notification.
            show = true;
        } else if (notifyType == CS_REJECT_CAUSE_ENABLED) {
            // always show notification due to CS reject irrespective of service state.
            show = true;
        } else if (mSS.getState() == ServiceState.STATE_IN_SERVICE) {
            // for non in service states, we have system UI and signal bar to indicate limited
            // service. No need to show notification again. This also helps to mitigate the
            // issue if phone go to OOS and camp to other networks and received restricted ind.
            show = true;
        }
        // update restricted state notification for this subId
        if (show) {
            notificationManager.notify(Integer.toString(mSubId), notificationId, mNotification);
        }
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    if (!SubscriptionManager.isValidSubscriptionId(mSubId)) {
        // notifications are posted per-sub-id, so return if current sub-id is invalid
        loge("cannot setNotification on invalid subid mSubId=" + mSubId);
        return;
    }
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    boolean autoCancelCsRejectNotification = false;
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfigForSubId(mPhone.getSubId());
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
            autoCancelCsRejectNotification = bundle.getBoolean(CarrierConfigManager.KEY_AUTO_CANCEL_CS_REJECT_NOTIFICATION, false);
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    final boolean multipleSubscriptions = (((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getPhoneCount() > 1);
    final int simNumber = mSubscriptionController.getSlotIndex(mSubId) + 1;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = multipleSubscriptions ? context.getString(com.android.internal.R.string.RestrictedStateContentMsimTemplate, simNumber) : context.getText(com.android.internal.R.string.RestrictedStateContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode, multipleSubscriptions);
            if (0 == resId) {
                if (autoCancelCsRejectNotification) {
                    notifyType = CS_REJECT_CAUSE_DISABLED;
                } else {
                    loge("setNotification: mRejectCode=" + mRejectCode + " is not handled.");
                    return;
                }
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                // if using the single SIM resource, simNumber will be ignored
                title = context.getString(resId, simNumber);
                details = null;
            }
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details + ", subId: " + mSubId);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setStyle(new Notification.BigTextStyle().bigText(details)).setContentText(details).setChannel(NotificationChannelController.CHANNEL_ID_ALERT).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED || notifyType == CS_REJECT_CAUSE_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(Integer.toString(mSubId), notificationId);
    } else {
        boolean show = false;
        if (mSS.isEmergencyOnly() && notifyType == CS_EMERGENCY_ENABLED) {
            // if reg state is emergency only, always show restricted emergency notification.
            show = true;
        } else if (notifyType == CS_REJECT_CAUSE_ENABLED) {
            // always show notification due to CS reject irrespective of service state.
            show = true;
        } else if (mSS.getState() == ServiceState.STATE_IN_SERVICE) {
            // for non in service states, we have system UI and signal bar to indicate limited
            // service. No need to show notification again. This also helps to mitigate the
            // issue if phone go to OOS and camp to other networks and received restricted ind.
            show = true;
        }
        // update restricted state notification for this subId
        if (show) {
            notificationManager.notify(Integer.toString(mSubId), notificationId, mNotification);
        }
    }
}
#end_block

#method_before
private void requestConnector(@NonNull NetworkStackCallback request) {
    // TODO: PID check.
    final int caller = Binder.getCallingUid();
    if (caller != Process.SYSTEM_UID && !UserHandle.isSameApp(caller, Process.BLUETOOTH_UID) && UserHandle.isSameApp(caller, Process.PHONE_UID)) {
        // Don't even attempt to obtain the connector and give a nice error message
        throw new SecurityException("Only the system server should try to bind to the network stack.");
    }
    if (!mNetworkStackStartRequested) {
        // The network stack is not being started in this process, e.g. this process is not
        // the system server. Get a remote connector registered by the system server.
        final INetworkStackConnector connector = getRemoteConnector();
        synchronized (mPendingNetStackRequests) {
            mConnector = connector;
        }
        request.onNetworkStackConnected(connector);
        return;
    }
    final INetworkStackConnector connector;
    synchronized (mPendingNetStackRequests) {
        connector = mConnector;
        if (connector == null) {
            mPendingNetStackRequests.add(request);
            return;
        }
    }
    request.onNetworkStackConnected(connector);
}
#method_after
private void requestConnector(@NonNull NetworkStackCallback request) {
    // TODO: PID check.
    final int caller = Binder.getCallingUid();
    if (caller != Process.SYSTEM_UID && !UserHandle.isSameApp(caller, Process.BLUETOOTH_UID) && !UserHandle.isSameApp(caller, Process.PHONE_UID)) {
        // Don't even attempt to obtain the connector and give a nice error message
        throw new SecurityException("Only the system server should try to bind to the network stack.");
    }
    if (!mNetworkStackStartRequested) {
        // The network stack is not being started in this process, e.g. this process is not
        // the system server. Get a remote connector registered by the system server.
        final INetworkStackConnector connector = getRemoteConnector();
        synchronized (mPendingNetStackRequests) {
            mConnector = connector;
        }
        request.onNetworkStackConnected(connector);
        return;
    }
    final INetworkStackConnector connector;
    synchronized (mPendingNetStackRequests) {
        connector = mConnector;
        if (connector == null) {
            mPendingNetStackRequests.add(request);
            return;
        }
    }
    request.onNetworkStackConnected(connector);
}
#end_block

#method_before
@Override
public void enter() {
    Message currentMessage = getCurrentMessage();
    Log.i(TAG, "Enter Connected(" + mDevice + "): " + (currentMessage == null ? "null" : messageWhatToString(currentMessage.what)));
    mConnectionState = BluetoothProfile.STATE_CONNECTED;
    removeDeferredMessages(CONNECT);
    broadcastConnectionState(mConnectionState, mLastConnectionState);
    // Upon connected, the audio starts out as stopped
    broadcastAudioState(BluetoothA2dp.STATE_NOT_PLAYING, BluetoothA2dp.STATE_PLAYING);
}
#method_after
@Override
public void enter() {
    Message currentMessage = getCurrentMessage();
    Log.i(TAG, "Enter Connected(" + mDevice + "): " + (currentMessage == null ? "null" : messageWhatToString(currentMessage.what)));
    mConnectionState = BluetoothProfile.STATE_CONNECTED;
    removeDeferredMessages(CONNECT);
    // Each time a device connects, we want to re-check if it supports optional
    // codecs (perhaps it's had a firmware update, etc.) and save that state if
    // it differs from what we had saved before.
    mA2dpService.updateOptionalCodecsSupport(mDevice);
    broadcastConnectionState(mConnectionState, mLastConnectionState);
    // Upon connected, the audio starts out as stopped
    broadcastAudioState(BluetoothA2dp.STATE_NOT_PLAYING, BluetoothA2dp.STATE_PLAYING);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    log("Connected process message(" + mDevice + "): " + messageWhatToString(message.what));
    switch(message.what) {
        case CONNECT:
            Log.w(TAG, "Connected: CONNECT ignored: " + mDevice);
            break;
        case DISCONNECT:
            {
                Log.i(TAG, "Disconnecting from " + mDevice);
                if (!mA2dpNativeInterface.disconnectA2dp(mDevice)) {
                    // If error in the native stack, transition directly to Disconnected state.
                    Log.e(TAG, "Connected: error disconnecting from " + mDevice);
                    transitionTo(mDisconnected);
                    break;
                }
                transitionTo(mDisconnecting);
            }
            break;
        case STACK_EVENT:
            A2dpStackEvent event = (A2dpStackEvent) message.obj;
            log("Connected: stack event: " + event);
            if (!mDevice.equals(event.device)) {
                Log.wtfStack(TAG, "Device(" + mDevice + "): event mismatch: " + event);
            }
            switch(event.type) {
                case A2dpStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(event.valueInt);
                    break;
                case A2dpStackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    processAudioStateEvent(event.valueInt);
                    break;
                case A2dpStackEvent.EVENT_TYPE_CODEC_CONFIG_CHANGED:
                    // Remote selectable codec could be changed if codec config changed
                    // in connected state, we need to re-check optional codec status
                    // for this codec change event.
                    changeCodecConfigAndOptionalStatus(event.codecStatus, true);
                    break;
                default:
                    Log.e(TAG, "Connected: ignoring stack event: " + event);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    log("Connected process message(" + mDevice + "): " + messageWhatToString(message.what));
    switch(message.what) {
        case CONNECT:
            Log.w(TAG, "Connected: CONNECT ignored: " + mDevice);
            break;
        case DISCONNECT:
            {
                Log.i(TAG, "Disconnecting from " + mDevice);
                if (!mA2dpNativeInterface.disconnectA2dp(mDevice)) {
                    // If error in the native stack, transition directly to Disconnected state.
                    Log.e(TAG, "Connected: error disconnecting from " + mDevice);
                    transitionTo(mDisconnected);
                    break;
                }
                transitionTo(mDisconnecting);
            }
            break;
        case STACK_EVENT:
            A2dpStackEvent event = (A2dpStackEvent) message.obj;
            log("Connected: stack event: " + event);
            if (!mDevice.equals(event.device)) {
                Log.wtfStack(TAG, "Device(" + mDevice + "): event mismatch: " + event);
            }
            switch(event.type) {
                case A2dpStackEvent.EVENT_TYPE_CONNECTION_STATE_CHANGED:
                    processConnectionEvent(event.valueInt);
                    break;
                case A2dpStackEvent.EVENT_TYPE_AUDIO_STATE_CHANGED:
                    processAudioStateEvent(event.valueInt);
                    break;
                case A2dpStackEvent.EVENT_TYPE_CODEC_CONFIG_CHANGED:
                    processCodecConfigEvent(event.codecStatus);
                    break;
                default:
                    Log.e(TAG, "Connected: ignoring stack event: " + event);
                    break;
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private void processCodecConfigEvent(BluetoothCodecStatus newCodecStatus) {
    changeCodecConfigAndOptionalStatus(newCodecStatus, false);
}
#method_after
@VisibleForTesting
void processCodecConfigEvent(BluetoothCodecStatus newCodecStatus) {
    BluetoothCodecConfig prevCodecConfig = null;
    BluetoothCodecStatus prevCodecStatus = mCodecStatus;
    synchronized (this) {
        if (mCodecStatus != null) {
            prevCodecConfig = mCodecStatus.getCodecConfig();
        }
        mCodecStatus = newCodecStatus;
    }
    if (DBG) {
        Log.d(TAG, "A2DP Codec Config: " + prevCodecConfig + "->" + newCodecStatus.getCodecConfig());
        for (BluetoothCodecConfig codecConfig : newCodecStatus.getCodecsLocalCapabilities()) {
            Log.d(TAG, "A2DP Codec Local Capability: " + codecConfig);
        }
        for (BluetoothCodecConfig codecConfig : newCodecStatus.getCodecsSelectableCapabilities()) {
            Log.d(TAG, "A2DP Codec Selectable Capability: " + codecConfig);
        }
    }
    if (isConnected() && !sameSelectableCodec(prevCodecStatus, mCodecStatus)) {
        // Remote selectable codec could be changed if codec config changed
        // in connected state, we need to re-check optional codec status
        // for this codec change event.
        mA2dpService.updateOptionalCodecsSupport(mDevice);
    }
    if (mA2dpOffloadEnabled) {
        boolean update = false;
        BluetoothCodecConfig newCodecConfig = mCodecStatus.getCodecConfig();
        if ((prevCodecConfig != null) && (prevCodecConfig.getCodecType() != newCodecConfig.getCodecType())) {
            update = true;
        } else if (!newCodecConfig.sameAudioFeedingParameters(prevCodecConfig)) {
            update = true;
        } else if ((newCodecConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC) && (prevCodecConfig != null) && (prevCodecConfig.getCodecSpecific1() != newCodecConfig.getCodecSpecific1())) {
            update = true;
        }
        if (update) {
            mA2dpService.codecConfigUpdated(mDevice, mCodecStatus, false);
        }
        return;
    }
    boolean sameAudioFeedingParameters = newCodecStatus.getCodecConfig().sameAudioFeedingParameters(prevCodecConfig);
    mA2dpService.codecConfigUpdated(mDevice, mCodecStatus, sameAudioFeedingParameters);
}
#end_block

#method_before
@VisibleForTesting
public void updateOptionalCodecsSupport(BluetoothDevice device) {
    int previousSupport = getSupportsOptionalCodecs(device);
    boolean supportsOptional = false;
    boolean isCapabilitiesReady = false;
    synchronized (mStateMachines) {
        A2dpStateMachine sm = mStateMachines.get(device);
        if (sm == null) {
            return;
        }
        BluetoothCodecStatus codecStatus = sm.getCodecStatus();
        if (codecStatus != null) {
            for (BluetoothCodecConfig config : codecStatus.getCodecsSelectableCapabilities()) {
                if (config.isMandatoryCodec()) {
                    isCapabilitiesReady = true;
                } else {
                    supportsOptional = true;
                }
            }
        }
    }
    if (!isCapabilitiesReady) {
        // SBC is not selectable, it could be caused by the remote device select codec
        // before native finish get codec capabilities. Stop use this codec status as
        // the reference to support/enable optional codec.
        Log.i(TAG, "updateOptionalCodecsSupport: Codec capabilities not ready.");
        return;
    }
    if (previousSupport == BluetoothA2dp.OPTIONAL_CODECS_SUPPORT_UNKNOWN || supportsOptional != (previousSupport == BluetoothA2dp.OPTIONAL_CODECS_SUPPORTED)) {
        setSupportsOptionalCodecs(device, supportsOptional);
    }
    if (supportsOptional) {
        int enabled = getOptionalCodecsEnabled(device);
        switch(enabled) {
            case BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN:
                // Enable optional codec by default.
                setOptionalCodecsEnabled(device, BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED);
            // Fall through intended
            case BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED:
                enableOptionalCodecs(device);
                break;
            case BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED:
                disableOptionalCodecs(device);
                break;
        }
    }
}
#method_after
@VisibleForTesting
public void updateOptionalCodecsSupport(BluetoothDevice device) {
    int previousSupport = getSupportsOptionalCodecs(device);
    boolean supportsOptional = false;
    boolean hasMandatoryCodec = false;
    synchronized (mStateMachines) {
        A2dpStateMachine sm = mStateMachines.get(device);
        if (sm == null) {
            return;
        }
        BluetoothCodecStatus codecStatus = sm.getCodecStatus();
        if (codecStatus != null) {
            for (BluetoothCodecConfig config : codecStatus.getCodecsSelectableCapabilities()) {
                if (config.isMandatoryCodec()) {
                    hasMandatoryCodec = true;
                } else {
                    supportsOptional = true;
                }
            }
        }
    }
    if (!hasMandatoryCodec) {
        // Mandatory codec(SBC) is not selectable. It could be caused by the remote device
        // select codec before native finish get codec capabilities. Stop use this codec
        // status as the reference to support/enable optional codecs.
        Log.i(TAG, "updateOptionalCodecsSupport: Mandatory codec is not selectable.");
        return;
    }
    if (previousSupport == BluetoothA2dp.OPTIONAL_CODECS_SUPPORT_UNKNOWN || supportsOptional != (previousSupport == BluetoothA2dp.OPTIONAL_CODECS_SUPPORTED)) {
        setSupportsOptionalCodecs(device, supportsOptional);
    }
    if (supportsOptional) {
        int enabled = getOptionalCodecsEnabled(device);
        switch(enabled) {
            case BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN:
                // Enable optional codec by default.
                setOptionalCodecsEnabled(device, BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED);
            // Fall through intended
            case BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED:
                enableOptionalCodecs(device);
                break;
            case BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED:
                disableOptionalCodecs(device);
                break;
        }
    }
}
#end_block

#method_before
private void connectionStateChanged(BluetoothDevice device, int fromState, int toState) {
    if ((device == null) || (fromState == toState)) {
        return;
    }
    synchronized (mStateMachines) {
        if (toState == BluetoothProfile.STATE_CONNECTED) {
            // Each time a device connects, we want to re-check if it supports optional
            // codecs (perhaps it's had a firmware update, etc.) and save that state if
            // it differs from what we had saved before.
            updateOptionalCodecsSupport(device);
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.A2DP);
        }
        // Set the active device if only one connected device is supported and it was connected
        if (toState == BluetoothProfile.STATE_CONNECTED && (mMaxConnectedAudioDevices == 1)) {
            setActiveDevice(device);
        }
        // Check if the active device is not connected anymore
        if (isActiveDevice(device) && (fromState == BluetoothProfile.STATE_CONNECTED)) {
            setActiveDevice(null);
        }
        // Check if the device is disconnected - if unbond, remove the state machine
        if (toState == BluetoothProfile.STATE_DISCONNECTED) {
            int bondState = mAdapterService.getBondState(device);
            if (bondState == BluetoothDevice.BOND_NONE) {
                removeStateMachine(device);
            }
        }
    }
}
#method_after
private void connectionStateChanged(BluetoothDevice device, int fromState, int toState) {
    if ((device == null) || (fromState == toState)) {
        return;
    }
    synchronized (mStateMachines) {
        if (toState == BluetoothProfile.STATE_CONNECTED) {
            MetricsLogger.logProfileConnectionEvent(BluetoothMetricsProto.ProfileId.A2DP);
        }
        // Set the active device if only one connected device is supported and it was connected
        if (toState == BluetoothProfile.STATE_CONNECTED && (mMaxConnectedAudioDevices == 1)) {
            setActiveDevice(device);
        }
        // Check if the active device is not connected anymore
        if (isActiveDevice(device) && (fromState == BluetoothProfile.STATE_CONNECTED)) {
            setActiveDevice(null);
        }
        // Check if the device is disconnected - if unbond, remove the state machine
        if (toState == BluetoothProfile.STATE_DISCONNECTED) {
            int bondState = mAdapterService.getBondState(device);
            if (bondState == BluetoothDevice.BOND_NONE) {
                removeStateMachine(device);
            }
        }
    }
}
#end_block

#method_before
void setCodecConfigPreference(BluetoothDevice device, BluetoothCodecStatus codecStatus, BluetoothCodecConfig codecConfig) {
    // change would actually happens.
    if (codecStatus == null) {
        Log.e(TAG, "codecStatus is null");
        return;
    }
    BluetoothCodecConfig priorityCodecConfig = codecConfig;
    BluetoothCodecConfig currentCodecConfig = codecStatus.getCodecConfig();
    BluetoothCodecConfig[] selectableCodecs = codecStatus.getCodecsSelectableCapabilities();
    boolean selectable = false;
    for (BluetoothCodecConfig config : selectableCodecs) {
        selectable = (isCodecConfigSelectable(codecConfig, config) || selectable);
        if (config.getCodecPriority() > priorityCodecConfig.getCodecPriority()) {
            priorityCodecConfig = config;
        }
    }
    if (!selectable) {
        Log.e(TAG, "Codec is not selectable: " + codecConfig.getCodecName());
        return;
    }
    if (priorityCodecConfig.getCodecType() == currentCodecConfig.getCodecType()) {
        if (priorityCodecConfig.sameAudioFeedingParameters(currentCodecConfig)) {
            Log.i(TAG, "setCodecConfigPreference: codec not changed.");
            return;
        }
    } else if (priorityCodecConfig.getCodecPriority() < currentCodecConfig.getCodecPriority()) {
        Log.i(TAG, "setCodecConfigPreference: current codec has highest priority.");
        return;
    }
    BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[1];
    codecConfigArray[0] = codecConfig;
    mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
}
#method_after
void setCodecConfigPreference(BluetoothDevice device, BluetoothCodecStatus codecStatus, BluetoothCodecConfig codecConfig) {
    Objects.requireNonNull(codecStatus);
    // Check whether the codecConfig is selectable for this Bluetooth device.
    BluetoothCodecConfig[] selectableCodecs = codecStatus.getCodecsSelectableCapabilities();
    if (!Arrays.asList(selectableCodecs).stream().anyMatch(codec -> codec.isMandatoryCodec())) {
        // Do not set codec preference to native if the selectableCodecs not contain mandatory
        // codec. The reason could be remote codec negotiation is not completed yet.
        Log.w(TAG, "Cannot find mandatory codec in selectableCodecs.");
        return;
    }
    if (!isCodecConfigSelectable(codecConfig, selectableCodecs)) {
        Log.w(TAG, "Codec is not selectable: " + codecConfig);
        return;
    }
    // Check whether the codecConfig would change current codec config.
    int prioritizedCodecType = getPrioitizedCodecType(codecConfig, selectableCodecs);
    BluetoothCodecConfig currentCodecConfig = codecStatus.getCodecConfig();
    if (prioritizedCodecType == currentCodecConfig.getCodecType() && (currentCodecConfig.getCodecType() != codecConfig.getCodecType() || currentCodecConfig.sameAudioFeedingParameters(codecConfig))) {
        // Same codec with same parameters, no need to send this request to native.
        Log.i(TAG, "setCodecConfigPreference: codec not changed.");
        return;
    }
    BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[1];
    codecConfigArray[0] = codecConfig;
    mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
}
#end_block

#method_before
void enableOptionalCodecs(BluetoothDevice device, BluetoothCodecConfig currentCodecConfig) {
    if (currentCodecConfig != null && !currentCodecConfig.isMandatoryCodec()) {
        Log.d(TAG, "enableOptionalCodecs: already using optional codec");
        return;
    }
    BluetoothCodecConfig[] codecConfigArray = assignCodecConfigPriorities();
    if (codecConfigArray == null) {
        return;
    }
    // Set the mandatory codec's priority to default, and remove the rest
    for (int i = 0; i < codecConfigArray.length; i++) {
        BluetoothCodecConfig codecConfig = codecConfigArray[i];
        if (!codecConfig.isMandatoryCodec()) {
            codecConfigArray[i] = null;
        }
    }
    mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
}
#method_after
void enableOptionalCodecs(BluetoothDevice device, BluetoothCodecConfig currentCodecConfig) {
    if (currentCodecConfig != null && !currentCodecConfig.isMandatoryCodec()) {
        Log.i(TAG, "enableOptionalCodecs: already using optional codec: " + currentCodecConfig.getCodecType());
        return;
    }
    BluetoothCodecConfig[] codecConfigArray = assignCodecConfigPriorities();
    if (codecConfigArray == null) {
        return;
    }
    // Set the mandatory codec's priority to default, and remove the rest
    for (int i = 0; i < codecConfigArray.length; i++) {
        BluetoothCodecConfig codecConfig = codecConfigArray[i];
        if (!codecConfig.isMandatoryCodec()) {
            codecConfigArray[i] = null;
        }
    }
    mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
}
#end_block

#method_before
void disableOptionalCodecs(BluetoothDevice device, BluetoothCodecConfig currentCodecConfig) {
    if (currentCodecConfig != null && currentCodecConfig.isMandatoryCodec()) {
        Log.d(TAG, "disableOptionalCodecs: already using mandatory codec");
        return;
    }
    BluetoothCodecConfig[] codecConfigArray = assignCodecConfigPriorities();
    if (codecConfigArray == null) {
        return;
    }
    // Set the mandatory codec's priority to highest, and remove the rest
    for (int i = 0; i < codecConfigArray.length; i++) {
        BluetoothCodecConfig codecConfig = codecConfigArray[i];
        if (codecConfig.isMandatoryCodec()) {
            codecConfig.setCodecPriority(BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST);
        } else {
            codecConfigArray[i] = null;
        }
    }
    mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
}
#method_after
void disableOptionalCodecs(BluetoothDevice device, BluetoothCodecConfig currentCodecConfig) {
    if (currentCodecConfig != null && currentCodecConfig.isMandatoryCodec()) {
        Log.i(TAG, "disableOptionalCodecs: already using mandatory codec");
        return;
    }
    BluetoothCodecConfig[] codecConfigArray = assignCodecConfigPriorities();
    if (codecConfigArray == null) {
        return;
    }
    // Set the mandatory codec's priority to highest, and remove the rest
    for (int i = 0; i < codecConfigArray.length; i++) {
        BluetoothCodecConfig codecConfig = codecConfigArray[i];
        if (codecConfig.isMandatoryCodec()) {
            codecConfig.setCodecPriority(BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST);
        } else {
            codecConfigArray[i] = null;
        }
    }
    mA2dpNativeInterface.setCodecConfigPreference(device, codecConfigArray);
}
#end_block

#method_before
private static boolean isCodecConfigSelectable(BluetoothCodecConfig codecConfig, BluetoothCodecConfig selectableCodec) {
    if (codecConfig.getCodecType() != selectableCodec.getCodecType()) {
        return false;
    }
    if ((codecConfig.getSampleRate() & selectableCodec.getSampleRate()) == 0) {
        return false;
    }
    if ((codecConfig.getBitsPerSample() & selectableCodec.getBitsPerSample()) == 0) {
        return false;
    }
    if ((codecConfig.getChannelMode() & selectableCodec.getChannelMode()) == 0) {
        return false;
    }
    return true;
}
#method_after
private static boolean isCodecConfigSelectable(BluetoothCodecConfig codecConfig, BluetoothCodecConfig[] selectableCodecs) {
    for (BluetoothCodecConfig config : selectableCodecs) {
        if (codecConfig.getCodecType() == config.getCodecType() && (codecConfig.getSampleRate() & config.getSampleRate()) != 0 && (codecConfig.getBitsPerSample() & config.getBitsPerSample()) != 0 && (codecConfig.getChannelMode() & config.getChannelMode()) != 0) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public void setCodecConfigPreference(BluetoothDevice device, BluetoothCodecConfig codecConfig) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    if (DBG) {
        Log.d(TAG, "setCodecConfigPreference(" + device + "): " + Objects.toString(codecConfig));
    }
    if (device == null) {
        device = mActiveDevice;
    }
    if (device == null) {
        Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
        return;
    }
    if (getSupportsOptionalCodecs(device) != BluetoothA2dp.OPTIONAL_CODECS_SUPPORTED) {
        Log.e(TAG, "Cannot set codec config preference: not supported");
        return;
    }
    mA2dpCodecConfig.setCodecConfigPreference(device, getCodecStatus(device), codecConfig);
}
#method_after
public void setCodecConfigPreference(BluetoothDevice device, BluetoothCodecConfig codecConfig) {
    enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
    if (DBG) {
        Log.d(TAG, "setCodecConfigPreference(" + device + "): " + Objects.toString(codecConfig));
    }
    if (device == null) {
        device = mActiveDevice;
    }
    if (device == null) {
        Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
        return;
    }
    if (getSupportsOptionalCodecs(device) != BluetoothA2dp.OPTIONAL_CODECS_SUPPORTED) {
        Log.e(TAG, "Cannot set codec config preference: not supported");
        return;
    }
    BluetoothCodecStatus codecStatus = getCodecStatus(device);
    if (codecStatus == null) {
        Log.e(TAG, "Codec status is null on " + device);
        return;
    }
    mA2dpCodecConfig.setCodecConfigPreference(device, codecStatus, codecConfig);
}
#end_block

#method_before
private void testSetCodecPreference_parametersChangeCase(int sampleRate, int bitPerSample, boolean invokeNative) {
    BluetoothCodecConfig[] selectableCodecs = new BluetoothCodecConfig[1];
    selectableCodecs[0] = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC, LDAC_PRIORITY_DEFAULT, (BluetoothCodecConfig.SAMPLE_RATE_44100 | BluetoothCodecConfig.SAMPLE_RATE_48000), (BluetoothCodecConfig.BITS_PER_SAMPLE_16 | BluetoothCodecConfig.BITS_PER_SAMPLE_24), BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[1];
    codecConfigArray[0] = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC, LDAC_PRIORITY_DEFAULT, sampleRate, bitPerSample, BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecStatus codecStatus = new BluetoothCodecStatus(mCodecConfigLdac, selectableCodecs, selectableCodecs);
    mA2dpCodecConfig.setCodecConfigPreference(mTestDevice, codecStatus, codecConfigArray[0]);
    verify(mA2dpNativeInterface, times(invokeNative ? 1 : 0)).setCodecConfigPreference(mTestDevice, codecConfigArray);
}
#method_after
private void testSetCodecPreference_parametersChangeCase(int sampleRate, int bitPerSample, boolean invokeNative) {
    BluetoothCodecConfig[] invalidSelectableCodecs = new BluetoothCodecConfig[1];
    invalidSelectableCodecs[0] = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC, LDAC_PRIORITY_DEFAULT, (BluetoothCodecConfig.SAMPLE_RATE_44100 | BluetoothCodecConfig.SAMPLE_RATE_48000), (BluetoothCodecConfig.BITS_PER_SAMPLE_16 | BluetoothCodecConfig.BITS_PER_SAMPLE_24), BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecConfig[] selectableCodecs = new BluetoothCodecConfig[2];
    selectableCodecs[0] = mCodecConfigSbc;
    selectableCodecs[1] = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC, LDAC_PRIORITY_DEFAULT, (BluetoothCodecConfig.SAMPLE_RATE_44100 | BluetoothCodecConfig.SAMPLE_RATE_48000), (BluetoothCodecConfig.BITS_PER_SAMPLE_16 | BluetoothCodecConfig.BITS_PER_SAMPLE_24), BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[1];
    codecConfigArray[0] = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC, LDAC_PRIORITY_DEFAULT, sampleRate, bitPerSample, BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecStatus codecStatus = new BluetoothCodecStatus(mCodecConfigLdac, invalidSelectableCodecs, invalidSelectableCodecs);
    mA2dpCodecConfig.setCodecConfigPreference(mTestDevice, codecStatus, codecConfigArray[0]);
    codecStatus = new BluetoothCodecStatus(mCodecConfigLdac, selectableCodecs, selectableCodecs);
    mA2dpCodecConfig.setCodecConfigPreference(mTestDevice, codecStatus, codecConfigArray[0]);
    verify(mA2dpNativeInterface, times(invokeNative ? 1 : 0)).setCodecConfigPreference(mTestDevice, codecConfigArray);
}
#end_block

#method_before
private void testSetCodecPreference_codecPriorityChangeCase(int newCodecType, int newCodecPriority, int oldCodecType, int oldCodecPriority, boolean invokeNative) {
    BluetoothCodecConfig[] selectableCodecs = new BluetoothCodecConfig[5];
    selectableCodecs[0] = mCodecConfigSbc;
    selectableCodecs[1] = mCodecConfigAac;
    selectableCodecs[2] = mCodecConfigAptx;
    selectableCodecs[3] = mCodecConfigAptxHd;
    selectableCodecs[4] = mCodecConfigLdac;
    BluetoothCodecConfig oldCodecConfig = new BluetoothCodecConfig(oldCodecType, newCodecPriority, BluetoothCodecConfig.SAMPLE_RATE_44100, BluetoothCodecConfig.BITS_PER_SAMPLE_16, BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[1];
    codecConfigArray[0] = new BluetoothCodecConfig(newCodecType, newCodecPriority, BluetoothCodecConfig.SAMPLE_RATE_44100, BluetoothCodecConfig.BITS_PER_SAMPLE_16, BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecStatus codecStatus = new BluetoothCodecStatus(oldCodecConfig, selectableCodecs, selectableCodecs);
    mA2dpCodecConfig.setCodecConfigPreference(mTestDevice, codecStatus, codecConfigArray[0]);
    verify(mA2dpNativeInterface, times(invokeNative ? 1 : 0)).setCodecConfigPreference(mTestDevice, codecConfigArray);
}
#method_after
private void testSetCodecPreference_codecPriorityChangeCase(int newCodecType, int newCodecPriority, int oldCodecType, int oldCodecPriority, boolean invokeNative) {
    BluetoothCodecConfig[] selectableCodecs = new BluetoothCodecConfig[5];
    selectableCodecs[0] = mCodecConfigSbc;
    selectableCodecs[1] = mCodecConfigAac;
    selectableCodecs[2] = mCodecConfigAptx;
    selectableCodecs[3] = mCodecConfigAptxHd;
    selectableCodecs[4] = mCodecConfigLdac;
    BluetoothCodecConfig[] invalidSelectableCodecs = new BluetoothCodecConfig[4];
    invalidSelectableCodecs[0] = mCodecConfigAac;
    invalidSelectableCodecs[1] = mCodecConfigAptx;
    invalidSelectableCodecs[2] = mCodecConfigAptxHd;
    invalidSelectableCodecs[3] = mCodecConfigLdac;
    BluetoothCodecConfig oldCodecConfig = new BluetoothCodecConfig(oldCodecType, oldCodecPriority, BluetoothCodecConfig.SAMPLE_RATE_44100, BluetoothCodecConfig.BITS_PER_SAMPLE_16, BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecConfig[] codecConfigArray = new BluetoothCodecConfig[1];
    codecConfigArray[0] = new BluetoothCodecConfig(newCodecType, newCodecPriority, BluetoothCodecConfig.SAMPLE_RATE_44100, BluetoothCodecConfig.BITS_PER_SAMPLE_16, BluetoothCodecConfig.CHANNEL_MODE_STEREO, 0, 0, 0, // Codec-specific fields
    0);
    BluetoothCodecStatus codecStatus = new BluetoothCodecStatus(oldCodecConfig, invalidSelectableCodecs, invalidSelectableCodecs);
    mA2dpCodecConfig.setCodecConfigPreference(mTestDevice, codecStatus, codecConfigArray[0]);
    codecStatus = new BluetoothCodecStatus(oldCodecConfig, selectableCodecs, selectableCodecs);
    mA2dpCodecConfig.setCodecConfigPreference(mTestDevice, codecStatus, codecConfigArray[0]);
    verify(mA2dpNativeInterface, times(invokeNative ? 1 : 0)).setCodecConfigPreference(mTestDevice, codecConfigArray);
}
#end_block

#method_before
private void initApnContexts() {
    log("initApnContexts: E");
    // Load device network attributes from resources
    String[] networkConfigStrings = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.networkAttributes);
    for (String networkConfigString : networkConfigStrings) {
        NetworkConfig networkConfig = new NetworkConfig(networkConfigString);
        ApnContext apnContext = null;
        switch(networkConfig.type) {
            case TYPE_MOBILE:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_DEFAULT, networkConfig);
                break;
            case TYPE_MOBILE_MMS:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_MMS, networkConfig);
                break;
            case TYPE_MOBILE_SUPL:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_SUPL, networkConfig);
                break;
            case TYPE_MOBILE_DUN:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_DUN, networkConfig);
                break;
            case TYPE_MOBILE_HIPRI:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_HIPRI, networkConfig);
                break;
            case TYPE_MOBILE_FOTA:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_FOTA, networkConfig);
                break;
            case TYPE_MOBILE_IMS:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_IMS, networkConfig);
                break;
            case TYPE_MOBILE_CBS:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_CBS, networkConfig);
                break;
            case TYPE_MOBILE_IA:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_IA, networkConfig);
                break;
            case TYPE_MOBILE_EMERGENCY:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_EMERGENCY, networkConfig);
                break;
            case TYPE_MOBILE_MCX:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_MCX, networkConfig);
                break;
            default:
                log("initApnContexts: skipping unknown type=" + networkConfig.type);
                continue;
        }
        log("initApnContexts: apnContext=" + apnContext);
    }
    if (VDBG)
        log("initApnContexts: X mApnContexts=" + mApnContexts);
}
#method_after
private void initApnContexts() {
    log("initApnContexts: E");
    // Load device network attributes from resources
    String[] networkConfigStrings = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.networkAttributes);
    for (String networkConfigString : networkConfigStrings) {
        NetworkConfig networkConfig = new NetworkConfig(networkConfigString);
        ApnContext apnContext = null;
        switch(networkConfig.type) {
            case NETWORK_TYPE_DEFAULT:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_DEFAULT, networkConfig);
                break;
            case NETWORK_TYPE_MMS:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_MMS, networkConfig);
                break;
            case NETWORK_TYPE_SUPL:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_SUPL, networkConfig);
                break;
            case NETWORK_TYPE_DUN:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_DUN, networkConfig);
                break;
            case NETWORK_TYPE_HIPRI:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_HIPRI, networkConfig);
                break;
            case NETWORK_TYPE_FOTA:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_FOTA, networkConfig);
                break;
            case NETWORK_TYPE_IMS:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_IMS, networkConfig);
                break;
            case NETWORK_TYPE_CBS:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_CBS, networkConfig);
                break;
            case NETWORK_TYPE_IA:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_IA, networkConfig);
                break;
            case NETWORK_TYPE_EMERGENCY:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_EMERGENCY, networkConfig);
                break;
            case NETWORK_TYPE_MCX:
                apnContext = addApnContext(PhoneConstants.APN_TYPE_MCX, networkConfig);
                break;
            default:
                log("initApnContexts: skipping unknown type=" + networkConfig.type);
                continue;
        }
        log("initApnContexts: apnContext=" + apnContext);
    }
    if (VDBG)
        log("initApnContexts: X mApnContexts=" + mApnContexts);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeString(key);
    out.writeString(name);
    out.writeInt(type);
    out.writeString(server);
    out.writeString(username);
    out.writeString(password);
    out.writeString(dnsServers);
    out.writeString(searchDomains);
    out.writeString(routes);
    out.writeInt(mppe ? 1 : 0);
    out.writeString(l2tpSecret);
    out.writeString(ipsecIdentifier);
    out.writeString(ipsecSecret);
    out.writeString(ipsecUserCert);
    out.writeString(ipsecCaCert);
    out.writeString(ipsecServerCert);
    out.writeInt(saveLogin ? 1 : 0);
    // VPN Proxy
    out.writeString(proxyHost);
    out.writeString(proxyPort);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    out.writeString(key);
    out.writeString(name);
    out.writeInt(type);
    out.writeString(server);
    out.writeString(username);
    out.writeString(password);
    out.writeString(dnsServers);
    out.writeString(searchDomains);
    out.writeString(routes);
    out.writeInt(mppe ? 1 : 0);
    out.writeString(l2tpSecret);
    out.writeString(ipsecIdentifier);
    out.writeString(ipsecSecret);
    out.writeString(ipsecUserCert);
    out.writeString(ipsecCaCert);
    out.writeString(ipsecServerCert);
    out.writeInt(saveLogin ? 1 : 0);
    out.writeParcelable(proxy, flags);
}
#end_block

#method_before
public static VpnProfile decode(String key, byte[] value) {
    try {
        if (key == null) {
            return null;
        }
        String[] values = new String(value, StandardCharsets.UTF_8).split("\0", -1);
        // There can be 14 - 17 Bytes in values.length.
        if (values.length < 14 || values.length > 17) {
            return null;
        }
        VpnProfile profile = new VpnProfile(key);
        profile.name = values[0];
        profile.type = Integer.parseInt(values[1]);
        if (profile.type < 0 || profile.type > TYPE_MAX) {
            return null;
        }
        profile.server = values[2];
        profile.username = values[3];
        profile.password = values[4];
        profile.dnsServers = values[5];
        profile.searchDomains = values[6];
        profile.routes = values[7];
        profile.mppe = Boolean.parseBoolean(values[8]);
        profile.l2tpSecret = values[9];
        profile.ipsecIdentifier = values[10];
        profile.ipsecSecret = values[11];
        profile.ipsecUserCert = values[12];
        profile.ipsecCaCert = values[13];
        profile.ipsecServerCert = (values.length > 14) ? values[14] : "";
        profile.proxyHost = (values.length > 15) ? values[15] : "";
        profile.proxyPort = (values.length > 16) ? values[16] : "";
        profile.saveLogin = !profile.username.isEmpty() || !profile.password.isEmpty();
        return profile;
    } catch (Exception e) {
    // ignore
    }
    return null;
}
#method_after
@UnsupportedAppUsage
public static VpnProfile decode(String key, byte[] value) {
    try {
        if (key == null) {
            return null;
        }
        String[] values = new String(value, StandardCharsets.UTF_8).split("\0", -1);
        // There can be 14 - 19 Bytes in values.length.
        if (values.length < 14 || values.length > 19) {
            return null;
        }
        VpnProfile profile = new VpnProfile(key);
        profile.name = values[0];
        profile.type = Integer.parseInt(values[1]);
        if (profile.type < 0 || profile.type > TYPE_MAX) {
            return null;
        }
        profile.server = values[2];
        profile.username = values[3];
        profile.password = values[4];
        profile.dnsServers = values[5];
        profile.searchDomains = values[6];
        profile.routes = values[7];
        profile.mppe = Boolean.parseBoolean(values[8]);
        profile.l2tpSecret = values[9];
        profile.ipsecIdentifier = values[10];
        profile.ipsecSecret = values[11];
        profile.ipsecUserCert = values[12];
        profile.ipsecCaCert = values[13];
        profile.ipsecServerCert = (values.length > 14) ? values[14] : "";
        if (values.length > 15) {
            String host = (values.length > 15) ? values[15] : "";
            String port = (values.length > 16) ? values[16] : "";
            String exclList = (values.length > 17) ? values[17] : "";
            String pacFileUrl = (values.length > 18) ? values[18] : "";
            if (pacFileUrl.isEmpty()) {
                profile.proxy = new ProxyInfo(host, port.isEmpty() ? 0 : Integer.parseInt(port), exclList);
            } else {
                profile.proxy = new ProxyInfo(pacFileUrl);
            }
        }
        // else profle.proxy = null
        profile.saveLogin = !profile.username.isEmpty() || !profile.password.isEmpty();
        return profile;
    } catch (Exception e) {
    // ignore
    }
    return null;
}
#end_block

#method_before
public byte[] encode() {
    StringBuilder builder = new StringBuilder(name);
    builder.append('\0').append(type);
    builder.append('\0').append(server);
    builder.append('\0').append(saveLogin ? username : "");
    builder.append('\0').append(saveLogin ? password : "");
    builder.append('\0').append(dnsServers);
    builder.append('\0').append(searchDomains);
    builder.append('\0').append(routes);
    builder.append('\0').append(mppe);
    builder.append('\0').append(l2tpSecret);
    builder.append('\0').append(ipsecIdentifier);
    builder.append('\0').append(ipsecSecret);
    builder.append('\0').append(ipsecUserCert);
    builder.append('\0').append(ipsecCaCert);
    builder.append('\0').append(ipsecServerCert);
    builder.append('\0').append(proxyHost);
    builder.append('\0').append(proxyPort);
    return builder.toString().getBytes(StandardCharsets.UTF_8);
}
#method_after
public byte[] encode() {
    StringBuilder builder = new StringBuilder(name);
    builder.append('\0').append(type);
    builder.append('\0').append(server);
    builder.append('\0').append(saveLogin ? username : "");
    builder.append('\0').append(saveLogin ? password : "");
    builder.append('\0').append(dnsServers);
    builder.append('\0').append(searchDomains);
    builder.append('\0').append(routes);
    builder.append('\0').append(mppe);
    builder.append('\0').append(l2tpSecret);
    builder.append('\0').append(ipsecIdentifier);
    builder.append('\0').append(ipsecSecret);
    builder.append('\0').append(ipsecUserCert);
    builder.append('\0').append(ipsecCaCert);
    builder.append('\0').append(ipsecServerCert);
    if (proxy != null) {
        builder.append('\0').append(proxy.getHost() != null ? proxy.getHost() : "");
        builder.append('\0').append(proxy.getPort());
        builder.append('\0').append(proxy.getExclusionListAsString() != null ? proxy.getExclusionListAsString() : "");
        builder.append('\0').append(proxy.getPacFileUrl().toString());
    }
    return builder.toString().getBytes(StandardCharsets.UTF_8);
}
#end_block

#method_before
public void updateCapabilities() {
    final Network[] underlyingNetworks = (mConfig != null) ? mConfig.underlyingNetworks : null;
    updateCapabilities(mContext.getSystemService(ConnectivityManager.class), underlyingNetworks, mNetworkCapabilities);
    if (mNetworkAgent != null) {
        mNetworkAgent.sendNetworkCapabilities(mNetworkCapabilities);
    }
}
#method_after
public void updateCapabilities() {
    final Network[] underlyingNetworks = (mConfig != null) ? mConfig.underlyingNetworks : null;
    // Only apps targeting Q and above can explicitly declare themselves as metered.
    final boolean isAlwaysMetered = mIsPackageTargetingAtLeastQ && (mConfig == null || mConfig.isMetered);
    updateCapabilities(mContext.getSystemService(ConnectivityManager.class), underlyingNetworks, mNetworkCapabilities, isAlwaysMetered);
    if (mNetworkAgent != null) {
        mNetworkAgent.sendNetworkCapabilities(mNetworkCapabilities);
    }
}
#end_block

#method_before
@VisibleForTesting
public static void updateCapabilities(ConnectivityManager cm, Network[] underlyingNetworks, NetworkCapabilities caps) {
    int[] transportTypes = new int[] { NetworkCapabilities.TRANSPORT_VPN };
    int downKbps = NetworkCapabilities.LINK_BANDWIDTH_UNSPECIFIED;
    int upKbps = NetworkCapabilities.LINK_BANDWIDTH_UNSPECIFIED;
    boolean metered = false;
    boolean roaming = false;
    boolean congested = false;
    boolean hadUnderlyingNetworks = false;
    if (null != underlyingNetworks) {
        for (Network underlying : underlyingNetworks) {
            final NetworkCapabilities underlyingCaps = cm.getNetworkCapabilities(underlying);
            if (underlyingCaps == null)
                continue;
            hadUnderlyingNetworks = true;
            for (int underlyingType : underlyingCaps.getTransportTypes()) {
                transportTypes = ArrayUtils.appendInt(transportTypes, underlyingType);
            }
            // When we have multiple networks, we have to assume the
            // worst-case link speed and restrictions.
            downKbps = NetworkCapabilities.minBandwidth(downKbps, underlyingCaps.getLinkDownstreamBandwidthKbps());
            upKbps = NetworkCapabilities.minBandwidth(upKbps, underlyingCaps.getLinkUpstreamBandwidthKbps());
            metered |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_METERED);
            roaming |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_ROAMING);
            congested |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_CONGESTED);
        }
    }
    if (!hadUnderlyingNetworks) {
        // No idea what the underlying networks are; assume sane defaults
        metered = true;
        roaming = false;
        congested = false;
    }
    caps.setTransportTypes(transportTypes);
    caps.setLinkDownstreamBandwidthKbps(downKbps);
    caps.setLinkUpstreamBandwidthKbps(upKbps);
    caps.setCapability(NET_CAPABILITY_NOT_METERED, !metered);
    caps.setCapability(NET_CAPABILITY_NOT_ROAMING, !roaming);
    caps.setCapability(NET_CAPABILITY_NOT_CONGESTED, !congested);
}
#method_after
@VisibleForTesting
public static void updateCapabilities(ConnectivityManager cm, Network[] underlyingNetworks, NetworkCapabilities caps, boolean isAlwaysMetered) {
    int[] transportTypes = new int[] { NetworkCapabilities.TRANSPORT_VPN };
    int downKbps = NetworkCapabilities.LINK_BANDWIDTH_UNSPECIFIED;
    int upKbps = NetworkCapabilities.LINK_BANDWIDTH_UNSPECIFIED;
    // VPN's meteredness is OR'd with isAlwaysMetered and meteredness of its underlying
    // networks.
    boolean metered = isAlwaysMetered;
    boolean roaming = false;
    boolean congested = false;
    boolean hadUnderlyingNetworks = false;
    if (null != underlyingNetworks) {
        for (Network underlying : underlyingNetworks) {
            final NetworkCapabilities underlyingCaps = cm.getNetworkCapabilities(underlying);
            if (underlyingCaps == null)
                continue;
            hadUnderlyingNetworks = true;
            for (int underlyingType : underlyingCaps.getTransportTypes()) {
                transportTypes = ArrayUtils.appendInt(transportTypes, underlyingType);
            }
            // When we have multiple networks, we have to assume the
            // worst-case link speed and restrictions.
            downKbps = NetworkCapabilities.minBandwidth(downKbps, underlyingCaps.getLinkDownstreamBandwidthKbps());
            upKbps = NetworkCapabilities.minBandwidth(upKbps, underlyingCaps.getLinkUpstreamBandwidthKbps());
            metered |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_METERED);
            roaming |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_ROAMING);
            congested |= !underlyingCaps.hasCapability(NET_CAPABILITY_NOT_CONGESTED);
        }
    }
    if (!hadUnderlyingNetworks) {
        // No idea what the underlying networks are; assume sane defaults
        metered = true;
        roaming = false;
        congested = false;
    }
    caps.setTransportTypes(transportTypes);
    caps.setLinkDownstreamBandwidthKbps(downKbps);
    caps.setLinkUpstreamBandwidthKbps(upKbps);
    caps.setCapability(NET_CAPABILITY_NOT_METERED, !metered);
    caps.setCapability(NET_CAPABILITY_NOT_ROAMING, !roaming);
    caps.setCapability(NET_CAPABILITY_NOT_CONGESTED, !congested);
}
#end_block

#method_before
public synchronized boolean setAlwaysOnPackage(String packageName, boolean lockdown) {
    enforceControlPermissionOrInternalCaller();
    if (setAlwaysOnPackageInternal(packageName, lockdown)) {
        saveAlwaysOnPackage();
        return true;
    }
    return false;
}
#method_after
public synchronized boolean setAlwaysOnPackage(String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    enforceControlPermissionOrInternalCaller();
    if (setAlwaysOnPackageInternal(packageName, lockdown, lockdownWhitelist)) {
        saveAlwaysOnPackage();
        return true;
    }
    return false;
}
#end_block

#method_before
@GuardedBy("this")
private boolean setAlwaysOnPackageInternal(String packageName, boolean lockdown) {
    if (VpnConfig.LEGACY_VPN.equals(packageName)) {
        Log.w(TAG, "Not setting legacy VPN \"" + packageName + "\" as always-on.");
        return false;
    }
    if (packageName != null) {
        // Pre-authorize new always-on VPN package.
        if (!setPackageAuthorization(packageName, true)) {
            return false;
        }
        mAlwaysOn = true;
    } else {
        packageName = VpnConfig.LEGACY_VPN;
        mAlwaysOn = false;
    }
    mLockdown = (mAlwaysOn && lockdown);
    if (isCurrentPreparedPackage(packageName)) {
        updateAlwaysOnNotification(mNetworkInfo.getDetailedState());
    } else {
        // Prepare this app. The notification will update as a side-effect of updateState().
        prepareInternal(packageName);
    }
    maybeRegisterPackageChangeReceiverLocked(packageName);
    setVpnForcedLocked(mLockdown);
    return true;
}
#method_after
@GuardedBy("this")
private boolean setAlwaysOnPackageInternal(String packageName, boolean lockdown, List<String> lockdownWhitelist) {
    if (VpnConfig.LEGACY_VPN.equals(packageName)) {
        Log.w(TAG, "Not setting legacy VPN \"" + packageName + "\" as always-on.");
        return false;
    }
    if (lockdownWhitelist != null) {
        for (String pkg : lockdownWhitelist) {
            if (pkg.contains(",")) {
                Log.w(TAG, "Not setting always-on vpn, invalid whitelisted package: " + pkg);
                return false;
            }
        }
    }
    if (packageName != null) {
        // Pre-authorize new always-on VPN package.
        if (!setPackageAuthorization(packageName, true)) {
            return false;
        }
        mAlwaysOn = true;
    } else {
        packageName = VpnConfig.LEGACY_VPN;
        mAlwaysOn = false;
    }
    mLockdown = (mAlwaysOn && lockdown);
    mLockdownWhitelist = (mLockdown && lockdownWhitelist != null) ? Collections.unmodifiableList(new ArrayList<>(lockdownWhitelist)) : Collections.emptyList();
    if (isCurrentPreparedPackage(packageName)) {
        updateAlwaysOnNotification(mNetworkInfo.getDetailedState());
        setVpnForcedLocked(mLockdown);
    } else {
        // Prepare this app. The notification will update as a side-effect of updateState().
        // It also calls setVpnForcedLocked().
        prepareInternal(packageName);
    }
    return true;
}
#end_block

#method_before
@GuardedBy("this")
private void saveAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, getAlwaysOnPackage(), mUserHandle);
        mSystemServices.settingsSecurePutIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, (mAlwaysOn && mLockdown ? 1 : 0), mUserHandle);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@GuardedBy("this")
private void saveAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, getAlwaysOnPackage(), mUserHandle);
        mSystemServices.settingsSecurePutIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, (mAlwaysOn && mLockdown ? 1 : 0), mUserHandle);
        mSystemServices.settingsSecurePutStringForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN_WHITELIST, String.join(",", mLockdownWhitelist), mUserHandle);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
@GuardedBy("this")
private void loadAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        final String alwaysOnPackage = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, mUserHandle);
        final boolean alwaysOnLockdown = mSystemServices.settingsSecureGetIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, 0, /*default*/
        mUserHandle) != 0;
        setAlwaysOnPackageInternal(alwaysOnPackage, alwaysOnLockdown);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@GuardedBy("this")
private void loadAlwaysOnPackage() {
    final long token = Binder.clearCallingIdentity();
    try {
        final String alwaysOnPackage = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_APP, mUserHandle);
        final boolean alwaysOnLockdown = mSystemServices.settingsSecureGetIntForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN, 0, /*default*/
        mUserHandle) != 0;
        final String whitelistString = mSystemServices.settingsSecureGetStringForUser(Settings.Secure.ALWAYS_ON_VPN_LOCKDOWN_WHITELIST, mUserHandle);
        final List<String> whitelistedPackages = TextUtils.isEmpty(whitelistString) ? Collections.emptyList() : Arrays.asList(whitelistString.split(","));
        setAlwaysOnPackageInternal(alwaysOnPackage, alwaysOnLockdown, whitelistedPackages);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
public boolean startAlwaysOnVpn() {
    final String alwaysOnPackage;
    synchronized (this) {
        alwaysOnPackage = getAlwaysOnPackage();
        // Skip if there is no service to start.
        if (alwaysOnPackage == null) {
            return true;
        }
        // Remove always-on VPN if it's not supported.
        if (!isAlwaysOnPackageSupported(alwaysOnPackage)) {
            setAlwaysOnPackage(null, false);
            return false;
        }
        // which may restart the connection.
        if (getNetworkInfo().isConnected()) {
            return true;
        }
    }
    // Tell the OS that background services in this app need to be allowed for
    // a short time, so we can bootstrap the VPN service.
    final long oldId = Binder.clearCallingIdentity();
    try {
        DeviceIdleController.LocalService idleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        idleController.addPowerSaveTempWhitelistApp(Process.myUid(), alwaysOnPackage, VPN_LAUNCH_IDLE_WHITELIST_DURATION_MS, mUserHandle, false, "vpn");
        // Start the VPN service declared in the app's manifest.
        Intent serviceIntent = new Intent(VpnConfig.SERVICE_INTERFACE);
        serviceIntent.setPackage(alwaysOnPackage);
        try {
            return mContext.startServiceAsUser(serviceIntent, UserHandle.of(mUserHandle)) != null;
        } catch (RuntimeException e) {
            Log.e(TAG, "VpnService " + serviceIntent + " failed to start", e);
            return false;
        }
    } finally {
        Binder.restoreCallingIdentity(oldId);
    }
}
#method_after
public boolean startAlwaysOnVpn() {
    final String alwaysOnPackage;
    synchronized (this) {
        alwaysOnPackage = getAlwaysOnPackage();
        // Skip if there is no service to start.
        if (alwaysOnPackage == null) {
            return true;
        }
        // Remove always-on VPN if it's not supported.
        if (!isAlwaysOnPackageSupported(alwaysOnPackage)) {
            setAlwaysOnPackage(null, false, null);
            return false;
        }
        // which may restart the connection.
        if (getNetworkInfo().isConnected()) {
            return true;
        }
    }
    // Tell the OS that background services in this app need to be allowed for
    // a short time, so we can bootstrap the VPN service.
    final long oldId = Binder.clearCallingIdentity();
    try {
        DeviceIdleController.LocalService idleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        idleController.addPowerSaveTempWhitelistApp(Process.myUid(), alwaysOnPackage, VPN_LAUNCH_IDLE_WHITELIST_DURATION_MS, mUserHandle, false, "vpn");
        // Start the VPN service declared in the app's manifest.
        Intent serviceIntent = new Intent(VpnConfig.SERVICE_INTERFACE);
        serviceIntent.setPackage(alwaysOnPackage);
        try {
            return mContext.startServiceAsUser(serviceIntent, UserHandle.of(mUserHandle)) != null;
        } catch (RuntimeException e) {
            Log.e(TAG, "VpnService " + serviceIntent + " failed to start", e);
            return false;
        }
    } finally {
        Binder.restoreCallingIdentity(oldId);
    }
}
#end_block

#method_before
private void prepareInternal(String newPackage) {
    long token = Binder.clearCallingIdentity();
    try {
        // Reset the interface.
        if (mInterface != null) {
            mStatusIntent = null;
            agentDisconnect();
            jniReset(mInterface);
            mInterface = null;
            mNetworkCapabilities.setUids(null);
        }
        // Revoke the connection or stop LegacyVpnRunner.
        if (mConnection != null) {
            try {
                mConnection.mService.transact(IBinder.LAST_CALL_TRANSACTION, Parcel.obtain(), null, IBinder.FLAG_ONEWAY);
            } catch (Exception e) {
            // ignore
            }
            mContext.unbindService(mConnection);
            mConnection = null;
        } else if (mLegacyVpnRunner != null) {
            mLegacyVpnRunner.exit();
            mLegacyVpnRunner = null;
        }
        try {
            mNetd.denyProtect(mOwnerUID);
        } catch (Exception e) {
            Log.wtf(TAG, "Failed to disallow UID " + mOwnerUID + " to call protect() " + e);
        }
        Log.i(TAG, "Switched from " + mPackage + " to " + newPackage);
        mPackage = newPackage;
        mOwnerUID = getAppUid(newPackage, mUserHandle);
        try {
            mNetd.allowProtect(mOwnerUID);
        } catch (Exception e) {
            Log.wtf(TAG, "Failed to allow UID " + mOwnerUID + " to call protect() " + e);
        }
        mConfig = null;
        updateState(DetailedState.IDLE, "prepare");
        setVpnForcedLocked(mLockdown);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
private void prepareInternal(String newPackage) {
    long token = Binder.clearCallingIdentity();
    try {
        // Reset the interface.
        if (mInterface != null) {
            mStatusIntent = null;
            agentDisconnect();
            jniReset(mInterface);
            mInterface = null;
            mNetworkCapabilities.setUids(null);
        }
        // Revoke the connection or stop LegacyVpnRunner.
        if (mConnection != null) {
            try {
                mConnection.mService.transact(IBinder.LAST_CALL_TRANSACTION, Parcel.obtain(), null, IBinder.FLAG_ONEWAY);
            } catch (Exception e) {
            // ignore
            }
            mContext.unbindService(mConnection);
            mConnection = null;
        } else if (mLegacyVpnRunner != null) {
            mLegacyVpnRunner.exit();
            mLegacyVpnRunner = null;
        }
        try {
            mNetd.denyProtect(mOwnerUID);
        } catch (Exception e) {
            Log.wtf(TAG, "Failed to disallow UID " + mOwnerUID + " to call protect() " + e);
        }
        Log.i(TAG, "Switched from " + mPackage + " to " + newPackage);
        mPackage = newPackage;
        mOwnerUID = getAppUid(newPackage, mUserHandle);
        mIsPackageTargetingAtLeastQ = doesPackageTargetAtLeastQ(newPackage);
        try {
            mNetd.allowProtect(mOwnerUID);
        } catch (Exception e) {
            Log.wtf(TAG, "Failed to allow UID " + mOwnerUID + " to call protect() " + e);
        }
        mConfig = null;
        updateState(DetailedState.IDLE, "prepare");
        setVpnForcedLocked(mLockdown);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private LinkProperties makeLinkProperties() {
    boolean allowIPv4 = mConfig.allowIPv4;
    boolean allowIPv6 = mConfig.allowIPv6;
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(mInterface);
    if (mConfig.addresses != null) {
        for (LinkAddress address : mConfig.addresses) {
            lp.addLinkAddress(address);
            allowIPv4 |= address.getAddress() instanceof Inet4Address;
            allowIPv6 |= address.getAddress() instanceof Inet6Address;
        }
    }
    if (mConfig.routes != null) {
        for (RouteInfo route : mConfig.routes) {
            lp.addRoute(route);
            InetAddress address = route.getDestination().getAddress();
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    if (mConfig.dnsServers != null) {
        for (String dnsServer : mConfig.dnsServers) {
            InetAddress address = InetAddress.parseNumericAddress(dnsServer);
            lp.addDnsServer(address);
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    if (!allowIPv4) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet4Address.ANY, 0), RTN_UNREACHABLE));
    }
    if (!allowIPv6) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet6Address.ANY, 0), RTN_UNREACHABLE));
    }
    // Concatenate search domains into a string.
    StringBuilder buffer = new StringBuilder();
    if (mConfig.searchDomains != null) {
        for (String domain : mConfig.searchDomains) {
            buffer.append(domain).append(' ');
        }
    }
    lp.setDomains(buffer.toString().trim());
    return lp;
}
#method_after
private LinkProperties makeLinkProperties() {
    boolean allowIPv4 = mConfig.allowIPv4;
    boolean allowIPv6 = mConfig.allowIPv6;
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(mInterface);
    if (mConfig.addresses != null) {
        for (LinkAddress address : mConfig.addresses) {
            lp.addLinkAddress(address);
            allowIPv4 |= address.getAddress() instanceof Inet4Address;
            allowIPv6 |= address.getAddress() instanceof Inet6Address;
        }
    }
    if (mConfig.routes != null) {
        for (RouteInfo route : mConfig.routes) {
            lp.addRoute(route);
            InetAddress address = route.getDestination().getAddress();
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    if (mConfig.dnsServers != null) {
        for (String dnsServer : mConfig.dnsServers) {
            InetAddress address = InetAddress.parseNumericAddress(dnsServer);
            lp.addDnsServer(address);
            allowIPv4 |= address instanceof Inet4Address;
            allowIPv6 |= address instanceof Inet6Address;
        }
    }
    lp.setHttpProxy(mConfig.proxyInfo);
    if (!allowIPv4) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet4Address.ANY, 0), RTN_UNREACHABLE));
    }
    if (!allowIPv6) {
        lp.addRoute(new RouteInfo(new IpPrefix(Inet6Address.ANY, 0), RTN_UNREACHABLE));
    }
    // Concatenate search domains into a string.
    StringBuilder buffer = new StringBuilder();
    if (mConfig.searchDomains != null) {
        for (String domain : mConfig.searchDomains) {
            buffer.append(domain).append(' ');
        }
    }
    lp.setDomains(buffer.toString().trim());
    return lp;
}
#end_block

#method_before
public synchronized ParcelFileDescriptor establish(VpnConfig config) {
    // Check if the caller is already prepared.
    UserManager mgr = UserManager.get(mContext);
    if (Binder.getCallingUid() != mOwnerUID) {
        return null;
    }
    // Check to ensure consent hasn't been revoked since we were prepared.
    if (!isVpnUserPreConsented(mPackage)) {
        return null;
    }
    // Check if the service is properly declared.
    Intent intent = new Intent(VpnConfig.SERVICE_INTERFACE);
    intent.setClassName(mPackage, config.user);
    long token = Binder.clearCallingIdentity();
    try {
        // Restricted users are not allowed to create VPNs, they are tied to Owner
        UserInfo user = mgr.getUserInfo(mUserHandle);
        if (user.isRestricted()) {
            throw new SecurityException("Restricted users cannot establish VPNs");
        }
        ResolveInfo info = AppGlobals.getPackageManager().resolveService(intent, null, 0, mUserHandle);
        if (info == null) {
            throw new SecurityException("Cannot find " + config.user);
        }
        if (!BIND_VPN_SERVICE.equals(info.serviceInfo.permission)) {
            throw new SecurityException(config.user + " does not require " + BIND_VPN_SERVICE);
        }
    } catch (RemoteException e) {
        throw new SecurityException("Cannot find " + config.user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // Save the old config in case we need to go back.
    VpnConfig oldConfig = mConfig;
    String oldInterface = mInterface;
    Connection oldConnection = mConnection;
    NetworkAgent oldNetworkAgent = mNetworkAgent;
    Set<UidRange> oldUsers = mNetworkCapabilities.getUids();
    // Configure the interface. Abort if any of these steps fails.
    ParcelFileDescriptor tun = ParcelFileDescriptor.adoptFd(jniCreate(config.mtu));
    try {
        String interfaze = jniGetName(tun.getFd());
        // TEMP use the old jni calls until there is support for netd address setting
        StringBuilder builder = new StringBuilder();
        for (LinkAddress address : config.addresses) {
            builder.append(" " + address);
        }
        if (jniSetAddresses(interfaze, builder.toString()) < 1) {
            throw new IllegalArgumentException("At least one address must be specified");
        }
        Connection connection = new Connection();
        if (!mContext.bindServiceAsUser(intent, connection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, new UserHandle(mUserHandle))) {
            throw new IllegalStateException("Cannot bind " + config.user);
        }
        mConnection = connection;
        mInterface = interfaze;
        // Fill more values.
        config.user = mPackage;
        config.interfaze = mInterface;
        config.startTime = SystemClock.elapsedRealtime();
        mConfig = config;
        // parameters. If that fails, disconnect.
        if (oldConfig != null && updateLinkPropertiesInPlaceIfPossible(mNetworkAgent, oldConfig)) {
        // Keep mNetworkAgent unchanged
        } else {
            mNetworkAgent = null;
            updateState(DetailedState.CONNECTING, "establish");
            // Set up forwarding and DNS rules.
            agentConnect();
            // Remove the old tun's user forwarding rules
            // The new tun's user rules have already been added above so they will take over
            // as rules are deleted. This prevents data leakage as the rules are moved over.
            agentDisconnect(oldNetworkAgent);
        }
        if (oldConnection != null) {
            mContext.unbindService(oldConnection);
        }
        if (oldInterface != null && !oldInterface.equals(interfaze)) {
            jniReset(oldInterface);
        }
        try {
            IoUtils.setBlocking(tun.getFileDescriptor(), config.blocking);
        } catch (IOException e) {
            throw new IllegalStateException("Cannot set tunnel's fd as blocking=" + config.blocking, e);
        }
    } catch (RuntimeException e) {
        IoUtils.closeQuietly(tun);
        agentDisconnect();
        // restore old state
        mConfig = oldConfig;
        mConnection = oldConnection;
        mNetworkCapabilities.setUids(oldUsers);
        mNetworkAgent = oldNetworkAgent;
        mInterface = oldInterface;
        throw e;
    }
    Log.i(TAG, "Established by " + config.user + " on " + mInterface);
    return tun;
}
#method_after
public synchronized ParcelFileDescriptor establish(VpnConfig config) {
    // Check if the caller is already prepared.
    UserManager mgr = UserManager.get(mContext);
    if (Binder.getCallingUid() != mOwnerUID) {
        return null;
    }
    // Check to ensure consent hasn't been revoked since we were prepared.
    if (!isVpnUserPreConsented(mPackage)) {
        return null;
    }
    // Check if the service is properly declared.
    Intent intent = new Intent(VpnConfig.SERVICE_INTERFACE);
    intent.setClassName(mPackage, config.user);
    long token = Binder.clearCallingIdentity();
    try {
        // Restricted users are not allowed to create VPNs, they are tied to Owner
        UserInfo user = mgr.getUserInfo(mUserHandle);
        if (user.isRestricted()) {
            throw new SecurityException("Restricted users cannot establish VPNs");
        }
        ResolveInfo info = AppGlobals.getPackageManager().resolveService(intent, null, 0, mUserHandle);
        if (info == null) {
            throw new SecurityException("Cannot find " + config.user);
        }
        if (!BIND_VPN_SERVICE.equals(info.serviceInfo.permission)) {
            throw new SecurityException(config.user + " does not require " + BIND_VPN_SERVICE);
        }
    } catch (RemoteException e) {
        throw new SecurityException("Cannot find " + config.user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // Save the old config in case we need to go back.
    VpnConfig oldConfig = mConfig;
    String oldInterface = mInterface;
    Connection oldConnection = mConnection;
    NetworkAgent oldNetworkAgent = mNetworkAgent;
    Set<UidRange> oldUsers = mNetworkCapabilities.getUids();
    // Configure the interface. Abort if any of these steps fails.
    ParcelFileDescriptor tun = ParcelFileDescriptor.adoptFd(jniCreate(config.mtu));
    try {
        String interfaze = jniGetName(tun.getFd());
        // TEMP use the old jni calls until there is support for netd address setting
        StringBuilder builder = new StringBuilder();
        for (LinkAddress address : config.addresses) {
            builder.append(" " + address);
        }
        if (jniSetAddresses(interfaze, builder.toString()) < 1) {
            throw new IllegalArgumentException("At least one address must be specified");
        }
        Connection connection = new Connection();
        if (!mContext.bindServiceAsUser(intent, connection, Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE, new UserHandle(mUserHandle))) {
            throw new IllegalStateException("Cannot bind " + config.user);
        }
        mConnection = connection;
        mInterface = interfaze;
        // Fill more values.
        config.user = mPackage;
        config.interfaze = mInterface;
        config.startTime = SystemClock.elapsedRealtime();
        mConfig = config;
        // parameters. If that fails, disconnect.
        if (oldConfig != null && updateLinkPropertiesInPlaceIfPossible(mNetworkAgent, oldConfig)) {
        // Keep mNetworkAgent unchanged
        } else {
            mNetworkAgent = null;
            updateState(DetailedState.CONNECTING, "establish");
            // Set up forwarding and DNS rules.
            agentConnect();
            // Remove the old tun's user forwarding rules
            // The new tun's user rules have already been added above so they will take over
            // as rules are deleted. This prevents data leakage as the rules are moved over.
            agentDisconnect(oldNetworkAgent);
        }
        // Set up VPN's capabilities such as meteredness.
        updateCapabilities();
        if (oldConnection != null) {
            mContext.unbindService(oldConnection);
        }
        if (oldInterface != null && !oldInterface.equals(interfaze)) {
            jniReset(oldInterface);
        }
        try {
            IoUtils.setBlocking(tun.getFileDescriptor(), config.blocking);
        } catch (IOException e) {
            throw new IllegalStateException("Cannot set tunnel's fd as blocking=" + config.blocking, e);
        }
    } catch (RuntimeException e) {
        IoUtils.closeQuietly(tun);
        agentDisconnect();
        // restore old state
        mConfig = oldConfig;
        mConnection = oldConnection;
        mNetworkCapabilities.setUids(oldUsers);
        mNetworkAgent = oldNetworkAgent;
        mInterface = oldInterface;
        throw e;
    }
    Log.i(TAG, "Established by " + config.user + " on " + mInterface);
    return tun;
}
#end_block

#method_before
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    unregisterPackageChangeReceiverLocked();
    // Quit any active connections
    agentDisconnect();
}
#method_after
public synchronized void onUserStopped() {
    // Switch off networking lockdown (if it was enabled)
    setLockdown(false);
    mAlwaysOn = false;
    // Quit any active connections
    agentDisconnect();
}
#end_block

#method_before
@GuardedBy("this")
private void setVpnForcedLocked(boolean enforce) {
    final List<String> exemptedPackages = isNullOrLegacyVpn(mPackage) ? null : Collections.singletonList(mPackage);
    final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers);
    Set<UidRange> addedRanges = Collections.emptySet();
    if (enforce) {
        addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */
        null, /* disallowedApplications */
        exemptedPackages);
        removedRanges.removeAll(addedRanges);
        addedRanges.removeAll(mBlockedUsers);
    }
    setAllowOnlyVpnForUids(false, removedRanges);
    setAllowOnlyVpnForUids(true, addedRanges);
}
#method_after
@GuardedBy("this")
private void setVpnForcedLocked(boolean enforce) {
    final List<String> exemptedPackages;
    if (isNullOrLegacyVpn(mPackage)) {
        exemptedPackages = null;
    } else {
        exemptedPackages = new ArrayList<>(mLockdownWhitelist);
        exemptedPackages.add(mPackage);
    }
    final Set<UidRange> removedRanges = new ArraySet<>(mBlockedUsers);
    Set<UidRange> addedRanges = Collections.emptySet();
    if (enforce) {
        addedRanges = createUserAndRestrictedProfilesRanges(mUserHandle, /* allowedApplications */
        null, /* disallowedApplications */
        exemptedPackages);
        // it through (b/69873852).
        for (UidRange range : addedRanges) {
            if (range.start == 0) {
                addedRanges.remove(range);
                if (range.stop != 0) {
                    addedRanges.add(new UidRange(1, range.stop));
                }
            }
        }
        removedRanges.removeAll(addedRanges);
        addedRanges.removeAll(mBlockedUsers);
    }
    setAllowOnlyVpnForUids(false, removedRanges);
    setAllowOnlyVpnForUids(true, addedRanges);
}
#end_block

#method_before
public synchronized boolean isBlockingUid(int uid) {
    if (!mLockdown) {
        return false;
    }
    if (mNetworkInfo.isConnected()) {
        return !appliesToUid(uid);
    } else {
        for (UidRange uidRange : mBlockedUsers) {
            if (uidRange.contains(uid)) {
                return true;
            }
        }
        return false;
    }
}
#method_after
public synchronized boolean isBlockingUid(int uid) {
    if (mNetworkInfo.isConnected()) {
        return !appliesToUid(uid);
    } else {
        for (UidRange uidRange : mBlockedUsers) {
            if (uidRange.contains(uid)) {
                return true;
            }
        }
        return false;
    }
}
#end_block

#method_before
public void startLegacyVpnPrivileged(VpnProfile profile, KeyStore keyStore, LinkProperties egress) {
    UserManager mgr = UserManager.get(mContext);
    UserInfo user = mgr.getUserInfo(mUserHandle);
    if (user.isRestricted() || mgr.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN, new UserHandle(mUserHandle))) {
        throw new SecurityException("Restricted users cannot establish VPNs");
    }
    final RouteInfo ipv4DefaultRoute = findIPv4DefaultRoute(egress);
    final String gateway = ipv4DefaultRoute.getGateway().getHostAddress();
    final String iface = ipv4DefaultRoute.getInterface();
    // Load certificates.
    String privateKey = "";
    String userCert = "";
    String caCert = "";
    String serverCert = "";
    if (!profile.ipsecUserCert.isEmpty()) {
        privateKey = Credentials.USER_PRIVATE_KEY + profile.ipsecUserCert;
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecUserCert);
        userCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecCaCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.CA_CERTIFICATE + profile.ipsecCaCert);
        caCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecServerCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecServerCert);
        serverCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (privateKey == null || userCert == null || caCert == null || serverCert == null) {
        throw new IllegalStateException("Cannot load credentials");
    }
    // Prepare arguments for racoon.
    String[] racoon = null;
    switch(profile.type) {
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
            racoon = new String[] { iface, profile.server, "udppsk", profile.ipsecIdentifier, profile.ipsecSecret, "1701" };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            racoon = new String[] { iface, profile.server, "udprsa", privateKey, userCert, caCert, serverCert, "1701" };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
            racoon = new String[] { iface, profile.server, "xauthpsk", profile.ipsecIdentifier, profile.ipsecSecret, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
            racoon = new String[] { iface, profile.server, "xauthrsa", privateKey, userCert, caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
            racoon = new String[] { iface, profile.server, "hybridrsa", caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
    }
    // Prepare arguments for mtpd.
    String[] mtpd = null;
    switch(profile.type) {
        case VpnProfile.TYPE_PPTP:
            mtpd = new String[] { iface, "pptp", profile.server, "1723", "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400", (profile.mppe ? "+mppe" : "nomppe") };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            mtpd = new String[] { iface, "l2tp", profile.server, "1701", profile.l2tpSecret, "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400" };
            break;
    }
    VpnConfig config = new VpnConfig();
    config.legacy = true;
    config.user = profile.key;
    config.interfaze = iface;
    config.session = profile.name;
    // Add proxy
    config.proxyHost = profile.proxyHost;
    config.proxyPort = profile.proxyPort;
    config.addLegacyRoutes(profile.routes);
    if (!profile.dnsServers.isEmpty()) {
        config.dnsServers = Arrays.asList(profile.dnsServers.split(" +"));
    }
    if (!profile.searchDomains.isEmpty()) {
        config.searchDomains = Arrays.asList(profile.searchDomains.split(" +"));
    }
    startLegacyVpn(config, racoon, mtpd);
}
#method_after
public void startLegacyVpnPrivileged(VpnProfile profile, KeyStore keyStore, LinkProperties egress) {
    UserManager mgr = UserManager.get(mContext);
    UserInfo user = mgr.getUserInfo(mUserHandle);
    if (user.isRestricted() || mgr.hasUserRestriction(UserManager.DISALLOW_CONFIG_VPN, new UserHandle(mUserHandle))) {
        throw new SecurityException("Restricted users cannot establish VPNs");
    }
    final RouteInfo ipv4DefaultRoute = findIPv4DefaultRoute(egress);
    final String gateway = ipv4DefaultRoute.getGateway().getHostAddress();
    final String iface = ipv4DefaultRoute.getInterface();
    // Load certificates.
    String privateKey = "";
    String userCert = "";
    String caCert = "";
    String serverCert = "";
    if (!profile.ipsecUserCert.isEmpty()) {
        privateKey = Credentials.USER_PRIVATE_KEY + profile.ipsecUserCert;
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecUserCert);
        userCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecCaCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.CA_CERTIFICATE + profile.ipsecCaCert);
        caCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (!profile.ipsecServerCert.isEmpty()) {
        byte[] value = keyStore.get(Credentials.USER_CERTIFICATE + profile.ipsecServerCert);
        serverCert = (value == null) ? null : new String(value, StandardCharsets.UTF_8);
    }
    if (privateKey == null || userCert == null || caCert == null || serverCert == null) {
        throw new IllegalStateException("Cannot load credentials");
    }
    // Prepare arguments for racoon.
    String[] racoon = null;
    switch(profile.type) {
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
            racoon = new String[] { iface, profile.server, "udppsk", profile.ipsecIdentifier, profile.ipsecSecret, "1701" };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            racoon = new String[] { iface, profile.server, "udprsa", privateKey, userCert, caCert, serverCert, "1701" };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_PSK:
            racoon = new String[] { iface, profile.server, "xauthpsk", profile.ipsecIdentifier, profile.ipsecSecret, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_XAUTH_RSA:
            racoon = new String[] { iface, profile.server, "xauthrsa", privateKey, userCert, caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
        case VpnProfile.TYPE_IPSEC_HYBRID_RSA:
            racoon = new String[] { iface, profile.server, "hybridrsa", caCert, serverCert, profile.username, profile.password, "", gateway };
            break;
    }
    // Prepare arguments for mtpd.
    String[] mtpd = null;
    switch(profile.type) {
        case VpnProfile.TYPE_PPTP:
            mtpd = new String[] { iface, "pptp", profile.server, "1723", "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400", (profile.mppe ? "+mppe" : "nomppe") };
            break;
        case VpnProfile.TYPE_L2TP_IPSEC_PSK:
        case VpnProfile.TYPE_L2TP_IPSEC_RSA:
            mtpd = new String[] { iface, "l2tp", profile.server, "1701", profile.l2tpSecret, "name", profile.username, "password", profile.password, "linkname", "vpn", "refuse-eap", "nodefaultroute", "usepeerdns", "idle", "1800", "mtu", "1400", "mru", "1400" };
            break;
    }
    VpnConfig config = new VpnConfig();
    config.legacy = true;
    config.user = profile.key;
    config.interfaze = iface;
    config.session = profile.name;
    config.isMetered = false;
    config.proxyInfo = profile.proxy;
    config.addLegacyRoutes(profile.routes);
    if (!profile.dnsServers.isEmpty()) {
        config.dnsServers = Arrays.asList(profile.dnsServers.split(" +"));
    }
    if (!profile.searchDomains.isEmpty()) {
        config.searchDomains = Arrays.asList(profile.searchDomains.split(" +"));
    }
    startLegacyVpn(config, racoon, mtpd);
}
#end_block

#method_before
@Test
public void testHelperReceivesProcessNames() throws Exception {
    Bundle b = new Bundle();
    b.putString(PROCESS_NAMES_KEY, String.format("%s%s%s", TEST_PROCESS_NAME_1, PROCESS_SEPARATOR, TEST_PROCESS_NAME_2));
    mListener = initListener(b);
    mListener.testRunStarted(mRunDesc);
    verify(mShowmapHelper).setUp(TEST_PROCESS_NAME_1, TEST_PROCESS_NAME_2);
}
#method_after
@Test
public void testHelperReceivesProcessNames() throws Exception {
    Bundle b = new Bundle();
    b.putString(PROCESS_NAMES_KEY, "process1" + PROCESS_SEPARATOR + "process2");
    mListener = initListener(b);
    mListener.testRunStarted(mRunDesc);
    verify(mShowmapHelper).setUp("process1", "process2");
}
#end_block

#method_before
@Test
public void equality() {
    RichTextElement element = createSampleElement();
    assertEquals(element, createSampleElement());
    assertNotEquals(element, new RichTextElement.Builder().setImage(TEST_IMAGE).build(""));
    assertNotEquals(element, new RichTextElement.Builder().setImage(null).build(TEST_TEXT));
    assertEquals(element.hashCode(), createSampleElement().hashCode());
}
#method_after
@Test
public void equality() {
    RichTextElement element = createSampleElement();
    assertEquals(element, createSampleElement());
    assertNotEquals(element, new RichTextElement.Builder().setImage(TEST_IMAGE).setText("").build());
    assertNotEquals(element, new RichTextElement.Builder().setImage(null).setText(TEST_TEXT).build());
    assertEquals(element.hashCode(), createSampleElement().hashCode());
}
#end_block

#method_before
public RichTextElement createSampleElement() {
    return new RichTextElement.Builder().setImage(TEST_IMAGE).build(TEST_TEXT);
}
#method_after
public RichTextElement createSampleElement() {
    return new RichTextElement.Builder().setImage(TEST_IMAGE).setText(TEST_TEXT).build();
}
#end_block

#method_before
public Builder setImage(@Nullable ImageReference image) {
    // Note: if new graphic element types are added in the future, this API should enforce
    // that no more than one of them is set at each moment.
    mImage = image;
    return this;
}
#method_after
@NonNull
public Builder setImage(@Nullable ImageReference image) {
    // Note: if new graphic element types are added in the future, this API should enforce
    // that no more than one of them is set at each moment.
    mImage = image;
    return this;
}
#end_block

#method_before
public RichTextElement build(@Nullable String text) {
    return new RichTextElement(Common.nonNullOrEmpty(text), mImage);
}
#method_after
@NonNull
public RichTextElement build() {
    return new RichTextElement(Common.nonNullOrEmpty(mText), mImage);
}
#end_block

#method_before
@Test
public void equality() {
    RichText expected = createSampleRichText();
    RichTextElement element = new RichTextElement.Builder().build(TEST_TEXT);
    assertEquals(expected, createSampleRichText());
    assertNotEquals(expected, new RichText.Builder().build(TEST_TEXT));
    assertNotEquals(expected, new RichText.Builder().addElement(element).addElement(element).build(TEST_TEXT));
    assertEquals(expected.hashCode(), createSampleRichText().hashCode());
}
#method_after
@Test
public void equality() {
    RichText expected = createSampleRichText();
    RichTextElement element = new RichTextElement.Builder().setText(TEST_TEXT_ELEMENT).build();
    assertEquals(expected, createSampleRichText());
    assertNotEquals(expected, new RichText.Builder().build(TEST_TEXT));
    assertNotEquals(expected, new RichText.Builder().addElement(element).addElement(element).build(TEST_TEXT));
    assertEquals(expected.hashCode(), createSampleRichText().hashCode());
}
#end_block

#method_before
public static RichText createSampleRichText() {
    return new RichText.Builder().addElement(new RichTextElement.Builder().build(TEST_TEXT)).build(TEST_TEXT);
}
#method_after
public static RichText createSampleRichText() {
    return new RichText.Builder().addElement(new RichTextElement.Builder().setText(TEST_TEXT_ELEMENT).build()).build(TEST_TEXT);
}
#end_block

