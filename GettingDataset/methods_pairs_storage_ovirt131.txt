339
#method_before
private boolean InsertUniqueId(String message) {
    String uniqueId = message.trim();
    UpdateUniqueId(uniqueId);
    if (VdsInstallHelper.isVdsUnique(_vds.getvds_id(), uniqueId)) {
        log.infoFormat("Installation of {0}. Assigning unique id {1} to Host. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
        _vds.setUniqueId(uniqueId);
        DbFacade.getInstance().getVdsStaticDAO().update(_vds.getStaticData());
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        return true;
    }
    log.errorFormat("Installation of {0}. Host with unique id {1} is already present in system. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
    return false;
}
#method_after
private boolean InsertUniqueId(String message) {
    String uniqueId = message.trim();
    UpdateUniqueId(uniqueId);
    if (VdsInstallHelper.isVdsUnique(_vds.getId(), uniqueId)) {
        log.infoFormat("Installation of {0}. Assigning unique id {1} to Host. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
        _vds.setUniqueId(uniqueId);
        DbFacade.getInstance().getVdsStaticDAO().update(_vds.getStaticData());
        _currentInstallStage = VdsInstallStages.forValue(_currentInstallStage.getValue() + 1);
        return true;
    }
    log.errorFormat("Installation of {0}. Host with unique id {1} is already present in system. (Stage: {2})", _serverName, uniqueId, getCurrentInstallStage());
    return false;
}
#end_block

#method_before
@Override
public int compare(bookmarks o1, bookmarks o2) {
    String name1 = o1.getbookmark_name();
    String name2 = o2.getbookmark_name();
    if (name1 == null || name2 == null) {
        return 0;
    }
    return name1.compareTo(name2);
}
#method_after
@Override
public int compare(bookmarks o1, bookmarks o2) {
    String name1 = o1.getbookmark_name();
    String name2 = o2.getbookmark_name();
    if (name1 == null || name2 == null) {
        throw new IllegalArgumentException("Bookmark name cannot be null");
    }
    return name1.compareTo(name2);
}
#end_block

#method_before
@Override
protected void onLogin(final LoginModel loginModel) {
    // init reports
    ReportInit.getInstance().init();
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // UiCommon login preparation
            Frontend.setLoggedInUser(loginModel.getLoggedUser());
            beforeUiCommonInitEvent(loginModel);
            UiCommonInitEvent.fire(eventBus);
            // UI login actions
            user.onUserLogin(loginModel.getLoggedUser().getUserName());
            clearPassword(loginModel);
        }
    });
}
#method_after
@Override
protected void onLogin(final LoginModel loginModel) {
    // init reports
    ReportInit.getInstance().init();
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ApplicationInit.super.onLogin(loginModel);
        }
    });
}
#end_block

#method_before
public void init() {
    parseReportsXML();
}
#method_after
public void init() {
    AsyncDataProvider.GetRedirectServletReportsPage(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            setReportBaseUrl((String) returnValue);
        }
    }));
    parseReportsXML();
}
#end_block

#method_before
private void checkIfInitFinished() {
    if (xmlInitialized && urlInitialized) {
        // Check if the reports should be enabled in this system
        if (!reportBaseUrl.equals("") && !resourceMap.isEmpty()) {
            setReportsEnabled(true);
        } else {
            setReportsEnabled(false);
        }
        reportsInitEvent.raise(this, null);
    }
}
#method_after
private void checkIfInitFinished() {
    if (xmlInitialized && urlInitialized) {
        // Check if the reports should be enabled in this system
        if (!reportBaseUrl.equals("") && !resourceMap.isEmpty()) {
            setReportsEnabled(true);
        } else {
            setReportsEnabled(false);
        }
        // The initialization process blocks on this event after the login
        reportsInitEvent.raise(this, null);
    }
}
#end_block

#method_before
public Map<String, List<String>> getReportParams() {
    return Collections.unmodifiableMap(reportParams);
}
#method_after
public Map<String, List<String>> getReportParams() {
    return paramsMap.getParameters();
}
#end_block

#method_before
public void setDataCenterID(final String uuid) {
    reportParams.put("P_DataCenter_ID", Collections.singletonList(uuid));
}
#method_after
public void setDataCenterID(final String uuid) {
    paramsMap.setParameter("P_DataCenter_ID", uuid);
}
#end_block

#method_before
public void addDataCenterID(final String uuid) {
    List<String> ids = reportParams.get("P_DataCenter_ID");
    if (ids == null) {
        setDataCenterID(uuid);
    } else {
        ids.add(uuid);
    }
}
#method_after
public void addDataCenterID(final String uuid) {
    paramsMap.addParameter("P_DataCenter_ID", uuid);
}
#end_block

#method_before
public void setPassword(String password) {
    reportParams.put("j_password", Collections.singletonList(password));
}
#method_after
public void setPassword(String password) {
    paramsMap.setParameter("j_password", password);
}
#end_block

#method_before
public void setReportEndDate(String date) {
    reportParams.put("P_End_Date", Collections.singletonList(date));
}
#method_after
public void setReportEndDate(String date) {
    paramsMap.setParameter("P_End_Date", date);
}
#end_block

#method_before
public void setReportStartDate(String date) {
    reportParams.put("P_Start_Date", Collections.singletonList(date));
}
#method_after
public void setReportStartDate(String date) {
    paramsMap.setParameter("P_Start_Date", date);
}
#end_block

#method_before
public void setUser(String user) {
    reportParams.put("j_username", Collections.singletonList(user));
}
#method_after
public void setUser(String user) {
    paramsMap.setParameter("j_username", user);
}
#end_block

#method_before
public void setReportUnit(String uri) {
    reportParams.put("reportUnit", Collections.singletonList(uri));
}
#method_after
public void setReportUnit(String uri) {
    paramsMap.setParameter("reportUnit", uri);
}
#end_block

#method_before
public void setResourceId(String idParamName, String id) {
    reportParams.put(idParamName, Collections.singletonList(id));
}
#method_after
public void setResourceId(String idParamName, String id) {
    paramsMap.setParameter(idParamName, id);
}
#end_block

#method_before
public void addResourceId(String idParamName, String id) {
    List<String> ids = reportParams.get(idParamName);
    if (ids == null) {
        setResourceId(idParamName, id);
    } else {
        ids.add(id);
    }
}
#method_after
public void addResourceId(String idParamName, String id) {
    paramsMap.addParameter(idParamName, id);
}
#end_block

#method_before
@Override
public GridTimer getTimer() {
    if (gettimer() == null) {
        settimer(new GridTimer(getListName()) {

            @Override
            public void execute() {
                performSearch();
            }
        });
        gettimer().setRefreshRate(getConfigurator().getPollingTimerInterval());
    }
    return gettimer();
}
#method_after
@Override
public GridTimer getTimer() {
    if (gettimer() == null) {
        settimer(new GridTimer(getListName()) {

            @Override
            public void execute() {
                logger.info(SearchableListModel.this.getClass().getName() + ": Executing search");
                if (getIsAsync()) {
                    AsyncSearch();
                } else {
                    SyncSearch();
                }
            }
        });
        gettimer().setRefreshRate(getConfigurator().getPollingTimerInterval());
    }
    return gettimer();
}
#end_block

#method_before
@Override
public void refresh() {
    performSearch();
}
#method_after
@Override
public void refresh() {
    getForceRefreshCommand().Execute();
}
#end_block

#method_before
public void SignOut() {
    // Stop search on all list models.
    for (SearchableListModel listModel : getItems()) {
        listModel.EnsureAsyncSearchStopped();
    }
    getEventList().EnsureAsyncSearchStopped();
    getAlertList().EnsureAsyncSearchStopped();
    if (Frontend.getIsUserLoggedIn()) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setHandleFailure(true);
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object ReturnValue) {
                CommonModel commonModel = (CommonModel) model;
                commonModel.setLoggedInUser(null);
                commonModel.getSignedOutEvent().raise(commonModel, EventArgs.Empty);
            }
        };
        Frontend.LogoffAsync(Frontend.getLoggedInUser(), _asyncQuery);
    }
}
#method_after
public void SignOut() {
    // Stop search on all list models.
    for (SearchableListModel listModel : getItems()) {
        listModel.EnsureAsyncSearchStopped();
    }
    getEventList().EnsureAsyncSearchStopped();
    getAlertList().EnsureAsyncSearchStopped();
    getTaskList().EnsureAsyncSearchStopped();
    if (Frontend.getIsUserLoggedIn()) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setHandleFailure(true);
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object model, Object ReturnValue) {
                CommonModel commonModel = (CommonModel) model;
                commonModel.setLoggedInUser(null);
                commonModel.getSignedOutEvent().raise(commonModel, EventArgs.Empty);
            }
        };
        Frontend.LogoffAsync(Frontend.getLoggedInUser(), _asyncQuery);
    }
}
#end_block

#method_before
public Map<String, List<String>> getCommonParams() {
    return Collections.unmodifiableMap(reportParams);
}
#method_after
public Map<String, List<String>> getCommonParams() {
    return htmlParams.getParameters();
}
#end_block

#method_before
public void setDataCenterID(final String uuid) {
    reportParams.put("P_DataCenter_ID", Collections.singletonList(uuid));
}
#method_after
public void setDataCenterID(final String uuid) {
    htmlParams.setParameter("P_DataCenter_ID", uuid);
}
#end_block

#method_before
public void setPassword(String password) {
    reportParams.put("j_password", Collections.singletonList(password));
}
#method_after
public void setPassword(String password) {
    htmlParams.setParameter("j_password", password);
}
#end_block

#method_before
public void setReportEndDate(String date) {
    reportParams.put("P_End_Date", Collections.singletonList(date));
}
#method_after
public void setReportEndDate(String date) {
    htmlParams.setParameter("P_End_Date", date);
}
#end_block

#method_before
public void setReportStartDate(String date) {
    reportParams.put("P_Start_Date", Collections.singletonList(date));
}
#method_after
public void setReportStartDate(String date) {
    htmlParams.setParameter("P_Start_Date", date);
}
#end_block

#method_before
public void setUser(String user) {
    reportParams.put("j_username", Collections.singletonList(user));
}
#method_after
public void setUser(String user) {
    htmlParams.setParameter("j_username", user);
}
#end_block

#method_before
public void setReportUnit(String uri) {
    reportParams.put("reportUnit", Collections.singletonList(uri));
}
#method_after
public void setReportUnit(String uri) {
    htmlParams.setParameter("reportUnit", uri);
}
#end_block

#method_before
public void setResourceId(String idParamName, String id) {
    reportParams.put(idParamName, Collections.singletonList(id));
    lastResourceId = idParamName;
}
#method_after
public void setResourceId(String idParamName, String id) {
    htmlParams.setParameter(idParamName, id);
    lastResourceId = idParamName;
}
#end_block

#method_before
public void addResourceId(String idParamName, String id) {
    List<String> ids = reportParams.get(idParamName);
    if (ids == null) {
        setResourceId(idParamName, id);
    } else {
        ids.add(id);
    }
}
#method_after
public void addResourceId(String idParamName, String id) {
    htmlParams.addParameter(idParamName, id);
}
#end_block

#method_before
public void removeParam(String paramName) {
    reportParams.remove(paramName);
}
#method_after
public void removeParam(String paramName) {
    htmlParams.removeParameter(paramName);
}
#end_block

#method_before
@Test
public void testGetAllForConnection() {
    List<storage_domains> result = dao.getAllForConnection(EXISTING_CONNECTION);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (storage_domains domain : result) {
        assertEquals(EXISTING_STORAGE_POOL_ID, domain.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllForConnection() {
    List<storage_domains> result = dao.getAllForConnection(EXISTING_CONNECTION);
    assertGetAllForStoragePoolResult(result);
}
#end_block

#method_before
@Test
public void testGetAllByStoragePoolAndConnection() {
    List<storage_domains> result = dao.getAllByStoragePoolAndConnection(EXISTING_STORAGE_POOL_ID, EXISTING_CONNECTION);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (storage_domains domain : result) {
        assertEquals(EXISTING_STORAGE_POOL_ID, domain.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllByStoragePoolAndConnection() {
    List<storage_domains> result = dao.getAllByStoragePoolAndConnection(EXISTING_STORAGE_POOL_ID, EXISTING_CONNECTION);
    assertGetAllForStoragePoolResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForStoragePool() {
    List<storage_domains> result = dao.getAllForStoragePool(EXISTING_STORAGE_POOL_ID);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (storage_domains domain : result) {
        assertEquals(EXISTING_STORAGE_POOL_ID, domain.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllForStoragePool() {
    List<storage_domains> result = dao.getAllForStoragePool(EXISTING_STORAGE_POOL_ID);
    assertGetAllForStoragePoolResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForStoragePoolWithPermissionsPrivilegedUser() {
    List<storage_domains> result = dao.getAllForStoragePool(EXISTING_STORAGE_POOL_ID, PRIVILEGED_USER_ID, true);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (storage_domains domain : result) {
        assertEquals(EXISTING_STORAGE_POOL_ID, domain.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllForStoragePoolWithPermissionsPrivilegedUser() {
    List<storage_domains> result = dao.getAllForStoragePool(EXISTING_STORAGE_POOL_ID, PRIVILEGED_USER_ID, true);
    assertGetAllForStoragePoolResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForStoragePoolWithPermissionsDisabledUnprivilegedUser() {
    List<storage_domains> result = dao.getAllForStoragePool(EXISTING_STORAGE_POOL_ID, UNPRIVILEGED_USER_ID, false);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (storage_domains domain : result) {
        assertEquals(EXISTING_STORAGE_POOL_ID, domain.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllForStoragePoolWithPermissionsDisabledUnprivilegedUser() {
    List<storage_domains> result = dao.getAllForStoragePool(EXISTING_STORAGE_POOL_ID, UNPRIVILEGED_USER_ID, false);
    assertGetAllForStoragePoolResult(result);
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    Guid storagePoolID = new Guid(UUID.randomUUID());
    storage_pool expectedResult = mock(storage_pool.class);
    StoragePoolQueryParametersBase paramsMock = getQueryParameters();
    when(paramsMock.getStoragePoolId()).thenReturn(storagePoolID);
    StoragePoolDAO storagePoolDAOMock = mock(StoragePoolDAO.class);
    when(storagePoolDAOMock.get(storagePoolID, getUser().getUserId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getStoragePoolDAO()).thenReturn(storagePoolDAOMock);
    getQuery().executeQueryCommand();
    storage_pool result = (storage_pool) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong storage pool returned", expectedResult, result);
    verify(storagePoolDAOMock, times(1)).get(storagePoolID, getUser().getUserId(), paramsMock.isFiltered());
    verifyNoMoreInteractions(storagePoolDAOMock);
}
#method_after
@Test
public void testExecuteQuery() {
    Guid storagePoolID = new Guid(UUID.randomUUID());
    storage_pool expectedResult = mock(storage_pool.class);
    StoragePoolQueryParametersBase paramsMock = getQueryParameters();
    when(paramsMock.getStoragePoolId()).thenReturn(storagePoolID);
    StoragePoolDAO storagePoolDAOMock = mock(StoragePoolDAO.class);
    when(storagePoolDAOMock.get(storagePoolID, getUser().getUserId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getStoragePoolDAO()).thenReturn(storagePoolDAOMock);
    getQuery().executeQueryCommand();
    storage_pool result = (storage_pool) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong storage pool returned", expectedResult, result);
}
#end_block

#method_before
@Test
public void testGetAllForCluster() {
    List<network> result = dao.getAllForCluster(cluster);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllForCluster() {
    List<network> result = dao.getAllForCluster(cluster);
    assertGetAllForClusterResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForClusterFilteredWithPermissions() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, PRIVILEGED_USER_ID, true);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllForClusterFilteredWithPermissions() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, PRIVILEGED_USER_ID, true);
    assertGetAllForClusterResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForClusterFilteredWithPermissionsNoPermissionsAndNoFilter() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, UNPRIVILEGED_USER_ID, false);
    assertNotNull(result);
    assertFalse(result.isEmpty());
}
#method_after
@Test
public void testGetAllForClusterFilteredWithPermissionsNoPermissionsAndNoFilter() {
    // A use with permissions
    List<network> result = dao.getAllForCluster(cluster, UNPRIVILEGED_USER_ID, false);
    assertGetAllForClusterResult(result);
}
#end_block

#method_before
@Test
public void testGetAllForDataCenter() {
    List<network> result = dao.getAllForDataCenter(datacenter);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (network net : result) {
        assertEquals(datacenter, net.getstorage_pool_id());
    }
}
#method_after
@Test
public void testGetAllForDataCenter() {
    List<network> result = dao.getAllForDataCenter(datacenter);
    assertGetAllForClusterResult(result);
    for (network net : result) {
        assertEquals(datacenter, net.getstorage_pool_id());
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid tryingImage = Guid.Empty;
    Guid vmId = getParameters().getId();
    String drive = getParameters().getDrive();
    DiskImage inactiveDisk = null;
    DiskImage activeDisk = null;
    RefObject<DiskImage> refActive = new RefObject<DiskImage>(activeDisk);
    RefObject<DiskImage> refInactive = new RefObject<DiskImage>(inactiveDisk);
    int count = ImagesHandler.getImagesMappedToDrive(vmId, drive, refActive, refInactive);
    activeDisk = refActive.argvalue;
    inactiveDisk = refInactive.argvalue;
    if ((count == 0 || count > 2 || activeDisk == null || (count == 2 && inactiveDisk == null))) {
        log.warnFormat("Vm {0} images data incorrect", vmId);
        getQueryReturnValue().setReturnValue(new ArrayList<DiskImage>());
    } else {
        if (inactiveDisk != null) {
            tryingImage = activeDisk.getParentId();
        }
        Guid topmostImageGuid = inactiveDisk == null ? activeDisk.getId() : inactiveDisk.getId();
        getQueryReturnValue().setReturnValue(ImagesHandler.getAllImageSnapshots(topmostImageGuid, activeDisk.getit_guid()));
        ((GetAllVmSnapshotsByDriveQueryReturnValue) getQueryReturnValue()).setTryingImage(tryingImage);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid tryingImage = Guid.Empty;
    Guid vmId = getParameters().getId();
    String drive = getParameters().getDrive();
    DiskImage inactiveDisk = null;
    DiskImage activeDisk = null;
    RefObject<DiskImage> refActive = new RefObject<DiskImage>(activeDisk);
    RefObject<DiskImage> refInactive = new RefObject<DiskImage>(inactiveDisk);
    int count = ImagesHandler.getImagesMappedToDrive(vmId, drive, refActive, refInactive);
    activeDisk = refActive.argvalue;
    inactiveDisk = refInactive.argvalue;
    if ((count == 0 || count > 2 || activeDisk == null || (count == 2 && inactiveDisk == null))) {
        log.warnFormat("Vm {0} images data incorrect", vmId);
        getQueryReturnValue().setReturnValue(new ArrayList<DiskImage>());
    } else {
        if (inactiveDisk != null) {
            tryingImage = activeDisk.getParentId();
        }
        Guid topmostImageGuid = inactiveDisk == null ? activeDisk.getId() : inactiveDisk.getId();
        getQueryReturnValue().setReturnValue(ImagesHandler.getAllImageSnapshots(topmostImageGuid, activeDisk.getit_guid()));
        getQueryReturnValue().setTryingImage(tryingImage);
    }
}
#end_block

#method_before
@Test
public void testExecuteQueryCommand() {
    // Mock the parameters
    Guid vmID = new Guid(UUID.randomUUID());
    GetAllDisksByVmIdParameters params = getQueryParameters();
    when(params.getVmId()).thenReturn(vmID);
    // Mock some disks
    DiskImage pluggedDisk = createDiskImage(vmID, true);
    DiskImage unpluggedDisk = createDiskImage(vmID, true);
    DiskImage inactiveDisk = createDiskImage(vmID, false);
    // Mock some devices
    VmDevice pluggedDevice = new VmDevice(new VmDeviceId(pluggedDisk.getId(), vmID), "disk", "disk", "", 1, "", true, true, true);
    // Mock the DAOs
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    // Disk Image DAO
    DiskImageDAO diskImageDAOMock = mock(DiskImageDAO.class);
    when(dbFacadeMock.getDiskImageDAO()).thenReturn(diskImageDAOMock);
    when(diskImageDAOMock.getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Arrays.asList(pluggedDisk, unpluggedDisk, inactiveDisk));
    // VM Device DAO
    VmDeviceDAO vmDeviceDAOMock = mock(VmDeviceDAO.class);
    when(dbFacadeMock.getVmDeviceDAO()).thenReturn(vmDeviceDAOMock);
    when(vmDeviceDAOMock.getVmDeviceByVmIdTypeAndDevice(vmID, "disk", "disk", getUser().getUserId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(pluggedDevice));
    // Image handler
    mockStatic(ImagesHandler.class);
    int numDisks = 3;
    when(ImagesHandler.getAllImageSnapshots(pluggedDisk.getId(), pluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(numDisks, pluggedDisk)));
    when(ImagesHandler.getAllImageSnapshots(unpluggedDisk.getId(), unpluggedDisk.getit_guid())).thenReturn(new ArrayList<DiskImage>(Collections.nCopies(numDisks, unpluggedDisk)));
    GetAllDisksByVmIdQuery<GetAllDisksByVmIdParameters> query = getQuery();
    query.executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<DiskImage> disks = (List<DiskImage>) query.getQueryReturnValue().getReturnValue();
    // Assert the correct disks are returned
    assertTrue("plugged disk should be in the return value", disks.contains(pluggedDisk));
    assertTrue("unplugged disk should be in the return value", disks.contains(unpluggedDisk));
    assertFalse("inactive disk should not be in the return value", disks.contains(inactiveDisk));
    // Assert the disks have the correct snapshots
    for (int i = 0; i < numDisks; ++i) {
        assertEquals("Wrong snapshot " + i + " for plugged disk ", pluggedDisk, pluggedDisk.getSnapshots().get(i));
        assertEquals("Wrong snapshot " + i + " for unplugged disk ", unpluggedDisk, unpluggedDisk.getSnapshots().get(i));
    }
    verify(diskImageDAOMock, times(1)).getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered());
    verify(vmDeviceDAOMock, times(1)).getVmDeviceByVmIdTypeAndDevice(vmID, "disk", "disk", getUser().getUserId(), getQueryParameters().isFiltered());
    verifyNoMoreInteractions(diskImageDAOMock, vmDeviceDAOMock);
}
#method_after
@Test
public void testExecuteQueryCommand() {
    GetAllDisksByVmIdParameters params = getQueryParameters();
    when(params.getVmId()).thenReturn(vmID);
    GetAllDisksByVmIdQuery<GetAllDisksByVmIdParameters> query = getQuery();
    query.executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<DiskImage> disks = (List<DiskImage>) query.getQueryReturnValue().getReturnValue();
    // Assert the correct disks are returned
    assertTrue("plugged disk should be in the return value", disks.contains(pluggedDisk));
    assertTrue("unplugged disk should be in the return value", disks.contains(unpluggedDisk));
    assertFalse("inactive disk should not be in the return value", disks.contains(inactiveDisk));
    // Assert the disks have the correct snapshots
    assertCorrectSnapshots(pluggedDisk);
    assertCorrectSnapshots(unpluggedDisk);
    verify(diskImageDAOMock).getAllForVm(vmID, getUser().getUserId(), getQueryParameters().isFiltered());
    verify(vmDeviceDAOMock).getVmDeviceByVmIdTypeAndDevice(vmID, VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.DISK), getUser().getUserId(), getQueryParameters().isFiltered());
    verifyNoMoreInteractions(diskImageDAOMock, vmDeviceDAOMock);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // LINQ
    // DbFacade.Instance.GetImagesByVmGuid(GetParameters.VmId).Where(image=>image.active
    // == true).ToList();
    List<DiskImage> disks = LinqUtils.filter(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId(), getUserID(), getParameters().isFiltered()), new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return (diskImage.getactive());
        }
    });
    Set<Guid> pluggedDiskIds = getPluggedDiskIds();
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        if (pluggedDiskIds.contains(diskImage.getId())) {
            diskImage.setPlugged(true);
        } else {
            diskImage.setPlugged(false);
        }
    }
    getQueryReturnValue().setReturnValue(disks);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<DiskImage> disks = LinqUtils.filter(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId(), getUserID(), getParameters().isFiltered()), new Predicate<DiskImage>() {

        @Override
        public boolean eval(DiskImage diskImage) {
            return (diskImage.getactive());
        }
    });
    Set<Guid> pluggedDiskIds = getPluggedDiskIds();
    for (DiskImage diskImage : disks) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
        diskImage.setPlugged(pluggedDiskIds.contains(diskImage.getDisk().getId()));
    }
    getQueryReturnValue().setReturnValue(disks);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk");
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk");
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringSetToFlase() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", null, false);
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringSetToFlase() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", null, false);
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, true);
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, true);
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithoutPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", UNPRIVILEGED_USER_ID, true);
    assertEquals("there should only be 0 disks", 0, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithoutPermissions() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", UNPRIVILEGED_USER_ID, true);
    assertTrue("A user without any permissions should not see any devices", devices.isEmpty());
}
#end_block

#method_before
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissionsNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, false);
    assertEquals("there should only be " + TOTAL_DEVICES + " disks", TOTAL_DEVICES, devices.size());
}
#method_after
@Test
public void testGetVmDeviceByVmIdTypeAndDeviceFilteringWithPermissionsNoFiltering() {
    List<VmDevice> devices = dao.getVmDeviceByVmIdTypeAndDevice(EXISTING_VM_ID, "disk", "disk", PRIVILEGED_USER_ID, false);
    assertGetVMDeviceByIdTypeAndDeviceFullResult(devices);
}
#end_block

#method_before
@Test
public void testGetAllForVM() {
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID);
    assertEquals("VM should have two disks", 2, disks.size());
}
#method_after
@Test
public void testGetAllForVM() {
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID);
    assertFullGetAllForVMResult(disks);
}
#end_block

#method_before
@Test
public void testGetAllForVMFilteredWithPermissions() {
    // test user 3 - has permissions
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID, PRIVILEGED_USER_ID, true);
    assertEquals("VM should have two disks", 2, disks.size());
}
#method_after
@Test
public void testGetAllForVMFilteredWithPermissions() {
    // test user 3 - has permissions
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID, PRIVILEGED_USER_ID, true);
    assertFullGetAllForVMResult(disks);
}
#end_block

#method_before
@Test
public void testGetAllForVMFilteredWithPermissionsNoPermissions() {
    // test user 2 - hasn't got permissions
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID, UNPRIVILEGED_USER_ID, true);
    assertEquals("VM should have two disks", 0, disks.size());
}
#method_after
@Test
public void testGetAllForVMFilteredWithPermissionsNoPermissions() {
    // test user 2 - hasn't got permissions
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID, UNPRIVILEGED_USER_ID, true);
    assertTrue("VM should have no disks viewable to the user", disks.isEmpty());
}
#end_block

#method_before
@Test
public void testGetAllForVMFilteredWithPermissionsNoPermissionsAndNoFilter() {
    // test user 2 - hasn't got permissions, but no filtering was requested
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID, UNPRIVILEGED_USER_ID, false);
    assertEquals("VM should have two disks", 2, disks.size());
}
#method_after
@Test
public void testGetAllForVMFilteredWithPermissionsNoPermissionsAndNoFilter() {
    // test user 2 - hasn't got permissions, but no filtering was requested
    List<DiskImage> disks = dao.getAllForVm(EXISTING_VM_ID, UNPRIVILEGED_USER_ID, false);
    assertFullGetAllForVMResult(disks);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testQueryCreation() throws Exception {
    for (VdcQueryType queryType : VdcQueryType.values()) {
        try {
            log.debug("evaluating " + queryType);
            // Get the query's class
            Class<? extends QueriesCommandBase<?>> clazz = (Class<? extends QueriesCommandBase<?>>) Class.forName(queryType.getPackageName() + "." + queryType.name() + "Query");
            // Create a new instance, parameters don't matter
            Constructor<? extends QueriesCommandBase<?>> cons = (Constructor<? extends QueriesCommandBase<?>>) clazz.getConstructors()[0];
            // Construct the parameter array
            Class<?>[] paramTypes = cons.getParameterTypes();
            Object[] params = new Object[paramTypes.length];
            for (int i = 0; i < paramTypes.length; ++i) {
                params[i] = mock(paramTypes[i]);
            }
            QueriesCommandBase<?> query = cons.newInstance(params);
            // get the getQueryType method - note that it's private.
            VdcQueryType type = TestHelperQueriesCommandType.getQueryTypeFieldValue(query);
            assertNotNull("could not find type", type);
            assertFalse("could not find type", type.equals(VdcQueryType.Unknown));
        } catch (ClassNotFoundException ignore) {
            log.debug("skipping");
        } catch (ExceptionInInitializerError ignore) {
            log.debug("skipping");
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testQueryCreation() throws Exception {
    for (VdcQueryType queryType : VdcQueryType.values()) {
        try {
            log.debug("evaluating " + queryType);
            // Get the query's class
            Class<? extends QueriesCommandBase<?>> clazz = (Class<? extends QueriesCommandBase<?>>) Class.forName(queryType.getPackageName() + "." + queryType.name() + "Query");
            // Create a new instance, parameters don't matter
            Constructor<? extends QueriesCommandBase<?>> cons = (Constructor<? extends QueriesCommandBase<?>>) clazz.getConstructors()[0];
            // Construct the parameter array
            Class<?>[] paramTypes = cons.getParameterTypes();
            Object[] params = new Object[paramTypes.length];
            for (int i = 0; i < paramTypes.length; ++i) {
                params[i] = mock(paramTypes[i]);
            }
            QueriesCommandBase<?> query = cons.newInstance(params);
            VdcQueryType type = TestHelperQueriesCommandType.getQueryTypeFieldValue(query);
            assertNotNull("could not find type", type);
            assertFalse("could not find type", type.equals(VdcQueryType.Unknown));
        } catch (ClassNotFoundException ignore) {
            log.debug("skipping");
        } catch (ExceptionInInitializerError ignore) {
            log.debug("skipping");
        }
    }
}
#end_block

#method_before
// TODO: Temporarily commented out until permission checking will be re-enabled, comment this back in when possible
// /** Tests Admin permission check */
// @Test
// public void testPermissionChecking() throws Exception {
// boolean[] booleans = { true, false };
// for (VdcQueryType queryType : VdcQueryType.values()) {
// for (boolean isFiltered : booleans) {
// for (boolean isUserAdmin : booleans) {
// for (boolean isInternalExecution : booleans) {
// boolean shouldBeAbleToRunQuery =
// isInternalExecution || isUserAdmin || (isFiltered && !queryType.isAdmin());
// 
// log.debug("Running on query: " + toString());
// 
// String sessionId = getClass().getSimpleName();
// 
// // Mock parameters
// VdcQueryParametersBase params = mock(VdcQueryParametersBase.class);
// when(params.isFiltered()).thenReturn(isFiltered);
// when(params.getSessionId()).thenReturn(sessionId);
// 
// Guid guid = mock(Guid.class);
// 
// PowerMockito.mockStatic(MultiLevelAdministrationHandler.class);
// when(MultiLevelAdministrationHandler.isAdminUser(guid)).thenReturn(isUserAdmin);
// 
// // Set up the user id env.
// IVdcUser user = mock(IVdcUser.class);
// when(user.getUserId()).thenReturn(guid);
// ThreadLocalParamsContainer.setHttpSessionId(sessionId);
// ThreadLocalParamsContainer.setVdcUser(user);
// 
// // Mock-Set the query as admin/user
// ThereIsNoSuchQuery query = new ThereIsNoSuchQuery(params);
// Field adminQueryField = getQueryTypeField();
// adminQueryField.set(query, queryType);
// 
// query.setInternalExecution(isInternalExecution);
// query.ExecuteCommand();
// assertEquals("Running with type=" + queryType + " isUserAdmin=" + isUserAdmin + " isFiltered="
// + isFiltered + " isInternalExecution=" + isInternalExecution + "\n " +
// "Query should succeed is: ", shouldBeAbleToRunQuery, query.getQueryReturnValue()
// .getSucceeded());
// 
// ThreadLocalParamsContainer.clean();
// SessionDataContainer.getInstance().removeSession();
// }
// }
// }
// }
// }
@Test
public void testGetUserID() {
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(Guid.EVERYONE);
    ThreadLocalParamsContainer.setVdcUser(user);
    ThereIsNoSuchQuery query = new ThereIsNoSuchQuery(new VdcQueryParametersBase());
    assertEquals("wrong guid", Guid.EVERYONE, query.getUserID());
}
#method_after
@Test
public void testGetUserID() {
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(Guid.EVERYONE);
    ThreadLocalParamsContainer.setVdcUser(user);
    ThereIsNoSuchQuery query = new ThereIsNoSuchQuery(new VdcQueryParametersBase());
    assertEquals("wrong guid", Guid.EVERYONE, query.getUserID());
}
#end_block

#method_before
@Test
public void testExectueQuery() {
    DbFacade dbFacadeMock = mock(DbFacade.class);
    mockStatic(DbFacade.class);
    when(DbFacade.getInstance()).thenReturn(dbFacadeMock);
    VmNetworkInterfaceDAO daoMock = mock(VmNetworkInterfaceDAO.class);
    when(dbFacadeMock.getVmNetworkInterfaceDAO()).thenReturn(daoMock);
    Guid guid = new Guid();
    Guid userID = new Guid();
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(userID);
    GetVmByVmIdParameters params = mock(GetVmByVmIdParameters.class);
    when(params.getId()).thenReturn(guid);
    when(params.isFiltered()).thenReturn(true);
    GetVmInterfacesByVmIdQuery query = spy(new GetVmInterfacesByVmIdQuery(params));
    when(query.getUser()).thenReturn(user);
    query.executeQueryCommand();
    verify(daoMock, times(1)).getAllForVm(guid, userID, true);
}
#method_after
@Test
public void testExectueQuery() {
    DbFacade dbFacadeMock = mock(DbFacade.class);
    mockStatic(DbFacade.class);
    when(DbFacade.getInstance()).thenReturn(dbFacadeMock);
    VmNetworkInterfaceDAO daoMock = mock(VmNetworkInterfaceDAO.class);
    when(dbFacadeMock.getVmNetworkInterfaceDAO()).thenReturn(daoMock);
    Guid guid = new Guid();
    Guid userID = new Guid();
    IVdcUser user = mock(IVdcUser.class);
    when(user.getUserId()).thenReturn(userID);
    GetVmByVmIdParameters params = mock(GetVmByVmIdParameters.class);
    when(params.getId()).thenReturn(guid);
    when(params.isFiltered()).thenReturn(true);
    GetVmInterfacesByVmIdQuery query = spy(new GetVmInterfacesByVmIdQuery(params));
    when(query.getUser()).thenReturn(user);
    when(query.getUserID()).thenReturn(userID);
    query.executeQueryCommand();
    verify(daoMock).getAllForVm(guid, userID, true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    // Parameters.EntityId = VmId;
    synchronized (_lockObject) {
        if (// no
        GetVmToAttach(getParameters().getVmPoolId()).equals(Guid.Empty)) // available
        // VMs:
        {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    synchronized (_lockObject) {
        // no available VMs:
        if (GetVmToAttach(getParameters().getVmPoolId()).equals(Guid.Empty)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_AVAILABLE_POOL_VMS);
            returnValue = false;
        }
    }
    // check user isn't already attached to vm from this pool
    if (returnValue) {
        List<VM> vmsForUser = DbFacade.getInstance().getVmDAO().getAllForUser(getAdUserId());
        for (VM vm : vmsForUser) {
            if (vm.getVmPoolId() != null && getVmPoolId().equals(vm.getVmPoolId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_USER_ATTACHED_TO_POOL);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ALLOCATE_AND_RUN);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_FROM_VM_POOL);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    /**
     * TODO: check users throw their groups as well
     */
    initUser();
    synchronized (_lockObject) {
        // check vm is not attached to user and attach
        List<permissions> vmUserPermissions = DbFacade.getInstance().getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.ENGINE_USER.getId(), getVmId());
        if (vmUserPermissions == null || vmUserPermissions.isEmpty()) {
            setVmId(GetVmToAttach(getParameters().getVmPoolId()));
            if (!getVmId().equals(Guid.Empty)) {
                getParameters().setEntityId(getVmId());
                permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), getVmId(), VdcObjectType.VM);
                PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
                permParams.setShouldBeLogged(false);
                permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
                Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, getCompensationContext());
                log.infoFormat("Vm {0} was attached to user {1} ", getVmId(), getAdUserId());
            }
        }
    }
    if (getVmId().equals(Guid.Empty)) {
        log.infoFormat("No free Vms in pool. Cannot allocate for user {1} ", getAdUserId());
        throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
    }
    CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVmId(), "SnapshotForVmFromPool");
    tempVar.setShouldBeLogged(false);
    tempVar.setParentCommand(getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.AttachUserToVmFromPoolAndRun);
    tempVar.setSessionId(getParameters().getSessionId());
    tempVar.setEntityId(getParameters().getEntityId());
    CreateAllSnapshotsFromVmParameters p = tempVar;
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, getCompensationContext());
    getParameters().getImagesParameters().add(p);
    getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    setSucceeded(vdcReturnValue.getSucceeded());
    setActionReturnValue(getVmId());
    getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    /**
     * TODO: check users throw their groups as well
     */
    initUser();
    synchronized (_lockObject) {
        // check vm is not attached to user and attach
        List<permissions> vmUserPermissions = DbFacade.getInstance().getPermissionDAO().getAllForRoleAndObject(PredefinedRoles.ENGINE_USER.getId(), getVmId());
        if (vmUserPermissions == null || vmUserPermissions.isEmpty()) {
            setVmId(GetVmToAttach(getParameters().getVmPoolId()));
            if (!getVmId().equals(Guid.Empty)) {
                getParameters().setEntityId(getVmId());
                permissions perm = new permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), getVmId(), VdcObjectType.VM);
                PermissionsOperationsParametes permParams = new PermissionsOperationsParametes(perm);
                permParams.setShouldBeLogged(false);
                permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
                VdcReturnValueBase vdcReturnValueFromAddPerm = Backend.getInstance().runInternalAction(VdcActionType.AddPermission, permParams, (CommandContext) getCompensationContext());
                if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                    log.infoFormat("Failed to give user {0} permission to Vm {1} ", getAdUserId(), getVmId());
                    setActionReturnValue(vdcReturnValueFromAddPerm);
                    return;
                }
                log.infoFormat("Vm {0} was attached to user {1} ", getVmId(), getAdUserId());
            } else {
                log.infoFormat("No free Vms in pool {0}. Cannot allocate for user {1} ", getVmPoolId(), getAdUserId());
                throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
            }
        }
    }
    CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVmId(), "SnapshotForVmFromPool");
    tempVar.setShouldBeLogged(false);
    tempVar.setParentCommand(getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.AttachUserToVmFromPoolAndRun);
    tempVar.setSessionId(getParameters().getSessionId());
    tempVar.setEntityId(getParameters().getEntityId());
    CreateAllSnapshotsFromVmParameters p = tempVar;
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, (CommandContext) getCompensationContext());
    getParameters().getImagesParameters().add(p);
    getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    setSucceeded(vdcReturnValue.getSucceeded());
    setActionReturnValue(getVmId());
    getReturnValue().getTaskIdList().addAll(getReturnValue().getInternalTaskIdList());
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    if (getVm() != null) {
        // next line is for retrieving the VmPool from the DB
        // so we won't get a log-deadlock because of the transaction.
        vm_pools vmPool = getVmPool();
        if (DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(getVm().getvm_guid()).size() > 0) {
            // From AttachUserToVmAndRunCommand
            Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
            setSucceeded(true);
            if (getSucceeded()) {
                // ParametersCurrentUser =
                // PoolUserParameters.ParametersCurrentUser,
                RunVmParams tempVar = new RunVmParams(getVm().getvm_guid());
                tempVar.setSessionId(getParameters().getSessionId());
                tempVar.setUseVnc(getVm().getvm_type() == VmType.Server);
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, tempVar);
                setSucceeded(vdcReturnValue.getSucceeded());
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            // just in case.
            DetachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    if (getVm() != null) {
        // next line is for retrieving the VmPool from the DB
        // so we won't get a log-deadlock because of the transaction.
        vm_pools vmPool = getVmPool();
        if (DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(getVm().getId()).size() > 0) {
            setSucceeded(Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext()).getSucceeded());
            if (getSucceeded()) {
                // ParametersCurrentUser =
                // PoolUserParameters.ParametersCurrentUser,
                RunVmParams tempVar = new RunVmParams(getVm().getId());
                tempVar.setSessionId(getParameters().getSessionId());
                tempVar.setUseVnc(getVm().getvm_type() == VmType.Server);
                VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RunVm, tempVar);
                setSucceeded(vdcReturnValue.getSucceeded());
            } else {
                log.warn("EndSuccessfully: EndAction of CreateAllSnapshotsFromVm failed, detaching user from Vm");
                // just in case.
                detachUserFromVmFromPool();
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // Pool-snapshot is gone (probably due to ProcessVmPoolOnStopVm
        // treatment) ->
        // no point in running the VM or trying to run again the EndAction
        // method:
        {
            log.warn("EndSuccessfully: No images were created for Vm, detaching user from Vm");
            // just in case.
            detachUserFromVmFromPool();
            getReturnValue().setEndActionTryAgain(false);
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("AttachUserToVmFromPoolAndRunCommand::EndSuccessfully: Vm is null - not performing full EndAction");
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void EndWithFailure() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    // next line is for retrieving the VmPool (and Vm, implicitly) from
    // the DB so we won't get a log-deadlock because of the transaction.
    vm_pools vmPool = getVmPool();
    // From AttachUserToVmAndRunCommand
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
    DetachUserFromVmFromPool();
    setSucceeded(true);
}
#method_after
@Override
protected void EndWithFailure() {
    // we are setting 'Vm' since VmId is overriden and 'Vm' is null
    // (since 'Vm' is dependant on 'mVmId', which is not set here).
    setVm(DbFacade.getInstance().getVmDAO().getById(getVmId()));
    // next line is for retrieving the VmPool (and Vm, implicitly) from
    // the DB so we won't get a log-deadlock because of the transaction.
    vm_pools vmPool = getVmPool();
    // From AttachUserToVmAndRunCommand
    Backend.getInstance().endAction(VdcActionType.CreateAllSnapshotsFromVm, getParameters().getImagesParameters().get(0), getCompensationContext());
    detachUserFromVmFromPool();
    setSucceeded(true);
}
#end_block

#method_before
public void LoadBalance() {
    setAllRelevantVdss(DbFacade.getInstance().getVdsDAO().getAllForVdsGroupWithoutMigrating(getVdsGroup().getID()));
    log.infoFormat("VdsLoadBalancer: number of relevant vdss (no migration, no pending): {0}.", getAllRelevantVdss().size());
    InitOverUtilizedList();
    InitReadyToMigrationList();
    InitUnderUtilizedList();
    if (getOverUtilizedServers().size() != 0 && (getReadyToMigrationServers().size() != 0 || getUnderUtilizedServers().size() != 0)) {
        ProceedOverUtilizedServers();
    }
    if (getUnderUtilizedServers().size() > 0 && (getReadyToMigrationServers().size() > 0 || getUnderUtilizedServers().size() > 1)) {
        ProceedUnderUtilizedServers();
    }
}
#method_after
public void LoadBalance() {
    setAllRelevantVdss(DbFacade.getInstance().getVdsDAO().getAllForVdsGroupWithoutMigrating(getVdsGroup().getId()));
    log.infoFormat("VdsLoadBalancer: number of relevant vdss (no migration, no pending): {0}.", getAllRelevantVdss().size());
    InitOverUtilizedList();
    InitReadyToMigrationList();
    InitUnderUtilizedList();
    if (getOverUtilizedServers().size() != 0 && (getReadyToMigrationServers().size() != 0 || getUnderUtilizedServers().size() != 0)) {
        ProceedOverUtilizedServers();
    }
    if (getUnderUtilizedServers().size() > 0 && (getReadyToMigrationServers().size() > 0 || getUnderUtilizedServers().size() > 1)) {
        ProceedUnderUtilizedServers();
    }
}
#end_block

#method_before
private void ProceedOverUtilizedServers() {
    // LINQ 29456
    // List<int> overUtilizedServersIds =
    // OverUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> overUtilizedServersIds = LinqUtils.foreach(getOverUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getvds_id();
        }
    });
    // LINQ 29456
    for (Guid vdsId : overUtilizedServersIds) {
        VDS vds = getOverUtilizedServers().get(vdsId);
        log.infoFormat("VdsLoadBalancer: Server {0} decided as overutilized", vds.getvds_name());
        java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
        if (vms.size() != 0) {
            /**
             * Get random desktop from under utilized server and try to
             * migrate it to other server
             */
            VM vm = getBestVmToMigrate(vms, vdsId);
            Map<Guid, VDS> currentList = getReadyToMigrationServers();
            /**
             * Try to find server in Ready to Migration list for migrate
             * desktop to
             */
            List<VDS> candidates = GetMigrationCandidates(currentList, vm);
            VDS destinationVds = null;
            if (candidates.isEmpty()) {
                /**
                 * No available server in ReadyToMigrationList Try to find
                 * server from UnderUtilized list for migrate desktop to
                 */
                currentList = getUnderUtilizedServers();
                candidates = GetMigrationCandidates(currentList, vm);
                if (!candidates.isEmpty()) {
                    destinationVds = candidates.get(candidates.size() - 1);
                }
            } else {
                destinationVds = candidates.get(0);
            }
            if (destinationVds == null) {
                log.infoFormat("VdsLoadBalancer: Server {0} detected as overutilized. Failed to found another server to migrate its vms", vds.getvds_name());
            } else {
                Guid destinationVdsId = destinationVds.getvds_id();
                /**
                 * Migrate vm from OverUtilezed server
                 */
                MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                parameters.setShouldBeLogged(false);
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                /**
                 * Remove server from list
                 */
                currentList.remove(destinationVdsId);
                log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from overutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
            }
        } else {
            log.info("VdsLoadBalancer: No vms found to migrate on this server");
        }
    }
}
#method_after
private void ProceedOverUtilizedServers() {
    // LINQ 29456
    // List<int> overUtilizedServersIds =
    // OverUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> overUtilizedServersIds = LinqUtils.foreach(getOverUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getId();
        }
    });
    // LINQ 29456
    for (Guid vdsId : overUtilizedServersIds) {
        VDS vds = getOverUtilizedServers().get(vdsId);
        log.infoFormat("VdsLoadBalancer: Server {0} decided as overutilized", vds.getvds_name());
        java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
        if (vms.size() != 0) {
            /**
             * Get random desktop from under utilized server and try to
             * migrate it to other server
             */
            VM vm = getBestVmToMigrate(vms, vdsId);
            Map<Guid, VDS> currentList = getReadyToMigrationServers();
            /**
             * Try to find server in Ready to Migration list for migrate
             * desktop to
             */
            List<VDS> candidates = GetMigrationCandidates(currentList, vm);
            VDS destinationVds = null;
            if (candidates.isEmpty()) {
                /**
                 * No available server in ReadyToMigrationList Try to find
                 * server from UnderUtilized list for migrate desktop to
                 */
                currentList = getUnderUtilizedServers();
                candidates = GetMigrationCandidates(currentList, vm);
                if (!candidates.isEmpty()) {
                    destinationVds = candidates.get(candidates.size() - 1);
                }
            } else {
                destinationVds = candidates.get(0);
            }
            if (destinationVds == null) {
                log.infoFormat("VdsLoadBalancer: Server {0} detected as overutilized. Failed to found another server to migrate its vms", vds.getvds_name());
            } else {
                Guid destinationVdsId = destinationVds.getId();
                /**
                 * Migrate vm from OverUtilezed server
                 */
                MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                parameters.setShouldBeLogged(false);
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                /**
                 * Remove server from list
                 */
                currentList.remove(destinationVdsId);
                log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from overutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
            }
        } else {
            log.info("VdsLoadBalancer: No vms found to migrate on this server");
        }
    }
}
#end_block

#method_before
private void ProceedUnderUtilizedServers() {
    // LINQ 29456
    // List<int> underUtilizedServersIds =
    // UnderUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> underUtilizedServersIds = LinqUtils.foreach(getUnderUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getvds_id();
        }
    });
    Set<Guid> processed = new HashSet<Guid>();
    for (Guid vdsId : underUtilizedServersIds) {
        if (!processed.contains(vdsId)) {
            VDS vds = getUnderUtilizedServers().get(vdsId);
            java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
            if (vms.size() != 0) {
                VM vm = getBestVmToMigrate(vms, vdsId);
                /**
                 * Get random desktop from under utilized server and try to
                 * migrate it to other server
                 */
                Map<Guid, VDS> currentList = getReadyToMigrationServers();
                List<VDS> candidates = GetMigrationCandidates(currentList, vm);
                VDS destinationVds = null;
                if (candidates.isEmpty()) {
                    /**
                     * Ready to Migrate servers not contain server to
                     * migrate current desktop, Try to find other
                     * UnderUtilized server with maximum count of running
                     * desktops
                     */
                    currentList = getUnderUtilizedServers();
                    final Guid vdsId1 = vdsId;
                    // LINQ 29456
                    // candidates = GetMigrationCandidates(currentList, vm).
                    // Where(a => a.vds_id != vdsId1).
                    // OrderByDescending(a => a.vm_count).ToList();
                    candidates = LinqUtils.filter(GetMigrationCandidates(currentList, vm), new Predicate<VDS>() {

                        @Override
                        public boolean eval(VDS a) {
                            return !a.getvds_id().equals(vdsId1);
                        }
                    });
                    if (!candidates.isEmpty()) {
                        destinationVds = Collections.max(candidates, new Comparator<VDS>() {

                            @Override
                            public int compare(VDS o1, VDS o2) {
                                return o1.getvm_count() - o2.getvm_count();
                            }
                        });
                    }
                } else {
                    destinationVds = candidates.get(0);
                }
                if (destinationVds == null) {
                    log.infoFormat("Server {0} detected as underutilized. Failed to found another server to migrate its vms", vds.getvds_name());
                } else {
                    Guid destinationVdsId = destinationVds.getvds_id();
                    MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                    parameters.setShouldBeLogged(false);
                    Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                    currentList.remove(destinationVdsId);
                    log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from underutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
                    processed.add(destinationVdsId);
                }
            } else {
                log.infoFormat("VdsLoadBalancer: No vms found to migrate on this server {0}", vds.getvds_name());
            }
            // remove the smallest
            getUnderUtilizedServers().remove(vdsId);
        // underutilized vds
        // which was already
        // processed, in
        // order to not
        // passed vm on it
        }
    }
}
#method_after
private void ProceedUnderUtilizedServers() {
    // LINQ 29456
    // List<int> underUtilizedServersIds =
    // UnderUtilizedServers.Values.Select(i => i.vds_id).ToList();
    List<Guid> underUtilizedServersIds = LinqUtils.foreach(getUnderUtilizedServers().values(), new Function<VDS, Guid>() {

        @Override
        public Guid eval(VDS vds) {
            return vds.getId();
        }
    });
    Set<Guid> processed = new HashSet<Guid>();
    for (Guid vdsId : underUtilizedServersIds) {
        if (!processed.contains(vdsId)) {
            VDS vds = getUnderUtilizedServers().get(vdsId);
            java.util.List<VM> vms = getMigrableVmsRunningOnVds(vdsId);
            if (vms.size() != 0) {
                VM vm = getBestVmToMigrate(vms, vdsId);
                /**
                 * Get random desktop from under utilized server and try to
                 * migrate it to other server
                 */
                Map<Guid, VDS> currentList = getReadyToMigrationServers();
                List<VDS> candidates = GetMigrationCandidates(currentList, vm);
                VDS destinationVds = null;
                if (candidates.isEmpty()) {
                    /**
                     * Ready to Migrate servers not contain server to
                     * migrate current desktop, Try to find other
                     * UnderUtilized server with maximum count of running
                     * desktops
                     */
                    currentList = getUnderUtilizedServers();
                    final Guid vdsId1 = vdsId;
                    // LINQ 29456
                    // candidates = GetMigrationCandidates(currentList, vm).
                    // Where(a => a.vds_id != vdsId1).
                    // OrderByDescending(a => a.vm_count).ToList();
                    candidates = LinqUtils.filter(GetMigrationCandidates(currentList, vm), new Predicate<VDS>() {

                        @Override
                        public boolean eval(VDS a) {
                            return !a.getId().equals(vdsId1);
                        }
                    });
                    if (!candidates.isEmpty()) {
                        destinationVds = Collections.max(candidates, new Comparator<VDS>() {

                            @Override
                            public int compare(VDS o1, VDS o2) {
                                return o1.getvm_count() - o2.getvm_count();
                            }
                        });
                    }
                } else {
                    destinationVds = candidates.get(0);
                }
                if (destinationVds == null) {
                    log.infoFormat("Server {0} detected as underutilized. Failed to found another server to migrate its vms", vds.getvds_name());
                } else {
                    Guid destinationVdsId = destinationVds.getId();
                    MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), destinationVdsId);
                    parameters.setShouldBeLogged(false);
                    Backend.getInstance().runInternalAction(VdcActionType.MigrateVmToServer, parameters);
                    currentList.remove(destinationVdsId);
                    log.infoFormat("VdsLoadBalancer: Desktop {0} migrated from underutilized server {1} to server {2}", vm.getvm_name(), vds.getvds_name(), destinationVds.getvds_name());
                    processed.add(destinationVdsId);
                }
            } else {
                log.infoFormat("VdsLoadBalancer: No vms found to migrate on this server {0}", vds.getvds_name());
            }
            // remove the smallest
            getUnderUtilizedServers().remove(vdsId);
        // underutilized vds
        // which was already
        // processed, in
        // order to not
        // passed vm on it
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    boolean retVal;
    // Load images from Import/Export domain
    GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    retVal = qretVal.getSucceeded();
    if (retVal) {
        List<VM> vms = (List) qretVal.getReturnValue();
        VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

            @Override
            public boolean eval(VM vm) {
                return vm.getId().equals(getParameters().getVm().getId());
            }
        });
        if (vm != null) {
            storage_domain_static destinationStorageDomainStatic = getStorageDomainStaticDAO().get(getParameters().getDestDomainId());
            // At this point we should work with the VM that was read from
            // the OVF
            setVm(vm);
            for (DiskImage image : getVm().getImages()) {
                // only if requested by the user
                if (getParameters().getCopyCollapse()) {
                    for (DiskImage p : imageList) {
                        if (p.getId().equals(image.getId())) {
                            if (p.getvolume_format() != null) {
                                image.setvolume_format(p.getvolume_format());
                            }
                            if (p.getvolume_type() != null) {
                                image.setvolume_type(p.getvolume_type());
                            }
                        }
                    }
                }
                retVal = ImagesHandler.CheckImageConfiguration(destinationStorageDomainStatic, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    // we put the source domain id in order that copy will
                    // work
                    // ok
                    // we fix it to DestDomainId in
                    // MoveOrCopyAllImageGroups();
                    image.setstorage_id(getParameters().getSourceDomainId());
                }
            }
            if (retVal) {
                Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                for (String drive : images.keySet()) {
                    List<DiskImage> list = images.get(drive);
                    getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                }
            }
        } else {
            retVal = false;
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getSourceDomainId(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getDestDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // TODO: checking disk target domains
    if (retVal) {
        if (!imageToDestinationDomainMap.isEmpty()) {
            for (Guid destGuid : imageToDestinationDomainMap.values()) {
                retVal = ImportExportCommon.CheckStorageDomain(destGuid, getReturnValue().getCanDoActionMessages());
                if (retVal && !domainIsValidDestination(getStorageDomain(destGuid))) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                    retVal = false;
                }
                if (!retVal)
                    break;
            }
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStoragePool(getParameters().getStoragePoolId(), getReturnValue().getCanDoActionMessages());
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    // check that the imported vm name is not in engine
    if (retVal) {
        List<VmStatic> dupVmNames = getVmStaticDAO().getAllByName(getParameters().getVm().getvm_name());
        if (dupVmNames.size() >= 1) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", getVm().getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!IsDomainActive(getParameters().getSourceDomainId(), getParameters().getStoragePoolId()) || !IsDomainActive(getParameters().getDestDomainId(), getParameters().getStoragePoolId()) || !TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<DiskImageBase>(getParameters().getDiskInfoList().values()), getReturnValue().getCanDoActionMessages());
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        getReturnValue().getCanDoActionMessages().add(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        if (!domainIsValidDestination(getStorageDomain())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        if (getSourceDomain() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
            retVal = false;
        }
        if (getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getID().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (domainMap.isEmpty()) {
            domainMap.put(getStorageDomain(), (int) getVm().getDiskSize());
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    boolean retVal;
    // Load images from Import/Export domain
    GetAllFromExportDomainQueryParamenters tempVar = new GetAllFromExportDomainQueryParamenters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    retVal = qretVal.getSucceeded();
    if (retVal) {
        List<VM> vms = (List) qretVal.getReturnValue();
        VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

            @Override
            public boolean eval(VM vm) {
                return vm.getId().equals(getParameters().getVm().getId());
            }
        });
        if (vm != null) {
            storage_domain_static destinationStorageDomainStatic = getStorageDomainStaticDAO().get(getParameters().getDestDomainId());
            // At this point we should work with the VM that was read from
            // the OVF
            setVm(vm);
            for (DiskImage image : getVm().getImages()) {
                // only if requested by the user
                if (getParameters().getCopyCollapse()) {
                    for (DiskImage p : imageList) {
                        if (p.getId().equals(image.getId())) {
                            if (p.getvolume_format() != null) {
                                image.setvolume_format(p.getvolume_format());
                            }
                            if (p.getvolume_type() != null) {
                                image.setvolume_type(p.getvolume_type());
                            }
                        }
                    }
                }
                retVal = ImagesHandler.CheckImageConfiguration(destinationStorageDomainStatic, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    // we put the source domain id in order that copy will
                    // work
                    // ok
                    // we fix it to DestDomainId in
                    // MoveOrCopyAllImageGroups();
                    image.setstorage_id(getParameters().getSourceDomainId());
                }
            }
            if (retVal) {
                Map<String, List<DiskImage>> images = GetImagesLeaf(getVm().getImages());
                for (String drive : images.keySet()) {
                    List<DiskImage> list = images.get(drive);
                    getVm().addDriveToImageMap(drive, list.get(list.size() - 1));
                }
            }
        } else {
            retVal = false;
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getSourceDomainId(), getReturnValue().getCanDoActionMessages());
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getDestDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // TODO: checking disk target domains
    if (retVal) {
        if (!imageToDestinationDomainMap.isEmpty()) {
            for (Guid destGuid : imageToDestinationDomainMap.values()) {
                retVal = ImportExportCommon.CheckStorageDomain(destGuid, getReturnValue().getCanDoActionMessages());
                if (retVal && !domainIsValidDestination(getStorageDomain(destGuid))) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                    retVal = false;
                }
                if (!retVal)
                    break;
            }
        }
    }
    if (retVal) {
        retVal = ImportExportCommon.CheckStoragePool(getParameters().getStoragePoolId(), getReturnValue().getCanDoActionMessages());
    }
    // check that the imported vm guid is not in engine
    if (retVal) {
        VmStatic duplicateVm = getVmStaticDAO().get(getParameters().getVm().getId());
        if (duplicateVm != null) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", duplicateVm.getvm_name()));
            retVal = false;
        }
    }
    // check that the imported vm name is not in engine
    if (retVal) {
        List<VmStatic> dupVmNames = getVmStaticDAO().getAllByName(getParameters().getVm().getvm_name());
        if (dupVmNames.size() >= 1) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", getVm().getvm_name()));
            retVal = false;
        }
    }
    setVmTemplateId(getVm().getvmt_guid());
    if (retVal) {
        if (!IsDomainActive(getParameters().getSourceDomainId(), getParameters().getStoragePoolId()) || !IsDomainActive(getParameters().getDestDomainId(), getParameters().getStoragePoolId()) || !TemplateExists() || !CheckTemplateInStorageDomain() || !CheckImagesGUIDsLegal() || !CanAddVm()) {
            retVal = false;
        }
    }
    if (retVal && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && getVmTemplate() != null && getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
        retVal = false;
    }
    if (retVal && getParameters().getCopyCollapse() && getParameters().getDiskInfoList() != null) {
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<DiskImageBase>(getParameters().getDiskInfoList().values()), getReturnValue().getCanDoActionMessages());
    }
    // (backup) domain
    if (retVal && getParameters().getCopyCollapse() && !TemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        getReturnValue().getCanDoActionMessages().add(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getstorage_name()));
        retVal = false;
    }
    if (retVal) {
        if (!domainIsValidDestination(getStorageDomain())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        SetSourceDomainId(getParameters().getSourceDomainId());
        if (getSourceDomain() == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
            retVal = false;
        }
        if (getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    if (retVal) {
        boolean inCluster = false;
        List<VDSGroup> groups = getVdsGroupDAO().getAllForStoragePool(getParameters().getStoragePoolId());
        for (VDSGroup group : groups) {
            if (group.getId().equals(getParameters().getVdsGroupId())) {
                inCluster = true;
                break;
            }
        }
        if (!inCluster) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            retVal = false;
        }
    }
    if (retVal) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
        if (domainMap.isEmpty()) {
            domainMap.put(getStorageDomain(), (int) getVm().getDiskSize());
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal && Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVdsGroup().getcompatibility_version().toString())) {
        // version 2.x)
        if (!VmCommand.validateNumberOfNics(getParameters().getVm().getInterfaces(), null)) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && CheckIfDisksExist(new ArrayList(getVm().getDiskMap().values()));
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getid();
            }
        });
        if (!domainsId.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && CheckIfDisksExist(new ArrayList(getVm().getDiskMap().values()));
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (!domainsId.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        Guid destinationDomain = (imageToDestinationDomainMap.get(disk.getId()) != null) ? imageToDestinationDomainMap.get(disk.getId()) : getParameters().getStorageDomainId();
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), destinationDomain, getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(true);
        MoveOrCopyImageGroupParameters p = tempVar;
        if (getParameters().getDiskInfoList() != null && getParameters().getDiskInfoList().containsKey(disk.getinternal_drive_mapping())) {
            p.setVolumeType(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_type());
            p.setVolumeFormat(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_format());
        }
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p);
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        Guid destinationDomain = (imageToDestinationDomainMap.get(disk.getId()) != null) ? imageToDestinationDomainMap.get(disk.getId()) : getParameters().getStorageDomainId();
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), destinationDomain, getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(true);
        MoveOrCopyImageGroupParameters p = tempVar;
        if (getParameters().getDiskInfoList() != null && getParameters().getDiskInfoList().containsKey(disk.getinternal_drive_mapping())) {
            p.setVolumeType(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_type());
            p.setVolumeFormat(getParameters().getDiskInfoList().get(disk.getinternal_drive_mapping()).getvolume_format());
        }
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(executionContext));
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
protected void AddVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(getNow());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(ComputeMinAllocatedMem());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDAO().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void AddVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(ComputeMinAllocatedMem());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDAO().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean returnVal = true;
    List<stateless_vm_image_map> statelessMap = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    List<DiskImage> imagesList = new java.util.ArrayList<DiskImage>(statelessMap.size());
    for (stateless_vm_image_map sMap : statelessMap) {
        imagesList.add(DbFacade.getInstance().getDiskImageDAO().getSnapshotById(sMap.getimage_guid()));
        /**
         * remove from db
         */
        DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(sMap.getimage_guid());
    }
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(getVm().getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        VdcReturnValueBase vdcReturn = Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar);
        returnVal = vdcReturn.getSucceeded();
    }
    setSucceeded(returnVal);
}
#method_after
@Override
protected void executeCommand() {
    boolean returnVal = true;
    List<stateless_vm_image_map> statelessMap = DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId());
    List<DiskImage> imagesList = new java.util.ArrayList<DiskImage>(statelessMap.size());
    for (stateless_vm_image_map sMap : statelessMap) {
        imagesList.add(DbFacade.getInstance().getDiskImageDAO().getSnapshotById(sMap.getimage_guid()));
        /**
         * remove from db
         */
        DbFacade.getInstance().getDiskImageDAO().removeStatelessVmImageMap(sMap.getimage_guid());
    }
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(getVm().getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        VdcReturnValueBase vdcReturn = Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar, ExecutionHandler.createDefaultContexForTasks(executionContext));
        returnVal = vdcReturn.getSucceeded();
    }
    setSucceeded(returnVal);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, true, true, true, true, false);
    setStoragePoolId(getVm().getstorage_pool_id());
    VmHandler.updateDisksFromDb(getVm());
    retValue = retValue && CheckTemplateInStorageDomain();
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    retValue = retValue && destinationHasSpace();
    if (!retValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__MOVE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, true, true, true, true, false);
    setStoragePoolId(getVm().getstorage_pool_id());
    VmHandler.updateDisksFromDb(getVm());
    retValue = retValue && CheckTemplateInStorageDomain();
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    retValue = retValue && destinationHasSpace();
    if (!retValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__MOVE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retValue;
}
#end_block

#method_before
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && // LINQ 32934 && CheckIfDisksExist(Vm.DiskMap.Values.ToList());
    CheckIfDisksExist(getVm().getDiskMap().values());
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid())) {
        List<storage_domains> domains = (List) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        // LINQ 32934 if (!domains.Select(a =>
        // a.id).Contains(MoveParameters.StorageDomainId))
        List<Guid> list = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains a) {
                return a.getid();
            }
        });
        if (!list.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean CheckTemplateInStorageDomain() {
    boolean retValue = CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && // LINQ 32934 && CheckIfDisksExist(Vm.DiskMap.Values.ToList());
    CheckIfDisksExist(getVm().getDiskMap().values());
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid())) {
        List<storage_domains> domains = (List) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        // LINQ 32934 if (!domains.Select(a =>
        // a.id).Contains(MoveParameters.StorageDomainId))
        List<Guid> list = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains a) {
                return a.getId();
            }
        });
        if (!list.contains(getParameters().getStorageDomainId())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups() {
    MoveMultipleImageGroupsParameters tempVar = new MoveMultipleImageGroupsParameters(getVm().getId(), Helper.ToList(getVm().getDiskMap().values()), getParameters().getStorageDomainId());
    tempVar.setParentCommand(getActionType());
    tempVar.setEntityId(getParameters().getEntityId());
    MoveMultipleImageGroupsParameters p = tempVar;
    VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveMultipleImageGroups, p);
    getParameters().getImagesParameters().add(p);
    getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups() {
    MoveMultipleImageGroupsParameters tempVar = new MoveMultipleImageGroupsParameters(getVm().getId(), Helper.ToList(getVm().getDiskMap().values()), getParameters().getStorageDomainId());
    tempVar.setParentCommand(getActionType());
    tempVar.setEntityId(getParameters().getEntityId());
    MoveMultipleImageGroupsParameters p = tempVar;
    VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveMultipleImageGroups, p, ExecutionHandler.createDefaultContexForTasks(executionContext));
    getParameters().getImagesParameters().add(p);
    getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
}
#end_block

#method_before
@XmlElement(name = "vm_guid")
public Guid getId() {
    return this.mVmStatic.getId();
}
#method_after
@XmlElement(name = "vm_guid")
@Override
public Guid getId() {
    return this.mVmStatic.getId();
}
#end_block

#method_before
public void setId(Guid value) {
    this.mVmStatic.setId(value);
    this.mVmDynamic.setId(value);
    this.mVmStatistics.setId(value);
}
#method_after
@Override
public void setId(Guid value) {
    this.mVmStatic.setId(value);
    this.mVmDynamic.setId(value);
    this.mVmStatistics.setId(value);
}
#end_block

#method_before
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (VM.isStatusUpOrPausedOrSuspended(getVm().getstatus())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if (_oldDisk.getdisk_interface() != getParameters().getDiskInfo().getdisk_interface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List allVmDisks = getDiskImageDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<DiskImageBase>() {

            @Override
            public boolean eval(DiskImageBase o) {
                return o.getinternal_drive_mapping().equals(_oldDisk.getinternal_drive_mapping());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!CheckPCIAndIDELimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    if (retValue && getParameters().getDiskInfo().getboot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (DiskImage disk : getVm().getDiskMap().values()) {
            if (disk.getboot() && !getParameters().getImageId().equals(disk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getinternal_drive_mapping()));
                break;
            }
        }
    }
    if (retValue && Boolean.FALSE.equals(getParameters().getDiskInfo().getPlugged()) && _oldDisk.getdisk_type() == DiskType.System) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_SYSTEM_DISK);
    }
    return retValue;
}
#method_after
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (VM.isStatusUpOrPausedOrSuspended(getVm().getstatus())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if (_oldDisk.getdisk_interface() != getParameters().getDiskInfo().getdisk_interface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getVmId());
        List allVmDisks = getDiskImageDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<DiskImageBase>() {

            @Override
            public boolean eval(DiskImageBase o) {
                return o.getinternal_drive_mapping().equals(_oldDisk.getinternal_drive_mapping());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!CheckPCIAndIDELimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    if (retValue && getParameters().getDiskInfo().getboot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (DiskImage disk : getVm().getDiskMap().values()) {
            if (disk.getboot() && !getParameters().getImageId().equals(disk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getinternal_drive_mapping()));
                break;
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    boolean returnValue = true;
    if (!Config.<Boolean>GetValue(ConfigValues.HotPlugEnabled, getVds().getvds_group_compatibility_version().getValue())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_SUPPORTED);
    } else if (!isOsSupported(getVm())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    } else if (!DiskInterface.VirtIO.equals(_oldDisk.getdisk_interface())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_VIRTIO);
    } else {
        if (oldVmDevice.getIsPlugged() == getParameters().getDiskInfo().getPlugged()) {
            if (oldVmDevice.getIsPlugged()) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
            } else {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
            }
        } else if (oldVmDevice.getIsPlugged() && _oldDisk.getdisk_type() == DiskType.System) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_SYSTEM_DISK);
        }
    }
    if (returnValue) {
        plugAction = oldVmDevice.getIsPlugged() ? VDSCommandType.HotUnPlugDisk : VDSCommandType.HotUnPlugDisk;
    }
    return returnValue;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    boolean returnValue = true;
    if (!Config.<Boolean>GetValue(ConfigValues.HotPlugEnabled, getVds().getvds_group_compatibility_version().getValue())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_SUPPORTED);
    } else if (!isOsSupported(getVm())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    } else if (!DiskInterface.VirtIO.equals(_oldDisk.getdisk_interface())) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_VIRTIO);
    } else if (oldVmDevice.getIsPlugged() == getParameters().getDiskInfo().getPlugged()) {
        if (oldVmDevice.getIsPlugged()) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
        } else {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
        }
    }
    if (returnValue) {
        plugAction = oldVmDevice.getIsPlugged() ? VDSCommandType.HotUnPlugDisk : VDSCommandType.HotPlugDisk;
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVm() == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that target domain exists
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getStorageDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getVm().getstorage_pool_id())) == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    // check if template exists only if asked for
    if (retVal && getParameters().getTemplateMustExists()) {
        retVal = CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
        }
    }
    // check if Vm has disks
    if (retVal && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retVal = false;
    }
    if (retVal) {
        Map<String, ? extends DiskImageBase> images = getParameters().getDiskInfoList();
        if (images == null) {
            images = getVm().getDiskMap();
        }
        // check that the images requested format are valid (COW+Sparse)
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new java.util.ArrayList<DiskImageBase>(images.values()), getReturnValue().getCanDoActionMessages());
        if (retVal && getParameters().getCopyCollapse()) {
            for (DiskImage img : getVm().getDiskMap().values()) {
                if (images.containsKey(img.getinternal_drive_mapping())) {
                    // mode)
                    if (images.get(img.getinternal_drive_mapping()).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                        retVal = false;
                    }
                }
            }
        }
    }
    // check destination storage is active
    if (retVal) {
        retVal = IsDomainActive(getStorageDomain().getid(), getVm().getstorage_pool_id());
    }
    // check destination storage is Export domain
    if (retVal) {
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    // check destination storage have free space
    if (retVal) {
        int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
        retVal = StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB);
        if (!retVal)
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    // Set source domain
    if (retVal) {
        // DiskImage image = null; //LINQ Vm.DiskMap.First().Value;
        DiskImage image = LinqUtils.first(getVm().getDiskMap().values());
        if (image == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
            retVal = false;
        }
        if (retVal) {
            SetSourceDomainId(image.getstorage_id().getValue());
            if (getSourceDomain() == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                retVal = false;
            }
        }
    }
    // check soource domain is active
    if (retVal) {
        retVal = IsDomainActive(getSourceDomain().getid(), getVm().getstorage_pool_id());
    }
    // check that source domain is not ISO or Export domain
    if (retVal) {
        if (getSourceDomain().getstorage_domain_type() == StorageDomainType.ISO || getSourceDomain().getstorage_domain_type() == StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    // check if Vm exists in export domain
    if (retVal) {
        retVal = CheckVmInStorageDomain();
    }
    if (retVal) {
        // check that vm is down and images are ok
        retVal = retVal && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, false);
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVm() == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    // check that target domain exists
    if (retVal) {
        retVal = ImportExportCommon.CheckStorageDomain(getParameters().getStorageDomainId(), getReturnValue().getCanDoActionMessages());
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    for (DiskImage diskImage : getVm().getDiskMap().values()) {
        diskImage.getSnapshots().addAll(ImagesHandler.getAllImageSnapshots(diskImage.getId(), diskImage.getit_guid()));
    }
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retVal = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    // check if template exists only if asked for
    if (retVal && getParameters().getTemplateMustExists()) {
        retVal = CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
        }
    }
    // check if Vm has disks
    if (retVal && getVm().getDiskMap().size() <= 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retVal = false;
    }
    if (retVal) {
        Map<String, ? extends DiskImageBase> images = getParameters().getDiskInfoList();
        if (images == null) {
            images = getVm().getDiskMap();
        }
        // check that the images requested format are valid (COW+Sparse)
        retVal = ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new java.util.ArrayList<DiskImageBase>(images.values()), getReturnValue().getCanDoActionMessages());
        if (retVal && getParameters().getCopyCollapse()) {
            for (DiskImage img : getVm().getDiskMap().values()) {
                if (images.containsKey(img.getinternal_drive_mapping())) {
                    // mode)
                    if (images.get(img.getinternal_drive_mapping()).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                        retVal = false;
                    }
                }
            }
        }
    }
    // check destination storage is active
    if (retVal) {
        retVal = IsDomainActive(getStorageDomain().getId(), getVm().getstorage_pool_id());
    }
    // check destination storage is Export domain
    if (retVal) {
        if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    // check destination storage have free space
    if (retVal) {
        int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
        retVal = StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB);
        if (!retVal)
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    // Set source domain
    if (retVal) {
        // DiskImage image = null; //LINQ Vm.DiskMap.First().Value;
        DiskImage image = LinqUtils.first(getVm().getDiskMap().values());
        if (image == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
            retVal = false;
        }
        if (retVal) {
            SetSourceDomainId(image.getstorage_id().getValue());
            if (getSourceDomain() == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                retVal = false;
            }
        }
    }
    // check soource domain is active
    if (retVal) {
        retVal = IsDomainActive(getSourceDomain().getId(), getVm().getstorage_pool_id());
    }
    // check that source domain is not ISO or Export domain
    if (retVal) {
        if (getSourceDomain().getstorage_domain_type() == StorageDomainType.ISO || getSourceDomain().getstorage_domain_type() == StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            retVal = false;
        }
    }
    // check if Vm exists in export domain
    if (retVal) {
        retVal = CheckVmInStorageDomain();
    }
    if (retVal) {
        // check that vm is down and images are ok
        retVal = retVal && ImagesHandler.PerformImagesChecks(getVmId(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, false);
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(disk);
        tempVar.setVolumeFormat(diskForVolumeInfo.getvolume_format());
        tempVar.setVolumeType(diskForVolumeInfo.getvolume_type());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(getParameters().getForceOverride());
        MoveOrCopyImageGroupParameters p = tempVar;
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p);
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#method_after
@Override
protected void MoveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        MoveOrCopyImageGroupParameters tempVar = new MoveOrCopyImageGroupParameters(containerID, disk.getimage_group_id().getValue(), disk.getId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
        tempVar.setParentCommand(getActionType());
        tempVar.setEntityId(getParameters().getEntityId());
        tempVar.setUseCopyCollapse(getParameters().getCopyCollapse());
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(disk);
        tempVar.setVolumeFormat(diskForVolumeInfo.getvolume_format());
        tempVar.setVolumeType(diskForVolumeInfo.getvolume_type());
        tempVar.setCopyVolumeType(CopyVolumeType.LeafVol);
        tempVar.setPostZero(disk.getwipe_after_delete());
        tempVar.setForceOverride(getParameters().getForceOverride());
        MoveOrCopyImageGroupParameters p = tempVar;
        p.setParentParemeters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.MoveOrCopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(executionContext));
        getParameters().getImagesParameters().add(p);
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
protected void RestartVdsVms() {
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    // restart all running vms of a failed vds.
    for (VM vm : mVmList) {
        DestroyVmOnDestination(vm);
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getvds_id(), vm.getId());
        }
        // ResourceManager.Instance.removeRunningVm(vm.vm_guid, VdsId);
        setVmId(vm.getId());
        setVmName(vm.getvm_name());
        setVm(vm);
        // Handle highly available VMs
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId(), true));
        }
    }
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setVm(null);
    setVmId(Guid.Empty);
    setVmName(null);
}
#method_after
protected void RestartVdsVms() {
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    // restart all running vms of a failed vds.
    for (VM vm : mVmList) {
        DestroyVmOnDestination(vm);
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getId(), vm.getId());
        }
        // ResourceManager.Instance.removeRunningVm(vm.vm_guid, VdsId);
        setVmId(vm.getId());
        setVmName(vm.getvm_name());
        setVm(vm);
        // Handle highly available VMs
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId(), true));
        }
    }
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setVm(null);
    setVmId(Guid.Empty);
    setVmName(null);
}
#end_block

#method_before
protected void setStatus(VDSStatus status) {
    if (getVds().getstatus() != status) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVds().getvds_id(), status));
    }
}
#method_after
protected void setStatus(VDSStatus status) {
    if (getVds().getstatus() != status) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVds().getId(), status));
    }
}
#end_block

#method_before
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.createVolume, p, false);
    return taskID;
}
#method_after
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters(), asyncTaskCreationInfo.getStepId()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.createVolume, p, false);
    return taskID;
}
#end_block

#method_before
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<image_vm_pool_map> list = DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(vm.getId());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<image_vm_pool_map, DiskImage>() {

        @Override
        public DiskImage eval(image_vm_pool_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar);
    }
}
#method_after
private void RestoreVmFromBaseSnapshot(VM vm) {
    List<image_vm_pool_map> list = DbFacade.getInstance().getDiskImageDAO().getImageVmPoolMapByVmId(vm.getId());
    // java.util.ArrayList<DiskImage> imagesList = null; // LINQ 32934
    // list.Select(a =>
    // DbFacade.Instance.GetSnapshotById(a.image_guid)).ToList();
    List<DiskImage> imagesList = LinqUtils.foreach(list, new Function<image_vm_pool_map, DiskImage>() {

        @Override
        public DiskImage eval(image_vm_pool_map a) {
            return DbFacade.getInstance().getDiskImageDAO().getSnapshotById(a.getimage_guid());
        }
    });
    if (imagesList.size() > 0) {
        /**
         * restore all snapshots
         */
        RestoreAllSnapshotsParameters tempVar = new RestoreAllSnapshotsParameters(vm.getId(), Guid.Empty);
        tempVar.setShouldBeLogged(false);
        tempVar.setImagesList(imagesList);
        Backend.getInstance().runInternalAction(VdcActionType.RestoreAllSnapshots, tempVar, ExecutionHandler.createDefaultContexForTasks(executionContext));
    }
}
#end_block

#method_before
@Override
public void ProcessOnVmStop(Guid vmId) {
    VmPoolHandler.ProcessVmPoolOnStopVm(vmId);
/**
 * Vitaly wating for Vm.ExitStatus in DB.
 * //HighAvailableVmsDirector.TryRunHighAvailableVmsOnVmDown(vmId);
 */
}
#method_after
@Override
public void ProcessOnVmStop(Guid vmId) {
    VmPoolHandler.ProcessVmPoolOnStopVm(vmId, null);
/**
 * Vitaly wating for Vm.ExitStatus in DB.
 * //HighAvailableVmsDirector.TryRunHighAvailableVmsOnVmDown(vmId);
 */
}
#end_block

#method_before
@Override
public void VdsNotResponding(final VDS vds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getvds_id(), vds.gethost_name());
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getvds_id(), FenceActionType.Restart));
        }
    });
}
#method_after
@Override
public void VdsNotResponding(final VDS vds) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("ResourceManager::vdsNotResponding entered for Host {0}, {1}", vds.getId(), vds.gethost_name());
            Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, new FenceVdsActionParameters(vds.getId(), FenceActionType.Restart));
        }
    });
}
#end_block

#method_before
@Override
public void ProcessOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(vmId);
    // clients, so we won't need to handle migration errors
    if (!StringHelper.isNullOrEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.DoCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getvds_id()));
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setguest_cur_user_id(null);
        vmDynamic.setguest_cur_user_name(null);
        DbFacade.getInstance().getVmDynamicDAO().update(vmDynamic);
    }
}
#method_after
@Override
public void ProcessOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(vmId);
    // clients, so we won't need to handle migration errors
    if (!StringHelper.isNullOrEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.DoCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getId()));
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setguest_cur_user_id(null);
        vmDynamic.setguest_cur_user_name(null);
        DbFacade.getInstance().getVmDynamicDAO().update(vmDynamic);
    }
}
#end_block

#method_before
@Override
public void RemoveAsyncRunningCommand(Guid vmId) {
    Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(vmId);
}
#method_after
@Override
public void RemoveAsyncRunningCommand(Guid vmId) {
    IVdsAsyncCommand command = Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(vmId);
    if (command != null) {
        command.reportCompleted();
    }
}
#end_block

#method_before
public static void ProcessStorageOnVdsInactive(VDS vds) {
    // Clear the problematic timers since the VDS is in maintenance so it doesn't make sense to check it
    // anymore.
    IrsBrokerCommand.clearVdsFromCache(vds.getstorage_pool_id(), vds.getvds_id(), vds.getvds_name());
    if (!vds.getstorage_pool_id().equals(Guid.Empty) && StoragePoolStatus.Uninitialized != DbFacade.getInstance().getStoragePoolDAO().get(vds.getstorage_pool_id()).getstatus() && Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getvds_id(), vds.getstorage_pool_id(), vds.getvds_spm_id())).getSucceeded()) {
        StoragePoolParametersBase tempVar = new StoragePoolParametersBase(vds.getstorage_pool_id());
        tempVar.setVdsId(vds.getvds_id());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, tempVar);
    }
}
#method_after
public static void ProcessStorageOnVdsInactive(VDS vds) {
    // Clear the problematic timers since the VDS is in maintenance so it doesn't make sense to check it
    // anymore.
    IrsBrokerCommand.clearVdsFromCache(vds.getstorage_pool_id(), vds.getId(), vds.getvds_name());
    if (!vds.getstorage_pool_id().equals(Guid.Empty) && StoragePoolStatus.Uninitialized != DbFacade.getInstance().getStoragePoolDAO().get(vds.getstorage_pool_id()).getstatus() && Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getstorage_pool_id(), vds.getvds_spm_id())).getSucceeded()) {
        StoragePoolParametersBase tempVar = new StoragePoolParametersBase(vds.getstorage_pool_id());
        tempVar.setVdsId(vds.getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        Backend.getInstance().runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, tempVar);
    }
}
#end_block

#method_before
public static void updateDisksFromDb(VM vm) {
    List<DiskImage> imageList = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
    for (DiskImage image : imageList) {
        if (image.getactive() != null && image.getactive()) {
            vm.getDiskMap().put(image.getinternal_drive_mapping(), image);
            vm.getDiskList().add(image);
        }
    }
}
#method_after
public static void updateDisksFromDb(VM vm) {
    List<DiskImage> imageList = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
    updateDisksForVm(vm, imageList);
}
#end_block

#method_before
public static boolean IsNotDuplicateInterfaceName(List<VmNetworkInterface> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREAY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean IsNotDuplicateInterfaceName(List<VmNetworkInterface> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(VdcBllMessages.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
private java.util.ArrayList<Guid> getRunVdssList() {
    return getVdsSelector().getRunVdssList();
}
#method_after
private ArrayList<Guid> getRunVdssList() {
    return getVdsSelector().getRunVdssList();
}
#end_block

#method_before
public static boolean hasCapacityToRunVM(VDS curVds) {
    boolean hasCapacity = true;
    if (curVds.getvds_type() == VDSType.PowerClient) {
        log.infoFormat("Checking capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getvds_id(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
        int pending_vm_count = 0;
        if (Config.<Boolean>GetValue(ConfigValues.PowerClientRunVmShouldVerifyPendingVMsAsWell) && _vds_pending_vm_count.containsKey(curVds.getvds_id())) {
            pending_vm_count = _vds_pending_vm_count.get(curVds.getvds_id());
        }
        if ((curVds.getvm_count() + pending_vm_count + 1) > Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs)) {
            log.infoFormat("No capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getvds_id(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
            hasCapacity = false;
        }
    }
    return hasCapacity;
}
#method_after
public static boolean hasCapacityToRunVM(VDS curVds) {
    boolean hasCapacity = true;
    if (curVds.getvds_type() == VDSType.PowerClient) {
        log.infoFormat("Checking capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getId(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
        int pending_vm_count = 0;
        if (Config.<Boolean>GetValue(ConfigValues.PowerClientRunVmShouldVerifyPendingVMsAsWell) && _vds_pending_vm_count.containsKey(curVds.getId())) {
            pending_vm_count = _vds_pending_vm_count.get(curVds.getId());
        }
        if ((curVds.getvm_count() + pending_vm_count + 1) > Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs)) {
            log.infoFormat("No capacity for a power client - id:{0}, name:{1}, host_name(ip):{2}, vds.vm_count:{3}, PowerClientMaxNumberOfConcurrentVMs:{4}", curVds.getId(), curVds.getvds_name(), curVds.gethost_name(), curVds.getvm_count(), Config.<Integer>GetValue(ConfigValues.PowerClientMaxNumberOfConcurrentVMs));
            hasCapacity = false;
        }
    }
    return hasCapacity;
}
#end_block

#method_before
public static void DoCompressionCheck(VDS vds, VmDynamic vm) {
    if (Config.<Boolean>GetValue(ConfigValues.PowerClientSpiceDynamicCompressionManagement)) {
        // comrpession allways enabled on VDS
        if (vds.getvds_type() != VDSType.PowerClient) {
            return;
        } else {
            String compression_enabled = "on";
            if (StringHelper.EqOp(vds.gethost_name(), vm.getclient_ip())) {
                compression_enabled = "off";
            }
            log.infoFormat("VdcBLL.VmHandler.DoCompressionCheck - sending monitor command for vmid: {0} - set_red_image_compression and set_red_streaming_video to {1}", vm.getId(), compression_enabled);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getvds_id(), vm.getId(), "set_red_image_compression " + compression_enabled));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getvds_id(), vm.getId(), "set_red_streaming_video " + compression_enabled));
        }
    }
}
#method_after
public static void DoCompressionCheck(VDS vds, VmDynamic vm) {
    if (Config.<Boolean>GetValue(ConfigValues.PowerClientSpiceDynamicCompressionManagement)) {
        // compression always enabled on VDS
        if (vds.getvds_type() != VDSType.PowerClient) {
            return;
        } else {
            String compression_enabled = "on";
            if (StringHelper.EqOp(vds.gethost_name(), vm.getclient_ip())) {
                compression_enabled = "off";
            }
            log.infoFormat("VdcBLL.VmHandler.DoCompressionCheck - sending monitor command for vmid: {0} - set_red_image_compression and set_red_streaming_video to {1}", vm.getId(), compression_enabled);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_image_compression " + compression_enabled));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.VmMonitorCommand, new VmMonitorCommandVDSCommandParameters(vds.getId(), vm.getId(), "set_red_streaming_video " + compression_enabled));
        }
    }
}
#end_block

#method_before
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getvds_id() : getCurrentVdsId();
    DecreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        ExecuteAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            FailedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        FailedToRunVm();
        _isRerun = false;
    }
}
#method_after
protected void rerunInternal() {
    Guid vdsId = getDestinationVds() != null ? getDestinationVds().getId() : getCurrentVdsId();
    DecreasePendingVms(vdsId);
    setSucceeded(false);
    setVm(null);
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>GetValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getstatus() != VMStatus.Paused) {
        _isRerun = true;
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        log();
        ExecuteAction();
        if (!getReturnValue().getCanDoAction()) {
            _isRerun = false;
            log();
            FailedToRunVm();
        }
    } else {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        FailedToRunVm();
        _isRerun = false;
    }
}
#end_block

#method_before
protected void FailedToRunVm() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            AnonymousMethod1();
        }
    });
}
#method_after
protected void FailedToRunVm() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            processVmPoolOnStopVm();
        }
    });
    ExecutionHandler.setAsyncJob(executionContext, false);
    ExecutionHandler.endJob(executionContext, false);
}
#end_block

#method_before
@Override
public void RunningSucceded() {
    DecreasePendingVms(getCurrentVdsId());
    setSucceeded(true);
    setActionReturnValue(VMStatus.Up);
    log();
    for (Guid vdsId : getRunVdssList()) {
        if (!getCurrentVdsId().equals(vdsId)) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
        }
    }
    if (getVm().getlast_vds_run_on() == null || !getVm().getlast_vds_run_on().equals(getCurrentVdsId())) {
        getVm().setlast_vds_run_on(getCurrentVdsId());
    }
    if (!StringHelper.isNullOrEmpty(getVm().gethibernation_vol_handle())) {
        HandleHibernatedVm(VdcActionType.RunVm, true);
        // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
        // this method (which is a part of the cached VM command,
        // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
        // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
        // status to up.
        getVm().setstatus(VMStatus.Up);
        getVm().sethibernation_vol_handle(null);
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
    }
}
#method_after
@Override
public void RunningSucceded() {
    DecreasePendingVms(getCurrentVdsId());
    setSucceeded(true);
    setActionReturnValue(VMStatus.Up);
    log();
    ExecutionHandler.setAsyncJob(executionContext, false);
    ExecutionHandler.endJob(executionContext, true);
    for (Guid vdsId : getRunVdssList()) {
        if (!getCurrentVdsId().equals(vdsId)) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
        }
    }
    if (getVm().getlast_vds_run_on() == null || !getVm().getlast_vds_run_on().equals(getCurrentVdsId())) {
        getVm().setlast_vds_run_on(getCurrentVdsId());
    }
    if (!StringHelper.isNullOrEmpty(getVm().gethibernation_vol_handle())) {
        HandleHibernatedVm(VdcActionType.RunVm, true);
        // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
        // this method (which is a part of the cached VM command,
        // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
        // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
        // status to up.
        getVm().setstatus(VMStatus.Up);
        getVm().sethibernation_vol_handle(null);
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
    }
}
#end_block

#method_before
protected Guid getCurrentVdsId() {
    return getVds().getvds_id();
}
#method_after
protected Guid getCurrentVdsId() {
    return getVds().getId();
}
#end_block

#method_before
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters());
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#method_after
protected boolean RemoveVmTemplateImages() {
    getParameters().setEntityId(getParameters().getEntityId());
    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveAllVmTemplateImageTemplates, getParameters(), ExecutionHandler.createDefaultContexForTasks(executionContext));
    if (!vdcReturnValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcReturnValue.getFault());
        return false;
    }
    getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
    return true;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    // NOTE: Assuming that we need to lock the vm before adding a disk!
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getVmId(), getParameters().getDiskInfo());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setVmSnapshotId(calculateSnapshotId());
    parameters.setParentCommand(VdcActionType.AddDiskToVm);
    parameters.setEntityId(getParameters().getEntityId());
    getParameters().getImagesParameters().add(parameters);
    getParameters().setVmSnapshotId(parameters.getVmSnapshotId());
    parameters.setParentParemeters(getParameters());
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters);
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    getReturnValue().setActionReturnValue(tmpRetValue.getActionReturnValue());
    getReturnValue().setFault(tmpRetValue.getFault());
    if (tmpRetValue.getSucceeded()) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId((Guid) getActionReturnValue(), getVmId()), VmDeviceType.DISK, VmDeviceType.DISK, "", true, false);
    }
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
@Override
protected void ExecuteVmCommand() {
    // NOTE: Assuming that we need to lock the vm before adding a disk!
    VmHandler.checkStatusAndLockVm(getVm().getId(), getCompensationContext());
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getVmId(), getParameters().getDiskInfo());
    parameters.setStorageDomainId(getStorageDomainId().getValue());
    parameters.setVmSnapshotId(calculateSnapshotId());
    parameters.setParentCommand(VdcActionType.AddDiskToVm);
    parameters.setEntityId(getParameters().getEntityId());
    getParameters().getImagesParameters().add(parameters);
    getParameters().setVmSnapshotId(parameters.getVmSnapshotId());
    parameters.setParentParemeters(getParameters());
    VdcReturnValueBase tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters, ExecutionHandler.createDefaultContexForTasks(executionContext));
    getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
    getReturnValue().setActionReturnValue(tmpRetValue.getActionReturnValue());
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void InitRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringHelper.isNullOrEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringHelper.isNullOrEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getvds_id() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true));
        refreshBootParameters(runVmParameters);
    }
}
#method_after
private void InitRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringHelper.isNullOrEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getstorage_pool_id());
    }
    if (!StringHelper.isNullOrEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getstorage_pool_id());
    }
    if (getVm() != null) {
        Guid destVdsId = (getDestinationVds() != null) ? (Guid) getDestinationVds().getId() : null;
        setVdsSelector(new VdsSelector(getVm(), destVdsId, true));
        refreshBootParameters(runVmParameters);
    }
}
#end_block

#method_before
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#method_after
private void ResumeVm() {
    mResume = true;
    // Vds = ResourceManager.Instance.getVds(Vm.run_on_vds.Value);
    setVdsId(new Guid(getVm().getrun_on_vds().toString()));
    if (getVds() != null) {
        try {
            IncrementVdsPendingVmsCount();
            VDSReturnValue result = Backend.getInstance().getResourceManager().RunAsyncVdsCommand(VDSCommandType.Resume, new ResumeVDSCommandParameters(getVdsId(), getVm().getId()), this);
            setActionReturnValue(result.getReturnValue());
            setSucceeded(result.getSucceeded());
            ExecutionHandler.setAsyncJob(executionContext, true);
        } finally {
            DecrementVdsPendingVmsCount();
        }
    } else {
        setActionReturnValue(getVm().getstatus());
    }
}
#end_block

#method_before
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            status = CreateVm();
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void RunVm() {
    setActionReturnValue(VMStatus.Down);
    if (GetVdsToRunOn()) {
        VMStatus status;
        try {
            IncrementVdsPendingVmsCount();
            AttachCd();
            status = CreateVm();
            ExecutionHandler.setAsyncJob(executionContext, true);
        } finally {
            DecrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (VM.isStatusUp(status) || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getvm_name());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            Rerun();
        }
    } else {
        FailedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
private void AttachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringHelper.isNullOrEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            GuestToolsVersionTreatment();
            // LINQ Vm.boot_sequence.toString().Contains(cd))
            refreshBootSequenceParameter(getParameters());
            if (getVm().getboot_sequence().toString().indexOf(cd) > -1) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringHelper.isNullOrEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        log.error("Can not attach CD without active ISO domain");
    }
}
#method_after
private void AttachCd() {
    Guid storagePoolId = getVm().getstorage_pool_id();
    boolean isIsoFound = (findActiveISODomain(storagePoolId) != null);
    if (isIsoFound) {
        if (StringHelper.isNullOrEmpty(getVm().getCdPath())) {
            getVm().setCdPath(getVm().getiso_path());
            GuestToolsVersionTreatment();
            refreshBootSequenceParameter(getParameters());
            if (getVm().getboot_sequence() == BootSequence.CD) {
                getVm().setCdPath(getVm().getiso_path());
            }
            getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(getVm().getCdPath(), getVm().getstorage_pool_id()));
        }
    } else if (!StringHelper.isNullOrEmpty(getVm().getiso_path())) {
        getVm().setCdPath("");
        log.error("Can not attach CD without active ISO domain");
    }
}
#end_block

#method_before
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, getCompensationContext());
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getId()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#method_after
private void StatelessVmTreatment() {
    /**
     * if one of vm's images is in the DB dont do anything.
     */
    if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVm().getId()).size() == 0) {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getvm_name(), getVm().getId());
        lockVmWithCompensationIfNeeded();
        CreateAllSnapshotsFromVmParameters tempVar = new CreateAllSnapshotsFromVmParameters(getVm().getId(), "stateless snapshot");
        tempVar.setShouldBeLogged(false);
        tempVar.setParentCommand(VdcActionType.RunVm);
        tempVar.setEntityId(getParameters().getEntityId());
        CreateAllSnapshotsFromVmParameters p = tempVar;
        VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, p, new CommandContext(getCompensationContext()));
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            // RestoreAllSnapshots)
            for (DiskImage disk : getVm().getDiskMap().values()) {
                /**
                 * add new stateless vm image to db
                 */
                DbFacade.getInstance().getDiskImageDAO().addStatelessVmImageMap(new stateless_vm_image_map(disk.getId(), disk.getinternal_drive_mapping(), getVm().getId()));
            }
            getParameters().getImagesParameters().add(p);
            getReturnValue().getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (vdcReturnValue.getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_IS_LOCKED.name())) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            } else {
                getReturnValue().setFault(vdcReturnValue.getFault());
            }
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getvm_name());
        }
    } else {
        log.errorFormat("RunVmAsStateless - {0} - found existing vm images in stateless_vm_image_map table - skipped creating snapshots.", getVm().getvm_name());
        removeVmStatlessImages();
    }
}
#end_block

#method_before
private void removeVmStatlessImages() {
    isFailedStatlessSnapshot = true;
    VmPoolHandler.removeVmStatelessImages(getVm().getId());
    setSucceeded(true);
}
#method_after
private void removeVmStatlessImages() {
    isFailedStatlessSnapshot = true;
    VmPoolHandler.removeVmStatelessImages(getVm().getId(), new CommandContext(executionContext));
    setSucceeded(true);
}
#end_block

#method_before
private void GuestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (!getVm().getvm_os().isLinux() && (null != (isoDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringHelper.isNullOrEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getid(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.regexToolPattern).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        // if minimalVdsRev isn't empty use new iso files name convention
        // string qumranetToolsPath = minimalVdsRev == string.Empty
        // ?
        // string.Format("{0}{1}.iso", GuestToolsSetupIsoPrefix, revision)
        // :
        // // format is RHEV-ToolsSetup_tools_ver_vds_min_ver
        // string.Format("{0}{1}_{2}.iso", GuestToolsSetupIsoPrefix,
        // revision,
        // minimalVdsRev);
        String qumranetToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.guestToolsSetupIsoPrefix, selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        qumranetToolsPath = Path.Combine(isoDir, qumranetToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(qumranetToolsPath, getVm().getstorage_pool_id()));
    }
}
#method_after
private void GuestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    storage_domains isoDomain = null;
    if (!getVm().getvm_os().isLinux() && (null != (isoDomain = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getVm().getstorage_pool_id()), new Predicate<storage_domains>() {

        @Override
        public boolean eval(storage_domains domain) {
            return domain.getstorage_domain_type() == StorageDomainType.ISO;
        }
    })) && isoDomain.getstatus() == StorageDomainStatus.Active && StringHelper.isNullOrEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoFileMetaData> repoFilesMap = IsoDomainListSyncronizer.getInstance().getCachedIsoListByDomainId(isoDomain.getId(), FileTypeExtension.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoFileMetaData map : repoFilesMap) {
            String fileName = map.getRepoFileName() != null ? map.getRepoFileName() : "";
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.regexToolPattern).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                // TODO: Should be group name string support in java7.
                Version clusterVer = new Version(matchToolPattern.group(1));
                int toolVersion = Integer.parseInt(matchToolPattern.group(3));
                if (clusterVer.compareTo(getVm().getvds_group_compatibility_version()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        // if minimalVdsRev isn't empty use new iso files name convention
        // string qumranetToolsPath = minimalVdsRev == string.Empty
        // ?
        // string.Format("{0}{1}.iso", GuestToolsSetupIsoPrefix, revision)
        // :
        // // format is RHEV-ToolsSetup_tools_ver_vds_min_ver
        // string.Format("{0}{1}_{2}.iso", GuestToolsSetupIsoPrefix,
        // revision,
        // minimalVdsRev);
        String qumranetToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.guestToolsSetupIsoPrefix, selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getstorage_pool_id())).getReturnValue();
        qumranetToolsPath = Path.Combine(isoDir, qumranetToolsPath);
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(qumranetToolsPath, getVm().getstorage_pool_id()));
    }
}
#end_block

#method_before
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        Guid storagePoolId = vm.getstorage_pool_id();
        // and no other boot devices are configured
        if (vmImages.isEmpty() && StringHelper.EqOp(boot_sequence.toString(), BootSequence.C.toString())) {
            message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString());
            retValue = false;
        } else {
            if ((findActiveISODomain(storagePoolId) == null) && boot_sequence.toString().length() > 0 && (boot_sequence.toString().charAt(0) == cd)) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else {
                    if (vmImages.size() > 0) {
                        Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                        // if VM is not HA VM
                        if (!ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                            retValue = false;
                        } else // Check if iso and floppy path exists
                        if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                            retValue = false;
                        } else {
                            boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                            if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                                }
                            } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                                VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                                if (vds.getstatus() != VDSStatus.Up) {
                                    retValue = false;
                                    if (message != null) {
                                        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                    }
                                }
                            }
                            boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                            if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                                retValue = false;
                                message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                            }
                            // if the VM itself is stateless or run once as stateless
                            if (retValue && isStatelessVm && vm.getauto_startup()) {
                                retValue = false;
                                message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                            }
                            retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                            /**
                             * only if can do action ok then check with actions matrix that status is valid for this
                             * action
                             */
                            if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                                retValue = false;
                            }
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public static boolean CanRunVm(VM vm, java.util.ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        if (message != null) {
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
        }
    } else if (!(validationErrors = VmPropertiesUtils.validateVMProperties(vm.getStaticData())).isEmpty()) {
        handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<DiskImage> vmImages = DbFacade.getInstance().getDiskImageDAO().getAllForVm(vm.getId());
        if (boot_sequence == BootSequence.C && !checkVmHasPluggedDisk(vm)) {
            String messageStr = !vmImages.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else // custom properties allowed only from cluster 2.3
            if (!StringHelper.isNullOrEmpty(vm.getStaticData().getCustomProperties()) && !Config.<Boolean>GetValue(ConfigValues.SupportCustomProperties, vm.getvds_group_compatibility_version().getValue())) {
                message.add(VdcBllMessages.CUSTOM_VM_PROPERTIES_INVALID_VALUES_NOT_ALLOWED_IN_CURRENT_CLUSTER.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence.toString().indexOf(NETWORK_BOOT_SEQUENCE_CHAR) > -1 && DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmImages.size() > 0) {
                    Guid storageDomainId = vmImages.get(0).getstorage_id().getValue();
                    // if VM is not HA VM
                    if (!ImagesHandler.PerformImagesChecks(vm.getId(), message, vm.getstorage_pool_id(), storageDomainId, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() && !storageDomainId.equals(Guid.Empty) || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup())) {
                        retValue = false;
                    } else // Check if iso and floppy path exists
                    if (!vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else {
                        boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            if (message != null) {
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                            }
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDAO().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                if (message != null) {
                                    message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                                }
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && ImagesHandler.isVmInPreview(vmImages)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.CanFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(new java.util.ArrayList<IVdcQueryable>(java.util.Arrays.asList(new IVdcQueryable[] { vm })), VM.class, VdcActionType.RunVm)) {
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                            retValue = false;
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        if (DbFacade.getInstance().getDiskImageDAO().getAllStatelessVmImageMapsForVm(getVmId()).size() > 0) {
            VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
            if (createSnapshotParameters != null) {
                createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
            }
            Backend.getInstance().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
            getParameters().setShouldBeLogged(false);
            getParameters().setRunAsStateless(false);
            getParameters().setIsInternal(true);
            setSucceeded(Backend.getInstance().runInternalAction(VdcActionType.RunVm, getParameters()).getSucceeded());
            if (!getSucceeded()) {
                // could not run the vm don't try to run the end action
                // again
                log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
                getReturnValue().setEndActionTryAgain(false);
            }
        } else // the stateless-snapshot no longer exists (probably due to
        // ProcessVmPoolOnStopVm
        // treatment) -> no point in running the VM or retrying to
        // EndAction:
        {
            getReturnValue().setEndActionTryAgain(false);
        }
    } else /**
     * Hibernation (VMStatus.Suspended) treatment:
     */
    {
        super.EndSuccessfully();
    }
}
#method_after
@Override
protected void EndSuccessfully() {
    SetIsVmRunningStateless();
    if (_isVmRunningStateless) {
        VdcActionParametersBase createSnapshotParameters = getParameters().getImagesParameters().get(0);
        if (createSnapshotParameters != null) {
            createSnapshotParameters.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        }
        Backend.getInstance().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        getParameters().setIsInternal(true);
        setSucceeded(Backend.getInstance().runInternalAction(VdcActionType.RunVm, getParameters()).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action
            // again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getvm_name());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else /**
     * Hibernation (VMStatus.Suspended) treatment:
     */
    {
        super.EndSuccessfully();
    }
}
#end_block

#method_before
public static Guid findActiveISODomain(Guid storagePoolId) {
    Guid isoGuid = null;
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(storagePoolId);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
            storage_domains sd = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domain.getid(), storagePoolId);
            if (sd != null && sd.getstatus() == StorageDomainStatus.Active) {
                isoGuid = sd.getid();
                break;
            }
        }
    }
    return isoGuid;
}
#method_after
public static Guid findActiveISODomain(Guid storagePoolId) {
    Guid isoGuid = null;
    List<storage_domains> domains = DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(storagePoolId);
    for (storage_domains domain : domains) {
        if (domain.getstorage_domain_type() == StorageDomainType.ISO) {
            storage_domains sd = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domain.getId(), storagePoolId);
            if (sd != null && sd.getstatus() == StorageDomainStatus.Active) {
                isoGuid = sd.getId();
                break;
            }
        }
    }
    return isoGuid;
}
#end_block

#method_before
@Override
protected VdsGroupDAO getVdsGroupDAO() {
    VdsGroupDAO d = mock(VdsGroupDAO.class);
    List<VDSGroup> list = new ArrayList<VDSGroup>();
    VDSGroup g = new VDSGroup();
    g.setID(getParameters().getVdsGroupId());
    Version v = new Version("2.2");
    g.setcompatibility_version(v);
    list.add(g);
    when(d.getAllForStoragePool(any(Guid.class))).thenReturn(list);
    when(d.get(any(Guid.class))).thenReturn(g);
    return d;
}
#method_after
@Override
protected VdsGroupDAO getVdsGroupDAO() {
    VdsGroupDAO d = mock(VdsGroupDAO.class);
    List<VDSGroup> list = new ArrayList<VDSGroup>();
    VDSGroup g = new VDSGroup();
    g.setId(getParameters().getVdsGroupId());
    Version v = new Version("2.2");
    g.setcompatibility_version(v);
    list.add(g);
    when(d.getAllForStoragePool(any(Guid.class))).thenReturn(list);
    when(d.get(any(Guid.class))).thenReturn(g);
    return d;
}
#end_block

#method_before
private boolean CanFindVdsToRun(java.util.ArrayList<String> messages, boolean isMigrate, Iterable<VDS> vdss) {
    VdcBllMessages message = VdcBllMessages.Unassigned;
    VdcBllMessages messageToReturn = VdcBllMessages.Unassigned;
    /**
     * save vdsVersion in order to know vds version that was wrong
     */
    VdsVersion vdsVersion = null;
    boolean noVDSs = true;
    for (VDS curVds : vdss) {
        if (isMigrate && getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getvds_id())) {
            continue;
        }
        noVDSs = false;
        RefObject<VdcBllMessages> tempRefObject = new RefObject<VdcBllMessages>(message);
        boolean tempVar = isReadyToRun(curVds, tempRefObject);
        message = tempRefObject.argvalue;
        if (tempVar) {
            return true;
        } else {
            if (// messageToReturn
            messageToReturn.getValue() < message.getValue()) // <
            // message)
            {
                messageToReturn = message;
                /**
                 * save version of current vds for later use
                 */
                vdsVersion = curVds.getVersion();
            }
        }
    }
    if (noVDSs) {
        if (messages != null) {
            messageToReturn = VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_AVAILABLE_IN_CLUSTER;
        }
    }
    if (messages != null) {
        messages.add(messageToReturn.toString());
        /**
         * if error due to versions, add versions information to can do
         * action message
         */
        if (messageToReturn == VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_VERSION && vdsVersion != null) {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            messages.add("$toolsVersion " + getVm().getPartialVersion());
            messages.add("$serverVersion " + vdsVersion.getPartialVersion());
        }
    }
    return false;
}
#method_after
private boolean CanFindVdsToRun(java.util.ArrayList<String> messages, boolean isMigrate, Iterable<VDS> vdss) {
    VdcBllMessages message = VdcBllMessages.Unassigned;
    VdcBllMessages messageToReturn = VdcBllMessages.Unassigned;
    /**
     * save vdsVersion in order to know vds version that was wrong
     */
    VdsVersion vdsVersion = null;
    boolean noVDSs = true;
    for (VDS curVds : vdss) {
        if (isMigrate && getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getId())) {
            continue;
        }
        noVDSs = false;
        RefObject<VdcBllMessages> tempRefObject = new RefObject<VdcBllMessages>(message);
        boolean tempVar = isReadyToRun(curVds, tempRefObject);
        message = tempRefObject.argvalue;
        if (tempVar) {
            return true;
        } else {
            if (// messageToReturn
            messageToReturn.getValue() < message.getValue()) // <
            // message)
            {
                messageToReturn = message;
                /**
                 * save version of current vds for later use
                 */
                vdsVersion = curVds.getVersion();
            }
        }
    }
    if (noVDSs) {
        if (messages != null) {
            messageToReturn = VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_AVAILABLE_IN_CLUSTER;
        }
    }
    if (messages != null) {
        messages.add(messageToReturn.toString());
        /**
         * if error due to versions, add versions information to can do
         * action message
         */
        if (messageToReturn == VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_VERSION && vdsVersion != null) {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            messages.add("$toolsVersion " + getVm().getPartialVersion());
            messages.add("$serverVersion " + vdsVersion.getPartialVersion());
        }
    }
    return false;
}
#end_block

#method_before
private boolean isReadyToRun(VDS vds, RefObject<VdcBllMessages> message) {
    boolean returnValue = true;
    if ((!vds.getvds_group_id().equals(getVm().getvds_group_id())) || (vds.getstatus() != VDSStatus.Up) || isVdsFailedToRunVm(vds.getvds_id())) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CLUSTER;
    } else // If Vm in Paused mode - no additional memory allocation needed
    if (getVm().getstatus() != VMStatus.Paused && !RunVmCommandBase.hasMemoryToRunVM(vds, getVm())) {
        // not enough memory
        // In case we are using this function in migration we make sure we
        // don't allocate the same VDS
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_MEMORY;
    } else // if vm has more vCpus then vds physical cpus - dont allow to run
    if (vds.getcpu_cores() != null && getVm().getnum_of_cpus() > vds.getcpu_cores()) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CPUS;
    } else // }
    if (!IsVMSwapValueLegal(vds)) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_SWAP;
    }
    return returnValue;
}
#method_after
private boolean isReadyToRun(VDS vds, RefObject<VdcBllMessages> message) {
    boolean returnValue = true;
    if ((!vds.getvds_group_id().equals(getVm().getvds_group_id())) || (vds.getstatus() != VDSStatus.Up) || isVdsFailedToRunVm(vds.getId())) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CLUSTER;
    } else // If Vm in Paused mode - no additional memory allocation needed
    if (getVm().getstatus() != VMStatus.Paused && !RunVmCommandBase.hasMemoryToRunVM(vds, getVm())) {
        // not enough memory
        // In case we are using this function in migration we make sure we
        // don't allocate the same VDS
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_MEMORY;
    } else // if vm has more vCpus then vds physical cpus - dont allow to run
    if (vds.getcpu_cores() != null && getVm().getnum_of_cpus() > vds.getcpu_cores()) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CPUS;
    } else // }
    if (!IsVMSwapValueLegal(vds)) {
        returnValue = false;
        message.argvalue = VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_SWAP;
    }
    return returnValue;
}
#end_block

#method_before
private Guid getVdsToRunOn(Iterable<VDS> vdss) {
    java.util.ArrayList<VDS> readyToRun = new java.util.ArrayList<VDS>();
    for (VDS curVds : vdss) {
        // vds must be in the correct group
        if (!curVds.getvds_group_id().equals(getVm().getvds_group_id()))
            continue;
        // vds must be up to run a vm
        if (curVds.getstatus() != VDSStatus.Up)
            continue;
        // apply limit on vds memory over commit.
        if (!RunVmCommandBase.hasMemoryToRunVM(curVds, getVm()))
            continue;
        // don't allocate the same VDS
        if ((getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getvds_id())) || isVdsFailedToRunVm(curVds.getvds_id()) || // RunVmCommandBase.isVdsVersionOld(curVds, getVm()) ||
        !RunVmCommandBase.hasCapacityToRunVM(curVds))
            continue;
        // vds must have at least cores as the vm
        if (curVds.getcpu_cores() != null && getVm().getnum_of_cpus() > curVds.getcpu_cores()) {
            continue;
        }
        if (!IsVMSwapValueLegal(curVds))
            continue;
        readyToRun.add(curVds);
    }
    return readyToRun.isEmpty() ? Guid.Empty : getBestVdsToRun(readyToRun);
}
#method_after
private Guid getVdsToRunOn(Iterable<VDS> vdss) {
    java.util.ArrayList<VDS> readyToRun = new java.util.ArrayList<VDS>();
    for (VDS curVds : vdss) {
        // vds must be in the correct group
        if (!curVds.getvds_group_id().equals(getVm().getvds_group_id()))
            continue;
        // vds must be up to run a vm
        if (curVds.getstatus() != VDSStatus.Up)
            continue;
        // apply limit on vds memory over commit.
        if (!RunVmCommandBase.hasMemoryToRunVM(curVds, getVm()))
            continue;
        // don't allocate the same VDS
        if ((getVm().getrun_on_vds() != null && getVm().getrun_on_vds().equals(curVds.getId())) || isVdsFailedToRunVm(curVds.getId()) || // RunVmCommandBase.isVdsVersionOld(curVds, getVm()) ||
        !RunVmCommandBase.hasCapacityToRunVM(curVds))
            continue;
        // vds must have at least cores as the vm
        if (curVds.getcpu_cores() != null && getVm().getnum_of_cpus() > curVds.getcpu_cores()) {
            continue;
        }
        if (!IsVMSwapValueLegal(curVds))
            continue;
        readyToRun.add(curVds);
    }
    return readyToRun.isEmpty() ? Guid.Empty : getBestVdsToRun(readyToRun);
}
#end_block

#method_before
private Guid getBestVdsToRun(java.util.ArrayList<VDS> list) {
    VdsComparer comparer = VdsComparer.CreateComparer(list.get(0).getselection_algorithm());
    VDS bestVDS = list.get(0);
    for (int i = 1; i < list.size(); i++) {
        VDS curVds = list.get(i);
        if (comparer.IsBetter(bestVDS, curVds, getVm())) // if (((bestVDS.physical_mem_mb - bestVDS.mem_commited) <
        // (curVds.physical_mem_mb - curVds.mem_commited)))
        {
            bestVDS = curVds;
        }
    }
    /**
     * add chosen vds to running vdss list.
     */
    comparer.BestVdsProcedure(bestVDS);
    getRunVdssList().add(bestVDS.getvds_id());
    return bestVDS.getvds_id();
}
#method_after
private Guid getBestVdsToRun(java.util.ArrayList<VDS> list) {
    VdsComparer comparer = VdsComparer.CreateComparer(list.get(0).getselection_algorithm());
    VDS bestVDS = list.get(0);
    for (int i = 1; i < list.size(); i++) {
        VDS curVds = list.get(i);
        if (comparer.IsBetter(bestVDS, curVds, getVm())) // if (((bestVDS.physical_mem_mb - bestVDS.mem_commited) <
        // (curVds.physical_mem_mb - curVds.mem_commited)))
        {
            bestVDS = curVds;
        }
    }
    /**
     * add chosen vds to running vdss list.
     */
    comparer.BestVdsProcedure(bestVDS);
    getRunVdssList().add(bestVDS.getId());
    return bestVDS.getId();
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, getNow(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().gethypervisor_type(), getParameters().getMasterVm().getoperation_mode()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    DbFacade.getInstance().getVmTemplateDAO().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams);
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams, ExecutionHandler.createDefaultContexForTasks(executionContext));
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
private void createVm() {
    VmStatic vm = new VmStatic();
    Date now = new Date(System.currentTimeMillis());
    vm.setvds_group_id(cluster.getID());
    vm.setId(new Guid(""));
    vm.setmem_size_mb(256);
    vm.setvm_type(VmType.Desktop);
    vm.setvmt_guid(Guid.Empty);
    vm.setdedicated_vm_for_vds(null);
    vm.setvm_type(VmType.Desktop);
    vm.setos(VmOsType.RHEL5);
    vm.setvm_name("vm" + testSequence);
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setcreation_date(now);
    ArrayList<DiskImageBase> diskInfoList = new ArrayList<DiskImageBase>();
    VmManagementParametersBase addVmFromScratchParams = new AddVmFromScratchParameters(vm, diskInfoList, getStorage().getid());
    // 
    // diskInfoList.add(disk);
    addVmFromScratchParams.setDontCheckTemplateImages(true);
    VdcReturnValueBase addVmAction = backend.runInternalAction(VdcActionType.AddVmFromScratch, addVmFromScratchParams);
    Assert.assertTrue(addVmAction.getSucceeded());
    this.vm = DB_FACADE.getVmDAO().get(vm.getId());
    Assert.assertNotNull(this.vm);
    createVmDiskImage(vm, now);
}
#method_after
private void createVm() {
    VmStatic vm = new VmStatic();
    Date now = new Date(System.currentTimeMillis());
    vm.setvds_group_id(cluster.getId());
    vm.setId(new Guid(""));
    vm.setmem_size_mb(256);
    vm.setvm_type(VmType.Desktop);
    vm.setvmt_guid(Guid.Empty);
    vm.setdedicated_vm_for_vds(null);
    vm.setvm_type(VmType.Desktop);
    vm.setos(VmOsType.RHEL5);
    vm.setvm_name("vm" + testSequence);
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setcreation_date(now);
    ArrayList<DiskImageBase> diskInfoList = new ArrayList<DiskImageBase>();
    VmManagementParametersBase addVmFromScratchParams = new AddVmFromScratchParameters(vm, diskInfoList, getStorage().getId());
    // 
    // diskInfoList.add(disk);
    addVmFromScratchParams.setDontCheckTemplateImages(true);
    VdcReturnValueBase addVmAction = backend.runInternalAction(VdcActionType.AddVmFromScratch, addVmFromScratchParams);
    Assert.assertTrue(addVmAction.getSucceeded());
    this.vm = DB_FACADE.getVmDAO().get(vm.getId());
    Assert.assertNotNull(this.vm);
    createVmDiskImage(vm, now);
}
#end_block

#method_before
private void createVmDiskImage(VmStatic vm, Date now) {
    Guid vmId = vm.getId();
    Guid ImageId = Guid.NewGuid();
    DiskImageBase disk = new DiskImage(false, now, now, 100, Long.toString(AbstractBackendTest.testSequenceNumber), ImageId, "", Guid.NewGuid(), 100, vmId, vmId, ImageStatus.OK, now, "");
    disk.setvolume_type(VolumeType.Sparse);
    disk.setvolume_format(VolumeFormat.COW);
    disk.setdisk_type(DiskType.Data);
    disk.setsize(100);
    disk.setinternal_drive_mapping(Long.toString(AbstractBackendTest.testSequenceNumber));
    disk.setdisk_interface(DiskInterface.IDE);
    disk.setboot(false);
    disk.setwipe_after_delete(false);
    disk.setpropagate_errors(PropagateErrors.Off);
    DiskImage image = new DiskImage(disk);
    image.setId(ImageId);
    image.setimageStatus(ImageStatus.OK);
    image.setvm_guid(vmId);
    image.setcreation_date(now);
    AddImageFromScratchParameters addImageParams = new AddImageFromScratchParameters(ImageId, vmId, disk);
    addImageParams.setStorageDomainId(storage.getid());
    addImageParams.setVmSnapshotId(Guid.NewGuid());
    addImageParams.setParentCommand(VdcActionType.AddDiskToVm);
    addImageParams.setEntityId(ImageId);
    addImageParams.setDestinationImageId(ImageId);
    AddImageFromScratchParameters parameters = addImageParams;
    VdcReturnValueBase addImageAction = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters);
    Assert.assertTrue(addImageAction.getSucceeded());
}
#method_after
private void createVmDiskImage(VmStatic vm, Date now) {
    Guid vmId = vm.getId();
    Guid ImageId = Guid.NewGuid();
    DiskImageBase disk = new DiskImage(false, now, now, 100, Long.toString(AbstractBackendTest.testSequenceNumber), ImageId, "", Guid.NewGuid(), 100, vmId, vmId, ImageStatus.OK, now, "");
    disk.setvolume_type(VolumeType.Sparse);
    disk.setvolume_format(VolumeFormat.COW);
    disk.setdisk_type(DiskType.Data);
    disk.setsize(100);
    disk.setinternal_drive_mapping(Long.toString(AbstractBackendTest.testSequenceNumber));
    disk.setdisk_interface(DiskInterface.IDE);
    disk.setboot(false);
    disk.setwipe_after_delete(false);
    disk.setpropagate_errors(PropagateErrors.Off);
    DiskImage image = new DiskImage(disk);
    image.setId(ImageId);
    image.setimageStatus(ImageStatus.OK);
    image.setvm_guid(vmId);
    image.setcreation_date(now);
    AddImageFromScratchParameters addImageParams = new AddImageFromScratchParameters(ImageId, vmId, disk);
    addImageParams.setStorageDomainId(storage.getId());
    addImageParams.setVmSnapshotId(Guid.NewGuid());
    addImageParams.setParentCommand(VdcActionType.AddDiskToVm);
    addImageParams.setEntityId(ImageId);
    addImageParams.setDestinationImageId(ImageId);
    AddImageFromScratchParameters parameters = addImageParams;
    VdcReturnValueBase addImageAction = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, parameters);
    Assert.assertTrue(addImageAction.getSucceeded());
}
#end_block

#method_before
private void createStorage() {
    storage_server_connections connection = new storage_server_connections();
    connection.setconnection("1.1.1.1/common");
    connection.setstorage_type(StorageType.NFS);
    StorageServerConnectionParametersBase addStorgeConnectionParams = new StorageServerConnectionParametersBase(connection, host.getvds_id());
    addStorgeConnectionParams.setStoragePoolId(dataCenter.getId());
    VdcReturnValueBase runInternalAction = backend.runInternalAction(VdcActionType.AddStorageServerConnection, addStorgeConnectionParams);
    Assert.assertTrue(runInternalAction.getSucceeded());
    storage_domain_static storageDomainStatic = new storage_domain_static();
    storageDomainStatic.setConnection(connection);
    storageDomainStatic.setstorage_domain_type(StorageDomainType.Data);
    storageDomainStatic.setstorage_type(StorageType.NFS);
    storageDomainStatic.setstorage_name(testSequence + "storage");
    storageDomainStatic.setstorage_pool_name(dataCenter.getname());
    Guid storageDomainId = Guid.NewGuid();
    storageDomainStatic.setId(storageDomainId);
    storage_domains storageDomain = new storage_domains(storageDomainId, connection.getconnection(), "storage" + testSequence, dataCenter.getId(), 2, 1, StorageDomainStatus.Active, dataCenter.getname(), dataCenter.getstorage_pool_type().getValue(), StorageType.NFS.getValue());
    storageDomain.setstatus(StorageDomainStatus.Active);
    storageDomain.setstorage_domain_type(StorageDomainType.Data);
    storage_domain_dynamic dynamicStorageDomain = new storage_domain_dynamic(null, storageDomainId, null);
    dynamicStorageDomain.setavailable_disk_size(50000);
    dynamicStorageDomain.setused_disk_size(10);
    storageDomain.setStorageDynamicData(dynamicStorageDomain);
    DB_FACADE.getStorageDomainStaticDAO().save(storageDomain.getStorageStaticData());
    DB_FACADE.getStorageDomainDynamicDAO().save(dynamicStorageDomain);
    DB_FACADE.getStorageDomainDynamicDAO().update(storageDomain.getStorageDynamicData());
    VdcReturnValueBase attachAction = backend.runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(storageDomainId, dataCenter.getId()));
    Assert.assertTrue(attachAction.getSucceeded());
    storage_pool_iso_map isoMap = DB_FACADE.getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(storageDomainId, dataCenter.getId()));
    isoMap.setstatus(StorageDomainStatus.Active);
    DB_FACADE.getStoragePoolIsoMapDAO().updateStatus(isoMap.getId(), isoMap.getstatus());
    storage = storageDomain;
}
#method_after
private void createStorage() {
    storage_server_connections connection = new storage_server_connections();
    connection.setconnection("1.1.1.1/common");
    connection.setstorage_type(StorageType.NFS);
    StorageServerConnectionParametersBase addStorgeConnectionParams = new StorageServerConnectionParametersBase(connection, host.getId());
    addStorgeConnectionParams.setStoragePoolId(dataCenter.getId());
    VdcReturnValueBase runInternalAction = backend.runInternalAction(VdcActionType.AddStorageServerConnection, addStorgeConnectionParams);
    Assert.assertTrue(runInternalAction.getSucceeded());
    storage_domain_static storageDomainStatic = new storage_domain_static();
    storageDomainStatic.setConnection(connection);
    storageDomainStatic.setstorage_domain_type(StorageDomainType.Data);
    storageDomainStatic.setstorage_type(StorageType.NFS);
    storageDomainStatic.setstorage_name(testSequence + "storage");
    storageDomainStatic.setstorage_pool_name(dataCenter.getname());
    Guid storageDomainId = Guid.NewGuid();
    storageDomainStatic.setId(storageDomainId);
    storage_domains storageDomain = new storage_domains(storageDomainId, connection.getconnection(), "storage" + testSequence, dataCenter.getId(), 2, 1, StorageDomainStatus.Active, dataCenter.getname(), dataCenter.getstorage_pool_type().getValue(), StorageType.NFS.getValue());
    storageDomain.setstatus(StorageDomainStatus.Active);
    storageDomain.setstorage_domain_type(StorageDomainType.Data);
    storage_domain_dynamic dynamicStorageDomain = new storage_domain_dynamic(null, storageDomainId, null);
    dynamicStorageDomain.setavailable_disk_size(50000);
    dynamicStorageDomain.setused_disk_size(10);
    storageDomain.setStorageDynamicData(dynamicStorageDomain);
    DB_FACADE.getStorageDomainStaticDAO().save(storageDomain.getStorageStaticData());
    DB_FACADE.getStorageDomainDynamicDAO().save(dynamicStorageDomain);
    DB_FACADE.getStorageDomainDynamicDAO().update(storageDomain.getStorageDynamicData());
    VdcReturnValueBase attachAction = backend.runInternalAction(VdcActionType.AttachStorageDomainToPool, new StorageDomainPoolParametersBase(storageDomainId, dataCenter.getId()));
    Assert.assertTrue(attachAction.getSucceeded());
    storage_pool_iso_map isoMap = DB_FACADE.getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(storageDomainId, dataCenter.getId()));
    isoMap.setstatus(StorageDomainStatus.Active);
    DB_FACADE.getStoragePoolIsoMapDAO().updateStatus(isoMap.getId(), isoMap.getstatus());
    storage = storageDomain;
}
#end_block

#method_before
private void createHost() {
    Guid hostId = Guid.NewGuid();
    String hostName = "host" + testSequence;
    VdsStatic vdsStatic = new VdsStatic(hostName, "1.1.1.1", hostName, 22, cluster.getID(), hostId, hostName, false, VDSType.VDS);
    AddVdsActionParameters addHostParams = new AddVdsActionParameters(vdsStatic, "root");
    // Hack certificate path check
    Config.getConfigUtils().SetStringValue(ConfigValues.UseSecureConnectionWithServers.toString(), "false");
    Boolean isMLA = Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn);
    setIsMultiLevelAdministrationOn(Boolean.FALSE);
    mockVdsInstallerHelper();
    AddVdsCommand<AddVdsActionParameters> addVdsCommand = createAddVdsCommand(addHostParams);
    VdcReturnValueBase addHostAction = addVdsCommand.ExecuteAction();
    setIsMultiLevelAdministrationOn(isMLA);
    Assert.assertTrue(addHostAction.getSucceeded());
    hostId = (Guid) addHostAction.getActionReturnValue();
    host = (VDS) backend.runInternalQuery(VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(hostId)).getReturnValue();
    Assert.assertNotNull(host);
    VDS vds = DB_FACADE.getVdsDAO().get(hostId);
    vds.setstatus(VDSStatus.Up);
    DB_FACADE.getVdsDynamicDAO().update(vds.getDynamicData());
}
#method_after
private void createHost() {
    Guid hostId = Guid.NewGuid();
    String hostName = "host" + testSequence;
    VdsStatic vdsStatic = new VdsStatic(hostName, "1.1.1.1", hostName, 22, cluster.getId(), hostId, hostName, false, VDSType.VDS);
    AddVdsActionParameters addHostParams = new AddVdsActionParameters(vdsStatic, "root");
    // Hack certificate path check
    Config.getConfigUtils().SetStringValue(ConfigValues.UseSecureConnectionWithServers.toString(), "false");
    Boolean isMLA = Config.<Boolean>GetValue(ConfigValues.IsMultilevelAdministrationOn);
    setIsMultiLevelAdministrationOn(Boolean.FALSE);
    mockVdsInstallerHelper();
    AddVdsCommand<AddVdsActionParameters> addVdsCommand = createAddVdsCommand(addHostParams);
    VdcReturnValueBase addHostAction = addVdsCommand.ExecuteAction();
    setIsMultiLevelAdministrationOn(isMLA);
    Assert.assertTrue(addHostAction.getSucceeded());
    hostId = (Guid) addHostAction.getActionReturnValue();
    host = (VDS) backend.runInternalQuery(VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(hostId)).getReturnValue();
    Assert.assertNotNull(host);
    VDS vds = DB_FACADE.getVdsDAO().get(hostId);
    vds.setstatus(VDSStatus.Up);
    DB_FACADE.getVdsDynamicDAO().update(vds.getDynamicData());
}
#end_block

#method_before
private void removeCluster() {
    // DbFacade.getInstance().RemoveVDSGroups(cluster.getID());
    backend.RunAction(VdcActionType.RemoveVdsGroup, new VdsGroupParametersBase(cluster.getID()));
    System.out.println("-- removed cluster " + cluster.getname() + " -- ");
}
#method_after
private void removeCluster() {
    // DbFacade.getInstance().RemoveVDSGroups(cluster.getID());
    backend.RunAction(VdcActionType.RemoveVdsGroup, new VdsGroupParametersBase(cluster.getId()));
    System.out.println("-- removed cluster " + cluster.getname() + " -- ");
}
#end_block

#method_before
private void removeHost() {
    DB_FACADE.getVdsDynamicDAO().remove(host.getvds_id());
    DB_FACADE.getVdsStatisticsDAO().remove(host.getvds_id());
    DB_FACADE.getVdsStaticDAO().remove(host.getvds_id());
    System.out.println("-- removed Host " + host.gethost_name() + " -- ");
}
#method_after
private void removeHost() {
    DB_FACADE.getVdsDynamicDAO().remove(host.getId());
    DB_FACADE.getVdsStatisticsDAO().remove(host.getId());
    DB_FACADE.getVdsStaticDAO().remove(host.getId());
    System.out.println("-- removed Host " + host.gethost_name() + " -- ");
}
#end_block

#method_before
private void removeStorage() {
    Guid id = storage.getid();
    DB_FACADE.getStorageDomainDynamicDAO().remove(id);
    List<DiskImage> snapshots = DB_FACADE.getDiskImageDAO().getAllSnapshotsForStorageDomain(id);
    for (DiskImage i : snapshots) {
        DB_FACADE.getDiskImageDAO().remove(i.getId());
    }
    DB_FACADE.getStorageDomainStaticDAO().remove(id);
    System.out.println("-- removed storage " + storage.getstorage_name() + " and its snapshots -- ");
}
#method_after
private void removeStorage() {
    Guid id = storage.getId();
    DB_FACADE.getStorageDomainDynamicDAO().remove(id);
    List<DiskImage> snapshots = DB_FACADE.getDiskImageDAO().getAllSnapshotsForStorageDomain(id);
    for (DiskImage i : snapshots) {
        DB_FACADE.getDiskImageDAO().remove(i.getId());
    }
    DB_FACADE.getStorageDomainStaticDAO().remove(id);
    System.out.println("-- removed storage " + storage.getstorage_name() + " and its snapshots -- ");
}
#end_block

#method_before
protected void AddVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setcreation_date(getNow());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.parseProperties(vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    DbFacade.getInstance().getVmStaticDAO().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void AddVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getorigin() == null) {
        vmStatic.setorigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setcreation_date(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.parseProperties(vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    DbFacade.getInstance().getVmStaticDAO().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
private void buildVmDrives() {
    int[] ideIndexSlots = new int[] { 0, 1, 3 };
    int ideCount = 0, pciCount = 0;
    int i = 0;
    if (!StringHelper.isNullOrEmpty(vm.getCdPath())) {
        createInfo.add(VdsProperties.CDRom, vm.getCdPath());
    }
    if (!StringHelper.isNullOrEmpty(vm.getFloppyPath())) {
        createInfo.add(VdsProperties.Floppy, vm.getFloppyPath());
    }
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<DiskImage> diskImages = new ArrayList<DiskImage>(vm.getDiskMap().values());
    Collections.sort(diskImages, new DiskImageByDriveMappingComparator());
    Collections.sort(diskImages, Collections.reverseOrder(new DiskImageByBootComparator()));
    List<VmDevice> diskVmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.DISK));
    Set<Guid> pluggedDiskIds = new HashSet<Guid>();
    for (VmDevice diskVmDevice : diskVmDevices) {
        if (diskVmDevice.getIsPlugged()) {
            pluggedDiskIds.add(diskVmDevice.getDeviceId());
        }
    }
    Map[] drives = new Map[pluggedDiskIds.size()];
    for (DiskImage disk : diskImages) {
        if (pluggedDiskIds.contains(disk.getId())) {
            Map drive = new HashMap();
            drive.put("domainID", disk.getstorage_id().toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    drive.put("if", "ide");
                    drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                    ideCount++;
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    break;
            }
            drives[i] = drive;
            i++;
        }
    }
    createInfo.add("drives", drives);
}
#method_after
private void buildVmDrives() {
    int[] ideIndexSlots = new int[] { 0, 1, 3 };
    int ideCount = 0, pciCount = 0;
    int i = 0;
    if (!StringHelper.isNullOrEmpty(vm.getCdPath())) {
        createInfo.add(VdsProperties.CDRom, vm.getCdPath());
    }
    if (!StringHelper.isNullOrEmpty(vm.getFloppyPath())) {
        createInfo.add(VdsProperties.Floppy, vm.getFloppyPath());
    }
    // order first by drive numbers and then order by boot for the bootable
    // drive to be first (important for IDE to be index 0) !
    List<DiskImage> diskImages = new ArrayList<DiskImage>(vm.getDiskMap().values());
    Collections.sort(diskImages, new DiskImageByDriveMappingComparator());
    Collections.sort(diskImages, Collections.reverseOrder(new DiskImageByBootComparator()));
    List<VmDevice> diskVmDevices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.DISK));
    Set<Guid> pluggedDiskIds = new HashSet<Guid>();
    for (VmDevice diskVmDevice : diskVmDevices) {
        if (diskVmDevice.getIsPlugged()) {
            pluggedDiskIds.add(diskVmDevice.getDeviceId());
        }
    }
    Map[] drives = new Map[pluggedDiskIds.size()];
    for (DiskImage disk : diskImages) {
        if (pluggedDiskIds.contains(disk.getDisk().getId())) {
            Map drive = new HashMap();
            drive.put("domainID", disk.getstorage_id().toString());
            drive.put("poolID", disk.getstorage_pool_id().toString());
            drive.put("volumeID", disk.getId().toString());
            drive.put("imageID", disk.getimage_group_id().toString());
            drive.put("format", disk.getvolume_format().toString().toLowerCase());
            drive.put("propagateErrors", disk.getpropagate_errors().toString().toLowerCase());
            switch(disk.getdisk_interface()) {
                case IDE:
                    drive.put("if", "ide");
                    drive.put("index", String.valueOf(ideIndexSlots[ideCount]));
                    ideCount++;
                    break;
                case VirtIO:
                    drive.put("if", "virtio");
                    drive.put("index", String.valueOf(pciCount));
                    drive.put("boot", String.valueOf(disk.getboot()).toLowerCase());
                    pciCount++;
                    break;
                default:
                    // ISCI not supported
                    break;
            }
            drives[i] = drive;
            i++;
        }
    }
    createInfo.add("drives", drives);
}
#end_block

#method_before
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p, false);
    return taskID;
}
#method_after
@Override
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), getParameters(), asyncTaskCreationInfo.getStepId()));
    p.setEntityId(getParameters().getEntityId());
    Guid taskID = AsyncTaskManager.getInstance().CreateTask(AsyncTaskType.deleteImage, p, false);
    return taskID;
}
#end_block

#method_before
private void OnSave() {
    VM vm = (VM) getEntity();
    DiskModel model = (DiskModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.Validate()) {
        return;
    }
    // Save changes.
    storage_domains storageDomain = (storage_domains) model.getStorageDomain().getSelectedItem();
    DiskImage disk = model.getIsNew() ? new DiskImage() : (DiskImage) getSelectedItem();
    disk.setSizeInGigabytes(Integer.parseInt(model.getSize().getEntity().toString()));
    DiskImageBase preset = (DiskImageBase) model.getPreset().getSelectedItem();
    disk.setdisk_type(preset.getdisk_type());
    disk.setdisk_interface((DiskInterface) model.getInterface().getSelectedItem());
    disk.setvolume_type((VolumeType) model.getVolumeType().getSelectedItem());
    disk.setvolume_format(model.getVolumeFormat());
    disk.setwipe_after_delete((Boolean) model.getWipeAfterDelete().getEntity());
    disk.setboot((Boolean) model.getIsBootable().getEntity());
    // NOTE: Since we doesn't support partial snapshots in GUI, propagate errors flag always must be set false.
    // disk.propagate_errors = model.PropagateErrors.ValueAsBoolean() ? PropagateErrors.On : PropagateErrors.Off;
    disk.setpropagate_errors(PropagateErrors.Off);
    model.StartProgress(null);
    if (model.getIsNew()) {
        AddDiskToVmParameters tempVar = new AddDiskToVmParameters(vm.getId(), disk);
        tempVar.setStorageDomainId(storageDomain.getid());
        Frontend.RunAction(VdcActionType.AddDiskToVm, tempVar, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        Frontend.RunAction(VdcActionType.UpdateVmDisk, new UpdateVmDiskParameters(vm.getId(), disk.getId(), disk), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    }
}
#method_after
private void OnSave() {
    VM vm = (VM) getEntity();
    DiskModel model = (DiskModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.Validate()) {
        return;
    }
    // Save changes.
    storage_domains storageDomain = (storage_domains) model.getStorageDomain().getSelectedItem();
    DiskImage disk = model.getIsNew() ? new DiskImage() : (DiskImage) getSelectedItem();
    disk.setSizeInGigabytes(Integer.parseInt(model.getSize().getEntity().toString()));
    DiskImageBase preset = (DiskImageBase) model.getPreset().getSelectedItem();
    disk.setdisk_type(preset.getdisk_type());
    disk.setdisk_interface((DiskInterface) model.getInterface().getSelectedItem());
    disk.setvolume_type((VolumeType) model.getVolumeType().getSelectedItem());
    disk.setvolume_format(model.getVolumeFormat());
    disk.setwipe_after_delete((Boolean) model.getWipeAfterDelete().getEntity());
    disk.setboot((Boolean) model.getIsBootable().getEntity());
    disk.setPlugged((Boolean) model.getIsPlugged().getEntity());
    // NOTE: Since we doesn't support partial snapshots in GUI, propagate errors flag always must be set false.
    // disk.propagate_errors = model.PropagateErrors.ValueAsBoolean() ? PropagateErrors.On : PropagateErrors.Off;
    disk.setpropagate_errors(PropagateErrors.Off);
    model.StartProgress(null);
    if (model.getIsNew()) {
        AddDiskToVmParameters tempVar = new AddDiskToVmParameters(vm.getId(), disk);
        tempVar.setStorageDomainId(storageDomain.getid());
        Frontend.RunAction(VdcActionType.AddDiskToVm, tempVar, new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        Frontend.RunAction(VdcActionType.UpdateVmDisk, new UpdateVmDiskParameters(vm.getId(), disk.getId(), disk), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                VmDiskListModel localModel = (VmDiskListModel) result.getState();
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }, this);
    }
}
#end_block

#method_before
private void UpdateActionAvailability() {
    VM vm = (VM) getEntity();
    boolean isDown = vm != null && vm.getstatus() == VMStatus.Down;
    getNewCommand().setIsExecutionAllowed(isDown);
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1 && isDown);
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0 && isDown);
}
#method_after
private void UpdateActionAvailability() {
    VM vm = (VM) getEntity();
    DiskImage disk = (DiskImage) getSelectedItem();
    getNewCommand().setIsExecutionAllowed(isVmDown());
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1 && isVmDown());
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0 && isVmDown());
    getPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(true));
    getUnPlugCommand().setIsExecutionAllowed(isPlugCommandAvailable(false));
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (command == getPlugCommand()) {
        Plug(true);
    } else if (command == getUnPlugCommand()) {
        Plug(false);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllRunningForVds(getVdsId());
    Collections.sort(vms, Collections.reverseOrder(new VmsComparer()));
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    for (VM vm : vms) {
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId()));
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getvds_id(), vm.getId());
        }
        VmPoolHandler.ProcessVmPoolOnStopVm(vm.getId());
    }
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVdsVMsCleared, new UpdateVdsVMsClearedVDSCommandParameters(getVdsId()));
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VM> vms = DbFacade.getInstance().getVmDAO().getAllRunningForVds(getVdsId());
    Collections.sort(vms, Collections.reverseOrder(new VmsComparer()));
    java.util.ArrayList<VdcActionParametersBase> runVmParamsList = new java.util.ArrayList<VdcActionParametersBase>();
    for (VM vm : vms) {
        if (vm.getauto_startup()) {
            runVmParamsList.add(new RunVmParams(vm.getId()));
        }
        VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
        // Write that this VM was shut down by host rebbot or manual fence
        if (returnValue != null && returnValue.getSucceeded()) {
            LogSettingVmToDown(getVds().getId(), vm.getId());
        }
        VmPoolHandler.ProcessVmPoolOnStopVm(vm.getId(), ExecutionHandler.createDefaultContexForTasks(executionContext));
    }
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVdsVMsCleared, new UpdateVdsVMsClearedVDSCommandParameters(getVdsId()));
    if (runVmParamsList.size() > 0) {
        Backend.getInstance().runInternalMultipleActions(VdcActionType.RunVm, runVmParamsList);
    }
    setSucceeded(true);
}
#end_block

#method_before
public static java.util.ArrayList<DiskImage> getAllImageSnapshots(Guid imageId, Guid imageTemplateId) {
    java.util.ArrayList<DiskImage> snapshots = new java.util.ArrayList<DiskImage>();
    Guid curImage = imageId;
    while (!imageTemplateId.equals(curImage) && !curImage.equals(Guid.Empty)) {
        DiskImage curDiskImage = DbFacade.getInstance().getDiskImageDAO().getSnapshotById(curImage);
        snapshots.add(curDiskImage);
        curImage = curDiskImage.getParentId();
    }
    return snapshots;
}
#method_after
public static ArrayList<DiskImage> getAllImageSnapshots(Guid imageId, Guid imageTemplateId) {
    ArrayList<DiskImage> snapshots = new ArrayList<DiskImage>();
    Guid curImage = imageId;
    while (!imageTemplateId.equals(curImage) && !curImage.equals(Guid.Empty)) {
        DiskImage curDiskImage = DbFacade.getInstance().getDiskImageDAO().getSnapshotById(curImage);
        snapshots.add(curDiskImage);
        curImage = curDiskImage.getParentId();
    }
    return snapshots;
}
#end_block

#method_before
public static Iterable<DiskImage> getAllImageSnapshotsFromIrs(Guid imageId, Guid imageTemplateId) {
    java.util.ArrayList<DiskImage> snapshots = new java.util.ArrayList<DiskImage>();
    Guid curImage = imageId;
    while (!imageTemplateId.equals(curImage) && !curImage.equals(Guid.Empty)) {
        DiskImage image = DbFacade.getInstance().getDiskImageDAO().getSnapshotById(curImage);
        Guid storagePoolId = image.getstorage_pool_id() != null ? image.getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = image.getstorage_id() != null ? image.getstorage_id().getValue() : Guid.Empty;
        Guid imageGroupId = image.getimage_group_id() != null ? image.getimage_group_id().getValue() : Guid.Empty;
        DiskImage curDiskImage = (DiskImage) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, curImage)).getReturnValue();
        snapshots.add(curDiskImage);
        curImage = curDiskImage.getParentId();
    }
    return snapshots;
}
#method_after
public static Iterable<DiskImage> getAllImageSnapshotsFromIrs(Guid imageId, Guid imageTemplateId) {
    List<DiskImage> snapshots = new ArrayList<DiskImage>();
    Guid curImage = imageId;
    while (!imageTemplateId.equals(curImage) && !curImage.equals(Guid.Empty)) {
        DiskImage image = DbFacade.getInstance().getDiskImageDAO().getSnapshotById(curImage);
        Guid storagePoolId = image.getstorage_pool_id() != null ? image.getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = image.getstorage_id() != null ? image.getstorage_id().getValue() : Guid.Empty;
        Guid imageGroupId = image.getimage_group_id() != null ? image.getimage_group_id().getValue() : Guid.Empty;
        DiskImage curDiskImage = (DiskImage) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, curImage)).getReturnValue();
        snapshots.add(curDiskImage);
        curImage = curDiskImage.getParentId();
    }
    return snapshots;
}
#end_block

#method_before
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId, Guid storageDomainId) {
    return isImagesExists(images, storagePoolId, storageDomainId, new RefObject<java.util.ArrayList<DiskImage>>());
}
#method_after
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId, Guid storageDomainId) {
    return isImagesExists(images, storagePoolId, storageDomainId, new RefObject<ArrayList<DiskImage>>());
}
#end_block

#method_before
@Test
public void testIsFiltered() {
    assertFalse("By default, query should not be run as user", base.isFiltered());
    base.setIsFiltered(true);
    assertTrue("Query should have been set to be run as user", base.isFiltered());
    base.setIsFiltered(false);
    assertFalse("Query should have been set to be NOT run as user", base.isFiltered());
}
#method_after
@Test
public void testIsFiltered() {
    assertFalse("By default, query should not be run as user", base.isFiltered());
    base.setFiltered(true);
    assertTrue("Query should have been set to be run as user", base.isFiltered());
    base.setFiltered(false);
    assertFalse("Query should have been set to be NOT run as user", base.isFiltered());
}
#end_block

#method_before
@Test
public void validateAddingNonExistingNetwork() {
    List<VdsNetworkInterface> vdsNics = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface nic1 = new VdsNetworkInterface();
    nic1.setNetworkName("vmnet");
    nic1.setName("nic1");
    vdsNics.add(nic1);
    VdsNetworkInterface nic2 = new VdsNetworkInterface();
    nic2.setNetworkName("mgmtnet");
    nic2.setName("nic2");
    vdsNics.add(nic2);
    List<network> clusterNetworks = new ArrayList<network>();
    network net1 = new network();
    net1.setname("vmnet");
    network net2 = new network();
    net2.setname("mgmtnet");
    clusterNetworks.add(net1);
    clusterNetworks.add(net2);
    List<VdsNetworkInterface> nics = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface nicWithUknownNetowrk = new VdsNetworkInterface();
    nicWithUknownNetowrk.setNetworkName("nonExisitigNetworkName");
    nicWithUknownNetowrk.setName("nic3");
    nics.add(nicWithUknownNetowrk);
    initMocks(vdsNics, clusterNetworks);
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(nics);
    SetupNetworksHelper validator = createHelper(params);
    assertTrue(validator.validate().contains(NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER));
}
#method_after
@Test
public void validateAddingNonExistingNetwork() {
    List<VdsNetworkInterface> vdsNics = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface nic1 = new VdsNetworkInterface();
    nic1.setNetworkName("vmnet");
    nic1.setName("nic1");
    vdsNics.add(nic1);
    VdsNetworkInterface nic2 = new VdsNetworkInterface();
    nic2.setNetworkName("mgmtnet");
    nic2.setName("nic2");
    vdsNics.add(nic2);
    List<network> clusterNetworks = new ArrayList<network>();
    network net1 = new network();
    net1.setname("vmnet");
    network net2 = new network();
    net2.setname("mgmtnet");
    clusterNetworks.add(net1);
    clusterNetworks.add(net2);
    List<VdsNetworkInterface> nics = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface nicWithUnknownNetwork = new VdsNetworkInterface();
    nicWithUnknownNetwork.setNetworkName("nonExisitigNetworkName");
    nicWithUnknownNetwork.setName("nic3");
    nics.add(nicWithUnknownNetwork);
    initMocks(vdsNics, clusterNetworks);
    SetupNetworksParameters params = new SetupNetworksParameters();
    params.setInterfaces(nics);
    SetupNetworksHelper validator = createHelper(params);
    assertTrue(validator.validate().contains(NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER));
}
#end_block

#method_before
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#method_after
@Override
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#end_block

#method_before
private void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#method_after
private static void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#end_block

#method_before
public DateTime getStartedAt() {
    return _startedAt;
}
#method_after
@Override
public DateTime getStartedAt() {
    return _startedAt;
}
#end_block

#method_before
public void Initialize() {
    log.infoFormat("Start time: {0}", new java.util.Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new java.util.Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new java.util.Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new java.util.Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new java.util.Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new java.util.Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new java.util.Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new java.util.Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new java.util.Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new java.util.Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#method_after
private static void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#end_block

#method_before
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CompensationContext context) {
    switch(actionType) {
        case AutoLogin:
            VdcReturnValueBase returnValue = new VdcReturnValueBase();
            returnValue.setCanDoAction(false);
            returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
            return returnValue;
        default:
            {
                CommandBase command = CommandsFactory.CreateCommand(actionType, parameters);
                command.setInternalExecution(runAsInternal);
                if (context != null) {
                    command.setCompensationContext(context);
                }
                return command.ExecuteAction();
            }
    }
}
#method_after
private static VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CompensationContext context) {
    switch(actionType) {
        case AutoLogin:
            VdcReturnValueBase returnValue = new VdcReturnValueBase();
            returnValue.setCanDoAction(false);
            returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
            return returnValue;
        default:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
                command.setInternalExecution(runAsInternal);
                if (context != null) {
                    command.setCompensationContext(context);
                }
                return command.ExecuteAction();
            }
    }
}
#end_block

#method_before
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#method_after
@Override
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#end_block

#method_before
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#end_block

#method_before
private VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().GetData(sessionId, "VdcUser", parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
private static VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#method_after
@Override
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#end_block

#method_before
private String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#method_after
private static String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#end_block

#method_before
@Override
public java.util.ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public java.util.ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#method_after
@Override
@ExcludeClassInterceptors
public ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#method_after
public ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#end_block

#method_before
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#method_after
@Override
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#end_block

#method_before
private VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#method_after
private static VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#end_block

#method_before
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#method_after
@Override
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#end_block

#method_before
public tags GetTagByTagName(String tagName) {
    throw new NotImplementedException();
}
#method_after
public tags GetTagByTagName(@SuppressWarnings("unused") String tagName) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdsAndChildrenIdsByRegExp(String tagNameRegExp) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdsAndChildrenIdsByRegExp(@SuppressWarnings("unused") String tagNameRegExp) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdAndChildrenIds(int tagId) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdAndChildrenIds(@SuppressWarnings("unused") int tagId) {
    throw new NotImplementedException();
}
#end_block

#method_before
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                } else {
                    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                    returnValue.setSucceeded(false);
                    returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                    return returnValue;
                }
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                }
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#end_block

#method_before
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    } else {
        return RunAction(actionType, parameters);
    }
}
#method_after
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    }
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            java.util.ArrayList<VdcReturnValueBase> returnValues = new java.util.ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#method_after
public ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#end_block

#method_before
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#method_after
@Override
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#method_after
@Override
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#end_block

#method_before
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#method_after
@Override
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#end_block

#method_before
public void initialize(String bundleBaseName) {
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
            throw new IllegalArgumentException("Illegal argument with key " + key);
        }
    }
}
#method_after
public void initialize(String bundleBaseName) {
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
        }
    }
}
#end_block

#method_before
private <T extends Enum<T>> void addMessage(String key, String value, Map<T, String> messagesMap, Class<T> enumClass, int prefixLength) {
    T enumKey = T.valueOf(enumClass, key.substring(prefixLength));
    if (!messagesMap.containsKey(key)) {
        messagesMap.put(enumKey, value);
    } else {
        log.warnFormat("Code {0} appears more then once in {1} table.", key, enumClass.getSimpleName());
    }
}
#method_after
private <T extends Enum<T>> void addMessage(String key, String value, Map<T, String> messagesMap, Class<T> enumClass, int prefixLength) {
    T enumKey = null;
    try {
        enumKey = T.valueOf(enumClass, key.substring(prefixLength));
    } catch (IllegalArgumentException e) {
        log.errorFormat("Message key {0} is not valid for enum {1}", key, enumClass.getSimpleName());
        return;
    }
    if (!messagesMap.containsKey(key)) {
        messagesMap.put(enumKey, value);
    } else {
        log.warnFormat("Code {0} appears more then once in {1} table.", key, enumClass.getSimpleName());
    }
}
#end_block

#method_before
@Test
public void verifyEngineMessagesSupported() throws FileNotFoundException, IOException {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(ExecutionMessageDirector.EXECUTION_MESSAGES_FILE_PATH);
}
#method_after
@Test
public void verifyEngineMessagesSupported() throws FileNotFoundException, IOException {
    ResourceBundle bundle = ResourceBundle.getBundle(EXECUTION_MESSAGES_FILE_PATH);
    String testKey = null;
    Class<?> testEnum = null;
    try {
        for (String key : bundle.keySet()) {
            testKey = key;
            if (key.startsWith(ExecutionMessageDirector.JOB_MESSAGE_PREFIX)) {
                testEnum = VdcActionType.class;
                VdcActionType.valueOf(key.substring(JOB_MESSAGE_PREFIX.length()));
            } else if (key.startsWith(ExecutionMessageDirector.STEP_MESSAGE_PREFIX)) {
                testEnum = StepEnum.class;
                StepEnum.valueOf(key.substring(STEP_MESSAGE_PREFIX.length()));
            }
        }
    } catch (RuntimeException e) {
        fail("Missing entry in enum " + testEnum.getSimpleName() + " for key " + testKey);
    }
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void readMissingMessageKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_KEY_TEST_BUNDLE_NAME);
}
#method_after
@Test
public void readMissingMessageKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_KEY_TEST_BUNDLE_NAME);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void readMissingMessageJobKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_JOB_KEY_TEST_BUNDLE_NAME);
}
#method_after
@Test
public void readMissingMessageJobKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_JOB_KEY_TEST_BUNDLE_NAME);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void readMissingMessageStepKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_STEP_KEY_TEST_BUNDLE_NAME);
}
#method_after
@Test
public void readMissingMessageStepKey() {
    ExecutionMessageDirector messageDirector = ExecutionMessageDirector.getInstance();
    messageDirector.initialize(INVALID_STEP_KEY_TEST_BUNDLE_NAME);
}
#end_block

#method_before
public static Job createJob(VdcActionType actionType, CommandBase<?> command) {
    Job job = new Job();
    job.setId(Guid.NewGuid());
    job.setActionType(actionType);
    job.setCommandId(command.getCommandId());
    job.setJobSubjectEntities(command.getPermissionCheckSubjects());
    job.setCommandId(command.getCommandId());
    job.setOwnerId(command.getUserId());
    job.setStatus(ExecutionStatus.STARTED);
    job.setStartTime(new Date());
    job.setJobRepository(JobRepositoryFactory.getJobRepository());
    // TODO: set actual value of correlation-ID
    job.setCorrelationId(Guid.NewGuid().toString());
    return job;
}
#method_after
public static Job createJob(VdcActionType actionType, CommandBase<?> command) {
    Job job = new Job();
    job.setId(Guid.NewGuid());
    job.setActionType(actionType);
    // TODO: create job description by resource bundle
    job.setDescription(actionType.name());
    job.setJobSubjectEntities(command.getPermissionCheckSubjects());
    job.setOwnerId(command.getUserId());
    job.setStatus(JobExecutionStatus.STARTED);
    job.setStartTime(new Date());
    // TODO: set actual value of correlation-ID
    job.setCorrelationId(Guid.NewGuid().toString());
    return job;
}
#end_block

#method_before
public static void endStep(ExecutionContext context, Step step, boolean exitStatus) {
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (step != null) {
                step.endStep(exitStatus);
            }
            if (exitStatus == false) {
                context.getJob().endJob(false);
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
            if (context.getStep() != null) {
                context.getStep().endStep(false);
            }
        }
    }
}
#method_after
public static void endStep(ExecutionContext context, Step step, boolean exitStatus) {
    if (context.isMonitored()) {
        Job job = context.getJob();
        try {
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                if (exitStatus) {
                    if (step != null) {
                        step.markStepEnded(exitStatus);
                        JobRepositoryFactory.getJobRepository().updateStep(step);
                    }
                } else {
                    // step failure will cause the job to be marked as failed
                    job.markJobEnded(false);
                    JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
                }
            } else {
                Step parentStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && parentStep != null) {
                    if (exitStatus) {
                        if (step != null) {
                            step.markStepEnded(exitStatus);
                            JobRepositoryFactory.getJobRepository().updateStep(step);
                        }
                    }
                }
            }
        } catch (Exception e) {
            log.error(e);
        }
    }
}
#end_block

#method_before
public static void prepareCommandForMonitoring(CommandBase<?> command, VdcActionType actionType, boolean runAsInternal) {
    ExecutionContext context = new ExecutionContext();
    try {
        boolean isMonitored = shouldMonitorCommand(actionType, runAsInternal);
        context.setMonitored(isMonitored);
        // A monitored job is created for monitored external flows
        if (isMonitored) {
            Job job = createJob(actionType, command);
            JobRepositoryFactory.getJobRepository().saveJob(job);
            context.setExecutionMethod(ExecutionMethod.AsJob);
            context.setJob(job);
            command.setExecutionContext(context);
        }
    } catch (Exception e) {
        log.errorFormat("Failed to prepare command of type {0} for monitoring due to error {1}", actionType.name(), ExceptionUtils.getMessage(e), e);
    }
}
#method_after
public static void prepareCommandForMonitoring(CommandBase<?> command, VdcActionType actionType, boolean runAsInternal) {
    ExecutionContext context = command.getExecutionContext();
    if (context == null) {
        context = new ExecutionContext();
    }
    try {
        boolean isMonitored = shouldMonitorCommand(actionType, runAsInternal);
        context.setMonitored(isMonitored);
        // A monitored job is created for monitored external flows
        if (isMonitored) {
            Job job = createJob(actionType, command);
            JobRepositoryFactory.getJobRepository().saveJob(job);
            context.setExecutionMethod(ExecutionMethod.AsJob);
            context.setJob(job);
            command.setExecutionContext(context);
        }
    } catch (Exception e) {
        log.errorFormat("Failed to prepare command of type {0} for monitoring due to error {1}", actionType.name(), ExceptionUtils.getMessage(e), e);
    }
}
#end_block

#method_before
public static Step addStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            step = context.getJob().addStep(stepName, description);
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
        // TODO: Implement adding a step under the step which represent the monitored internal command.
        }
    }
    return step;
}
#method_after
public static Step addStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context.isMonitored()) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        try {
            Job job = context.getJob();
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                step = job.addStep(stepName, description);
                try {
                    JobRepositoryFactory.getJobRepository().saveStep(step);
                } catch (Exception e) {
                    log.errorFormat("Failed to save new step {0} for job {1}, {2}.", stepName.name(), job.getId(), job.getActionType().name(), e);
                    job.getSteps().remove(step);
                    step = null;
                }
            } else {
                Step contextStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && contextStep != null) {
                    step = addSubStep(contextStep, stepName, description);
                }
            }
        } catch (Exception e) {
            log.error(e);
        }
    }
    return step;
}
#end_block

#method_before
public static Step addTaskStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context != null) {
        Step parentTaskStep = context.getParentTasksStep();
        if (parentTaskStep != null) {
            parentTaskStep.addStep(stepName, description);
        }
    }
    return step;
}
#method_after
public static Step addTaskStep(ExecutionContext context, StepEnum stepName, String description) {
    Step step = null;
    if (context != null && context.isTasksMonitored()) {
        Step parentTaskStep = context.getParentTasksStep();
        if (parentTaskStep != null) {
            step = addSubStep(parentTaskStep, stepName, description);
        }
    }
    return step;
}
#end_block

#method_before
public static Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description) {
    Step step = null;
    if (parentStep == null) {
        return null;
    }
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (DbFacade.getInstance().getStepDao().exists(parentStep.getId())) {
                if (parentStep.getJobId().equals(context.getJob().getId())) {
                    step = parentStep.addStep(newStepName, description);
                }
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
        // TODO: Implement adding a step under the step which represent the monitored internal command.
        }
    }
    return step;
}
#method_after
private static Step addSubStep(Step parentStep, StepEnum stepName, String description) {
    Step step = null;
    if (parentStep != null) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        step = parentStep.addStep(stepName, description);
        try {
            JobRepositoryFactory.getJobRepository().saveStep(step);
        } catch (Exception e) {
            log.errorFormat("Failed to save new step {0} for step {1}, {2}.", stepName.name(), parentStep.getId(), parentStep.getStepType().name(), e);
            parentStep.getSteps().remove(step);
            step = null;
        }
    }
    return step;
}
#end_block

#method_before
public static Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description) {
    Step step = null;
    if (parentStep == null) {
        return null;
    }
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (DbFacade.getInstance().getStepDao().exists(parentStep.getId())) {
                if (parentStep.getJobId().equals(context.getJob().getId())) {
                    step = parentStep.addStep(newStepName, description);
                }
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
        // TODO: Implement adding a step under the step which represent the monitored internal command.
        }
    }
    return step;
}
#method_after
public static Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description) {
    Step step = null;
    if (parentStep == null) {
        return null;
    }
    try {
        if (context.isMonitored()) {
            if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
                if (DbFacade.getInstance().getStepDao().exists(parentStep.getId())) {
                    if (parentStep.getJobId().equals(context.getJob().getId())) {
                        step = parentStep.addStep(newStepName, description);
                    }
                }
            } else if (parentStep != null && context.getExecutionMethod() == ExecutionMethod.AsStep) {
                step = parentStep.addStep(newStepName, description);
            }
        }
        if (step != null) {
            JobRepositoryFactory.getJobRepository().saveStep(step);
        }
    } catch (Exception e) {
        log.error(e);
    }
    return step;
}
#end_block

#method_before
public static void endJob(ExecutionContext context, boolean exitStatus) {
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (!context.getJob().isAsyncJob()) {
                context.getJob().endJob(exitStatus);
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
            if (context.shouldEndJob()) {
                Job job = JobRepositoryFactory.getJobRepository().getJob(context.getStep().getJobId());
                job.endJob(exitStatus);
            }
        }
    }
}
#method_after
public static void endJob(ExecutionContext context, boolean exitStatus) {
    Job job = context.getJob();
    try {
        if (context.isMonitored()) {
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                if (!(job.isAsyncJob() && exitStatus)) {
                    endJob(exitStatus, job);
                }
            } else {
                Step step = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && step != null) {
                    if (context.shouldEndJob()) {
                        if (job == null) {
                            job = JobRepositoryFactory.getJobRepository().getJob(step.getJobId());
                        }
                        if (job != null) {
                            endJob(exitStatus, job);
                        }
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(e);
    }
}
#end_block

#method_before
public static void endJob(ExecutionContext context, boolean exitStatus) {
    if (context.isMonitored()) {
        if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
            if (!context.getJob().isAsyncJob()) {
                context.getJob().endJob(exitStatus);
            }
        } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
            if (context.shouldEndJob()) {
                Job job = JobRepositoryFactory.getJobRepository().getJob(context.getStep().getJobId());
                job.endJob(exitStatus);
            }
        }
    }
}
#method_after
private static void endJob(boolean exitStatus, Job job) {
    job.markJobEnded(exitStatus);
    try {
        JobRepositoryFactory.getJobRepository().updateCompletedJobAndSteps(job);
    } catch (Exception e) {
        log.errorFormat("Failed to end Job {0}, {1}", job.getId(), job.getActionType().name(), e);
    }
}
#end_block

#method_before
public static ExecutionContext createDefaultContexForTasks(ExecutionContext parentContext) {
    ExecutionContext context = new ExecutionContext();
    if (parentContext != null) {
        if (parentContext.getJob() != null) {
            Step parentStep = parentContext.getParentTasksStep();
            if (parentStep != null) {
                context.setParentTasksStep(parentStep);
            }
        } else {
            context.setParentTasksStep(parentContext.getParentTasksStep());
        }
    }
    return context;
}
#method_after
public static CommandContext createDefaultContexForTasks(ExecutionContext parentContext) {
    ExecutionContext executionContext = new ExecutionContext();
    if (parentContext != null) {
        if (parentContext.getJob() != null) {
            Step parentStep = parentContext.getParentTasksStep();
            if (parentStep != null) {
                executionContext.setParentTasksStep(parentStep);
            }
        } else {
            executionContext.setParentTasksStep(parentContext.getParentTasksStep());
        }
    }
    return new CommandContext(executionContext);
}
#end_block

#method_before
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#method_after
@Override
@ExcludeClassInterceptors
public VDSBrokerFrontend getResourceManager() {
    return _resourceManger;
}
#end_block

#method_before
private void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#method_after
private static void checkDBConnectivity() {
    boolean dbUp = false;
    long expectedTimeout = System.currentTimeMillis() + DbFacade.getInstance().getOnStartConnectionTimeout();
    long waitBetweenInterval = DbFacade.getInstance().getConnectionCheckInterval();
    while (!dbUp && System.currentTimeMillis() < expectedTimeout) {
        try {
            dbUp = DbFacade.getInstance().CheckDBConnection();
            try {
                Thread.sleep(waitBetweenInterval);
            } catch (InterruptedException e) {
                log.warn("Failed to wait between connection polling attempts. " + "Original exception is: " + ExceptionUtils.getMessage(e));
            }
        } catch (RuntimeException ex) {
            log.error("Error in getting DB connection. The database is inaccessible. " + "Original exception is: " + ExceptionUtils.getMessage(ex));
        }
    }
    if (!dbUp) {
        throw new IllegalStateException("Could not obtain connection to the database." + " Please make sure that DB is up and accepting connections, and " + "restart the application.");
    }
}
#end_block

#method_before
public DateTime getStartedAt() {
    return _startedAt;
}
#method_after
@Override
public DateTime getStartedAt() {
    return _startedAt;
}
#end_block

#method_before
public void Initialize() {
    log.infoFormat("Start time: {0}", new java.util.Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new java.util.Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new java.util.Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new java.util.Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new java.util.Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new java.util.Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new java.util.Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new java.util.Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new java.util.Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new java.util.Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    initJobRepository();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance();
    log.infoFormat("TagsDirector: {0}", new Date());
    ImagesSyncronizer.getInstance();
    log.infoFormat("ImagesSyncronizer: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private void initJobRepository() {
    JobRepositoryFactory.getJobRepository().finalizeJobs();
}
#method_after
private void initJobRepository() {
    try {
        JobRepositoryFactory.getJobRepository().finalizeJobs();
    } catch (Exception e) {
        log.error("Failed to finalize running Jobs", e);
    }
}
#end_block

#method_before
private void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#method_after
private static void compensate() {
    // get all command snapshot entries
    List<KeyValue> commandSnapshots = DbFacade.getInstance().getBusinessEntitySnapshotDAO().getAllCommands();
    for (KeyValue commandSnapshot : commandSnapshots) {
        // create an instance of the related command by its class name and command id
        CommandBase<?> cmd = CommandsFactory.CreateCommand(commandSnapshot.getValue().toString(), (Guid) commandSnapshot.getKey());
        if (cmd != null) {
            cmd.compensate();
            log.infoFormat("Running compensation on startup for Command : {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        } else {
            log.errorFormat("Failed to run compensation on startup for Command {0} , Command Id : {1}", commandSnapshot.getValue(), commandSnapshot.getKey());
        }
    }
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcReturnValueBase runInternalAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, true, null);
}
#end_block

#method_before
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return runActionImpl(actionType, parameters, false, null);
}
#end_block

#method_before
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#method_after
@Override
public VdcReturnValueBase EndAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return endAction(actionType, parameters, null);
}
#end_block

#method_before
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#method_after
@Override
@ExcludeClassInterceptors
public VdcQueryReturnValue runInternalQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, false);
}
#end_block

#method_before
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runQueryImpl(actionType, parameters, true);
}
#end_block

#method_before
private VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().GetData(sessionId, "VdcUser", parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
private static VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringHelper.isNullOrEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
            returnValue.setSucceeded(false);
            returnValue.setExceptionString(VdcBllMessages.USER_IS_NOT_LOGGED_IN.toString());
            return returnValue;
        }
    }
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#method_after
@Override
public void RunAsyncQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    addSessionToContext(parameters);
    QueriesCommandBase<?> command = CommandsFactory.CreateQueryCommand(actionType, parameters);
    command.Execute();
}
#end_block

#method_before
private String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#method_after
private static String addSessionToContext(VdcQueryParametersBase parameters) {
    String sessionId = parameters.getHttpSessionId();
    boolean isAddToContext = true;
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = parameters.getSessionId();
    }
    // request
    if (StringHelper.isNullOrEmpty(sessionId)) {
        sessionId = ThreadLocalParamsContainer.getHttpSessionId();
        isAddToContext = false;
    }
    if (!StringHelper.isNullOrEmpty(sessionId) && isAddToContext) {
        ThreadLocalParamsContainer.setHttpSessionId(sessionId);
    }
    return sessionId;
}
#end_block

#method_before
@Override
public java.util.ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, false);
}
#end_block

#method_before
@Override
@ExcludeClassInterceptors
public java.util.ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#method_after
@Override
@ExcludeClassInterceptors
public ArrayList<VdcReturnValueBase> runInternalMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    return runMultipleActionsImpl(actionType, parameters, true);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#method_after
public ArrayList<VdcReturnValueBase> runMultipleActionsImpl(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (!StringHelper.isNullOrEmpty(sessionId)) {
        for (VdcActionParametersBase parameter : parameters) {
            if (StringHelper.isNullOrEmpty(parameter.getSessionId())) {
                parameter.setSessionId(sessionId);
            }
        }
    }
    MultipleActionsRunner runner = MultipleActionsRunnersFactory.CreateMultipleActionsRunner(actionType, parameters, isInternal);
    return runner.Execute();
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getErrorsTranslator() {
    return errorsTranslator;
}
#end_block

#method_before
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#method_after
@Override
@ExcludeClassInterceptors
public ErrorTranslator getVdsErrorsTranslator() {
    return _vdsErrorsTranslator;
}
#end_block

#method_before
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#method_after
@Override
public VdcReturnValueBase Login(LoginUserParameters parameters) {
    switch(parameters.getActionType()) {
        case AutoLogin:
        case LoginAdminUser:
            {
                CommandBase<?> command = CommandsFactory.CreateCommand(parameters.getActionType(), parameters);
                return command.ExecuteAction();
            }
        default:
            {
                return NotAutorizedError();
            }
    }
}
#end_block

#method_before
private VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#method_after
private static VdcReturnValueBase NotAutorizedError() {
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setCanDoAction(false);
    returnValue.getCanDoActionMessages().add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.toString());
    return returnValue;
}
#end_block

#method_before
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#method_after
@Override
public VdcReturnValueBase Logoff(LogoutUserParameters parameters) {
    return RunAction(VdcActionType.LogoutUser, parameters);
}
#end_block

#method_before
public tags GetTagByTagName(String tagName) {
    throw new NotImplementedException();
}
#method_after
public tags GetTagByTagName(@SuppressWarnings("unused") String tagName) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdsAndChildrenIdsByRegExp(String tagNameRegExp) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdsAndChildrenIdsByRegExp(@SuppressWarnings("unused") String tagNameRegExp) {
    throw new NotImplementedException();
}
#end_block

#method_before
public String GetTagIdAndChildrenIds(int tagId) {
    throw new NotImplementedException();
}
#method_after
public String GetTagIdAndChildrenIds(@SuppressWarnings("unused") int tagId) {
    throw new NotImplementedException();
}
#end_block

#method_before
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                } else {
                    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                    returnValue.setSucceeded(false);
                    returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                    return returnValue;
                }
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#method_after
@Override
public VdcQueryReturnValue RunPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    switch(actionType) {
        case GetDomainList:
        case GetLicenseProperties:
        case RegisterVds:
        case CheckDBConnection:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            {
                GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
                if (configParameters.getConfigValue() == ConfigurationValues.VdcVersion || configParameters.getConfigValue() == ConfigurationValues.ProductRPMVersion) {
                    return runQueryImpl(actionType, parameters, false);
                }
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
        default:
            {
                VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
                returnValue.setSucceeded(false);
                returnValue.setExceptionString(VdcBllMessages.USER_CANNOT_RUN_QUERY_NOT_PUBLIC.toString());
                return returnValue;
            }
    }
}
#end_block

#method_before
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    } else {
        return RunAction(actionType, parameters);
    }
}
#method_after
public VdcReturnValueBase RunUserAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    if (StringHelper.isNullOrEmpty(parameters.getHttpSessionId())) {
        return NotAutorizedError();
    }
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public java.util.ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, java.util.ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            java.util.ArrayList<VdcReturnValueBase> returnValues = new java.util.ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#method_after
public ArrayList<VdcReturnValueBase> RunUserMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters) {
    for (VdcActionParametersBase parameter : parameters) {
        if (StringHelper.isNullOrEmpty(parameter.getHttpSessionId())) {
            ArrayList<VdcReturnValueBase> returnValues = new ArrayList<VdcReturnValueBase>();
            for (int i = 0; i < parameters.size(); i++) {
                returnValues.add(NotAutorizedError());
            }
            return returnValues;
        }
    }
    return runInternalMultipleActions(actionType, parameters);
}
#end_block

#method_before
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#method_after
@Override
public VdcReturnValueBase RunAutoAction(VdcActionType actionType, VdcActionParametersBase parameters) {
    return RunAction(actionType, parameters);
}
#end_block

#method_before
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#method_after
@Override
public VdcQueryReturnValue RunAutoQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    return runInternalQuery(actionType, parameters);
}
#end_block

#method_before
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#method_after
@Override
public AsyncQueryResults GetAsyncQueryResults() {
    return BackendCallBacksDirector.getInstance().GetAsyncQueryResults();
}
#end_block

#method_before
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean isCanDoActionPassed = false;
    Step validatingStep = ExecutionHandler.addStep(executionContext, StepEnum.VALIDATING, null);
    try {
        isCanDoActionPassed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
    } finally {
        ExecutionHandler.endStep(executionContext, validatingStep, isCanDoActionPassed);
    }
    if (isCanDoActionPassed) {
        getReturnValue().setCanDoAction(true);
        getReturnValue().setIsSyncronious(true);
        getParameters().setTaskStartTime(System.currentTimeMillis());
        Execute();
    } else {
        getReturnValue().setCanDoAction(false);
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase ExecuteAction() {
    _actionState = CommandActionState.EXECUTE;
    String tempVar = getDescription();
    getReturnValue().setDescription((tempVar != null) ? tempVar : getReturnValue().getDescription());
    setActionMessageParameters();
    boolean actionAllowed = false;
    Step validatingStep = ExecutionHandler.addStep(executionContext, StepEnum.VALIDATING, null);
    try {
        actionAllowed = acquireLock() && (getReturnValue().getCanDoAction() || InternalCanDoAction());
        ExecutionHandler.endStep(executionContext, validatingStep, actionAllowed);
        if (actionAllowed) {
            getReturnValue().setCanDoAction(true);
            getReturnValue().setIsSyncronious(true);
            getParameters().setTaskStartTime(System.currentTimeMillis());
            Execute();
        } else {
            getReturnValue().setCanDoAction(false);
        }
    } finally {
        freeLock();
    }
    return getReturnValue();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected void compensate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#method_after
@SuppressWarnings({ "unchecked", "synthetic-access" })
protected void compensate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            Deserializer deserializer = SerializationFactory.getFactory().createDeserializer();
            List<BusinessEntitySnapshot> entitySnapshots = getBusinessEntitySnapshotDAO().getAllForCommandId(commandId);
            log.debugFormat("Command [id={0}]: {1} compensation data.", commandId, entitySnapshots.isEmpty() ? "No" : "Going over");
            for (BusinessEntitySnapshot snapshot : entitySnapshots) {
                Class<Serializable> snapshotClass = (Class<Serializable>) ReflectionUtils.getClassFor(snapshot.getSnapshotClass());
                Serializable snapshotData = deserializer.deserialize(snapshot.getEntitySnapshot(), snapshotClass);
                log.infoFormat("Command [id={0}]: Compensating {1} of {2}; snapshot: {3}.", commandId, snapshot.getSnapshotType(), snapshot.getEntityType(), (snapshot.getSnapshotType() == SnapshotType.CHANGED_ENTITY ? "id=" + snapshot.getEntityId() : snapshotData.toString()));
                Class<BusinessEntity<Serializable>> entityClass = (Class<BusinessEntity<Serializable>>) ReflectionUtils.getClassFor(snapshot.getEntityType());
                GenericDao<BusinessEntity<Serializable>, Serializable> daoForEntity = DbFacade.getInstance().getDaoForEntity(entityClass);
                switch(snapshot.getSnapshotType()) {
                    case CHANGED_STATUS_ONLY:
                        EntityStatusSnapshot entityStatusSnapshot = (EntityStatusSnapshot) snapshotData;
                        ((StatusAwareDao<Serializable, Enum<?>>) daoForEntity).updateStatus(entityStatusSnapshot.getId(), entityStatusSnapshot.getStatus());
                        break;
                    case CHANGED_ENTITY:
                        BusinessEntity<Serializable> entitySnapshot = (BusinessEntity<Serializable>) snapshotData;
                        if (daoForEntity.get(entitySnapshot.getId()) == null) {
                            daoForEntity.save(entitySnapshot);
                        } else {
                            daoForEntity.update(entitySnapshot);
                        }
                        break;
                    case NEW_ENTITY_ID:
                        daoForEntity.remove(snapshotData);
                        break;
                }
            }
            cleanUpCompensationData();
            return null;
        }
    });
}
#end_block

#method_before
public VdcReturnValueBase EndAction() {
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase EndAction() {
    ExecutionHandler.startFinalizingStep(executionContext);
    try {
        SetActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        if (getCommandShouldBeLogged()) {
            LogCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
protected boolean validateInputs() {
    List<Class<?>> validationGroupList = getValidationGroups();
    Set<ConstraintViolation<T>> violations = validator.validate(getParameters(), ((Class<?>[]) validationGroupList.toArray(new Class<?>[validationGroupList.size()])));
    if (!violations.isEmpty()) {
        ArrayList<String> msgs = getReturnValue().getCanDoActionMessages();
        for (ConstraintViolation<T> constraintViolation : violations) {
            msgs.add(constraintViolation.getMessage());
        }
        return false;
    }
    return true;
}
#method_after
protected boolean validateInputs() {
    List<Class<?>> validationGroupList = getValidationGroups();
    Set<ConstraintViolation<T>> violations = validator.validate(getParameters(), validationGroupList.toArray(new Class<?>[validationGroupList.size()]));
    if (!violations.isEmpty()) {
        ArrayList<String> msgs = getReturnValue().getCanDoActionMessages();
        for (ConstraintViolation<T> constraintViolation : violations) {
            msgs.add(constraintViolation.getMessage());
        }
        return false;
    }
    return true;
}
#end_block

#method_before
protected void setActionMessageParameters() {
}
#method_after
protected void setActionMessageParameters() {
// No-op method for inheritors to implement
}
#end_block

#method_before
private void Execute() {
    Step executionStep = ExecutionHandler.addStep(executionContext, StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (getReturnValue().getTaskIdList().isEmpty()) {
                ExecutionHandler.endStep(executionContext, executionStep, getSucceeded());
                ExecutionHandler.endJob(executionContext, getSucceeded());
            }
        }
    }
}
#method_after
private void Execute() {
    ExecutionHandler.addStep(executionContext, StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            freeLock();
            if (getCommandShouldBeLogged()) {
                LogCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                UpdateTasksWithActionParameters();
                StartPollingAsyncTasks();
            }
        } finally {
            if (getReturnValue().getTaskIdList().isEmpty()) {
                ExecutionHandler.endJob(executionContext, getSucceeded());
            }
        }
    }
}
#end_block

#method_before
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        try {
            retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        } catch (RuntimeException ex) {
            log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
        }
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid CreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        // TODO: Set step description by resource bundle which holds the message and populate its properties by the
        // command.
        Step taskStep = ExecutionHandler.addTaskStep(executionContext, StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), null);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        retValue = ConcreteCreateTask(asyncTaskCreationInfo, parentCommand);
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#end_block

#method_before
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    throw new NotImplementedException();
}
#method_after
@SuppressWarnings("unused")
protected Guid ConcreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    throw new NotImplementedException();
}
#end_block

#method_before
protected void RevertTasks() {
    if (getParameters().getTaskIds() != null) {
        // list to send to the PollTasks mathod
        java.util.ArrayList<Guid> taskIdAsList = new java.util.ArrayList<Guid>();
        for (Guid taskId : getParameters().getTaskIds()) {
            taskIdAsList.add(taskId);
            java.util.ArrayList<AsyncTaskStatus> tasksStatuses = AsyncTaskManager.getInstance().PollTasks(taskIdAsList);
            // call revert task only if ended succeesfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                SPMTaskGuidBaseVDSCommandParameters tempVar = new SPMTaskGuidBaseVDSCommandParameters(getStoragePool().getId(), taskId);
                tempVar.setCompatibilityVersion(getStoragePool().getcompatibility_version().toString());
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, tempVar);
            }
            taskIdAsList.clear();
        }
    }
}
#method_after
protected void RevertTasks() {
    if (getParameters().getTaskIds() != null) {
        // list to send to the PollTasks method
        java.util.ArrayList<Guid> taskIdAsList = new java.util.ArrayList<Guid>();
        for (Guid taskId : getParameters().getTaskIds()) {
            taskIdAsList.add(taskId);
            java.util.ArrayList<AsyncTaskStatus> tasksStatuses = AsyncTaskManager.getInstance().PollTasks(taskIdAsList);
            // call revert task only if ended successfully
            if (tasksStatuses.get(0).getTaskEndedSuccessfully()) {
                SPMTaskGuidBaseVDSCommandParameters tempVar = new SPMTaskGuidBaseVDSCommandParameters(getStoragePool().getId(), taskId);
                tempVar.setCompatibilityVersion(getStoragePool().getcompatibility_version().toString());
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMRevertTask, tempVar);
            }
            taskIdAsList.clear();
        }
    }
}
#end_block

#method_before
@Override
public Object runInTransaction() {
    if (_actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
        return null;
    } else {
        endActionInTransactionScope();
        return null;
    }
}
#method_after
@Override
public Object runInTransaction() {
    if (_actionState == CommandActionState.EXECUTE) {
        executeActionInTransactionScope();
    } else {
        endActionInTransactionScope();
    }
    return null;
}
#end_block

#method_before
void initTable(ApplicationResources resources) {
    getTable().addColumn(new DcStatusColumn(), "", "30px");
    TextColumnWithTooltip<storage_pool> nameColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getname();
        }
    };
    getTable().addColumn(nameColumn, "Name");
    TextColumnWithTooltip<storage_pool> storageTypeColumn = new EnumColumn<storage_pool, StorageType>() {

        @Override
        public StorageType getRawValue(storage_pool object) {
            return object.getstorage_pool_type();
        }
    };
    getTable().addColumn(storageTypeColumn, "Storage Type");
    TextColumnWithTooltip<storage_pool> statusColumn = new EnumColumn<storage_pool, StoragePoolStatus>() {

        @Override
        public StoragePoolStatus getRawValue(storage_pool object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, "Status");
    TextColumnWithTooltip<storage_pool> versionColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getcompatibility_version().getValue();
        }
    };
    getTable().addColumn(versionColumn, "Compatibility Version");
    TextColumnWithTooltip<storage_pool> descColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getdescription();
        }
    };
    getTable().addColumn(descColumn, "Description");
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("New") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Edit") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Force Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getForceRemoveCommand();
        }
    });
    List<ActionButtonDefinition<storage_pool>> resourceSubActions = ReportsHelper.getInstance().getResourceSubActions("DataCenter", getMainModel());
    if (resourceSubActions != null && resourceSubActions.size() > 0) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<storage_pool>("Show Report", resourceSubActions));
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<storage_pool>("Guide Me", resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources) {
    getTable().addColumn(new DcStatusColumn(), "", "30px");
    TextColumnWithTooltip<storage_pool> nameColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getname();
        }
    };
    getTable().addColumn(nameColumn, "Name");
    TextColumnWithTooltip<storage_pool> storageTypeColumn = new EnumColumn<storage_pool, StorageType>() {

        @Override
        public StorageType getRawValue(storage_pool object) {
            return object.getstorage_pool_type();
        }
    };
    getTable().addColumn(storageTypeColumn, "Storage Type");
    TextColumnWithTooltip<storage_pool> statusColumn = new EnumColumn<storage_pool, StoragePoolStatus>() {

        @Override
        public StoragePoolStatus getRawValue(storage_pool object) {
            return object.getstatus();
        }
    };
    getTable().addColumn(statusColumn, "Status");
    TextColumnWithTooltip<storage_pool> versionColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getcompatibility_version().getValue();
        }
    };
    getTable().addColumn(versionColumn, "Compatibility Version");
    TextColumnWithTooltip<storage_pool> descColumn = new TextColumnWithTooltip<storage_pool>() {

        @Override
        public String getValue(storage_pool object) {
            return object.getdescription();
        }
    };
    getTable().addColumn(descColumn, "Description");
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("New") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Edit") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Force Remove") {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getForceRemoveCommand();
        }
    });
    List<ActionButtonDefinition<storage_pool>> resourceSubActions = ReportsHelper.getInstance().getResourceSubActions("DataCenter", getMainModel());
    if (resourceSubActions != null && resourceSubActions.size() > 0) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<storage_pool>("Show Report", resourceSubActions));
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<storage_pool>("Guide Me", resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<storage_pool>("Re-Initialize Data Center", true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRecoveryStorageCommand();
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters(ErrorPopupView.class, DefaultConfirmationPopupView.class);
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    // MAIN SECTION: -POPUPS-
    bindPresenterWidget(RemoveConfirmationPopupPresenterWidget.class, RemoveConfirmationPopupPresenterWidget.ViewDef.class, RemoveConfirmationPopupView.class);
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(DataCenterNetworkPopupPresenterWidget.class, DataCenterNetworkPopupPresenterWidget.ViewDef.class, DataCenterNetworkPopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNewNetworkPopupPresenterWidget.class, ClusterNewNetworkPopupPresenterWidget.ViewDef.class, ClusterNewNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters(ErrorPopupView.class, DefaultConfirmationPopupView.class);
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    // MAIN SECTION: -POPUPS-
    bindPresenterWidget(RemoveConfirmationPopupPresenterWidget.class, RemoveConfirmationPopupPresenterWidget.ViewDef.class, RemoveConfirmationPopupView.class);
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(DataCenterNetworkPopupPresenterWidget.class, DataCenterNetworkPopupPresenterWidget.ViewDef.class, DataCenterNetworkPopupView.class);
    // Cluster
    bindPresenterWidget(ClusterNewNetworkPopupPresenterWidget.class, ClusterNewNetworkPopupPresenterWidget.ViewDef.class, ClusterNewNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(VmDesktopNewPopupPresenterWidget.class, VmDesktopNewPopupPresenterWidget.ViewDef.class, VmDesktopNewPopupView.class);
    bindPresenterWidget(VmServerNewPopupPresenterWidget.class, VmServerNewPopupPresenterWidget.ViewDef.class, VmServerNewPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
}
#end_block

#method_before
public String getItemsCountString() {
    if (getItems() == null) {
        return "";
    }
    int fromItemCount = getSearchPageSize() * (getSearchPageNumber() - 1) + 1;
    int toItemCount = (fromItemCount - 1) + ((ArrayList<Object>) getItems()).size();
    if (toItemCount == 0 || fromItemCount > toItemCount) {
        return "";
    }
    return fromItemCount + "-" + toItemCount;
}
#method_after
public String getItemsCountString() {
    if (getItems() == null) {
        return "";
    }
    int fromItemCount = getSearchPageSize() * (getSearchPageNumber() - 1) + 1;
    int toItemCount = (fromItemCount - 1) + ((List) getItems()).size();
    if (toItemCount == 0 || fromItemCount > toItemCount) {
        return "";
    }
    return fromItemCount + "-" + toItemCount;
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<storage_pool, DataCenterListModel> getDataCenterListProvider(ClientGinjector ginjector, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider) {
    return new MainTabModelProvider<storage_pool, DataCenterListModel>(ginjector, DataCenterListModel.class) {

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else {
                return super.getModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<storage_pool, DataCenterListModel> getDataCenterListProvider(ClientGinjector ginjector, final Provider<DataCenterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RecoveryStoragePopupPresenterWidget> recoveryStorageConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider) {
    return new MainTabModelProvider<storage_pool, DataCenterListModel>(ginjector, DataCenterListModel.class) {

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else {
                return super.getModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand() || lastExecutedCommand == getModel().getForceRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRecoveryStorageCommand()) {
                return recoveryStorageConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    // LINQ 29456
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNetworkInterface oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    // LINQ 29456
    if (!StringHelper.EqOp(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check if user change the mac
    boolean macChanged = false;
    if (!StringHelper.EqOp(oldIface.getMacAddress(), getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        macChanged = true;
        MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses, getVm().getvds_group_compatibility_version().toString());
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__ACTION__UPDATE.toString());
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__TYPE__INTERFACE.toString());
    // return false;
    // }
    List allDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        List<VmNetworkInterface> ifaces = new ArrayList<VmNetworkInterface>(interfaces);
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    // LINQ 29456
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNetworkInterface oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    // LINQ 29456
    if (!StringHelper.EqOp(oldIface.getName(), getParameters().getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check if user change the mac
    boolean macChanged = false;
    if (!StringHelper.EqOp(oldIface.getMacAddress(), getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        macChanged = true;
        MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getParameters().getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__ACTION__UPDATE.toString());
    // ReturnValue.CanDoActionMessages.Add(VdcBllMessages.VAR__TYPE__INTERFACE.toString());
    // return false;
    // }
    List allDisks = DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId());
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for versions 2.1, 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        List<VmNetworkInterface> ifaces = new ArrayList<VmNetworkInterface>(interfaces);
        interfaces.remove(oldIface);
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        interfaces.add(oldIface);
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        String mac = null;
        RefObject<String> tempRefObject = new RefObject<String>(mac);
        MacPoolManager.getInstance().allocateNewMac(tempRefObject);
        mac = tempRefObject.argvalue;
        getParameters().getInterface().setMacAddress(mac);
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice iface = new VmDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), VmDeviceType.getName(VmDeviceType.INTERFACE), VmDeviceType.getName(VmDeviceType.BRIDGE), "", 0, "", true, false, false, false);
    dbFacade.getVmDeviceDAO().save(iface);
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        String mac = null;
        RefObject<String> tempRefObject = new RefObject<String>(mac);
        MacPoolManager.getInstance().allocateNewMac(tempRefObject);
        mac = tempRefObject.argvalue;
        getParameters().getInterface().setMacAddress(mac);
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice iface = new VmDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), VmDeviceType.getName(VmDeviceType.INTERFACE), VmDeviceType.getName(VmDeviceType.BRIDGE), "", 0, "", true, true, false);
    dbFacade.getVmDeviceDAO().save(iface);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down && vmDynamic.getstatus() != VMStatus.ImageLocked) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // return false;
    // }
    List<DiskImageBase> allDisks = LinqUtils.foreach(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId()), new Function<DiskImage, DiskImageBase>() {

        @Override
        public DiskImageBase eval(DiskImage diskImage) {
            return diskImage;
        }
    });
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // this must be the last check because it's add mac to the pool
    if (!StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses, getVm().getvds_group_compatibility_version().toString());
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDAO().get(getParameters().getVmId());
    if (vmDynamic.getstatus() != VMStatus.Down && vmDynamic.getstatus() != VMStatus.ImageLocked) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN);
        return false;
    }
    VmStatic vm = DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId());
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    // LINQ 29456
    // List<DiskImageBase> allDisks =
    // DbFacade.Instance.GetImagesByVmGuid(AddVmInterfaceParameters.VmId).Select(a
    // => (DiskImageBase)a).ToList();
    // if (!CheckPCIAndIDELimit(vm.num_of_monitors, allInterfaces,
    // allDisks))
    // {
    // return false;
    // }
    List<DiskImageBase> allDisks = LinqUtils.foreach(DbFacade.getInstance().getDiskImageDAO().getAllForVm(getParameters().getVmId()), new Function<DiskImage, DiskImageBase>() {

        @Override
        public DiskImageBase eval(DiskImage diskImage) {
            return diskImage;
        }
    });
    if (!CheckPCIAndIDELimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check that the number of interfaces does not exceed limit. Necessary
    // only for version 2.2.
    boolean limitNumOfNics = Config.<Boolean>GetValue(ConfigValues.LimitNumberOfNetworkInterfaces, getVm().getvds_group_compatibility_version().toString());
    if (limitNumOfNics) {
        boolean numOfNicsLegal = validateNumberOfNics(interfaces, getParameters().getInterface());
        if (!numOfNicsLegal) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_EXITED_MAX_INTERFACES);
            return false;
        }
    }
    // this must be the last check because it's add mac to the pool
    if (!StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getParameters().getInterface().getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        if (!MacPoolManager.getInstance().AddMac(getParameters().getInterface().getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    // check that the exists in current cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(vm.getvds_group_id());
    // AddVmInterfaceParameters.Interface.network_name))
    if (null == LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network network) {
            return network.getname().equals(getParameters().getInterface().getNetworkName());
        }
    })) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
        return false;
    }
    return super.canDoAction();
}
#end_block

#method_before
@XmlElement(name = "runAsUser", defaultValue = "false")
public boolean isRunAsUser() {
    return isRunAsUser;
}
#method_after
public boolean isRunAsUser() {
    return runAsUser;
}
#end_block

#method_before
public void setRunAsUser(boolean isRunAsUser) {
    this.isRunAsUser = isRunAsUser;
}
#method_after
public void setRunAsUser(boolean isRunAsUser) {
    this.runAsUser = isRunAsUser;
}
#end_block

#method_before
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the _type field");
    return null;
}
#method_after
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the type field");
    return null;
}
#end_block

#method_before
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the _type field");
    return null;
}
#method_after
private static Field getQueryTypeField() {
    for (Field f : QueriesCommandBase.class.getDeclaredFields()) {
        if (f.getName().equals("type")) {
            f.setAccessible(true);
            return f;
        }
    }
    fail("Can't find the type field");
    return null;
}
#end_block

#method_before
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Map<String, Map<String, Object>> map = getInstance().deleteOldGeneration();
    if (map != null && !map.isEmpty()) {
        Map<String, Guid> userSessionMap = new HashMap<String, Guid>();
        for (Map.Entry<String, Map<String, Object>> entry : map.entrySet()) {
            VdcUser user = (VdcUser) entry.getValue().get("VdcUser");
            if (user != null) {
                userSessionMap.put(entry.getKey(), user.getUserId());
            }
        }
        if (!userSessionMap.isEmpty()) {
            DbFacade.getInstance().getDbUserDAO().removeUserSessions(userSessionMap);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Map<String, Map<String, Object>> map = deleteOldGeneration();
    if (map != null && !map.isEmpty()) {
        Map<String, Guid> userSessionMap = new HashMap<String, Guid>();
        for (Map.Entry<String, Map<String, Object>> entry : map.entrySet()) {
            VdcUser user = (VdcUser) entry.getValue().get("VdcUser");
            if (user != null) {
                userSessionMap.put(entry.getKey(), user.getUserId());
            }
        }
        if (!userSessionMap.isEmpty()) {
            DbFacade.getInstance().getDbUserDAO().removeUserSessions(userSessionMap);
        }
    }
}
#end_block

#method_before
public java.util.ArrayList<VdcActionParametersBase> getImagesParameters() {
    if (imagesParameters == null) {
        imagesParameters = new java.util.ArrayList<VdcActionParametersBase>();
    }
    return imagesParameters;
}
#method_after
public ArrayList<VdcActionParametersBase> getImagesParameters() {
    if (imagesParameters == null) {
        imagesParameters = new ArrayList<VdcActionParametersBase>();
    }
    return imagesParameters;
}
#end_block

#method_before
public void setImagesParameters(java.util.ArrayList<VdcActionParametersBase> value) {
    imagesParameters = value;
}
#method_after
public void setImagesParameters(ArrayList<VdcActionParametersBase> value) {
    imagesParameters = value;
}
#end_block

#method_before
public java.util.ArrayList<Guid> getTaskIds() {
    return taskIds;
}
#method_after
public ArrayList<Guid> getTaskIds() {
    return taskIds;
}
#end_block

#method_before
public void setTaskIds(java.util.ArrayList<Guid> value) {
    taskIds = value;
}
#method_after
public void setTaskIds(ArrayList<Guid> value) {
    taskIds = value;
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    // return mac to pool
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    // LINQ 29456
    // Interface iface = interfaces.FirstOrDefault(i => i.id ==
    // RemoveVmInterfaceParameters.InterfaceId);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterfaceId());
        }
    });
    // LINQ 29456
    if (iface != null) {
        MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        _interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getInterfaceTranslation().toString();
        if (interType != null) {
            AddCustomValue("InterfaceType", interType);
        }
    }
    // remove from db
    DbFacade.getInstance().getVmNetworkInterfaceDAO().remove(getParameters().getInterfaceId());
    DbFacade.getInstance().getVmNetworkStatisticsDAO().remove(getParameters().getInterfaceId());
    DbFacade.getInstance().getVmDeviceDAO().remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    // return mac to pool
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(getParameters().getVmId());
    // LINQ 29456
    // Interface iface = interfaces.FirstOrDefault(i => i.id ==
    // RemoveVmInterfaceParameters.InterfaceId);
    VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getParameters().getInterfaceId());
        }
    });
    // LINQ 29456
    if (iface != null) {
        MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        _interfaceName = iface.getName();
        // Get Interface type.
        String interType = VmInterfaceType.forValue(iface.getType()).getInterfaceTranslation().toString();
        if (interType != null) {
            AddCustomValue("InterfaceType", interType);
        }
    }
    // remove from db
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().remove(getParameters().getInterfaceId());
    dbFacade.getVmNetworkStatisticsDAO().remove(getParameters().getInterfaceId());
    dbFacade.getVmDeviceDAO().remove(new VmDeviceId(getParameters().getInterfaceId(), getParameters().getVmId()));
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        String mac = null;
        RefObject<String> tempRefObject = new RefObject<String>(mac);
        MacPoolManager.getInstance().allocateNewMac(tempRefObject);
        mac = tempRefObject.argvalue;
        getParameters().getInterface().setMacAddress(mac);
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade.getInstance().getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    DbFacade.getInstance().getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice iface = new VmDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), VmDeviceCommonUtils.INTERFACE, VmDeviceCommonUtils.BRIDGE, "", 0, "", true, false, false, false);
    DbFacade.getInstance().getVmDeviceDAO().save(iface);
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getInterfaceTranslation()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringHelper.isNullOrEmpty(getParameters().getInterface().getMacAddress())) {
        String mac = null;
        RefObject<String> tempRefObject = new RefObject<String>(mac);
        MacPoolManager.getInstance().allocateNewMac(tempRefObject);
        mac = tempRefObject.argvalue;
        getParameters().getInterface().setMacAddress(mac);
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDAO().save(getParameters().getInterface());
    dbFacade.getVmNetworkStatisticsDAO().save(getParameters().getInterface().getStatistics());
    VmDevice iface = new VmDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmId()), VmDeviceType.getName(VmDeviceType.INTERFACE), VmDeviceType.getName(VmDeviceType.BRIDGE), "", 0, "", true, false, false, false);
    dbFacade.getVmDeviceDAO().save(iface);
    setSucceeded(true);
}
#end_block

#method_before
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static void updateVmDevices(Guid newVmId) {
    VmStatic newVmStatic = DbFacade.getInstance().getVmDAO().get(newVmId).getStaticData();
    updateCdInVmDevice(newVmStatic);
    updateBootOrderInVmDevice(newVmStatic);
    updateNumOfMonitorsInVmDevice(newVmStatic);
}
#method_after
/**
 * Update the vm devices according to changes made in vm static for new VM
 */
public static void updateVmDevices(Guid newVmId) {
    vm = DbFacade.getInstance().getVmDAO().get(newVmId);
    VmStatic newVmStatic = vm.getStaticData();
    updateCdInVmDevice(newVmStatic);
    updateBootOrderInVmDevice(newVmStatic);
    updateNumOfMonitorsInVmDevice(newVmStatic);
}
#end_block

#method_before
private static void updateCdInVmDevice(VmStatic oldVmStatic, VmStatic newVmStatic) {
    if (oldVmStatic.getiso_path().isEmpty() && !newVmStatic.getiso_path().isEmpty()) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM, "", 0, newVmStatic.getiso_path(), true, false, false, false);
        DbFacade.getInstance().getVmDeviceDAO().save(cd);
    } else if (!oldVmStatic.getiso_path().isEmpty() && newVmStatic.getiso_path().isEmpty()) {
        // existing CD was removed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM);
        DbFacade.getInstance().getVmDeviceDAO().remove(list.get(0).getId());
    } else {
        // CD was changed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM);
        VmDevice cd = list.get(0);
        cd.setSpecParams(newVmStatic.getiso_path());
        DbFacade.getInstance().getVmDeviceDAO().save(cd);
    }
}
#method_after
private static void updateCdInVmDevice(VmStatic oldVmStatic, VmStatic newVmStatic) {
    if (oldVmStatic.getiso_path().isEmpty() && !newVmStatic.getiso_path().isEmpty()) {
        // new CD was added
        VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmStatic.getiso_path(), true, false, false, false);
        DbFacade.getInstance().getVmDeviceDAO().save(cd);
    } else if (!oldVmStatic.getiso_path().isEmpty() && newVmStatic.getiso_path().isEmpty()) {
        // existing CD was removed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
        DbFacade.getInstance().getVmDeviceDAO().remove(list.get(0).getId());
    } else {
        // CD was changed
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdTypeAndDevice(newVmStatic.getId(), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM));
        VmDevice cd = list.get(0);
        cd.setSpecParams(newVmStatic.getiso_path());
        DbFacade.getInstance().getVmDeviceDAO().update(cd);
    }
}
#end_block

#method_before
/**
 * updates new VM CD ROM in vm_device
 * @param newVmStatic
 */
private static void updateCdInVmDevice(VmStatic newVmStatic) {
    // new CD was added
    VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceCommonUtils.DISK, VmDeviceCommonUtils.CDROM, "", 0, newVmStatic.getiso_path(), true, false, false, false);
    DbFacade.getInstance().getVmDeviceDAO().save(cd);
}
#method_after
/**
 * updates new VM CD ROM in vm_device
 * @param newVmStatic
 */
private static void updateCdInVmDevice(VmStatic newVmStatic) {
    // new CD was added
    VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newVmStatic.getId()), VmDeviceType.getName(VmDeviceType.DISK), VmDeviceType.getName(VmDeviceType.CDROM), "", 0, newVmStatic.getiso_path(), true, false, false, false);
    DbFacade.getInstance().getVmDeviceDAO().save(cd);
}
#end_block

#method_before
private static void updateBootOrderInVmDevice(VmStatic newStatic) {
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(newStatic.getId());
    int bootOrder = 1;
    switch(newStatic.getdefault_boot_sequence()) {
        case C:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case CD:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
    }
    // update boot order in vm device
    for (VmDevice device : devices) {
        DbFacade.getInstance().getVmDeviceDAO().save(device);
    }
}
#method_after
private static void updateBootOrderInVmDevice(VmStatic newStatic) {
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmId(newStatic.getId());
    int bootOrder = 1;
    switch(newStatic.getdefault_boot_sequence()) {
        case C:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case CD:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder);
            break;
    }
    // update boot order in vm device
    for (VmDevice device : devices) {
        DbFacade.getInstance().getVmDeviceDAO().update(device);
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceCommonUtils.INTERFACE) && device.getDevice().equals(VmDeviceCommonUtils.BRIDGE)) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.BRIDGE))) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceCommonUtils.DISK) && device.getDevice().equals(VmDeviceCommonUtils.CDROM)) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM))) {
            device.setBootOrder(bootOrder++);
            // only one CD is currently supported.
            break;
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceCommonUtils.DISK) && device.getDevice().equals(VmDeviceCommonUtils.DISK)) {
            device.setBootOrder(bootOrder++);
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(List<VmDevice> devices, int bootOrder) {
    boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm);
    for (VmDevice device : devices) {
        if (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK))) {
            if (isOldCluster) {
                // old version.
                if (DbFacade.getInstance().getDiskDao().get(device.getDeviceId()).getDiskType().equals(DiskType.System)) {
                    device.setBootOrder(bootOrder++);
                    break;
                }
            } else {
                // supporting more than 1 bootable disk in 3.1 and up.
                device.setBootOrder(bootOrder++);
            }
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmStatic oldVmStatic, VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > oldVmStatic.getnum_of_monitors()) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = oldVmStatic.getnum_of_monitors(); i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceCommonUtils.VIDEO, DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceCommonUtils.VIDEO);
        for (int i = 1; i <= (oldVmStatic.getnum_of_monitors() - newStatic.getnum_of_monitors()); i++) {
            DbFacade.getInstance().getVmDeviceDAO().remove(list.get(i).getId());
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmStatic oldVmStatic, VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > oldVmStatic.getnum_of_monitors()) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = oldVmStatic.getnum_of_monitors(); i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.getName(VmDeviceType.VIDEO), DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    } else {
        // delete video cards
        List<VmDevice> list = DbFacade.getInstance().getVmDeviceDAO().getVmDeviceByVmIdAndType(newStatic.getId(), VmDeviceType.getName(VmDeviceType.VIDEO));
        for (int i = 1; i <= (oldVmStatic.getnum_of_monitors() - newStatic.getnum_of_monitors()); i++) {
            DbFacade.getInstance().getVmDeviceDAO().remove(list.get(i).getId());
        }
    }
}
#end_block

#method_before
private static void updateNumOfMonitorsInVmDevice(VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > 0) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = 1; i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceCommonUtils.VIDEO, DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    }
}
#method_after
private static void updateNumOfMonitorsInVmDevice(VmStatic newStatic) {
    if (newStatic.getnum_of_monitors() > 0) {
        String mem = (newStatic.getnum_of_monitors() > 2 ? LOW_VIDEO_MEM : HIGH_VIDEO_MEM);
        // monitors were added
        for (int i = 1; i <= newStatic.getnum_of_monitors(); i++) {
            VmDevice cd = new VmDevice(new VmDeviceId(Guid.NewGuid(), newStatic.getId()), VmDeviceType.getName(VmDeviceType.VIDEO), DisplayType.qxl.name(), "", 0, mem, true, false, false, false);
            DbFacade.getInstance().getVmDeviceDAO().save(cd);
        }
    }
}
#end_block

#method_before
public static boolean isNetwork(VmDevice device) {
    return (device.getType().equals(INTERFACE));
}
#method_after
public static boolean isNetwork(VmDevice device) {
    return (device.getType().equals(VmDeviceType.getName(VmDeviceType.INTERFACE)));
}
#end_block

#method_before
public static boolean isDisk(VmDevice device) {
    return (device.getType().equals(DISK) && device.getDevice().equals(DISK));
}
#method_after
public static boolean isDisk(VmDevice device) {
    return (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.DISK)));
}
#end_block

#method_before
public static boolean isCD(VmDevice device) {
    return (device.getType().equals(DISK) && device.getDevice().equals(CDROM));
}
#method_after
public static boolean isCD(VmDevice device) {
    return (device.getType().equals(VmDeviceType.getName(VmDeviceType.DISK)) && device.getDevice().equals(VmDeviceType.getName(VmDeviceType.CDROM)));
}
#end_block

#method_before
public static BootSequence getBootSequence(List<VmDevice> devices) {
    BootSequence ret = BootSequence.C;
    String seq = "";
    for (VmDevice device : devices) {
        if (device.getBootOrder() > 0) {
            if (isNetwork(device) && seq.indexOf('N') < 0) {
                seq.concat("N");
            }
            if (isDisk(device) && seq.indexOf('C') < 0) {
                seq.concat("C");
            }
            if (isCD(device) && seq.indexOf('D') < 0) {
                seq.concat("D");
            }
            // maximum string is 3 characters, so, if reached , exit loop.
            if (seq.length() == 3) {
                break;
            }
        }
    }
    for (BootSequence bs : BootSequence.values()) {
        if (bs.name().equals(seq)) {
            ret = bs;
        }
    }
    return ret;
}
#method_after
public static BootSequence getBootSequence(List<VmDevice> devices) {
    BootSequence ret = BootSequence.C;
    String seq = "";
    for (VmDevice device : devices) {
        if (device.getBootOrder() > 0) {
            if (isNetwork(device) && seq.indexOf('N') < 0) {
                seq.concat("N");
            }
            if (isDisk(device) && seq.indexOf('C') < 0) {
                seq.concat("C");
            }
            if (isCD(device) && seq.indexOf('D') < 0) {
                seq.concat("D");
            }
            // maximum string is 3 characters, so, if reached , exit loop.
            if (seq.length() == 3) {
                break;
            }
        }
    }
    for (BootSequence bs : BootSequence.values()) {
        if (bs.name().equals(seq)) {
            ret = bs;
            break;
        }
    }
    return ret;
}
#end_block

#method_before
@XmlElement(name = "guest_requested_memory")
public String getHash() {
    return mVmDynamic.getHash();
}
#method_after
@XmlElement(name = "hash")
public String getHash() {
    return mVmDynamic.getHash();
}
#end_block

#method_before
public static String getDefaultNamingContextFromNameingContexts(Attribute namingContexts) {
    for (int index = 0; index < namingContexts.size(); ++index) {
        String namingContext;
        try {
            namingContext = (String) namingContexts.get(index);
        } catch (NamingException e) {
            log.error("Failed getting naming contexts from root DSE", e);
            return null;
        }
        if (!namingContext.equalsIgnoreCase("o=netscaperoot")) {
            return namingContext;
        }
    }
    return null;
}
#method_after
public static String getDefaultNamingContextFromNameingContexts(Attribute namingContexts) {
    for (int index = 0; index < namingContexts.size(); ++index) {
        String namingContext;
        try {
            namingContext = (String) namingContexts.get(index);
        } catch (NamingException e) {
            log.error("Failed getting naming contexts from root DSE", e);
            return null;
        }
        if (!RHDS_NAMING_CONTEXT.equalsIgnoreCase(namingContext)) {
            return namingContext;
        }
    }
    return null;
}
#end_block

#method_before
public LdapProviderType retrieveLdapProviderType(String domain) {
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            return LdapProviderType.activeDirectory;
        } else if (attributes.get(RHDSRootDSEAttributes.netscapemdsuffix.name()) != null) {
            return LdapProviderType.rhds;
        } else {
            return LdapProviderType.ipa;
        }
    } else {
        return LdapProviderType.general;
    }
}
#method_after
public LdapProviderType retrieveLdapProviderType(String domain) {
    LdapProviderType retVal = LdapProviderType.general;
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            retVal = LdapProviderType.activeDirectory;
        } else if (attributes.get(RHDSRootDSEAttributes.netscapemdsuffix.name()) != null) {
            retVal = LdapProviderType.rhds;
        } else if (attributes.get(IPARootDSEAttributes.namingContexts.name()) != null) {
            retVal = LdapProviderType.ipa;
        }
    }
    return retVal;
}
#end_block

#method_before
private static void prepareQueryFormatters() {
    activeDirectorySearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "sAMAccountType=805306368");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "userPrincipalName");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "ObjectCategory=Group");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "name");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "samaccountname");
    ipaSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=posixAccount)(objectClass=krbPrincipalAux)");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "krbPrincipalName");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=ipaUserGroup");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    dsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    // We put here a duplicate. Need to solve it in another way.
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupofuniquenames");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
}
#method_after
private static void prepareQueryFormatters() {
    activeDirectorySearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "sAMAccountType=805306368");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "userPrincipalName");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "ObjectCategory=Group");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "name");
    activeDirectorySearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "samaccountname");
    ipaSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=posixAccount)(objectClass=krbPrincipalAux)");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "krbPrincipalName");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=ipaUserGroup");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    ipaSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
    dsSearchSyntaxMap = new EnumMap<SearchLangageLDAPTokens, String>(SearchLangageLDAPTokens.class);
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$GIVENNAME, "givenname");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_TYPE, "&(objectClass=person)");
    // We put here a duplicate. Need to solve it in another way.
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$PRINCIPAL_NAME, "uid");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$LDAP_GROUP_CATEGORY, "objectClass=groupOfUniqueNames");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$CN, "cn");
    dsSearchSyntaxMap.put(SearchLangageLDAPTokens.$USER_ACCOUNT_NAME, "uid");
}
#end_block

#method_before
private InstallVdsCommand<InstallVdsParameters> createCommand(InstallVdsParameters params) {
    InstallVdsCommand<InstallVdsParameters> command = spy(new InstallVdsCommand<InstallVdsParameters>(params));
    doReturn(vdsDAO).when(command).getVdsDAO();
    doReturn(vdsDynamicDAO).when(command).getVdsDynamicDAO();
    return command;
}
#method_after
private InstallVdsCommand<InstallVdsParameters> createCommand(InstallVdsParameters params) {
    return new InstallVdsCommand<InstallVdsParameters>(params);
}
#end_block

#method_before
@Test
public void canDoActionSucceeds() {
    mockVdsDynamicWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertTrue(command.canDoAction());
}
#method_after
@Test
public void canDoActionSucceeds() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertTrue(command.canDoAction());
}
#end_block

#method_before
@Test
public void canDoActionFailsNullParameterForIsoFile() {
    mockVdsDynamicWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(null);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#method_after
@Test
public void canDoActionFailsNullParameterForIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(null);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#end_block

#method_before
@Test
public void canDoActionFailsMissingIsoFile() {
    mockVdsDynamicWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(INVALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#method_after
@Test
public void canDoActionFailsMissingIsoFile() {
    mockVdsWithOsVersion(VALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(INVALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
}
#end_block

#method_before
@Test
public void canDoActionFailsIsoVersionNotCompatible() {
    mockVdsDynamicWithOsVersion(INVALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
}
#method_after
@Test
public void canDoActionFailsIsoVersionNotCompatible() {
    mockVdsWithOsVersion(INVALID_OVIRT_VERSION);
    InstallVdsParameters param = createParameters();
    param.setoVirtIsoFile(VALID_VERSION_OVIRT_ISO_FILENAME);
    InstallVdsCommand<InstallVdsParameters> command = createCommand(param);
    assertFailsWithCanDoActionMessage(command, VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        retValue = false;
    } else if (isOvirtReInstallOrUpgrade()) {
        String isoFile = getParameters().getoVirtIsoFile();
        if (!isIsoFileValid(isoFile)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
            retValue = false;
        } else if (!isIsoVersionCompatible(isoFile)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVdsId() == null || getVdsId().equals(Guid.Empty)) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        retValue = false;
    } else if (getVds() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
        retValue = false;
    } else if (isOvirtReInstallOrUpgrade()) {
        String isoFile = getParameters().getoVirtIsoFile();
        if (!isIsoFileValid(isoFile)) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_MISSING_IMAGE_FILE);
            retValue = false;
        } else {
            RpmVersion ovirtHostOsVersion = VdsHandler.getOvirtHostOsVersion(getVds());
            if (ovirtHostOsVersion != null && !isIsoVersionCompatible(ovirtHostOsVersion, isoFile)) {
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_UPGRADE_BETWEEN_MAJOR_VERSION);
                addCanDoActionMessage(String.format("$IsoVersion %1$s", ovirtHostOsVersion.getMajor()));
                retValue = false;
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null) {
        if (getVds().getvds_type() == VDSType.VDS) {
            _vdsInstaller = new VdsInstaller(getVds(), getParameters().getRootPassword(), getParameters().getOverrideFirewall());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (getParameters().getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            if (isOvirtReInstallOrUpgrade()) {
                _vdsInstaller = new OVirtInstaller(getVds(), getParameters().getoVirtIsoFile());
            } else {
                _vdsInstaller = new CBCInstaller(getVds());
            }
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        setSucceeded(_vdsInstaller.Install());
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (!getSucceeded()) {
            AddCustomValue("FailedInstallMessage", getErrorMessage(_vdsInstaller.getErrorMessage()));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.InstallFailed));
        } else {
            if (_vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
            if (getVds().getvds_type() == VDSType.VDS || (getVds().getvds_type() == VDSType.oVirtNode && getParameters().getIsReinstallOrUpgrade())) {
                RunSleepOnReboot();
            } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
                ThreadPoolUtil.execute(new Runnable() {

                    @Override
                    public void run() {
                        CBCSetStatus();
                    }
                });
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null) {
        if (getVds().getvds_type() == VDSType.VDS) {
            _vdsInstaller = new VdsInstaller(getVds(), getParameters().getRootPassword(), getParameters().getOverrideFirewall());
        } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
            log.infoFormat("Before Installation {0}, Powerclient/oVirtNode case: setting status to installing", Thread.currentThread().getName());
            if (getParameters().getOverrideFirewall()) {
                log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Installing));
            if (isOvirtReInstallOrUpgrade()) {
                _vdsInstaller = new OVirtInstaller(getVds(), getParameters().getoVirtIsoFile());
            } else {
                _vdsInstaller = new CBCInstaller(getVds());
            }
        }
        log.infoFormat("Before Installation {0}", Thread.currentThread().getName());
        boolean installResult = false;
        try {
            installResult = _vdsInstaller.Install();
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getvds_id(), getVds().getvds_name(), e);
        }
        setSucceeded(installResult);
        log.infoFormat("After Installation {0}", Thread.currentThread().getName());
        if (!getSucceeded()) {
            AddCustomValue("FailedInstallMessage", getErrorMessage(_vdsInstaller.getErrorMessage()));
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.InstallFailed));
        } else {
            if (_vdsInstaller.isAddOvirtFlow()) {
                log.debugFormat("Add manual oVirt flow ended successfully for {0}.", getVds().getvds_name());
                return;
            }
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Reboot));
            if (getVds().getvds_type() == VDSType.VDS || isOvirtReInstallOrUpgrade()) {
                RunSleepOnReboot();
            } else if (getVds().getvds_type() == VDSType.PowerClient || getVds().getvds_type() == VDSType.oVirtNode) {
                ThreadPoolUtil.execute(new Runnable() {

                    @Override
                    public void run() {
                        CBCSetStatus();
                    }
                });
            }
        }
    }
}
#end_block

#method_before
private boolean isIsoVersionCompatible(String isoFile) {
    boolean retValue = true;
    VdsDynamic vdsDynamic = getVdsDynamicDAO().get(getVdsId());
    try {
        RpmVersion vdsOsVersion = new RpmVersion(vdsDynamic.gethost_os(), "RHEV Hypervisor -", true);
        RpmVersion isoVersion = new RpmVersion(isoFile, Config.<String>GetValue(ConfigValues.OvirtIsoPrefix), true);
        if (isoVersion.getMajor() != vdsOsVersion.getMajor() && vdsOsVersion.getMajor() != -1 && isoVersion.getMajor() != -1) {
            retValue = false;
        }
    } catch (RuntimeException e) {
        log.errorFormat("Failed to parse iso version {0} or ovirt os version {1} with error {2}", vdsDynamic.gethost_os(), isoFile, ExceptionUtils.getMessage(e));
    }
    return retValue;
}
#method_after
public boolean isIsoVersionCompatible(RpmVersion ovirtOsVersion, String isoFile) {
    boolean retValue = true;
    if (ovirtOsVersion != null) {
        try {
            RpmVersion isoVersion = new RpmVersion(isoFile, Config.<String>GetValue(ConfigValues.OvirtIsoPrefix), true);
            if (!VdsHandler.isIsoVersionCompatibleForUpgrade(ovirtOsVersion, isoVersion)) {
                retValue = false;
            }
        } catch (RuntimeException e) {
            log.warnFormat("Failed to parse ISO file version {0} with error {1}", isoFile, ExceptionUtils.getMessage(e));
        }
    }
    return retValue;
}
#end_block

#method_before
@Before
public void setUp() {
    ConfigMocker cfgMocker = new ConfigMocker();
    cfgMocker.mockOVirtISOsRepositoryPath(OVIRT_ISOS_REPOSITORY_PATH);
    cfgMocker.mockConfigOvirtIsoPrefix(OVIRT_ISO_PREFIX);
    cfgMocker.mockConfigOvirtInitialSupportedIsoVersion(OVIRT_INIT_SUPPORTED_VERSION);
}
#method_after
@Before
public void setUp() {
    initMocks(this);
    ConfigMocker cfgMocker = new ConfigMocker();
    cfgMocker.mockOVirtISOsRepositoryPath(OVIRT_ISOS_REPOSITORY_PATH);
    cfgMocker.mockConfigOvirtIsoPrefix(OVIRT_ISO_PREFIX);
    cfgMocker.mockConfigOvirtInitialSupportedIsoVersion(OVIRT_INIT_SUPPORTED_VERSION);
    mockStatic(DbFacade.class);
    when(DbFacade.getInstance()).thenReturn(dbFacade);
    when(dbFacade.getVdsDAO()).thenReturn(vdsDAO);
    when(vdsDAO.get(any(Guid.class))).thenReturn(null);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkReturnValue(GetoVirtISOsQuery<VdcQueryParametersBase> query) {
    List<RpmVersion> isosList = (List<RpmVersion>) query.getQueryReturnValue().getReturnValue();
    assertTrue(!isosList.isEmpty());
}
#method_after
@SuppressWarnings("unchecked")
private void checkReturnValue(GetoVirtISOsQuery<VdsIdParametersBase> query) {
    List<RpmVersion> isosList = (List<RpmVersion>) query.getQueryReturnValue().getReturnValue();
    assertTrue(!isosList.isEmpty());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    File directory = new File(Config.resolveOVirtISOsRepositoryPath());
    if (directory.isDirectory()) {
        List<String> listOfIsoFiles = getListOfIsoFiles(directory);
        if (!listOfIsoFiles.isEmpty()) {
            File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
            for (File versionFile : ovirtVersionFiles) {
                try {
                    String isoVersionText = readIsoVersion(versionFile);
                    if (StringUtils.isBlank(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String majorVersionStr = versionParts[0];
                    String releaseStr = versionParts[1];
                    String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                    if (isoFileName == null) {
                        log.debugFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                        continue;
                    }
                    RpmVersion isoVersion = parseIsoFileVersion(isoFileName, majorVersionStr);
                    if (isoVersion != null) {
                        if (isIsoVersionSupported(isoVersion)) {
                            availableISOsList.add(isoVersion);
                        }
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                }
            }
        }
    } else {
        log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#method_after
@Override
protected void executeQueryCommand() {
    RpmVersion vdsOsVersion = getOvirtOsVersion();
    List<RpmVersion> availableISOsList = new ArrayList<RpmVersion>();
    File directory = new File(Config.resolveOVirtISOsRepositoryPath());
    if (directory.isDirectory()) {
        List<String> listOfIsoFiles = getListOfIsoFiles(directory);
        if (!listOfIsoFiles.isEmpty()) {
            File[] ovirtVersionFiles = filterOvirtFiles(directory, isoVersionPattern);
            for (File versionFile : ovirtVersionFiles) {
                try {
                    String isoVersionText = readIsoVersion(versionFile);
                    if (StringUtils.isBlank(isoVersionText)) {
                        log.debugFormat("Iso version file {0} is empty.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String[] versionParts = isoVersionText.split(",");
                    if (versionParts.length < 2) {
                        log.debugFormat("Iso version file {0} contains invalid content. Excpected: <major-version>,<release> format.", versionFile.getAbsolutePath());
                        continue;
                    }
                    String majorVersionStr = versionParts[0];
                    String releaseStr = versionParts[1];
                    String isoFileName = getIsoFileNameByVersion(listOfIsoFiles, majorVersionStr, releaseStr);
                    if (isoFileName == null) {
                        log.debugFormat("Iso version file {0} has no matching iso file searched by version parts: {1} and {2}.", versionFile.getAbsolutePath(), majorVersionStr, releaseStr);
                        continue;
                    }
                    RpmVersion isoVersion = parseIsoFileVersion(isoFileName, majorVersionStr);
                    boolean shouldAdd = false;
                    if (isoVersion != null && isIsoVersionSupported(isoVersion)) {
                        if (vdsOsVersion != null) {
                            if (VdsHandler.isIsoVersionCompatibleForUpgrade(vdsOsVersion, isoVersion)) {
                                shouldAdd = true;
                            }
                        } else {
                            shouldAdd = true;
                        }
                    }
                    if (shouldAdd) {
                        availableISOsList.add(isoVersion);
                    }
                } catch (RuntimeException e) {
                    log.errorFormat("Failed to parse ovirt iso version {0} with error {1}", versionFile.getAbsolutePath(), ExceptionUtils.getMessage(e));
                }
            }
        }
    } else {
        log.errorFormat("ovirt ISOs directory not found. Search in: {0}", directory.getPath());
    }
    Collections.sort(availableISOsList);
    getQueryReturnValue().setReturnValue(availableISOsList);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <P extends VdcActionParametersBase> CommandBase<P> CreateCommand(VdcActionType action, P parameters) {
    try {
        Constructor<CommandBase<? extends VdcActionParametersBase>> constructor = findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass());
        return (CommandBase<P>) constructor.newInstance(new Object[] { parameters });
    } catch (java.lang.Exception e) {
        log.error("CommandsFactory [parameter: VdcActionParametersBase]: Failed to get type information using " + "reflection for Action: " + action, e);
        return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
public static <P extends VdcActionParametersBase> CommandBase<P> CreateCommand(VdcActionType action, P parameters) {
    try {
        Constructor<CommandBase<? extends VdcActionParametersBase>> constructor = findCommandConstructor(getCommandClass(action.name(), CommandSuffix), parameters.getClass());
        return (CommandBase<P>) constructor.newInstance(new Object[] { parameters });
    } catch (Exception e) {
        log.error("CommandsFactory [parameter: VdcActionParametersBase]: Failed to get type information using " + "reflection for Action: " + action, e);
        return null;
    }
}
#end_block

#method_before
public static CommandBase<?> CreateCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        return (CommandBase<?>) constructor.newInstance(new Object[] { commandId });
    } catch (java.lang.Exception e) {
        log.error("CommandsFactory : Failed to get type information using " + "reflection for Class : " + className + ", Command Id:" + commandId, e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#method_after
public static CommandBase<?> CreateCommand(String className, Guid commandId) {
    Constructor<?> constructor = null;
    Boolean isAcessible = null;
    try {
        constructor = Class.forName(className).getDeclaredConstructor(Guid.class);
        // since this constructor is defined as protected, we must modify accessability and restore it afterwards
        if (!constructor.isAccessible()) {
            isAcessible = constructor.isAccessible();
            constructor.setAccessible(true);
        }
        return (CommandBase<?>) constructor.newInstance(new Object[] { commandId });
    } catch (Exception e) {
        log.error("CommandsFactory : Failed to get type information using " + "reflection for Class : " + className + ", Command Id:" + commandId, e);
        return null;
    } finally {
        if (isAcessible != null) {
            constructor.setAccessible(isAcessible);
        }
    }
}
#end_block

#method_before
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl(utilityConfiguration);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ConnectException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ClassNotFoundException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (SQLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#method_after
public void init(String configFilePath) throws ManageDomainsResult {
    try {
        utilityConfiguration = new ManageDomainsConfiguration(configFilePath);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CONFIGURATION, e.getMessage());
    }
    try {
        daoImpl = new ManageDomainsDAOImpl(utilityConfiguration);
    } catch (ConfigurationException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ConnectException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (ClassNotFoundException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (SQLException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    } catch (XPathExpressionException e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DB_EXCEPTION, e.getMessage());
    }
}
#end_block

#method_before
public void addDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    }
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "added", domainName));
}
#method_after
public void addDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode = DEFAULT_AUTH_MODE;
    if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
        authMode = LdapAuthModeEnum.SIMPLE.name();
    } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
        authMode = LdapAuthModeEnum.GSSAPI.name();
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, password);
    authModeEntry.setValueForDomain(domainName, authMode);
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "added", domainName));
}
#end_block

#method_before
public void editDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode;
    if (mode == null) {
        authMode = getDomainAuthMode(domainName);
    } else {
        authMode = DEFAULT_AUTH_MODE;
        if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
            authMode = LdapAuthModeEnum.SIMPLE.name();
        } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
            authMode = LdapAuthModeEnum.GSSAPI.name();
        }
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (mode != null) {
        authModeEntry.setValueForDomain(domainName, authMode);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    }
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "edited", domainName));
}
#method_after
public void editDomain(String domainName, String userName, String password, String mode) throws ManageDomainsResult {
    String authMode;
    if (mode == null) {
        authMode = getDomainAuthMode(domainName);
    } else {
        authMode = DEFAULT_AUTH_MODE;
        if (mode.equalsIgnoreCase(LdapModeEnum.LOCAL.name())) {
            authMode = LdapAuthModeEnum.SIMPLE.name();
        } else if (mode.equalsIgnoreCase(LdapModeEnum.REMOTE.name())) {
            authMode = LdapAuthModeEnum.GSSAPI.name();
        }
    }
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    String domainNameEntryString = domainNameEntry.getDomainsConfigurationEntry();
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    if (mode != null) {
        authModeEntry.setValueForDomain(domainName, authMode);
    }
    if (authMode.equalsIgnoreCase(LdapAuthModeEnum.SIMPLE.name())) {
        ldapServersEntry.setValueForDomain(domainName, utilityConfiguration.getLocalHostEntry());
    }
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, true, false);
    if (addPermissions) {
        updatePermissionsTable(adUserNameEntry, adUserIdEntry);
    } else {
        System.out.println(WARNING_NOT_ADDING_PERMISSIONS);
    }
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry);
    System.out.println(String.format(SUCCESSFULLY_COMPLETED_ACTION_ON_DOMAIN, "edited", domainName));
}
#end_block

#method_before
@Override
public void performRemove(String id) {
    StorageDomain storageDomain = getAttachedStorageDomainSubResource(id).get();
    if (storageDomain.getStorage().getType().equals(StorageType.LOCALFS.value())) {
        RemoveStorageDomainParameters params = new RemoveStorageDomainParameters(asGuid(id));
        params.setDoFormat(true);
        performAction(VdcActionType.RemoveStorageDomain, params);
    } else {
        performAction(VdcActionType.DetachStorageDomainFromPool, new DetachStorageDomainFromPoolParameters(asGuid(id), dataCenterId));
    }
}
#method_after
@Override
public Response performRemove(String id) {
    StorageDomain storageDomain = getAttachedStorageDomainSubResource(id).get();
    if (storageDomain.getStorage().getType().equals(StorageType.LOCALFS.value())) {
        RemoveStorageDomainParameters params = new RemoveStorageDomainParameters(asGuid(id));
        params.setDoFormat(true);
        return (performAction(VdcActionType.RemoveStorageDomain, params));
    } else {
        return (performAction(VdcActionType.DetachStorageDomainFromPool, new DetachStorageDomainFromPoolParameters(asGuid(id), dataCenterId)));
    }
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0));
    setUriInfo(setUpActionExpectations(VdcActionType.DetachStorageDomainFromPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true));
    collection.remove(GUIDS[0].toString());
}
#method_after
@Test
public void testRemove() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0));
    setUriInfo(setUpActionExpectations(VdcActionType.DetachStorageDomainFromPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testRemoveLocalStorage() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0, StorageType.LOCALFS));
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveStorageDomain, RemoveStorageDomainParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true));
    collection.remove(GUIDS[0].toString());
}
#method_after
@Test
public void testRemoveLocalStorage() throws Exception {
    setUpGetConnection(2);
    setUpGetEntityExpectations(GUIDS[0], 2, getEntity(0, StorageType.LOCALFS));
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveStorageDomain, RemoveStorageDomainParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
private boolean refreshCallBackQuery(CallBackData callBackData) {
    if (callBackData != null) {
        boolean toRemove = false;
        try {
            int refreshCyclesSinceLastPolling = callBackData.RefreshCyclesWithoutPolling.incrementAndGet();
            if (refreshCyclesSinceLastPolling < Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend)) {
                callBackData.RefreshQueries();
            } else // }
            if (refreshCyclesSinceLastPolling == Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend))
                log.warnFormat("Client did not poll async queries updates for {1} cycles, suspending server side updates for session id = {0}", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend));
            else if (refreshCyclesSinceLastPolling > Config.<Integer>GetValue(// enough,
            ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup)) // assume
            // client
            // is
            // gone
            {
                log.warnFormat("Client did not poll async queries updates for {1} cycles sessionId = {0}. Callback will be removed.", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup));
                toRemove = true;
            }
        } catch (RuntimeException ex) {
            log.infoFormat("Communication with client has aborted sessionId = {0}. Callback will be removed.", callBackData.getSessionId());
            if (Config.<Boolean>GetValue(ConfigValues.DebugSearchLogging)) {
                log.info("Problem with refreshing callback query", ex);
            }
            toRemove = true;
        }
        if (toRemove) {
            for (Guid QueryId : callBackData.getQueryIDs()) {
                callBackData.UnregisterQuery(QueryId);
            }
        }
        return toRemove;
    }
    return false;
}
#method_after
private boolean refreshCallBackQuery(CallBackData callBackData) {
    if (callBackData != null) {
        boolean toRemove = false;
        try {
            int refreshCyclesSinceLastPolling = callBackData.RefreshCyclesWithoutPolling.incrementAndGet();
            if (refreshCyclesSinceLastPolling < Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend)) {
                callBackData.RefreshQueries();
            } else // }
            if (refreshCyclesSinceLastPolling == Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend))
                log.debugFormat("Client did not poll async queries updates for {1} cycles, suspending server side updates for session id = {0}", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeRefreshSuspend));
            else if (refreshCyclesSinceLastPolling > Config.<Integer>GetValue(// enough,
            ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup)) // assume
            // client
            // is
            // gone
            {
                log.debugFormat("Client did not poll async queries updates for {1} cycles sessionId = {0}. Callback will be removed.", callBackData.getSessionId(), Config.<Integer>GetValue(ConfigValues.AsyncPollingCyclesBeforeCallbackCleanup));
                toRemove = true;
            }
        } catch (RuntimeException ex) {
            log.infoFormat("Communication with client has aborted sessionId = {0}. Callback will be removed.", callBackData.getSessionId());
            if (Config.<Boolean>GetValue(ConfigValues.DebugSearchLogging)) {
                log.info("Problem with refreshing callback query", ex);
            }
            toRemove = true;
        }
        if (toRemove) {
            for (Guid QueryId : callBackData.getQueryIDs()) {
                callBackData.UnregisterQuery(QueryId);
            }
        }
        return toRemove;
    }
    return false;
}
#end_block

#method_before
public static SearchControls createSearchControls() {
    SearchControls searchControls = new SearchControls();
    searchControls.setSearchScope(SearchControls.OBJECT_SCOPE);
    searchControls.setReturningObjFlag(true);
    return searchControls;
}
#method_after
public static SearchControls createSearchControls() {
    SearchControls searchControls = new SearchControls();
    searchControls.setSearchScope(SearchControls.OBJECT_SCOPE);
    // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
    searchControls.setReturningObjFlag(true);
    return searchControls;
}
#end_block

#method_before
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    DnsSRVResult ldapDnsResult;
    try {
        ldapDnsResult = locator.getLdapServers(domainName);
    } catch (Exception ex) {
        return KerberosUtils.convertDNSException(ex);
    }
    DirContext ctx = null;
    boolean foundUser = false;
    String currentLdapServer = null;
    if (ldapDnsResult == null || ldapDnsResult.getNumOfValidAddresses() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
        String address = ldapDnsResult.getAddresses()[counter];
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address);
            env.put(Context.PROVIDER_URL, uri.toString());
            ctx = new InitialDirContext(env);
            // Get the base DN from rootDSE
            String domainDN = getDomainDN(ctx);
            if (domainDN != null) {
                // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                // ldap:hostname:port/baseDN ) to query for the user
                StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                ldapQueryPath.append("/").append(domainDN);
                SearchControls controls = new SearchControls();
                controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                controls.setReturningObjFlag(true);
                currentLdapServer = ldapQueryPath.toString();
                env.put(Context.PROVIDER_URL, currentLdapServer);
                // Run the LDAP query to get the user
                ctx = new InitialDirContext(env);
                NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                while (answer.hasMoreElements()) {
                    // Print the objectGUID for the user
                    userGuid.append(guidFromResults(answer.next()));
                    log.debug("User guid is: " + userGuid.toString());
                    foundUser = true;
                    return AuthenticationResult.OK;
                }
                System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
            } else {
                System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain" + domainName);
            }
        } catch (CommunicationException ex) {
            System.out.println("Cannot connect to LDAP URL: " + currentLdapServer + ". Trying next LDAP server in list (if exists)");
        } catch (AuthenticationException ex) {
            ex.printStackTrace();
            AuthenticationResult result = AuthenticationResult.OTHER;
            KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
            result = parser.parse(ex.toString());
            String errorMsg = result.getDetailedMessage().replace("Authentication Failed", "LDAP query Failed");
            System.out.println(InstallerConstants.ERROR_PREFIX + errorMsg);
        } catch (Exception ex) {
            System.out.println("General error has occured" + ex.getMessage());
            ex.printStackTrace();
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (NamingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#method_after
@Override
public Object run() {
    Hashtable env = new Hashtable(11);
    env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    env.put("java.naming.ldap.attributes.binary", "objectGUID");
    env.put(Context.SECURITY_AUTHENTICATION, "GSSAPI");
    // Send an SRV record DNS query to retrieve all the LDAP servers in the domain
    LdapSRVLocator locator = new LdapSRVLocator();
    DnsSRVResult ldapDnsResult;
    try {
        ldapDnsResult = locator.getLdapServers(domainName);
    } catch (Exception ex) {
        return KerberosUtils.convertDNSException(ex);
    }
    DirContext ctx = null;
    String currentLdapServer = null;
    if (ldapDnsResult == null || ldapDnsResult.getNumOfValidAddresses() == 0) {
        return AuthenticationResult.CANNOT_FIND_LDAP_SERVER_FOR_DOMAIN;
    }
    // Goes over all the retrieved LDAP servers
    for (int counter = 0; counter < ldapDnsResult.getNumOfValidAddresses(); counter++) {
        String address = ldapDnsResult.getAddresses()[counter];
        try {
            // Constructs an LDAP url in a format of ldap://hostname:port (based on the data in the SRV record
            // This URL is not enough in order to query for user - as for querying users, we should also provide a
            // base dn, for example: ldap://hostname:389/DC=abc,DC=com . However, this URL (ldap:hostname:port)
            // suffices for
            // getting the rootDSE information, which includes the baseDN.
            URI uri = locator.constructURI("LDAP", address);
            env.put(Context.PROVIDER_URL, uri.toString());
            ctx = new InitialDirContext(env);
            // Get the base DN from rootDSE
            String domainDN = getDomainDN(ctx);
            if (domainDN != null) {
                // Append the base DN to the ldap URL in order to construct a full ldap URL (in form of
                // ldap:hostname:port/baseDN ) to query for the user
                StringBuilder ldapQueryPath = new StringBuilder(uri.toString());
                ldapQueryPath.append("/").append(domainDN);
                SearchControls controls = new SearchControls();
                controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
                // Adding all the three attributes possible, as RHDS doesn't return the nsUniqueId by default
                controls.setReturningAttributes(new String[] { "nsUniqueId", "ipaUniqueId", "objectGuid" });
                // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
                controls.setReturningObjFlag(true);
                currentLdapServer = ldapQueryPath.toString();
                env.put(Context.PROVIDER_URL, currentLdapServer);
                // Run the LDAP query to get the user
                ctx = new InitialDirContext(env);
                NamingEnumeration<SearchResult> answer = executeQuery(ctx, controls, prepareQuery());
                while (answer.hasMoreElements()) {
                    // Print the objectGUID for the user
                    userGuid.append(guidFromResults(answer.next()));
                    log.debug("User guid is: " + userGuid.toString());
                    return AuthenticationResult.OK;
                }
                System.out.println("No user in Directory was found for " + userName + ". Trying next LDAP server in list");
            } else {
                System.out.println(InstallerConstants.ERROR_PREFIX + " Failed to query rootDSE in order to get the baseDN. Could not query for user " + userName + " in domain" + domainName);
            }
        } catch (CommunicationException ex) {
            System.out.println("Cannot connect to LDAP URL: " + currentLdapServer + ". Trying next LDAP server in list (if exists)");
        } catch (AuthenticationException ex) {
            ex.printStackTrace();
            AuthenticationResult result = AuthenticationResult.OTHER;
            KerberosReturnCodeParser parser = new KerberosReturnCodeParser();
            result = parser.parse(ex.toString());
            String errorMsg = result.getDetailedMessage().replace("Authentication Failed", "LDAP query Failed");
            System.out.println(InstallerConstants.ERROR_PREFIX + errorMsg);
        } catch (Exception ex) {
            System.out.println("General error has occured" + ex.getMessage());
            ex.printStackTrace();
            break;
        } finally {
            if (ctx != null) {
                try {
                    ctx.close();
                } catch (NamingException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
    return AuthenticationResult.NO_USER_INFORMATION_WAS_FOUND_FOR_USER;
}
#end_block

#method_before
private String guidFromResults(SearchResult sr) throws NamingException {
    String guidString = "";
    if (isIPA) {
        String ipaUniqueId = (String) sr.getAttributes().get("ipaUniqueId").get();
        guidString += ipaUniqueId;
    } else {
        Object objectGuid = sr.getAttributes().get("objectGUID").get();
        byte[] guid = (byte[]) objectGuid;
        guidString += ((new org.ovirt.engine.core.compat.Guid(guid, false)).toString());
    }
    return guidString;
}
#method_after
private String guidFromResults(SearchResult sr) throws NamingException {
    String guidString = "";
    if (ldapProviderType.equals(LdapProviderType.ipa)) {
        String ipaUniqueId = (String) sr.getAttributes().get("ipaUniqueId").get();
        guidString += ipaUniqueId;
    } else if (ldapProviderType.equals(LdapProviderType.rhds)) {
        String nsUniqueId = (String) sr.getAttributes().get("nsUniqueId").get();
        guidString += RHDSUserContextMapper.getGuidFromNsUniqueId(nsUniqueId);
    } else {
        Object objectGuid = sr.getAttributes().get("objectGUID").get();
        byte[] guid = (byte[]) objectGuid;
        guidString += ((new org.ovirt.engine.core.compat.Guid(guid, false)).toString());
    }
    return guidString;
}
#end_block

#method_before
private String prepareQuery() {
    String query;
    if (isIPA) {
        userName = userName.split("@")[0];
        query = "(&(objectClass=posixAccount)(objectClass=krbPrincipalAux)(uid=" + userName + "))";
    } else {
        StringBuilder queryBase = new StringBuilder("(&(sAMAccountType=805306368)(");
        if (userName.contains("@")) {
            queryBase.append("userPrincipalName=" + userName);
        } else {
            if (userName.length() > 20) {
                queryBase.append("userPrincipalName=").append(userName).append("@").append(domainName.toUpperCase());
            } else {
                queryBase.append("sAMAccountName=").append(userName);
            }
        }
        query = queryBase.append("))").toString();
    }
    return query;
}
#method_after
private String prepareQuery() {
    String query;
    if (ldapProviderType.equals(LdapProviderType.ipa)) {
        userName = userName.split("@")[0];
        query = "(&(objectClass=posixAccount)(objectClass=krbPrincipalAux)(uid=" + userName + "))";
    } else if (ldapProviderType.equals(LdapProviderType.rhds)) {
        userName = userName.split("@")[0];
        query = "(&(objectClass=person)(uid=" + userName + "))";
    } else {
        StringBuilder queryBase = new StringBuilder("(&(sAMAccountType=805306368)(");
        if (userName.contains("@")) {
            queryBase.append("userPrincipalName=" + userName);
        } else {
            if (userName.length() > 20) {
                queryBase.append("userPrincipalName=").append(userName).append("@").append(domainName.toUpperCase());
            } else {
                queryBase.append("sAMAccountName=").append(userName);
            }
        }
        query = queryBase.append("))").toString();
    }
    return query;
}
#end_block

#method_before
private String getDomainDN(DirContext ctx) throws NamingException {
    // Queries the rootDSE and get the "defaultNamingContext" attribute value -
    // this attribute will be a part of the LDAP URL to perform users queries (i.e - search for a user)
    SearchControls controls = RootDSEQueryInfo.createSearchControls();
    String query = RootDSEQueryInfo.ROOT_DSE_LDAP_QUERY;
    NamingEnumeration<SearchResult> searchResults = executeQuery(ctx, controls, query);
    // The information on base DN is located in the attribute "defaultNamingContext"
    while (searchResults.hasMoreElements()) {
        SearchResult searchResult = searchResults.nextElement();
        Attributes attributes = searchResult.getAttributes();
        Attribute attribute = attributes.get(RootDSEQueryInfo.DEFAULT_NAMING_CONTEXT_RESULT_ATTRIBUTE);
        if (attribute != null) {
            String domainDN = (String) attribute.get();
            return domainDN;
        } else {
            Attribute ipaAttribute = attributes.get(RootDSEQueryInfo.NAMING_CONTEXTS_RESULT_ATTRIBUTE);
            if (ipaAttribute != null) {
                isIPA = true;
                String domainDN = (String) ipaAttribute.get(0);
                return domainDN;
            }
            return null;
        }
    }
    return null;
}
#method_after
private String getDomainDN(DirContext ctx) throws NamingException {
    RootDSEData rootDSEData = new RootDSEData(ctx);
    ldapProviderType = rootDSEData.getLdapProviderType();
    return rootDSEData.getDomainDN();
}
#end_block

#method_before
@Override
public List call() throws Exception {
    ContextMapperCallbackHandler cmCallback = new NotNullContextMapperCallbackHandler(queryExecution.getContextMapper());
    SearchControls controls = new SearchControls();
    if (queryExecution.getReturningAttributes() != null) {
        controls.setReturningAttributes(queryExecution.getReturningAttributes());
    }
    controls.setSearchScope(queryExecution.getSearchScope());
    controls.setCountLimit(resultcount);
    controls.setReturningObjFlag(true);
    ldapTemplate.search("", queryExecution.getFilter(), queryExecution.getDisplayFilter(), controls, cmCallback);
    return cmCallback.getList();
}
#method_after
@Override
public List call() throws Exception {
    ContextMapperCallbackHandler cmCallback = new NotNullContextMapperCallbackHandler(queryExecution.getContextMapper());
    SearchControls controls = new SearchControls();
    if (queryExecution.getReturningAttributes() != null) {
        controls.setReturningAttributes(queryExecution.getReturningAttributes());
    }
    controls.setSearchScope(queryExecution.getSearchScope());
    controls.setCountLimit(resultcount);
    // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
    controls.setReturningObjFlag(true);
    ldapTemplate.search("", queryExecution.getFilter(), queryExecution.getDisplayFilter(), controls, cmCallback);
    return cmCallback.getList();
}
#end_block

#method_before
private List<Class<?>> discoverClasses(String packageName) {
    List<Class<?>> ret = new ArrayList<Class<?>>();
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    try {
        Enumeration<URL> resources = classLoader.getResources(toPath(packageName));
        List<File> dirs = new ArrayList<File>();
        List<JarInputStream> jars = new ArrayList<JarInputStream>();
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            if (isJar(resource)) {
                jars.add(new JarInputStream(resource.openStream()));
            } else if (containsJar(resource)) {
                jars.add(getContainingResource(classLoader, resource));
            } else {
                dirs.add(new File(resource.getFile()));
            }
        }
        walkJars(ret, packageName, jars);
        walkDirs(ret, packageName, dirs);
    } catch (Exception e) {
        ret = Collections.emptyList();
    }
    return ret;
}
#method_after
private List<Class<?>> discoverClasses(String packageName) {
    List<Class<?>> ret = new ArrayList<Class<?>>();
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    try {
        Enumeration<URL> resources = classLoader.getResources(toPath(packageName));
        List<File> dirs = new ArrayList<File>();
        List<JarInputStream> jars = new ArrayList<JarInputStream>();
        while (resources.hasMoreElements()) {
            URL resource = resources.nextElement();
            if (isJar(resource)) {
                jars.add(new JarInputStream(new FileInputStream(getJarName(resource))));
            } else if (containsJar(resource)) {
                jars.add(getContainingResource(classLoader, resource));
            } else {
                dirs.add(new File(resource.getFile()));
            }
        }
        walkJars(ret, packageName, jars);
        walkDirs(ret, packageName, dirs);
    } catch (Exception e) {
        ret = Collections.emptyList();
    }
    return ret;
}
#end_block

#method_before
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        searchControls.setReturningObjFlag(true);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#method_after
private void execute(LdapProviderType ldapProviderType, String domain) {
    Hashtable<String, String> env = new Hashtable<String, String>();
    initContextVariables(env);
    Attributes results = null;
    DirContext ctx = null;
    try {
        ctx = createContext(env);
        LdapQueryData ldapQueryData = new LdapQueryDataImpl();
        ldapQueryData.setLdapQueryType(LdapQueryType.rootDSE);
        ldapQueryData.setDomain(domain);
        LdapQueryExecution queryExecution = LdapQueryExecutionBuilderImpl.getInstance().build(ldapProviderType, ldapQueryData);
        SearchControls searchControls = new SearchControls();
        searchControls.setReturningAttributes(queryExecution.getReturningAttributes());
        searchControls.setSearchScope(queryExecution.getSearchScope());
        // Added this in order to prevent a warning saying: "the returning obj flag wasn't set, setting it to true"
        searchControls.setReturningObjFlag(true);
        NamingEnumeration<SearchResult> search = ctx.search(queryExecution.getBaseDN(), queryExecution.getFilter(), searchControls);
        try {
            // build a map of attributes and their string values
            results = search.next().getAttributes();
        } finally {
            // make sure we close this search, otherwise the ldap connection will stick until GC kills it
            search.close();
        }
    } catch (NamingException e) {
        log.errorFormat("Failed to query rootDSE for LDAP server {0} due to {1}", ldapURI, e.getMessage());
    } finally {
        closeContext(ctx);
    }
    attributes = results;
}
#end_block

#method_before
public LdapProviderType retrieveLdapProviderType(String domain) {
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            return LdapProviderType.activeDirectory;
        } else {
            return LdapProviderType.ipa;
        }
    } else {
        return LdapProviderType.general;
    }
}
#method_after
public LdapProviderType retrieveLdapProviderType(String domain) {
    LdapProviderType retVal = LdapProviderType.general;
    Attributes attributes = getDomainAttributes(LdapProviderType.general, domain);
    if (attributes != null) {
        if (attributes.get(ADRootDSEAttributes.domainControllerFunctionality.name()) != null) {
            retVal = LdapProviderType.activeDirectory;
        } else if (attributes.get(RHDSRootDSEAttributes.netscapemdsuffix.name()) != null) {
            retVal = LdapProviderType.rhds;
        } else if (attributes.get(IPARootDSEAttributes.namingContexts.name()) != null) {
            retVal = LdapProviderType.ipa;
        }
    }
    return retVal;
}
#end_block

#method_before
@Test
public void canDoActionSucceedsOnDiskDomainCheckWhenStorageGuidInParamsMismatches() throws Exception {
    Guid storageId = Guid.NewGuid();
    initializeCommand(storageId);
    mockVmWithDisk(Guid.NewGuid());
    mockVmNetworks();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    doReturn(storageDomainStaticDAO).when(command).getStorageDomainStaticDao();
    assertTrue(command.canDoAction());
    assertFalse(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_DOMAIN_MISMATCH.toString()));
}
#method_after
@Test
public void canDoActionSucceedsOnDiskDomainCheckWhenStorageGuidInParamsMismatches() throws Exception {
    Guid storageId = Guid.NewGuid();
    initializeCommand(storageId);
    mockVmWithDisk(Guid.NewGuid());
    mockVmNetworks();
    mockStorageDomain(storageId);
    mockStoragePoolIsoMap();
    doReturn(storageDomainStaticDAO).when(command).getStorageDomainStaticDao();
    assertTrue(command.canDoAction());
}
#end_block

#method_before
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (diskImage.getstorage_id() != null && !diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams);
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#method_after
protected void AddVmTemplateImages() {
    Guid srcStorageDomain = mImages.get(0).getstorage_id().getValue();
    Guid vmSnapshotId = Guid.NewGuid();
    for (DiskImage diskImage : mImages) {
        CreateImageTemplateParameters createParams = new CreateImageTemplateParameters(diskImage.getId(), getVmTemplateId(), getVmTemplateName(), getVmId());
        if (!diskImage.getstorage_id().equals(Guid.Empty)) {
            createParams.setStorageDomainId(diskImage.getstorage_id().getValue());
        } else {
            createParams.setStorageDomainId(srcStorageDomain);
        }
        createParams.setVmSnapshotId(vmSnapshotId);
        createParams.setEntityId(getParameters().getEntityId());
        createParams.setDestinationStorageDomainId(getStorageDomainId().getValue());
        createParams.setParentParemeters(getParameters());
        getParameters().getImagesParameters().add(createParams);
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, createParams);
        getReturnValue().getTaskIdList().addAll(retValue.getInternalTaskIdList());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase;
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // execute StopVds action
    returnValueBase = executeStopVdsFenceAction(vdsId, sessionId);
    if (returnValueBase.getSucceeded()) {
        executeFenceVdsManulalyAction(vdsId, sessionId);
        // execute StartVds action
        returnValueBase = executeStartVdsFenceAction(vdsId, sessionId);
        setSucceeded(returnValueBase.getSucceeded());
        setFencingSucceeded(getSucceeded());
    } else {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void executeCommand() {
    VdcReturnValueBase returnValueBase;
    final Guid vdsId = getVdsId();
    final String sessionId = getParameters().getSessionId();
    // execute StopVds action
    returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Stop, VdcActionType.StopVds);
    if (returnValueBase.getSucceeded()) {
        executeFenceVdsManulalyAction(vdsId, sessionId);
        // execute StartVds action
        returnValueBase = executeVdsFenceAction(vdsId, sessionId, FenceActionType.Start, VdcActionType.StartVds);
        setSucceeded(returnValueBase.getSucceeded());
        setFencingSucceeded(getSucceeded());
    } else {
        setSucceeded(false);
    }
}
#end_block

#method_before
private void AddDefaultNetworks() {
    network net = new network();
    net.setId(Guid.NewGuid());
    net.setname(Config.<String>GetValue(ConfigValues.managementNetwork));
    net.setdescription(AddVdsGroupCommand.DefaultNetworkDescription);
    net.setstorage_pool_id(getStoragePool().getId());
    DbFacade.getInstance().getNetworkDAO().save(net);
}
#method_after
private void AddDefaultNetworks() {
    network net = new network();
    net.setId(Guid.NewGuid());
    net.setname(Config.<String>GetValue(ConfigValues.ManagementNetwork));
    net.setdescription(AddVdsGroupCommand.DefaultNetworkDescription);
    net.setstorage_pool_id(getStoragePool().getId());
    DbFacade.getInstance().getNetworkDAO().save(net);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // to prevent cases where low utilization > high utilization due to specific configuration defaults
    if (getVdsGroup().gethigh_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION || getVdsGroup().getlow_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION) {
        VdsSelectionAlgorithm selectionAlgorithm;
        try {
            selectionAlgorithm = VdsSelectionAlgorithm.valueOf(Config.<String>GetValue(ConfigValues.VdsSelectionAlgorithm));
        } catch (java.lang.Exception e) {
            selectionAlgorithm = VdsSelectionAlgorithm.None;
        }
        if (selectionAlgorithm == VdsSelectionAlgorithm.EvenlyDistribute) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute));
        } else if (selectionAlgorithm == VdsSelectionAlgorithm.PowerSave) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave));
        }
    }
    if (getVdsGroup().getcpu_over_commit_duration_minutes() == -1) {
        getVdsGroup().setcpu_over_commit_duration_minutes(Config.<Integer>GetValue(ConfigValues.CpuOverCommitDurationMinutes));
    }
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getstorage_pool_id() != null) {
        final String networkName = Config.<String>GetValue(ConfigValues.managementNetwork);
        List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getParameters().getVdsGroup().getstorage_pool_id().getValue());
        // network net = null; //LINQ 31899 networks.FirstOrDefault(n =>
        // n.name == networkName);
        network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network network) {
                return network.getname().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getParameters().getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), false));
        }
    }
    setActionReturnValue(getVdsGroup().getID());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // to prevent cases where low utilization > high utilization due to specific configuration defaults
    if (getVdsGroup().gethigh_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION || getVdsGroup().getlow_utilization() == GET_CPU_THRESHOLDS_FROM_CONFIGURATION) {
        VdsSelectionAlgorithm selectionAlgorithm;
        try {
            selectionAlgorithm = VdsSelectionAlgorithm.valueOf(Config.<String>GetValue(ConfigValues.VdsSelectionAlgorithm));
        } catch (java.lang.Exception e) {
            selectionAlgorithm = VdsSelectionAlgorithm.None;
        }
        if (selectionAlgorithm == VdsSelectionAlgorithm.EvenlyDistribute) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute));
        } else if (selectionAlgorithm == VdsSelectionAlgorithm.PowerSave) {
            getVdsGroup().sethigh_utilization(Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave));
            getVdsGroup().setlow_utilization(Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave));
        }
    }
    if (getVdsGroup().getcpu_over_commit_duration_minutes() == -1) {
        getVdsGroup().setcpu_over_commit_duration_minutes(Config.<Integer>GetValue(ConfigValues.CpuOverCommitDurationMinutes));
    }
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().save(getVdsGroup());
    // add default network
    if (getParameters().getVdsGroup().getstorage_pool_id() != null) {
        final String networkName = Config.<String>GetValue(ConfigValues.ManagementNetwork);
        List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getParameters().getVdsGroup().getstorage_pool_id().getValue());
        // network net = null; //LINQ 31899 networks.FirstOrDefault(n =>
        // n.name == networkName);
        network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network network) {
                return network.getname().equals(networkName);
            }
        });
        if (net != null) {
            DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getParameters().getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), false));
        }
    }
    setActionReturnValue(getVdsGroup().getID());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAll();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__NETWORK);
    if (getStoragePool() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
        return false;
    }
    // check that network name not start with 'bond'
    if (getParameters().getNetwork().getname().toLowerCase().startsWith("bond")) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CONTAIN_BOND_NAME);
        return false;
    }
    // check vlan is valid
    if (getParameters().getNetwork().getvlan_id() != null) {
        if (!AddNetworkCommand.IsVlanInRange(getParameters().getNetwork().getvlan_id())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_OUT_OF_RANGE);
            return false;
        } else // //LINQ && n.id != AddNetworkParameters.Network.id) != null)
        if (null != LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network n) {
                if (n.getvlan_id() != null) {
                    return n.getvlan_id().equals(getParameters().getNetwork().getvlan_id()) && n.getstorage_pool_id().equals(getParameters().getNetwork().getstorage_pool_id()) && !n.getId().equals(getParameters().getNetwork().getId());
                }
                return false;
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_IN_USE);
            return false;
        }
    }
    // check that network not exsits
    // network oldNetwork = null; //LINQ networks.FirstOrDefault(n => n.id
    // == AddNetworkParameters.Network.id);
    network oldNetwork = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getId().equals(getParameters().getNetwork().getId());
        }
    });
    if (oldNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_NOT_EXISTS);
        return false;
    }
    // check defalut network name is not renamed
    String defaultNetwork = Config.<String>GetValue(ConfigValues.managementNetwork);
    if (oldNetwork.getname().equals(defaultNetwork) && !getParameters().getNetwork().getname().equals(defaultNetwork)) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK);
        return false;
    }
    // network net = null; //LINQ networks.FirstOrDefault(n =>
    // n.name.Trim().ToLower() ==
    // AddNetworkParameters.Network.name.Trim().ToLower()
    // LINQ && n.id != AddNetworkParameters.Network.id &&
    // AddNetworkParameters.Network.storage_pool_id == n.storage_pool_id);
    network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().trim().toLowerCase().equals(getParameters().getNetwork().getname().trim().toLowerCase()) && !n.getId().equals(getParameters().getNetwork().getId()) && getParameters().getNetwork().getstorage_pool_id().equals(n.getstorage_pool_id());
        }
    });
    if (net != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_IN_USE);
        return false;
    }
    // check if the network in use with running vm
    _clusters = DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
    for (VDSGroup cluster : _clusters) {
        List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(cluster.getID(), getParameters().getNetwork().getname());
        if (vms.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
            return false;
        }
    }
    return RemoveNetworkCommand.CommonNetworkValidation(oldNetwork, getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAll();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__NETWORK);
    if (getStoragePool() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
        return false;
    }
    // check that network name not start with 'bond'
    if (getParameters().getNetwork().getname().toLowerCase().startsWith("bond")) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CONTAIN_BOND_NAME);
        return false;
    }
    // check vlan is valid
    if (getParameters().getNetwork().getvlan_id() != null) {
        if (!AddNetworkCommand.IsVlanInRange(getParameters().getNetwork().getvlan_id())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_OUT_OF_RANGE);
            return false;
        } else // //LINQ && n.id != AddNetworkParameters.Network.id) != null)
        if (null != LinqUtils.firstOrNull(networks, new Predicate<network>() {

            @Override
            public boolean eval(network n) {
                if (n.getvlan_id() != null) {
                    return n.getvlan_id().equals(getParameters().getNetwork().getvlan_id()) && n.getstorage_pool_id().equals(getParameters().getNetwork().getstorage_pool_id()) && !n.getId().equals(getParameters().getNetwork().getId());
                }
                return false;
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_VLAN_IN_USE);
            return false;
        }
    }
    // check that network not exsits
    // network oldNetwork = null; //LINQ networks.FirstOrDefault(n => n.id
    // == AddNetworkParameters.Network.id);
    network oldNetwork = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getId().equals(getParameters().getNetwork().getId());
        }
    });
    if (oldNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_NOT_EXISTS);
        return false;
    }
    // check defalut network name is not renamed
    String defaultNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    if (oldNetwork.getname().equals(defaultNetwork) && !getParameters().getNetwork().getname().equals(defaultNetwork)) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK);
        return false;
    }
    // network net = null; //LINQ networks.FirstOrDefault(n =>
    // n.name.Trim().ToLower() ==
    // AddNetworkParameters.Network.name.Trim().ToLower()
    // LINQ && n.id != AddNetworkParameters.Network.id &&
    // AddNetworkParameters.Network.storage_pool_id == n.storage_pool_id);
    network net = LinqUtils.firstOrNull(networks, new Predicate<network>() {

        @Override
        public boolean eval(network n) {
            return n.getname().trim().toLowerCase().equals(getParameters().getNetwork().getname().trim().toLowerCase()) && !n.getId().equals(getParameters().getNetwork().getId()) && getParameters().getNetwork().getstorage_pool_id().equals(n.getstorage_pool_id());
        }
    });
    if (net != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_NETWORK_IN_USE);
        return false;
    }
    // check if the network in use with running vm
    _clusters = DbFacade.getInstance().getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId());
    for (VDSGroup cluster : _clusters) {
        List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(cluster.getID(), getParameters().getNetwork().getname());
        if (vms.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
            return false;
        }
    }
    return RemoveNetworkCommand.CommonNetworkValidation(oldNetwork, getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // YAIRPOSTGRES - this code should be split to several blocks of run in new transaction + set states
    VDSGroup oldGroup = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVdsGroup().getID());
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()) || oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null) {
        for (VdsStatic vds : DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(oldGroup.getID())) {
            VdsActionParameters parameters = new VdsActionParameters(vds.getId());
            if (oldGroup.getstorage_pool_id() != null) {
                VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, parameters);
                if (!removeVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
                    return;
                }
            }
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVdsGroup().getID());
    boolean exists = false;
    for (network net : networks) {
        if (StringHelper.EqOp(net.getname(), Config.<String>GetValue(ConfigValues.managementNetwork))) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<network> storagePoolNets = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (network net : storagePoolNets) {
                if (StringHelper.EqOp(net.getname(), Config.<String>GetValue(ConfigValues.managementNetwork))) {
                    DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), true));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // YAIRPOSTGRES - this code should be split to several blocks of run in new transaction + set states
    VDSGroup oldGroup = DbFacade.getInstance().getVdsGroupDAO().get(getParameters().getVdsGroup().getID());
    CheckMaxMemoryOverCommitValue();
    DbFacade.getInstance().getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getstorage_pool_id() != null && !oldGroup.getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id()) || oldGroup.getstorage_pool_id() == null && getVdsGroup().getstorage_pool_id() != null) {
        for (VdsStatic vds : DbFacade.getInstance().getVdsStaticDAO().getAllForVdsGroup(oldGroup.getID())) {
            VdsActionParameters parameters = new VdsActionParameters(vds.getId());
            if (oldGroup.getstorage_pool_id() != null) {
                VdcReturnValueBase removeVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.RemoveVdsSpmId, parameters);
                if (!removeVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(removeVdsSpmIdReturn.getFault());
                    return;
                }
            }
            if (getVdsGroup().getstorage_pool_id() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<network> networks = DbFacade.getInstance().getNetworkDAO().getAllForCluster(getVdsGroup().getID());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (network net : networks) {
        if (StringHelper.EqOp(net.getname(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getstorage_pool_id() != null) {
            List<network> storagePoolNets = DbFacade.getInstance().getNetworkDAO().getAllForDataCenter(getVdsGroup().getstorage_pool_id().getValue());
            for (network net : storagePoolNets) {
                if (StringHelper.EqOp(net.getname(), managementNetwork)) {
                    DbFacade.getInstance().getNetworkClusterDAO().save(new network_cluster(getVdsGroup().getID(), net.getId(), NetworkStatus.Operational.getValue(), true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // check that we are not removing the management network
    if (StringHelper.EqOp(getParameters().getNetwork().getname(), Config.<String>GetValue(ConfigValues.managementNetwork))) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK);
        return false;
    }
    // check that there is no vm running with this network
    List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(getParameters().getVdsGroupId(), getParameters().getNetwork().getname());
    if (vms.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_VM);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", getParameters().getNetwork().getname()));
        return false;
    }
    // chech that no template is using this network
    List<VmTemplate> templates = DbFacade.getInstance().getVmTemplateDAO().getAllForVdsGroup(getParameters().getVdsGroupId());
    for (VmTemplate tmpl : templates) {
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(tmpl.getId());
        // != null)
        if (LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

            @Override
            public boolean eval(VmNetworkInterface t) {
                return t.getNetworkName().equals(getParameters().getNetwork().getname());
            }
        }) != null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_TEMPLATE);
            return false;
        }
    }
    // check if network in use by vm
    String query = "Vms: cluster = " + getVdsGroup().getname();
    SearchParameters searchParams = new SearchParameters(query, SearchType.VM);
    searchParams.setMaxCount(Integer.MAX_VALUE);
    VdcQueryReturnValue tempVar = Backend.getInstance().runInternalQuery(VdcQueryType.Search, searchParams);
    SearchReturnValue ret = (SearchReturnValue) ((tempVar instanceof SearchReturnValue) ? tempVar : null);
    if (ret != null && ret.getSucceeded()) {
        List<IVdcQueryable> vmList = (List<IVdcQueryable>) ret.getReturnValue();
        for (IVdcQueryable vm_helper : vmList) {
            VM vm = (VM) vm_helper;
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getvm_guid());
            // Interface iface = null; //LINQ interfaces.FirstOrDefault(i =>
            // i.network_name ==
            // AttachNetworkToClusterParameter.Network.name);
            VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

                @Override
                public boolean eval(VmNetworkInterface i) {
                    return i.getNetworkName().equals(getParameters().getNetwork().getname());
                }
            });
            if (iface != null) {
                addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
                return false;
            }
        }
    }
    if (getParameters().getNetwork().getname().equals(NetworkUtils.EngineNetwork)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.NETWORK_DEFAULT_UPDATE_NAME_INVALID.toString());
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // check that we are not removing the management network
    if (StringHelper.EqOp(getParameters().getNetwork().getname(), Config.<String>GetValue(ConfigValues.ManagementNetwork))) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_MANAGEMENT_NETWORK);
        return false;
    }
    // check that there is no vm running with this network
    List<VmStatic> vms = DbFacade.getInstance().getVmStaticDAO().getAllByGroupAndNetworkName(getParameters().getVdsGroupId(), getParameters().getNetwork().getname());
    if (vms.size() > 0) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_VM);
        getReturnValue().getCanDoActionMessages().add(String.format("$NetworkName %1$s", getParameters().getNetwork().getname()));
        return false;
    }
    // chech that no template is using this network
    List<VmTemplate> templates = DbFacade.getInstance().getVmTemplateDAO().getAllForVdsGroup(getParameters().getVdsGroupId());
    for (VmTemplate tmpl : templates) {
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForTemplate(tmpl.getId());
        // != null)
        if (LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

            @Override
            public boolean eval(VmNetworkInterface t) {
                return t.getNetworkName().equals(getParameters().getNetwork().getname());
            }
        }) != null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_REMOVE_NETWORK_IN_USE_BY_TEMPLATE);
            return false;
        }
    }
    // check if network in use by vm
    String query = "Vms: cluster = " + getVdsGroup().getname();
    SearchParameters searchParams = new SearchParameters(query, SearchType.VM);
    searchParams.setMaxCount(Integer.MAX_VALUE);
    VdcQueryReturnValue tempVar = Backend.getInstance().runInternalQuery(VdcQueryType.Search, searchParams);
    SearchReturnValue ret = (SearchReturnValue) ((tempVar instanceof SearchReturnValue) ? tempVar : null);
    if (ret != null && ret.getSucceeded()) {
        List<IVdcQueryable> vmList = (List<IVdcQueryable>) ret.getReturnValue();
        for (IVdcQueryable vm_helper : vmList) {
            VM vm = (VM) vm_helper;
            List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDAO().getAllForVm(vm.getvm_guid());
            // Interface iface = null; //LINQ interfaces.FirstOrDefault(i =>
            // i.network_name ==
            // AttachNetworkToClusterParameter.Network.name);
            VmNetworkInterface iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

                @Override
                public boolean eval(VmNetworkInterface i) {
                    return i.getNetworkName().equals(getParameters().getNetwork().getname());
                }
            });
            if (iface != null) {
                addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
                return false;
            }
        }
    }
    if (getParameters().getNetwork().getname().equals(NetworkUtils.EngineNetwork)) {
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.NETWORK_DEFAULT_UPDATE_NAME_INVALID.toString());
        return false;
    }
    return true;
}
#end_block

#method_before
synchronized private Set<Guid> removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    Map<Guid, SPMAsyncTask> activeTaskMap = new HashMap<Guid, SPMAsyncTask>();
    boolean isShouldBeUpdated = false;
    for (SPMAsyncTask task : _tasks.values()) {
        if (!CachingOver(task)) {
            activeTaskMap.put(task.getTaskID(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            isShouldBeUpdated = true;
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (isShouldBeUpdated) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    return poolsOfClearedAndOldTasks;
}
#method_after
synchronized private Set<Guid> removeClearedAndOldTasks() {
    Set<Guid> poolsOfActiveTasks = new HashSet<Guid>();
    Set<Guid> poolsOfClearedAndOldTasks = new HashSet<Guid>();
    Map<Guid, SPMAsyncTask> activeTaskMap = new HashMap<Guid, SPMAsyncTask>();
    for (SPMAsyncTask task : _tasks.values()) {
        if (!CachingOver(task)) {
            activeTaskMap.put(task.getTaskID(), task);
            poolsOfActiveTasks.add(task.getStoragePoolID());
        } else {
            poolsOfClearedAndOldTasks.add(task.getStoragePoolID());
        }
    }
    // Check if _tasks need to be updated with less tasks (activated tasks).
    if (poolsOfClearedAndOldTasks.size() > 0) {
        setNewMap(activeTaskMap);
        poolsOfClearedAndOldTasks.removeAll(poolsOfActiveTasks);
    }
    return poolsOfClearedAndOldTasks;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getvds_id().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    model.setStorageManager(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    if (entity.getcpu_cores() != null) {
        CpuTopology cpuTopology = new CpuTopology();
        cpuTopology.setCores(entity.getcpu_cores());
        cpu.setTopology(cpuTopology);
    }
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getvds_id().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    model.setStorageManager(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    if (entity.getcpu_cores() != null) {
        CpuTopology cpuTopology = new CpuTopology();
        cpuTopology.setCores(entity.getcpu_cores());
        cpuTopology.setSockets(entity.getcpu_sockets());
        cpu.setTopology(cpuTopology);
    }
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE);
    return model;
}
#end_block

#method_before
@Test
public void testCpuMapping() {
    VDS vds = new VDS();
    vds.setvds_id(Guid.Empty);
    vds.setcpu_cores(2);
    vds.setcpu_model("some cpu model");
    vds.setcpu_speed_mh(5.5);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getCpu());
    assertEquals(new Integer(host.getCpu().getTopology().getCores()), new Integer(2));
    assertEquals(host.getCpu().getName(), "some cpu model");
    assertEquals(host.getCpu().getSpeed(), new BigDecimal(5.5));
}
#method_after
@Test
public void testCpuMapping() {
    VDS vds = new VDS();
    vds.setvds_id(Guid.Empty);
    vds.setcpu_cores(2);
    vds.setcpu_sockets(3);
    vds.setcpu_model("some cpu model");
    vds.setcpu_speed_mh(5.5);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getCpu());
    assertEquals(new Integer(host.getCpu().getTopology().getCores()), new Integer(2));
    assertEquals(new Integer(host.getCpu().getTopology().getSockets()), new Integer(3));
    assertEquals(host.getCpu().getName(), "some cpu model");
    assertEquals(host.getCpu().getSpeed(), new BigDecimal(5.5));
}
#end_block

#method_before
protected static <T> List<T> merge(List<T> list, List<T> items) {
    List<T> returnValue = list;
    if (list != null) {
        if (items != null) {
            for (T item : items) {
                if (!returnValue.contains(item)) {
                    returnValue.add(item);
                }
            }
        }
    } else {
        returnValue = items;
    }
    return returnValue;
}
#method_after
protected static <T> List<T> merge(List<T> list, List<T> items) {
    if (list != null) {
        if (items != null) {
            for (T item : items) {
                if (!list.contains(item)) {
                    list.add(item);
                }
            }
        }
    } else {
        return items;
    }
    return list;
}
#end_block

#method_before
@Override
public boolean acquireLock(EngineLock lock) {
    try {
        globalLock.lock();
        return acquireLockInternal(lock);
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public boolean acquireLock(EngineLock lock) {
    log.debugFormat("Before acquiring lock {0}", lock);
    globalLock.lock();
    try {
        return acquireLockInternal(lock);
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
@Override
public void acquireLockWait(EngineLock lock) {
    try {
        globalLock.lock();
        while (!acquireLockInternal(lock)) {
            releasedLock.await();
        }
    } catch (InterruptedException e) {
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public void acquireLockWait(EngineLock lock) {
    log.debugFormat("Before acquiring and wait lock {0}", lock);
    globalLock.lock();
    try {
        boolean firstRun = true;
        while (!acquireLockInternal(lock)) {
            // In case of first try, just wait
            if (firstRun) {
                firstRun = false;
            } else {
                // This is a second try, we did not successes, but possible that release signal for other waiting thread
                // so try to signal to other thread
                releasedLock.signal();
            }
            releasedLock.await();
        }
    } catch (InterruptedException e) {
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
@Override
public void releaseLock(EngineLock lock) {
    try {
        globalLock.lock();
        if (lock.getUpdateRegions() != null) {
            for (Entry<String, Guid> entry : lock.getUpdateRegions().entrySet()) {
                releaseUpdateLock(buildHashMapKey(entry));
            }
        }
        if (lock.getLockedRegions() != null) {
            for (Entry<String, Guid> entry : lock.getLockedRegions().entrySet()) {
                releaseLockedLock(buildHashMapKey(entry));
            }
        }
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public void releaseLock(EngineLock lock) {
    log.debugFormat("Before releasing a lock {0}", lock);
    globalLock.lock();
    try {
        if (lock.getSharedLocks() != null) {
            for (Entry<String, Guid> entry : lock.getSharedLocks().entrySet()) {
                releaseSharedLock(buildHashMapKey(entry));
            }
        }
        if (lock.getExclusiveLocks() != null) {
            for (Entry<String, Guid> entry : lock.getExclusiveLocks().entrySet()) {
                releaseExclusiveLock(buildHashMapKey(entry));
            }
        }
        releasedLock.signal();
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
@Override
public void clear() {
    try {
        log.warn("All in memory locks are going to be cleaned");
        globalLock.lock();
        locks.clear();
        releasedLock.signalAll();
    } finally {
        globalLock.unlock();
    }
}
#method_after
@Override
public void clear() {
    log.warn("All in memory locks are going to be cleaned");
    globalLock.lock();
    try {
        locks.clear();
        releasedLock.signalAll();
    } finally {
        globalLock.unlock();
    }
}
#end_block

#method_before
private boolean acquireLockInternal(EngineLock lock) {
    boolean checkOnly = true;
    for (int i = 0; i < 2; i++) {
        if (lock.getUpdateRegions() != null) {
            for (Entry<String, Guid> entry : lock.getUpdateRegions().entrySet()) {
                if (!insertUpdateLock(buildHashMapKey(entry), checkOnly)) {
                    return false;
                }
            }
        }
        if (lock.getLockedRegions() != null) {
            for (Entry<String, Guid> entry : lock.getLockedRegions().entrySet()) {
                if (!insertLockedLock(buildHashMapKey(entry), checkOnly)) {
                    return false;
                }
            }
        }
        checkOnly = false;
    }
    return true;
}
#method_after
private boolean acquireLockInternal(EngineLock lock) {
    boolean checkOnly = true;
    for (int i = 0; i < 2; i++) {
        if (lock.getSharedLocks() != null) {
            for (Entry<String, Guid> entry : lock.getSharedLocks().entrySet()) {
                if (!insertSharedLock(buildHashMapKey(entry), checkOnly)) {
                    log.debugFormat("Failed to acquire a lock because of shared lock - key :{0} and value {1}", entry.getKey(), entry.getValue());
                    return false;
                }
            }
        }
        if (lock.getExclusiveLocks() != null) {
            for (Entry<String, Guid> entry : lock.getExclusiveLocks().entrySet()) {
                if (!insertExclusiveLock(buildHashMapKey(entry), checkOnly)) {
                    log.debugFormat("Failed to acquire a lock because of exclusive lock - key :{0} and value {1}", entry.getKey(), entry.getValue());
                    return false;
                }
            }
        }
        checkOnly = false;
    }
    log.debug("Successed to acquire a lock");
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm().getstatus() != VMStatus.MigratingFrom) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_CANCEL_MIGRATION_WHEN_VM_IS_NOT_MIGRATING);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CANCEL_MIGRATE);
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (getVm().getstatus() != VMStatus.MigratingFrom) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_CANCEL_MIGRATION_WHEN_VM_IS_NOT_MIGRATING);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((activeImage == null) ? 0 : activeImage.hashCode());
    result = prime * result + ((diskInterface == null) ? 0 : diskInterface.hashCode());
    result = prime * result + ((diskType == null) ? 0 : diskType.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((propagateErrors == null) ? 0 : propagateErrors.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + (wipeAfterDelete ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((activeImage == null) ? 0 : activeImage.hashCode());
    result = prime * result + ((diskInterface == null) ? 0 : diskInterface.hashCode());
    result = prime * result + ((diskType == null) ? 0 : diskType.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + internalDriveMapping;
    result = prime * result + ((propagateErrors == null) ? 0 : propagateErrors.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + (wipeAfterDelete ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof Disk)) {
        return false;
    }
    Disk other = (Disk) obj;
    if (activeImage == null) {
        if (other.activeImage != null) {
            return false;
        }
    } else if (!activeImage.equals(other.activeImage)) {
        return false;
    }
    if (diskInterface != other.diskInterface) {
        return false;
    }
    if (diskType != other.diskType) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (propagateErrors != other.propagateErrors) {
        return false;
    }
    if (status != other.status) {
        return false;
    }
    if (wipeAfterDelete != other.wipeAfterDelete) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof Disk)) {
        return false;
    }
    Disk other = (Disk) obj;
    if (activeImage == null) {
        if (other.activeImage != null) {
            return false;
        }
    } else if (!activeImage.equals(other.activeImage)) {
        return false;
    }
    if (diskInterface != other.diskInterface) {
        return false;
    }
    if (diskType != other.diskType) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (internalDriveMapping != other.internalDriveMapping) {
        return false;
    }
    if (propagateErrors != other.propagateErrors) {
        return false;
    }
    if (status != other.status) {
        return false;
    }
    if (wipeAfterDelete != other.wipeAfterDelete) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static String combine(String head, List<KeyValuePair> params) {
    String combined_params = "";
    if (params != null) {
        for (KeyValuePair pair : params) {
            combined_params += String.format(PARAMETER_TEMPLATE, pair.getKey(), pair.getValue());
        }
    }
    return head + combined_params;
}
#method_after
public static String combine(String head, Map<String, String> params) {
    String combined_params = "";
    if (params != null) {
        for (Entry<String, String> entry : params.entrySet()) {
            combined_params += String.format(PARAMETER_TEMPLATE, entry.getKey(), entry.getValue());
        }
    }
    return head + combined_params;
}
#end_block

#method_before
private RSDL construct() throws ClassNotFoundException, IOException {
    RSDL rsdl = new RSDL();
    for (DetailedLink link : getLinks()) {
        rsdl.getLinks().add(link);
    }
    return rsdl;
}
#method_after
private RSDL construct() throws ClassNotFoundException, IOException {
    RSDL rsdl = new RSDL();
    rsdl.setLinks(new DetailedLinks());
    for (DetailedLink link : getLinks()) {
        rsdl.getLinks().getLinks().add(link);
    }
    return rsdl;
}
#end_block

#method_before
@Override
public String toString() {
    return "RSDL Href: " + getHref() + ", Description:" + getDescription() + ", Links: " + (rsdl != null ? rsdl.getLinks().size() : "0") + ".";
}
#method_after
@Override
public String toString() {
    return "RSDL Href: " + getHref() + ", Description:" + getDescription() + ", Links: " + (rsdl != null ? (rsdl.isSetLinks() ? rsdl.getLinks().getLinks().size() : "0") : "0") + ".";
}
#end_block

#method_before
private API getApi() {
    API api = new API();
    for (DetailedLink link : getLinks()) {
        // add thin link
        api.getLinks().add(LinkHelper.createLink(link.getHref(), link.getRel()));
        // when required - add extra link for search
        if (link.isSetLinkCapabilities() && link.getLinkCapabilities().isSetSearchable() && link.getLinkCapabilities().isSearchable()) {
            api.getLinks().add(LinkHelper.createLink(link.getHref(), link.getRel(), link.getUrlParmeters()));
        }
    }
    return api;
}
#method_after
private API getApi() {
    API api = new API();
    for (DetailedLink detailedLink : getLinks()) {
        // add thin link
        api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel()));
        // when required - add extra link for search
        if (detailedLink.isSetLinkCapabilities() && detailedLink.getLinkCapabilities().isSetSearchable() && detailedLink.getLinkCapabilities().isSearchable()) {
            api.getLinks().add(LinkHelper.createLink(detailedLink.getHref(), detailedLink.getRel(), detailedLink.getUrlParmeters()));
        }
    }
    return api;
}
#end_block

#method_before
@Override
public Response get() {
    BaseResource response = null;
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        response = addSystemVersion(getRSDL());
    } else {
        response = addSummary(addSystemVersion(getApi()));
    }
    return getResponseBuilder(response).entity(response).build();
}
#method_after
@Override
public Response get() {
    BaseResource response = null;
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        response = addSystemVersion(getRSDL());
    } else if (QueryHelper.hasConstraint(getUriInfo(), SCHEMA_CONSTRAINT_PARAMETER)) {
        return getSchema();
    } else {
        response = addSummary(addSystemVersion(getApi()));
    }
    return getResponseBuilder(response).entity(response).build();
}
#end_block

#method_before
private synchronized RSDL getRSDL() {
    if (rsdl == null) {
        rsdl = new RsdlBuilder(this).description(RSDL_DESCRIPTION).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).build();
    }
    return rsdl;
}
#method_after
private synchronized RSDL getRSDL() {
    if (rsdl == null) {
        rsdl = new RsdlBuilder(this).description(RSDL_DESCRIPTION).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + RSDL_CONSTRAINT_PARAMETER).schema(new SchemaBuilder().rel(SCHEMA_REL).href(getUriInfo().getBaseUri().getPath() + QUERY_PARAMETER + SCHEMA_CONSTRAINT_PARAMETER).name(SCHEMA_NAME).description(SCHEMA_DESCRIPTION).build()).build();
    }
    return rsdl;
}
#end_block

#method_before
public static Link createLink(String url, String rel) {
    Link link = new Link();
    link.setRel(rel);
    // link.setHref(combine(url, rel));
    link.setHref(url);
    return link;
}
#method_after
public static Link createLink(String url, String rel) {
    Link link = new Link();
    link.setRel(rel);
    link.setHref(url);
    return link;
}
#end_block

#method_before
@Before
public void setUpEngineConfigLogicTest() throws Exception {
    engineConfigLogic = new EngineConfigLogic(parser);
}
#method_after
@BeforeClass
public static void setUpEngineConfigLogicTest() throws Exception {
    engineConfigLogic = new EngineConfigLogic(parser);
}
#end_block

#method_before
@Test
public void testGetValue() throws Exception {
    String key = "MaxNumberOfHostsInStoragePool";
    log.info("getValue: Testing fetch of " + key);
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    log.info("getValue: got: " + configKey);
    Assert.assertNotNull(configKey.getValue());
}
#method_after
@Test
public void testGetValue() throws Exception {
    final String key = "MaxNumberOfHostsInStoragePool";
    log.info("getValue: Testing fetch of " + key);
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    log.info("getValue: got: " + configKey);
    Assert.assertNotNull(configKey.getValue());
}
#end_block

#method_before
@Test
public void testSetIntValue() throws Exception {
    String key = "VdsRefreshRate";
    String newValue = "15";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setIntValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(Integer.parseInt(updatedValue), Integer.parseInt(newValue));
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#method_after
@Test
public void testSetIntValue() throws Exception {
    final String key = "VdsRefreshRate";
    final String newValue = "15";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setIntValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(Integer.parseInt(updatedValue), Integer.parseInt(newValue));
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#end_block

#method_before
@Test
public void testSetStringValue() throws Exception {
    String key = "DefaultWorkgroup";
    String newValue = "ExampleWorkGroup";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setStringValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(updatedValue, newValue);
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#method_after
@Test
public void testSetStringValue() throws Exception {
    final String key = "DefaultWorkgroup";
    final String newValue = "ExampleWorkGroup";
    String oldValue = getOldValue(key);
    log.info(key + " old value: " + oldValue);
    log.info("setStringValue: Testing set of " + key);
    engineConfigLogic.persist(key, newValue, "");
    String updatedValue = engineConfigLogic.fetchConfigKey(key, null).getValue();
    log.info(key + " new value: " + updatedValue);
    Assert.assertEquals(updatedValue, newValue);
    // Restoring original value
    engineConfigLogic.persist(key, oldValue, "");
}
#end_block

#method_before
@Test
public void testGetNonExitingKey() throws Exception {
    String key = "NonExistignKeyDB";
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    Assert.assertTrue(configKey == null || configKey.getKey() == null);
}
#method_after
@Test
public void testGetNonExitingKey() throws Exception {
    final String key = "NonExistignKeyDB";
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    Assert.assertTrue(configKey == null || configKey.getKey() == null);
}
#end_block

#method_before
@Test(expected = IllegalAccessException.class)
public void testSetInvalidIntValue() throws Exception {
    String key = "VdsRefreshRate";
    // An exception should be thrown
    engineConfigLogic.persist(key, "Not A Number", "");
}
#method_after
@Test(expected = IllegalAccessException.class)
public void testSetInvalidIntValue() throws Exception {
    final String key = "VdsRefreshRate";
    // An exception should be thrown
    engineConfigLogic.persist(key, "Not A Number", "");
}
#end_block

#method_before
private String getOldValue(String key) {
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    return configKey.getValue();
}
#method_after
private String getOldValue(final String key) {
    ConfigKey configKey = engineConfigLogic.fetchConfigKey(key, null);
    return configKey.getValue();
}
#end_block

#method_before
@BeforeClass
public static void setConfigFilePathProperty() {
    String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    System.setProperty(EngineConfig.CONFIG_FILE_PATH_PROPERTY, path);
}
#method_after
@BeforeClass
public static void setConfigFilePathProperty() {
    final String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    System.setProperty(EngineConfig.CONFIG_FILE_PATH_PROPERTY, path);
}
#end_block

#method_before
@Test
public void testConfigDirWithFlagSet() throws Exception {
    // get the real path of the config file
    String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    assertNotNull(path);
    EngineConfig.main("-a", "--config=" + path);
}
#method_after
@Test
public void testConfigDirWithFlagSet() throws Exception {
    // get the real path of the config file
    final String path = ClassLoader.getSystemResource("engine-config.conf").getPath();
    Assert.assertNotNull(path);
    EngineConfig.main("-a", "--config=" + path);
}
#end_block

#method_before
@Test
public void getValueWithMultipleVersions() throws Exception {
    String key = "MaxNumOfVmSockets";
    log.info("getValue: Testing fetch multiple version of " + key);
    List<ConfigKey> keys = config.getEngineConfigLogic().getConfigDAO().getKeysForName(key);
    for (ConfigKey configKey : keys) {
        log.info(configKey.getDisplayValue() + " version: " + configKey.getVersion());
    }
    Assert.assertTrue(keys.size() > 0);
}
#method_after
@Test
public void getValueWithMultipleVersions() throws Exception {
    final String key = "MaxNumOfVmSockets";
    log.info("getValue: Testing fetch multiple version of " + key);
    List<ConfigKey> keys = config.getEngineConfigLogic().getConfigDAO().getKeysForName(key);
    for (ConfigKey configKey : keys) {
        log.info(configKey.getDisplayValue() + " version: " + configKey.getVersion());
    }
    Assert.assertTrue(keys.size() > 0);
}
#end_block

#method_before
@Test(expected = IllegalAccessException.class)
public void setOutOfRangeValue() throws Exception {
    String key = "FenceQuietTimeBetweenOperationsInSec";
    // Should throw IllegalAccessException since the given value is out of range
    boolean setKeyValue = config.getEngineConfigLogic().persist(key, OUT_OF_RANGE_FOR_FENCE_QUIET_TIME, "");
}
#method_after
@Test(expected = IllegalAccessException.class)
public void setOutOfRangeValue() throws Exception {
    final String outOfRangeForFenceQuietTime = "601";
    final String key = "FenceQuietTimeBetweenOperationsInSec";
    // Should throw IllegalAccessException since the given value is out of range
    config.getEngineConfigLogic().persist(key, outOfRangeForFenceQuietTime, "");
}
#end_block

#method_before
@Test
public void setInvalidStringValue() throws Exception {
    String key = "LDAP_Security_mode";
    // not valid
    Assert.assertFalse(config.getEngineConfigLogic().persist(key, "GSSAPI-invalid-value"));
}
#method_after
@Test
public void setInvalidStringValue() throws Exception {
    final String key = "LDAP_Security_mode";
    // not valid
    Assert.assertFalse(config.getEngineConfigLogic().persist(key, "GSSAPI-invalid-value"));
}
#end_block

#method_before
@Test
public void setStringValueFromFlag() throws Exception {
    String certificateFileNameKey = "CertificateFileName";
    // Backing up current CertificateFileName
    ConfigKey originalAuthenticationMethod = config.getEngineConfigLogic().fetchConfigKey(certificateFileNameKey, "general");
    String certificateFileNameNewValue = "/certs/";
    String version = "general";
    setKeyAndValidate(certificateFileNameKey, certificateFileNameNewValue, version);
    // Restoring original value and making sure it was restored successfully
    restoreOriginalValue(certificateFileNameKey, originalAuthenticationMethod);
}
#method_after
@Test
public void setStringValueFromFlag() throws Exception {
    final String certificateFileNameKey = "CertificateFileName";
    // Backing up current CertificateFileName
    ConfigKey originalAuthenticationMethod = config.getEngineConfigLogic().fetchConfigKey(certificateFileNameKey, "general");
    final String certificateFileNameNewValue = "/certs/";
    setKeyAndValidate(certificateFileNameKey, certificateFileNameNewValue, "general");
    // Restoring original value and making sure it was restored successfully
    restoreOriginalValue(certificateFileNameKey, originalAuthenticationMethod);
}
#end_block

#method_before
private void setKeyAndValidate(String keyName, String value, String version) throws IllegalAccessException {
    boolean setKeyValue = config.getEngineConfigLogic().persist(keyName, value, version);
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(value, currentConfigKey.getValue());
}
#method_after
private void setKeyAndValidate(final String keyName, final String value, final String version) throws IllegalAccessException {
    config.getEngineConfigLogic().persist(keyName, value, version);
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(value, currentConfigKey.getValue());
}
#end_block

#method_before
private void restoreOriginalValue(String keyName, ConfigKey originialValue) throws IllegalAccessException {
    boolean setKeyValue = config.getEngineConfigLogic().persist(keyName, originialValue.getValue(), originialValue.getVersion());
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(originialValue.getValue(), currentConfigKey.getValue());
}
#method_after
private void restoreOriginalValue(final String keyName, ConfigKey originialValue) throws IllegalAccessException {
    config.getEngineConfigLogic().persist(keyName, originialValue.getValue(), originialValue.getVersion());
    ConfigKey currentConfigKey = config.getEngineConfigLogic().fetchConfigKey(keyName, "general");
    Assert.assertEquals(originialValue.getValue(), currentConfigKey.getValue());
}
#end_block

#method_before
@Test
public void testMemory() {
    storage_domains entity = new storage_domains();
    entity.setavailable_disk_size(3);
    entity.setused_disk_size(4);
    entity.setcommitted_disk_size(5);
    StorageDomain model = StorageDomainMapper.map(entity, (StorageDomain) null);
    assertEquals(model.getAvailable(), new Long(3221225472L));
    assertEquals(model.getUsed(), new Long(4294967296L));
    assertEquals(model.getCommitted(), Long.valueOf(5368709120L));
}
#method_after
@Test
public void testMemory() {
    storage_domains entity = new storage_domains();
    entity.setavailable_disk_size(3);
    entity.setused_disk_size(4);
    entity.setcommitted_disk_size(5);
    StorageDomain model = StorageDomainMapper.map(entity, (StorageDomain) null);
    assertEquals(model.getAvailable(), Long.valueOf(3221225472L));
    assertEquals(model.getUsed(), Long.valueOf(4294967296L));
    assertEquals(model.getCommitted(), Long.valueOf(5368709120L));
}
#end_block

#method_before
public boolean CheckFreeSpaceOnDestinationDomains() {
    boolean retValue = true;
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDAO().get(getParameters().getVmStaticData().getvmt_guid());
    VmTemplateHandler.UpdateDisksFromDb(vmTemplate);
    double size = 0.0;
    java.util.ArrayList<Guid> domainsList;
    if (getStorageDomainId() == null || getStorageDomainId().getValue().equals(Guid.Empty)) {
        domainsList = (java.util.ArrayList<Guid>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageDomainsList, new GetImageDomainsListVDSCommandParameters(vmTemplate.getstorage_pool_id().getValue(), vmTemplate.getDiskList().get(0).getimage_group_id().getValue())).getReturnValue();
    } else {
        domainsList = new java.util.ArrayList<Guid>();
        domainsList.add(getStorageDomainId().getValue());
    }
    for (Guid domainId : domainsList) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domainId, vmTemplate.getstorage_pool_id());
        if (domain != null && domain.getstorage_domain_type() != StorageDomainType.ImportExport && domain.getstatus() == StorageDomainStatus.Active && domain.getavailable_disk_size() != null && StorageDomainSpaceChecker.hasSpaceForRequest(domain, getBlockSparseInitSizeInGB())) {
            size += domain.getavailable_disk_size() - Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
        }
    }
    if (size < (getBlockSparseInitSizeInGB() * getParameters().getVmsCount() * vmTemplate.getDiskMap().size())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    return retValue;
}
#method_after
public boolean CheckFreeSpaceOnDestinationDomains() {
    boolean retValue = true;
    VmTemplate vmTemplate = DbFacade.getInstance().getVmTemplateDAO().get(getParameters().getVmStaticData().getvmt_guid());
    VmTemplateHandler.UpdateDisksFromDb(vmTemplate);
    double size = 0.0;
    java.util.ArrayList<Guid> domainsList;
    if (getStorageDomainId() == null || getStorageDomainId().getValue().equals(Guid.Empty)) {
        domainsList = (java.util.ArrayList<Guid>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageDomainsList, new GetImageDomainsListVDSCommandParameters(vmTemplate.getstorage_pool_id().getValue(), vmTemplate.getDiskList().get(0).getimage_group_id().getValue())).getReturnValue();
    } else {
        domainsList = new java.util.ArrayList<Guid>();
        domainsList.add(getStorageDomainId().getValue());
    }
    for (Guid domainId : domainsList) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().getForStoragePool(domainId, vmTemplate.getstorage_pool_id());
        if (domain != null && domain.getstorage_domain_type() != StorageDomainType.ImportExport && domain.getstatus() == StorageDomainStatus.Active && domain.getavailable_disk_size() != null && StorageDomainSpaceChecker.hasSpaceForRequest(domain, getBlockSparseInitSizeInGB())) {
            size += domain.getavailable_disk_size() - getFreeSpaceCriticalLowInGB();
        }
    }
    if (size < (getBlockSparseInitSizeInGB() * getParameters().getVmsCount() * vmTemplate.getDiskMap().size())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
    }
    return retValue;
}
#end_block

#method_before
public boolean CanAddVm(Object vmTemplateId, java.util.ArrayList<String> reasons) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = CanAddVm(vmTemplateId, reasons, 1, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = VmPropertiesUtils.validateVMProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    if (returnValue && getVmTemplate().getDiskMap().size() > 0 && !LinqUtils.firstOrNull(getVmTemplate().getDiskMap().values(), new All<DiskImageTemplate>()).getId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().get(getStorageDomainId().getValue());
        if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
            returnValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        } else if (!getStoragePoolId().equals(getVmTemplate().getstorage_pool_id().getValue())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else if (domain.getStorageDynamicData() != null) {
            // populate template disks for domain size check
            VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
            int diskSizeAmount = getParameters().getIsVmCloned() ? (int) getVmTemplate().getActualDiskSize() : getBlockSparseInitSizeInGB() * getVmTemplate().getDiskMap().size();
            returnValue = StorageDomainSpaceChecker.hasSpaceForRequest(domain, diskSizeAmount);
            if (!returnValue)
                reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        }
    }
    // Check id dedicated host is same as VM cluster
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
public boolean CanAddVm(Object vmTemplateId, java.util.ArrayList<String> reasons) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = CanAddVm(vmTemplateId, reasons, 1, vmStaticFromParams.getvm_name(), getStoragePoolId().getValue(), vmStaticFromParams.getpriority());
    if (returnValue) {
        List<ValidationError> validationErrors = VmPropertiesUtils.validateVMProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    if (returnValue && getVmTemplate().getDiskMap().size() > 0 && !LinqUtils.firstOrNull(getVmTemplate().getDiskMap().values(), new All<DiskImageTemplate>()).getId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        storage_domains domain = DbFacade.getInstance().getStorageDomainDAO().get(getStorageDomainId().getValue());
        if (!StorageDomainSpaceChecker.isBelowThresholds(domain)) {
            returnValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        } else if (!getStoragePoolId().equals(getVmTemplate().getstorage_pool_id().getValue())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else if (domain.getStorageDynamicData() != null) {
            // populate template disks for domain size check
            VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
            returnValue = StorageDomainSpaceChecker.hasSpaceForRequest(domain, getNeededDiskSize());
            if (!returnValue)
                reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.toString());
        }
    }
    // Check id dedicated host is same as VM cluster
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
public static String encryptPassword(String password) {
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.encrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        result = password;
    }
    return result;
}
#method_after
public static String encryptPassword(String password) {
    if (StringHelper.isEmpty(password)) {
        return password;
    }
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.encrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        throw new SecurityException(e);
    }
    return result;
}
#end_block

#method_before
public static String decryptPassword(String password) {
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.decrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        result = password;
    }
    return result;
}
#method_after
public static String decryptPassword(String password) {
    if (StringHelper.isEmpty(password)) {
        return password;
    }
    String result = password;
    String keyFile = Config.<String>GetValue(ConfigValues.keystoreUrl, Config.DefaultConfigurationVersion);
    String passwd = Config.<String>GetValue(ConfigValues.keystorePass, Config.DefaultConfigurationVersion);
    String alias = Config.<String>GetValue(ConfigValues.CertAlias, Config.DefaultConfigurationVersion);
    try {
        result = EncryptionUtils.decrypt((String) result, keyFile, passwd, alias);
    } catch (Exception e) {
        log.debugFormat("Failed to decrypt password, error message: {0}", e.getMessage());
        result = password;
    }
    return result;
}
#end_block

#method_before
static List<Class<?>> getClassNamesInJarPackage(ClassLoader loader, String jarName, String packageName) throws MalformedURLException {
    ArrayList<Class<?>> classes = new ArrayList<Class<?>>();
    packageName = packageName.replaceAll("\\.", "/");
    JarInputStream jarFileInputStream = null;
    try {
        jarFileInputStream = new JarInputStream(new FileInputStream(jarName));
        JarEntry jarEntry;
        while (true) {
            jarEntry = jarFileInputStream.getNextJarEntry();
            if (jarEntry == null)
                break;
            if ((jarEntry.getName().startsWith(packageName)) && (jarEntry.getName().endsWith(".class"))) {
                classes.add(loader.loadClass(jarEntry.getName().replaceAll("/", "\\.").replace(".class", "")));
            }
        }
        jarFileInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (jarFileInputStream != null) {
                jarFileInputStream.close();
            }
        } catch (IOException e) {
        // ignore
        }
    }
    return classes;
}
#method_after
static List<Class<?>> getClassNamesInJarPackage(ClassLoader loader, String jarName, String packageName) throws MalformedURLException {
    ArrayList<Class<?>> classes = new ArrayList<Class<?>>();
    packageName = packageName.replaceAll("\\.", "/");
    JarInputStream jarFileInputStream = null;
    try {
        jarFileInputStream = new JarInputStream(new FileInputStream(jarName));
        JarEntry jarEntry;
        while (true) {
            jarEntry = jarFileInputStream.getNextJarEntry();
            if (jarEntry == null)
                break;
            if ((jarEntry.getName().startsWith(packageName)) && (jarEntry.getName().endsWith(".class"))) {
                classes.add(loader.loadClass(jarEntry.getName().replaceAll("/", "\\.").replace(".class", "")));
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (jarFileInputStream != null) {
                jarFileInputStream.close();
            }
        } catch (IOException e) {
        // ignore
        }
    }
    return classes;
}
#end_block

#method_before
@Test
public void statusMatches() {
    storageDomainIsInactive();
    assertTrue(cmd.CheckStorageDomainStatus(StorageDomainStatus.InActive));
    assertFalse(commandHasInvalidStatusMessage());
}
#method_after
@Test
public void statusMatches() {
    storageDomainIsInactive();
    assertTrue(cmd.checkStorageDomainStatus(StorageDomainStatus.InActive));
    assertFalse(commandHasInvalidStatusMessage());
}
#end_block

#method_before
@Test
public void statusNotMatch() {
    storageDomainIsInactive();
    assertFalse(cmd.CheckStorageDomainStatus(StorageDomainStatus.Active));
    assertTrue(commandHasInvalidStatusMessage());
}
#method_after
@Test
public void statusNotMatch() {
    storageDomainIsInactive();
    assertFalse(cmd.checkStorageDomainStatus(StorageDomainStatus.Active));
    assertTrue(commandHasInvalidStatusMessage());
}
#end_block

#method_before
private void createTestCommand() {
    StorageDomainParametersBase parameters = new StorageDomainParametersBase(Guid.NewGuid());
    cmd = spy(new TestStorageCommandBaseTest(new StorageDomainParametersBase()));
}
#method_after
private void createTestCommand() {
    StorageDomainParametersBase parameters = new StorageDomainParametersBase(Guid.NewGuid());
    cmd = spy(new TestStorageCommandBase(new StorageDomainParametersBase()));
}
#end_block

#method_before
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    boolean returnValue = CheckStoragePool() && CheckStorageDomain() && CheckStorageDomainStatus(StorageDomainStatus.InActive) && (getStorageDomain().getstorage_domain_type() == StorageDomainType.Master || isDestroyStoragePool || CheckMasterDomainIsUp());
    if (returnValue) {
        if (this.getStoragePool().getstorage_pool_type() == StorageType.LOCALFS && getStorageDomain().getstorage_domain_type() == StorageDomainType.Data && !isInternal) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DETACH_DATA_DOMAIN_FROM_LOCAL_STORAGE);
        }
    }
    if (returnValue) {
        if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getStoragePoolId())) == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
        } else if (DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getid()).size() != 0 || DbFacade.getInstance().getStorageDomainDAO().getAllImageGroupStorageDomainMapsForStorageDomain(getStorageDomain().getid()).size() != 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_STORAGE_DOMAIN_WITH_IMAGES);
        } else if (!isRemoveLast && getStorageDomain().getstorage_domain_type() == StorageDomainType.Master) {
            storage_domains storage_domains = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getstorage_pool_id().getValue()), new Predicate<storage_domains>() {

                @Override
                public boolean eval(storage_domains a) {
                    return a.getid().equals(getStorageDomain().getid()) && a.getstatus() == StorageDomainStatus.Active;
                }
            });
            if (storage_domains == null) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    boolean returnValue = CheckStoragePool() && CheckStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.InActive) && (getStorageDomain().getstorage_domain_type() == StorageDomainType.Master || isDestroyStoragePool || CheckMasterDomainIsUp());
    if (returnValue) {
        if (this.getStoragePool().getstorage_pool_type() == StorageType.LOCALFS && getStorageDomain().getstorage_domain_type() == StorageDomainType.Data && !isInternal) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DETACH_DATA_DOMAIN_FROM_LOCAL_STORAGE);
        }
    }
    if (returnValue) {
        if (DbFacade.getInstance().getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getStorageDomain().getid(), getStoragePoolId())) == null) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
        } else if (DbFacade.getInstance().getDiskImageDAO().getAllSnapshotsForStorageDomain(getStorageDomain().getid()).size() != 0 || DbFacade.getInstance().getStorageDomainDAO().getAllImageGroupStorageDomainMapsForStorageDomain(getStorageDomain().getid()).size() != 0) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_STORAGE_DOMAIN_WITH_IMAGES);
        } else if (!isRemoveLast && getStorageDomain().getstorage_domain_type() == StorageDomainType.Master) {
            storage_domains storage_domains = LinqUtils.firstOrNull(DbFacade.getInstance().getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getstorage_pool_id().getValue()), new Predicate<storage_domains>() {

                @Override
                public boolean eval(storage_domains a) {
                    return a.getid().equals(getStorageDomain().getid()) && a.getstatus() == StorageDomainStatus.Active;
                }
            });
            if (storage_domains == null) {
                returnValue = false;
                addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    if (getStorageDomainStatus() != null) {
        valid = isStorageDomainStatusInList(getStorageDomainStatus(), statuses);
    }
    if (!valid) {
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#method_after
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    if (getStorageDomainStatus() != null) {
        valid = Arrays.asList(statuses).contains(getStorageDomainStatus());
    }
    if (!valid) {
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#end_block

#method_before
private StorageDomainStatus getStorageDomainStatus() {
    StorageDomainStatus status = null;
    if (getStorageDomain() != null && getStorageDomain().getstatus() != null) {
        status = getStorageDomain().getstatus();
    }
    return status;
}
#method_after
private StorageDomainStatus getStorageDomainStatus() {
    StorageDomainStatus status = null;
    if (getStorageDomain() != null) {
        status = getStorageDomain().getstatus();
    }
    return status;
}
#end_block

#method_before
public static String LocalDateToUtcDateString(java.util.Date date) {
    return getDateFormat(utcDateFormatStr).format(date);
}
#method_after
public static String LocalDateToUtcDateString(Date date) {
    return getDateFormat(utcDateFormatStr).format(date);
}
#end_block

#method_before
private String readAllLines(BufferedReader bufferedReader) {
    String tempString;
    String returnString = null;
    try {
        while ((tempString = bufferedReader.readLine()) != null) {
            returnString += tempString + '\n';
        }
    } catch (IOException e) {
        log.error("IOException while trying to read from buffer", e);
    }
    return (returnString == null) ? null : returnString.toString();
}
#method_after
private String readAllLines(BufferedReader bufferedReader) {
    String tempString;
    StringBuilder returnString = new StringBuilder();
    try {
        while ((tempString = bufferedReader.readLine()) != null) {
            returnString.append(tempString).append('\n');
        }
    } catch (IOException e) {
        log.error("IOException while trying to read from buffer", e);
    }
    return returnString.toString();
}
#end_block

#method_before
private void logOutputAndErrors(String output, String errors) {
    if (errors != null && errors.length() != 0) {
        log.error("Sign Certificate request script errors:\n" + errors);
    }
    if (output != null && errors.length() != 0) {
        log.debug("Sign Certificate request script output:\n" + output);
    }
}
#method_after
private void logOutputAndErrors(String output, String errors) {
    if (errors != null && errors.length() != 0) {
        log.error("Sign Certificate request script errors:\n" + errors);
    }
    if (output != null && output.length() != 0) {
        log.debug("Sign Certificate request script output:\n" + output);
    }
}
#end_block

