180
#method_before
@Override
public void updateCard(CmCard card) {
    if (card instanceof ApiCard) {
        ApiCard apiCard = (ApiCard) card;
        long cardId = apiCard.getDbId();
        CardData cardData = mApiManager.getCard(apiCard.getApiAuthority(), cardId);
        boolean stillMatches = apiCard.getMatcher().hasMatchingContent(cardData);
        if (cardData != null && stillMatches) {
            apiCard.updateFromCardData(cardData);
        } else if (cardData != null) {
            // The card no longer matches, we will remove it and add a new one.
            onCardDelete(cardData.getGlobalId());
            onCardInsertOrUpdate(cardData.getGlobalId());
        }
    }
}
#method_after
@Override
public void updateCard(CmCard card) {
    if (card instanceof ApiCard) {
        ApiCard apiCard = (ApiCard) card;
        long cardId = apiCard.getDbId();
        CardData cardData = mApiManager.getCard(apiCard.getApiAuthority(), cardId);
        boolean stillMatches = apiCard.getMatcher().hasMatchingContent(cardData);
        if (cardData != null && stillMatches) {
            apiCard.updateFromCardData(cardData);
        } else if (cardData != null) {
            // The card no longer matches, we will remove it and add a new one.
            onCardDelete(cardData.getGlobalId());
            onCardInsertOrUpdate(cardData.getGlobalId(), false);
        }
    }
}
#end_block

#method_before
@Override
public List<CmCard> getCards() {
    List<CmCard> listOfCards = new ArrayList<CmCard>();
    if (mApiManager == null) {
        return listOfCards;
    }
    List<CardData> theCards = mApiManager.getAllCardDatas();
    for (CardData cardData : theCards) {
        listOfCards.add(getCardFromCardData(cardData));
    }
    return listOfCards;
}
#method_after
@Override
public List<CmCard> getCards() {
    List<CmCard> listOfCards = new ArrayList<CmCard>();
    if (mApiManager == null) {
        return listOfCards;
    }
    List<CardData> theCards = mApiManager.getAllCardDatas();
    for (CardData cardData : theCards) {
        CmCard cmCard = getCardFromCardData(cardData);
        if (cmCard != null) {
            listOfCards.add(cmCard);
        }
    }
    return listOfCards;
}
#end_block

#method_before
@Override
public void onCardInsertOrUpdate(String globalId) {
    for (CardProviderUpdateListener listener : mUpdateListeners) {
        listener.onCardProviderUpdate(globalId);
    }
}
#method_after
@Override
public void onCardInsertOrUpdate(String globalId, boolean wasPending) {
    for (CardProviderUpdateListener listener : mUpdateListeners) {
        listener.onCardProviderUpdate(globalId, wasPending);
    }
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_SYSTEM_SERVICES_READY) {
        synchronized (this) {
            mPm = getLocalService(PowerManagerInternal.class);
            if (mProfilesEnabled) {
                int profile = CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, mPerfProfileDefault);
                if (profile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
                    profile = mPerfProfileDefault;
                }
                setPowerProfileInternal(profile, true);
                mPm.registerLowPowerModeObserver(mLowPowerModeListener);
            }
        }
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_SYSTEM_SERVICES_READY) {
        synchronized (this) {
            mPm = getLocalService(PowerManagerInternal.class);
            mNumProfiles = mPm.getFeature(POWER_FEATURE_SUPPORTED_PROFILES);
            Slog.d(TAG, "Supported profiles: " + mNumProfiles);
            if (mNumProfiles > 0) {
                int profile = CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, PerformanceManager.PROFILE_BALANCED);
                if (profile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
                    profile = PerformanceManager.PROFILE_BALANCED;
                }
                setPowerProfileInternal(profile, true);
                mPm.registerLowPowerModeObserver(mLowPowerModeListener);
            }
        }
    }
}
#end_block

#method_before
private boolean hasAppProfiles() {
    return mProfilesEnabled && mPatterns != null && (CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.APP_PERFORMANCE_PROFILES_ENABLED, 1) == 1);
}
#method_after
private boolean hasAppProfiles() {
    return mNumProfiles > 0 && mPatterns != null && (CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.APP_PERFORMANCE_PROFILES_ENABLED, 1) == 1);
}
#end_block

#method_before
private synchronized void setPowerProfileInternal(int profile, boolean fromUser) {
    if (profile == mCurrentProfile) {
        return;
    }
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER, null);
    long token = Binder.clearCallingIdentity();
    if (fromUser) {
        CMSettings.Secure.putInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, profile);
    }
    mCurrentProfile = profile;
    mHandler.removeMessages(MSG_CPU_BOOST);
    mHandler.removeMessages(MSG_LAUNCH_BOOST);
    mHandler.sendMessage(Message.obtain(mHandler, MSG_SET_PROFILE, profile, (fromUser ? 1 : 0)));
    Binder.restoreCallingIdentity(token);
}
#method_after
private synchronized boolean setPowerProfileInternal(int profile, boolean fromUser) {
    if (profile == mCurrentProfile) {
        return false;
    }
    if (profile < 0 || profile > mNumProfiles) {
        Slog.e(TAG, "Invalid profile: " + profile);
        return false;
    }
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER, null);
    long token = Binder.clearCallingIdentity();
    if (fromUser) {
        CMSettings.Secure.putInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, profile);
    }
    mCurrentProfile = profile;
    mHandler.removeMessages(MSG_CPU_BOOST);
    mHandler.removeMessages(MSG_LAUNCH_BOOST);
    mHandler.sendMessage(Message.obtain(mHandler, MSG_SET_PROFILE, profile, (fromUser ? 1 : 0)));
    Binder.restoreCallingIdentity(token);
    return true;
}
#end_block

#method_before
private int getProfileForActivity(String componentName) {
    if (componentName != null) {
        for (int i = 0; i < mPatterns.length; i++) {
            if (mPatterns[i].matcher(componentName).matches()) {
                return mProfiles[i];
            }
        }
    }
    return mPerfProfileDefault;
}
#method_after
private int getProfileForActivity(String componentName) {
    if (componentName != null) {
        for (int i = 0; i < mPatterns.length; i++) {
            if (mPatterns[i].matcher(componentName).matches()) {
                return mProfiles[i];
            }
        }
    }
    return PerformanceManager.PROFILE_BALANCED;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_CPU_BOOST:
            mPm.powerHint(POWER_HINT_CPU_BOOST, msg.arg1);
            break;
        case MSG_LAUNCH_BOOST:
            mPm.powerHint(POWER_HINT_LAUNCH_BOOST, 0);
            break;
        case MSG_SET_PROFILE:
            int profile = msg.arg1;
            if (mUsePowerHAL) {
                mPm.powerHint(POWER_HINT_SET_PROFILE, profile);
            } else {
                SystemProperties.set(mPerfProfileProperty, String.valueOf(profile));
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    Slog.d(TAG, "handler what=" + msg.what + " arg=" + msg.arg1);
    switch(msg.what) {
        case MSG_CPU_BOOST:
            mPm.powerHint(POWER_HINT_CPU_BOOST, msg.arg1);
            break;
        case MSG_LAUNCH_BOOST:
            mPm.powerHint(POWER_HINT_LAUNCH_BOOST, 0);
            break;
        case MSG_SET_PROFILE:
            mPm.powerHint(POWER_HINT_SET_PROFILE, msg.arg1);
            break;
    }
}
#end_block

#method_before
public void cpuBoost(int duration) {
    try {
        if (mService != null) {
            mService.cpuBoost(duration);
        }
    } catch (RemoteException e) {
    }
}
#method_after
public void cpuBoost(int duration) {
    try {
        if (checkService()) {
            sService.cpuBoost(duration);
        }
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
public boolean setPowerProfile(int profile) {
    if (!hasPowerProfiles()) {
        throw new IllegalArgumentException("Power profiles not enabled on this system!");
    }
    boolean changed = false;
    try {
        if (mService != null) {
            changed = mService.setPowerProfile(profile);
        }
    } catch (RemoteException e) {
        throw new IllegalArgumentException(e);
    }
    return changed;
}
#method_after
public boolean setPowerProfile(int profile) {
    if (mNumberOfProfiles < 1) {
        throw new IllegalArgumentException("Power profiles not enabled on this system!");
    }
    boolean changed = false;
    try {
        if (checkService()) {
            changed = sService.setPowerProfile(profile);
        }
    } catch (RemoteException e) {
        throw new IllegalArgumentException(e);
    }
    return changed;
}
#end_block

#method_before
public int getPowerProfile() {
    int ret = -1;
    if (hasPowerProfiles()) {
        try {
            if (mService != null) {
                ret = mService.getPowerProfile();
            }
        } catch (RemoteException e) {
        // nothing
        }
    }
    return ret;
}
#method_after
public int getPowerProfile() {
    int ret = -1;
    if (mNumberOfProfiles > 0) {
        try {
            if (checkService()) {
                ret = sService.getPowerProfile();
            }
        } catch (RemoteException e) {
        // nothing
        }
    }
    return ret;
}
#end_block

#method_before
private void migrateCMSettingsForUser(int userId) {
    synchronized (this) {
        if (LOCAL_LOGV)
            Log.d(TAG, "CM settings will be migrated for user id: " + userId);
        // Migrate system settings
        HashMap<String, String> systemToCmSettingsMap = new HashMap<String, String>();
        systemToCmSettingsMap.put(LegacyCMSettings.STATUS_BAR_QUICK_QS_PULLDOWN, CMSettings.System.QS_QUICK_PULLDOWN);
        systemToCmSettingsMap.put(LegacyCMSettings.NAV_BUTTONS, CMSettings.System.NAV_BUTTONS);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_HOME_LONG_PRESS_ACTION, CMSettings.System.KEY_HOME_LONG_PRESS_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_HOME_DOUBLE_TAP_ACTION, CMSettings.System.KEY_HOME_DOUBLE_TAP_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.BACK_WAKE_SCREEN, CMSettings.System.BACK_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.MENU_WAKE_SCREEN, CMSettings.System.MENU_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.VOLUME_WAKE_SCREEN, CMSettings.System.VOLUME_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_MENU_ACTION, CMSettings.System.KEY_MENU_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_MENU_LONG_PRESS_ACTION, CMSettings.System.KEY_MENU_LONG_PRESS_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_ASSIST_ACTION, CMSettings.System.KEY_ASSIST_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_ASSIST_LONG_PRESS_ACTION, CMSettings.System.KEY_ASSIST_LONG_PRESS_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_APP_SWITCH_ACTION, CMSettings.System.KEY_APP_SWITCH_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.KEY_APP_SWITCH_LONG_PRESS_ACTION, CMSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION);
        systemToCmSettingsMap.put(LegacyCMSettings.HOME_WAKE_SCREEN, CMSettings.System.HOME_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.ASSIST_WAKE_SCREEN, CMSettings.System.ASSIST_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.APP_SWITCH_WAKE_SCREEN, CMSettings.System.APP_SWITCH_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.CAMERA_WAKE_SCREEN, CMSettings.System.CAMERA_WAKE_SCREEN);
        systemToCmSettingsMap.put(LegacyCMSettings.CAMERA_SLEEP_ON_RELEASE, CMSettings.System.CAMERA_SLEEP_ON_RELEASE);
        systemToCmSettingsMap.put(LegacyCMSettings.CAMERA_LAUNCH, CMSettings.System.CAMERA_LAUNCH);
        systemToCmSettingsMap.put(LegacyCMSettings.SWAP_VOLUME_KEYS_ON_ROTATION, CMSettings.System.SWAP_VOLUME_KEYS_ON_ROTATION);
        systemToCmSettingsMap.put(LegacyCMSettings.BATTERY_LIGHT_ENABLED, CMSettings.System.BATTERY_LIGHT_ENABLED);
        systemToCmSettingsMap.put(LegacyCMSettings.BATTERY_LIGHT_PULSE, CMSettings.System.BATTERY_LIGHT_PULSE);
        systemToCmSettingsMap.put(LegacyCMSettings.BATTERY_LIGHT_LOW_COLOR, CMSettings.System.BATTERY_LIGHT_LOW_COLOR);
        systemToCmSettingsMap.put(LegacyCMSettings.BATTERY_LIGHT_MEDIUM_COLOR, CMSettings.System.BATTERY_LIGHT_MEDIUM_COLOR);
        systemToCmSettingsMap.put(LegacyCMSettings.BATTERY_LIGHT_FULL_COLOR, CMSettings.System.BATTERY_LIGHT_FULL_COLOR);
        systemToCmSettingsMap.put(LegacyCMSettings.ENABLE_MWI_NOTIFICATION, CMSettings.System.ENABLE_MWI_NOTIFICATION);
        systemToCmSettingsMap.put(LegacyCMSettings.PROXIMITY_ON_WAKE, CMSettings.System.PROXIMITY_ON_WAKE);
        systemToCmSettingsMap.put(LegacyCMSettings.ENABLE_FORWARD_LOOKUP, CMSettings.System.ENABLE_FORWARD_LOOKUP);
        systemToCmSettingsMap.put(LegacyCMSettings.ENABLE_PEOPLE_LOOKUP, CMSettings.System.ENABLE_PEOPLE_LOOKUP);
        systemToCmSettingsMap.put(LegacyCMSettings.ENABLE_REVERSE_LOOKUP, CMSettings.System.ENABLE_REVERSE_LOOKUP);
        systemToCmSettingsMap.put(LegacyCMSettings.FORWARD_LOOKUP_PROVIDER, CMSettings.System.FORWARD_LOOKUP_PROVIDER);
        systemToCmSettingsMap.put(LegacyCMSettings.PEOPLE_LOOKUP_PROVIDER, CMSettings.System.PEOPLE_LOOKUP_PROVIDER);
        systemToCmSettingsMap.put(LegacyCMSettings.REVERSE_LOOKUP_PROVIDER, CMSettings.System.REVERSE_LOOKUP_PROVIDER);
        systemToCmSettingsMap.put(LegacyCMSettings.DIALER_OPENCNAM_ACCOUNT_SID, CMSettings.System.DIALER_OPENCNAM_ACCOUNT_SID);
        systemToCmSettingsMap.put(LegacyCMSettings.DIALER_OPENCNAM_AUTH_TOKEN, CMSettings.System.DIALER_OPENCNAM_AUTH_TOKEN);
        systemToCmSettingsMap.put(LegacyCMSettings.WIFI_AUTO_CONNECT_TYPE, CMSettings.System.WIFI_AUTO_CONNECT_TYPE);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_TEMPERATURE_DAY, CMSettings.System.DISPLAY_TEMPERATURE_DAY);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_TEMPERATURE_NIGHT, CMSettings.System.DISPLAY_TEMPERATURE_NIGHT);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_TEMPERATURE_MODE, CMSettings.System.DISPLAY_TEMPERATURE_MODE);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_AUTO_OUTDOOR_MODE, CMSettings.System.DISPLAY_AUTO_OUTDOOR_MODE);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_LOW_POWER, CMSettings.System.DISPLAY_LOW_POWER);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_COLOR_ENHANCE, CMSettings.System.DISPLAY_COLOR_ENHANCE);
        systemToCmSettingsMap.put(LegacyCMSettings.DISPLAY_COLOR_ADJUSTMENT, CMSettings.System.DISPLAY_COLOR_ADJUSTMENT);
        systemToCmSettingsMap.put(LegacyCMSettings.LIVE_DISPLAY_HINTED, CMSettings.System.LIVE_DISPLAY_HINTED);
        systemToCmSettingsMap.put(LegacyCMSettings.DOUBLE_TAP_SLEEP_GESTURE, CMSettings.System.DOUBLE_TAP_SLEEP_GESTURE);
        systemToCmSettingsMap.put(LegacyCMSettings.STATUS_BAR_SHOW_WEATHER, CMSettings.System.STATUS_BAR_SHOW_WEATHER);
        systemToCmSettingsMap.put(LegacyCMSettings.RECENTS_SHOW_SEARCH_BAR, CMSettings.System.RECENTS_SHOW_SEARCH_BAR);
        systemToCmSettingsMap.put(LegacyCMSettings.NAVBAR_LEFT_IN_LANDSCAPE, CMSettings.System.NAVBAR_LEFT_IN_LANDSCAPE);
        systemToCmSettingsMap.put(LegacyCMSettings.T9_SEARCH_INPUT_LOCALE, CMSettings.System.T9_SEARCH_INPUT_LOCALE);
        systemToCmSettingsMap.put(LegacyCMSettings.BLUETOOTH_ACCEPT_ALL_FILES, CMSettings.System.BLUETOOTH_ACCEPT_ALL_FILES);
        systemToCmSettingsMap.put(LegacyCMSettings.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT, CMSettings.System.LOCKSCREEN_PIN_SCRAMBLE_LAYOUT);
        systemToCmSettingsMap.put(LegacyCMSettings.SHOW_ALARM_ICON, CMSettings.System.SHOW_ALARM_ICON);
        systemToCmSettingsMap.put(LegacyCMSettings.STATUS_BAR_IME_SWITCHER, CMSettings.System.STATUS_BAR_IME_SWITCHER);
        systemToCmSettingsMap.put(LegacyCMSettings.QS_SHOW_BRIGHTNESS_SLIDER, CMSettings.System.QS_SHOW_BRIGHTNESS_SLIDER);
        systemToCmSettingsMap.put(LegacyCMSettings.STATUS_BAR_BRIGHTNESS_CONTROL, CMSettings.System.STATUS_BAR_BRIGHTNESS_CONTROL);
        systemToCmSettingsMap.put(LegacyCMSettings.VOLBTN_MUSIC_CONTROLS, CMSettings.System.VOLBTN_MUSIC_CONTROLS);
        systemToCmSettingsMap.put(LegacyCMSettings.SWAP_VOLUME_KEYS_ON_ROTATION, CMSettings.System.SWAP_VOLUME_KEYS_ON_ROTATION);
        systemToCmSettingsMap.put(LegacyCMSettings.USE_EDGE_SERVICE_FOR_GESTURES, CMSettings.System.USE_EDGE_SERVICE_FOR_GESTURES);
        systemToCmSettingsMap.put(LegacyCMSettings.STATUS_BAR_NOTIF_COUNT, CMSettings.System.STATUS_BAR_NOTIF_COUNT);
        systemToCmSettingsMap.put(LegacyCMSettings.CALL_RECORDING_FORMAT, CMSettings.System.CALL_RECORDING_FORMAT);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_BRIGHTNESS_LEVEL, CMSettings.System.NOTIFICATION_LIGHT_BRIGHTNESS_LEVEL);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_MULTIPLE_LEDS_ENABLE, CMSettings.System.NOTIFICATION_LIGHT_MULTIPLE_LEDS_ENABLE);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_SCREEN_ON, CMSettings.System.NOTIFICATION_LIGHT_SCREEN_ON);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_CALL_COLOR, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CALL_COLOR);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_CALL_LED_ON, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CALL_LED_ON);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_CALL_LED_OFF, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CALL_LED_OFF);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_VMAIL_COLOR, CMSettings.System.NOTIFICATION_LIGHT_PULSE_VMAIL_COLOR);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_VMAIL_LED_ON, CMSettings.System.NOTIFICATION_LIGHT_PULSE_VMAIL_LED_ON);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_VMAIL_LED_OFF, CMSettings.System.NOTIFICATION_LIGHT_PULSE_VMAIL_LED_OFF);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE);
        systemToCmSettingsMap.put(LegacyCMSettings.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES);
        int rowsMigrated = migrateCMSettingsForTable(userId, CMDatabaseHelper.CMTableNames.TABLE_SYSTEM, systemToCmSettingsMap);
        if (LOCAL_LOGV)
            Log.d(TAG, "Migrated " + rowsMigrated + " to CM system table");
        // Migrate secure settings
        HashMap<String, String> secureToCmSettingsMap = new HashMap<String, String>();
        secureToCmSettingsMap.put(LegacyCMSettings.ADVANCED_MODE, CMSettings.Secure.ADVANCED_MODE);
        secureToCmSettingsMap.put(LegacyCMSettings.BUTTON_BACKLIGHT_TIMEOUT, CMSettings.Secure.BUTTON_BACKLIGHT_TIMEOUT);
        secureToCmSettingsMap.put(LegacyCMSettings.BUTTON_BRIGHTNESS, CMSettings.Secure.BUTTON_BRIGHTNESS);
        secureToCmSettingsMap.put(LegacyCMSettings.DEFAULT_THEME_COMPONENTS, CMSettings.Secure.DEFAULT_THEME_COMPONENTS);
        secureToCmSettingsMap.put(LegacyCMSettings.DEFAULT_THEME_PACKAGE, CMSettings.Secure.DEFAULT_THEME_PACKAGE);
        secureToCmSettingsMap.put(LegacyCMSettings.DEV_FORCE_SHOW_NAVBAR, CMSettings.Secure.DEV_FORCE_SHOW_NAVBAR);
        secureToCmSettingsMap.put(LegacyCMSettings.THEME_PKG_CONFIGURATION_PERSISTENCE_PROPERTY, CMSettings.Secure.NAME_THEME_CONFIG);
        secureToCmSettingsMap.put(LegacyCMSettings.KEYBOARD_BRIGHTNESS, CMSettings.Secure.KEYBOARD_BRIGHTNESS);
        secureToCmSettingsMap.put(LegacyCMSettings.POWER_MENU_ACTIONS, CMSettings.Secure.POWER_MENU_ACTIONS);
        secureToCmSettingsMap.put(LegacyCMSettings.STATS_COLLECTION, CMSettings.Secure.STATS_COLLECTION);
        secureToCmSettingsMap.put(LegacyCMSettings.QS_SHOW_BRIGHTNESS_SLIDER, CMSettings.Secure.QS_SHOW_BRIGHTNESS_SLIDER);
        secureToCmSettingsMap.put(LegacyCMSettings.QS_TILES, CMSettings.Secure.QS_TILES);
        secureToCmSettingsMap.put(LegacyCMSettings.QS_USE_MAIN_TILES, CMSettings.Secure.QS_USE_MAIN_TILES);
        secureToCmSettingsMap.put(LegacyCMSettings.VOLUME_LINK_NOTIFICATION, CMSettings.Secure.VOLUME_LINK_NOTIFICATION);
        int navRingTargetsLength = LegacyCMSettings.NAVIGATION_RING_TARGETS.length;
        int cmNavRingTargetsLength = CMSettings.Secure.NAVIGATION_RING_TARGETS.length;
        int minNavRingTargetsLength = navRingTargetsLength <= cmNavRingTargetsLength ? navRingTargetsLength : cmNavRingTargetsLength;
        for (int i = 0; i < minNavRingTargetsLength; i++) {
            systemToCmSettingsMap.put(LegacyCMSettings.NAVIGATION_RING_TARGETS[i], CMSettings.Secure.NAVIGATION_RING_TARGETS[i]);
        }
        secureToCmSettingsMap.put(LegacyCMSettings.RECENTS_LONG_PRESS_ACTIVITY, CMSettings.Secure.RECENTS_LONG_PRESS_ACTIVITY);
        secureToCmSettingsMap.put(LegacyCMSettings.INCALL_POWER_BUTTON_BEHAVIOR, CMSettings.Secure.INCALL_POWER_BUTTON_BEHAVIOR);
        secureToCmSettingsMap.put(LegacyCMSettings.INCALL_POWER_BUTTON_BEHAVIOR, CMSettings.Secure.INCALL_POWER_BUTTON_BEHAVIOR);
        secureToCmSettingsMap.put(LegacyCMSettings.ADB_NOTIFY, CMSettings.Secure.ADB_NOTIFY);
        secureToCmSettingsMap.put(LegacyCMSettings.ADB_PORT, CMSettings.Secure.ADB_PORT);
        secureToCmSettingsMap.put(LegacyCMSettings.DEVICE_HOSTNAME, CMSettings.Secure.DEVICE_HOSTNAME);
        secureToCmSettingsMap.put(LegacyCMSettings.KILL_APP_LONGPRESS_BACK, CMSettings.Secure.KILL_APP_LONGPRESS_BACK);
        secureToCmSettingsMap.put(LegacyCMSettings.PROTECTED_COMPONENTS, CMSettings.Secure.PROTECTED_COMPONENTS);
        secureToCmSettingsMap.put(LegacyCMSettings.LIVE_DISPLAY_COLOR_MATRIX, CMSettings.Secure.LIVE_DISPLAY_COLOR_MATRIX);
        secureToCmSettingsMap.put(LegacyCMSettings.ADVANCED_REBOOT, CMSettings.Secure.ADVANCED_REBOOT);
        secureToCmSettingsMap.put(LegacyCMSettings.THEME_PREV_BOOT_API_LEVEL, CMSettings.Secure.THEME_PREV_BOOT_API_LEVEL);
        rowsMigrated = migrateCMSettingsForTable(userId, CMDatabaseHelper.CMTableNames.TABLE_SECURE, secureToCmSettingsMap);
        if (LOCAL_LOGV)
            Log.d(TAG, "Migrated " + rowsMigrated + " to CM secure table");
        // Migrate global settings
        HashMap<String, String> globalToCmSettingsMap = new HashMap<String, String>();
        globalToCmSettingsMap.put(LegacyCMSettings.WAKE_WHEN_PLUGGED_OR_UNPLUGGED, CMSettings.Global.WAKE_WHEN_PLUGGED_OR_UNPLUGGED);
        globalToCmSettingsMap.put(LegacyCMSettings.BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX, CMSettings.Global.BLUETOOTH_A2DP_SRC_PRIORITY_PREFIX);
        globalToCmSettingsMap.put(LegacyCMSettings.POWER_NOTIFICATIONS_ENABLED, CMSettings.Global.POWER_NOTIFICATIONS_ENABLED);
        globalToCmSettingsMap.put(LegacyCMSettings.POWER_NOTIFICATIONS_VIBRATE, CMSettings.Global.POWER_NOTIFICATIONS_VIBRATE);
        globalToCmSettingsMap.put(LegacyCMSettings.POWER_NOTIFICATIONS_RINGTONE, CMSettings.Global.POWER_NOTIFICATIONS_RINGTONE);
        globalToCmSettingsMap.put(LegacyCMSettings.ZEN_DISABLE_DUCKING_DURING_MEDIA_PLAYBACK, CMSettings.Global.ZEN_DISABLE_DUCKING_DURING_MEDIA_PLAYBACK);
        globalToCmSettingsMap.put(LegacyCMSettings.WIFI_AUTO_PRIORITIES_CONFIGURATION, CMSettings.Global.WIFI_AUTO_PRIORITIES_CONFIGURATION);
        rowsMigrated = migrateCMSettingsForTable(userId, CMDatabaseHelper.CMTableNames.TABLE_GLOBAL, globalToCmSettingsMap);
        if (LOCAL_LOGV)
            Log.d(TAG, "Migrated " + rowsMigrated + " to CM global table");
    }
}
#method_after
private void migrateCMSettingsForUser(int userId) {
    synchronized (this) {
        if (LOCAL_LOGV)
            Log.d(TAG, "CM settings will be migrated for user id: " + userId);
        // Migrate system settings
        int rowsMigrated = migrateCMSettingsForTable(userId, CMDatabaseHelper.CMTableNames.TABLE_SYSTEM, CMSettings.System.LEGACY_SYSTEM_SETTINGS);
        if (LOCAL_LOGV)
            Log.d(TAG, "Migrated " + rowsMigrated + " to CM system table");
        // Migrate secure settings
        rowsMigrated = migrateCMSettingsForTable(userId, CMDatabaseHelper.CMTableNames.TABLE_SECURE, CMSettings.Secure.LEGACY_SECURE_SETTINGS);
        if (LOCAL_LOGV)
            Log.d(TAG, "Migrated " + rowsMigrated + " to CM secure table");
        // Migrate global settings
        rowsMigrated = migrateCMSettingsForTable(userId, CMDatabaseHelper.CMTableNames.TABLE_GLOBAL, CMSettings.Global.LEGACY_GLOBAL_SETTINGS);
        if (LOCAL_LOGV)
            Log.d(TAG, "Migrated " + rowsMigrated + " to CM global table");
    }
}
#end_block

#method_before
private int migrateCMSettingsForTable(int userId, String tableName, HashMap<String, String> settingsMap) {
    ContentResolver contentResolver = getContext().getContentResolver();
    Set<Map.Entry<String, String>> entrySet = settingsMap.entrySet();
    ContentValues[] contentValues = new ContentValues[settingsMap.size()];
    int migrateSettingsCount = 0;
    for (Map.Entry<String, String> keyPair : entrySet) {
        String settingsKey = keyPair.getKey();
        String cmSettingsKey = keyPair.getValue();
        String settingsValue = null;
        if (tableName.equals(CMDatabaseHelper.CMTableNames.TABLE_SYSTEM)) {
            settingsValue = Settings.System.getStringForUser(contentResolver, settingsKey, userId);
        } else if (tableName.equals(CMDatabaseHelper.CMTableNames.TABLE_SECURE)) {
            settingsValue = Settings.Secure.getStringForUser(contentResolver, settingsKey, userId);
        } else if (tableName.equals(CMDatabaseHelper.CMTableNames.TABLE_GLOBAL)) {
            settingsValue = Settings.Global.getStringForUser(contentResolver, settingsKey, userId);
        }
        if (LOCAL_LOGV)
            Log.d(TAG, "Table: " + tableName + ", Key: " + settingsKey + ", Value: " + settingsValue);
        ContentValues contentValue = new ContentValues();
        contentValue.put(Settings.NameValueTable.NAME, cmSettingsKey);
        contentValue.put(Settings.NameValueTable.VALUE, settingsValue);
        contentValues[migrateSettingsCount++] = contentValue;
    }
    int rowsInserted = 0;
    if (contentValues.length > 0) {
        Uri uri = mUriBuilder.build();
        uri = uri.buildUpon().appendPath(tableName).build();
        rowsInserted = bulkInsertForUser(userId, uri, contentValues);
    }
    return rowsInserted;
}
#method_after
private int migrateCMSettingsForTable(int userId, String tableName, String[] settings) {
    ContentResolver contentResolver = getContext().getContentResolver();
    ContentValues[] contentValues = new ContentValues[settings.length];
    int migrateSettingsCount = 0;
    for (String settingsKey : settings) {
        String settingsValue = null;
        if (tableName.equals(CMDatabaseHelper.CMTableNames.TABLE_SYSTEM)) {
            settingsValue = Settings.System.getStringForUser(contentResolver, settingsKey, userId);
        } else if (tableName.equals(CMDatabaseHelper.CMTableNames.TABLE_SECURE)) {
            settingsValue = Settings.Secure.getStringForUser(contentResolver, settingsKey, userId);
        } else if (tableName.equals(CMDatabaseHelper.CMTableNames.TABLE_GLOBAL)) {
            settingsValue = Settings.Global.getStringForUser(contentResolver, settingsKey, userId);
        }
        if (LOCAL_LOGV)
            Log.d(TAG, "Table: " + tableName + ", Key: " + settingsKey + ", Value: " + settingsValue);
        ContentValues contentValue = new ContentValues();
        contentValue.put(Settings.NameValueTable.NAME, settingsKey);
        contentValue.put(Settings.NameValueTable.VALUE, settingsValue);
        contentValues[migrateSettingsCount++] = contentValue;
    }
    int rowsInserted = 0;
    if (contentValues.length > 0) {
        Uri uri = mUriBuilder.build();
        uri = uri.buildUpon().appendPath(tableName).build();
        rowsInserted = bulkInsertForUser(userId, uri, contentValues);
    }
    return rowsInserted;
}
#end_block

#method_before
private Uri insertForUser(int userId, Uri uri, ContentValues values) {
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, userId));
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        final String value = values.getAsString(Settings.NameValueTable.VALUE);
        validateSystemSettingValue(name, value);
    }
    long rowId = db.insert(tableName, null, values);
    Uri returnUri = null;
    if (rowId > -1) {
        returnUri = Uri.withAppendedPath(uri, name);
        notifyChange(returnUri, tableName, userId);
        if (LOCAL_LOGV)
            Log.d(TAG, "Inserted row id: " + rowId + " into tableName: " + tableName);
    }
    return returnUri;
}
#method_after
private Uri insertForUser(int userId, Uri uri, ContentValues values) {
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, userId));
    // Validate value if inserting int System table
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        final String value = values.getAsString(Settings.NameValueTable.VALUE);
        validateSystemSettingNameValue(name, value);
    }
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    long rowId = db.insert(tableName, null, values);
    Uri returnUri = null;
    if (rowId > -1) {
        returnUri = Uri.withAppendedPath(uri, name);
        notifyChange(returnUri, tableName, userId);
        if (LOCAL_LOGV)
            Log.d(TAG, "Inserted row id: " + rowId + " into tableName: " + tableName);
    }
    return returnUri;
}
#end_block

#method_before
@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    // be done by system code, and that code should be using the correct API up front.
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    int callingUserId = UserHandle.getCallingUserId();
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, callingUserId));
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    int numRowsAffected = db.update(tableName, values, selection, selectionArgs);
    if (numRowsAffected > 0) {
        notifyChange(uri, tableName, callingUserId);
        if (LOCAL_LOGV)
            Log.d(TAG, tableName + ": " + numRowsAffected + " row(s) updated");
    }
    return numRowsAffected;
}
#method_after
@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    // be done by system code, and that code should be using the correct API up front.
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    // Validate value if updating System table
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        final String value = values.getAsString(Settings.NameValueTable.VALUE);
        validateSystemSettingNameValue(name, value);
    }
    int callingUserId = UserHandle.getCallingUserId();
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, callingUserId));
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    int numRowsAffected = db.update(tableName, values, selection, selectionArgs);
    if (numRowsAffected > 0) {
        notifyChange(uri, tableName, callingUserId);
        if (LOCAL_LOGV)
            Log.d(TAG, tableName + ": " + numRowsAffected + " row(s) updated");
    }
    return numRowsAffected;
}
#end_block

#method_before
public int getUserProfile() {
    return CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, PerformanceManager.PROFILE_BALANCED);
}
#method_after
private int getUserProfile() {
    return CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, PerformanceManager.PROFILE_BALANCED);
}
#end_block

#method_before
public int getUserProfile() {
    return CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, PerformanceManager.PROFILE_BALANCED);
}
#method_after
private int getUserProfile() {
    return CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, PerformanceManager.PROFILE_BALANCED);
}
#end_block

#method_before
private void applyProfile() {
    if (mNumProfiles < 1) {
        // don't have profiles, bail.
        return;
    }
    int profile;
    if (mLowPowerModeEnabled) {
        // LPM always wins
        profile = PerformanceManager.PROFILE_POWER_SAVE;
    } else {
        profile = getUserProfile();
        // use app specific rules if profile is balanced
        if (hasAppProfiles() && profile == PerformanceManager.PROFILE_BALANCED) {
            profile = getProfileForActivity(mCurrentActivityName);
        }
    }
    setPowerProfileInternal(profile, false);
}
#method_after
private void applyProfile() {
    if (mNumProfiles < 1) {
        // don't have profiles, bail.
        return;
    }
    int profile;
    if (mLowPowerModeEnabled) {
        // LPM always wins
        profile = PerformanceManager.PROFILE_POWER_SAVE;
    } else {
        profile = getUserProfile();
        // use app specific rules if profile is balanced
        if (hasAppProfiles() && getProfileHasAppProfilesInternal(profile)) {
            profile = getProfileForActivity(mCurrentActivityName);
        }
    }
    setPowerProfileInternal(profile, false);
}
#end_block

#method_before
// endregion Migration Methods
// region Content Provider Methods
@Override
public Bundle call(String method, String request, Bundle args) {
    if (LOCAL_LOGV)
        Log.d(TAG, "Call method: " + method + " " + request);
    int callingUserId = UserHandle.getCallingUserId();
    if (args != null) {
        int reqUser = args.getInt(CMSettings.CALL_METHOD_USER_KEY, callingUserId);
        if (reqUser != callingUserId) {
            callingUserId = ActivityManager.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), reqUser, false, true, "get/set setting for user", null);
            if (LOCAL_LOGV)
                Log.v(TAG, "   access setting for user " + callingUserId);
        }
    }
    boolean hasMigratedCMSettings = mSharedPrefs.getBoolean(PREF_HAS_MIGRATED_CM_SETTINGS, false);
    if (!hasMigratedCMSettings) {
        if (LOCAL_LOGV) {
            Log.d(TAG, "Reenabling component preboot receiver");
        }
        getContext().getPackageManager().setComponentEnabledSetting(new ComponentName("org.cyanogenmod.cmsettings", "org.cyanogenmod.cmsettings.PreBootReceiver"), PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
    }
    // Migrate methods
    if (CMSettings.CALL_METHOD_MIGRATE_SETTINGS.equals(method)) {
        migrateCMSettingsForExistingUsersIfNeeded();
        return null;
    } else if (CMSettings.CALL_METHOD_MIGRATE_SETTINGS_FOR_USER.equals(method)) {
        migrateCMSettingsForUser(callingUserId);
        return null;
    }
    // Get methods
    if (CMSettings.CALL_METHOD_GET_SYSTEM.equals(method)) {
        return lookupSingleValue(callingUserId, CMSettings.System.CONTENT_URI, request);
    } else if (CMSettings.CALL_METHOD_GET_SECURE.equals(method)) {
        return lookupSingleValue(callingUserId, CMSettings.Secure.CONTENT_URI, request);
    } else if (CMSettings.CALL_METHOD_GET_GLOBAL.equals(method)) {
        return lookupSingleValue(callingUserId, CMSettings.Global.CONTENT_URI, request);
    }
    // Put methods - new value is in the args bundle under the key named by
    // the Settings.NameValueTable.VALUE static.
    final String newValue = (args == null) ? null : args.getString(Settings.NameValueTable.VALUE);
    // to do it here.
    if (getContext().checkCallingOrSelfPermission(cyanogenmod.platform.Manifest.permission.WRITE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(String.format("Permission denial: writing to settings requires %1$s", cyanogenmod.platform.Manifest.permission.WRITE_SETTINGS));
    }
    // Put methods
    final ContentValues values = new ContentValues();
    values.put(Settings.NameValueTable.NAME, request);
    values.put(Settings.NameValueTable.VALUE, newValue);
    if (CMSettings.CALL_METHOD_PUT_SYSTEM.equals(method)) {
        insertForUser(callingUserId, CMSettings.System.CONTENT_URI, values);
    } else if (CMSettings.CALL_METHOD_PUT_SECURE.equals(method)) {
        insertForUser(callingUserId, CMSettings.Secure.CONTENT_URI, values);
    } else if (CMSettings.CALL_METHOD_PUT_GLOBAL.equals(method)) {
        insertForUser(callingUserId, CMSettings.Global.CONTENT_URI, values);
    }
    return null;
}
#method_after
// endregion Migration Methods
// region Content Provider Methods
@Override
public Bundle call(String method, String request, Bundle args) {
    if (LOCAL_LOGV)
        Log.d(TAG, "Call method: " + method + " " + request);
    int callingUserId = UserHandle.getCallingUserId();
    if (args != null) {
        int reqUser = args.getInt(CMSettings.CALL_METHOD_USER_KEY, callingUserId);
        if (reqUser != callingUserId) {
            callingUserId = ActivityManager.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), reqUser, false, true, "get/set setting for user", null);
            if (LOCAL_LOGV)
                Log.v(TAG, "   access setting for user " + callingUserId);
        }
    }
    boolean hasMigratedCMSettings = mSharedPrefs.getBoolean(PREF_HAS_MIGRATED_CM_SETTINGS, false);
    final ComponentName preBootReceiver = new ComponentName("org.cyanogenmod.cmsettings", "org.cyanogenmod.cmsettings.PreBootReceiver");
    final PackageManager packageManager = getContext().getPackageManager();
    if (!hasMigratedCMSettings && packageManager.getComponentEnabledSetting(preBootReceiver) == PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
        if (LOCAL_LOGV) {
            Log.d(TAG, "Reenabling component preboot receiver");
        }
        packageManager.setComponentEnabledSetting(preBootReceiver, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
    }
    // Migrate methods
    if (CMSettings.CALL_METHOD_MIGRATE_SETTINGS.equals(method)) {
        migrateCMSettingsForExistingUsersIfNeeded();
        return null;
    } else if (CMSettings.CALL_METHOD_MIGRATE_SETTINGS_FOR_USER.equals(method)) {
        migrateCMSettingsForUser(callingUserId);
        return null;
    }
    // Get methods
    if (CMSettings.CALL_METHOD_GET_SYSTEM.equals(method)) {
        return lookupSingleValue(callingUserId, CMSettings.System.CONTENT_URI, request);
    } else if (CMSettings.CALL_METHOD_GET_SECURE.equals(method)) {
        return lookupSingleValue(callingUserId, CMSettings.Secure.CONTENT_URI, request);
    } else if (CMSettings.CALL_METHOD_GET_GLOBAL.equals(method)) {
        return lookupSingleValue(callingUserId, CMSettings.Global.CONTENT_URI, request);
    }
    // Put methods - new value is in the args bundle under the key named by
    // the Settings.NameValueTable.VALUE static.
    final String newValue = (args == null) ? null : args.getString(Settings.NameValueTable.VALUE);
    // to do it here.
    if (getContext().checkCallingOrSelfPermission(cyanogenmod.platform.Manifest.permission.WRITE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException(String.format("Permission denial: writing to settings requires %1$s", cyanogenmod.platform.Manifest.permission.WRITE_SETTINGS));
    }
    // Put methods
    final ContentValues values = new ContentValues();
    values.put(Settings.NameValueTable.NAME, request);
    values.put(Settings.NameValueTable.VALUE, newValue);
    if (CMSettings.CALL_METHOD_PUT_SYSTEM.equals(method)) {
        insertForUser(callingUserId, CMSettings.System.CONTENT_URI, values);
    } else if (CMSettings.CALL_METHOD_PUT_SECURE.equals(method)) {
        insertForUser(callingUserId, CMSettings.Secure.CONTENT_URI, values);
    } else if (CMSettings.CALL_METHOD_PUT_GLOBAL.equals(method)) {
        insertForUser(callingUserId, CMSettings.Global.CONTENT_URI, values);
    }
    return null;
}
#end_block

#method_before
private Uri insertForUser(int userId, Uri uri, ContentValues values) {
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, userId));
    // Validate value if inserting int System table
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    final String value = values.getAsString(Settings.NameValueTable.VALUE);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        validateSystemSettingNameValue(name, value);
    } else if (CMDatabaseHelper.CMTableNames.TABLE_SECURE.equals(tableName)) {
        validateSecureSettingNameValue(name, value);
    }
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    long rowId = db.insert(tableName, null, values);
    Uri returnUri = null;
    if (rowId > -1) {
        returnUri = Uri.withAppendedPath(uri, name);
        notifyChange(returnUri, tableName, userId);
        if (LOCAL_LOGV)
            Log.d(TAG, "Inserted row id: " + rowId + " into tableName: " + tableName);
    }
    return returnUri;
}
#method_after
private Uri insertForUser(int userId, Uri uri, ContentValues values) {
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, userId));
    // Validate value if inserting int System table
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    final String value = values.getAsString(Settings.NameValueTable.VALUE);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        validateSystemSettingNameValue(name, value);
    } else if (CMDatabaseHelper.CMTableNames.TABLE_SECURE.equals(tableName)) {
        validateSecureSettingValue(name, value);
    }
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    long rowId = db.insert(tableName, null, values);
    Uri returnUri = null;
    if (rowId > -1) {
        returnUri = Uri.withAppendedPath(uri, name);
        notifyChange(returnUri, tableName, userId);
        if (LOCAL_LOGV)
            Log.d(TAG, "Inserted row id: " + rowId + " into tableName: " + tableName);
    }
    return returnUri;
}
#end_block

#method_before
@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    // be done by system code, and that code should be using the correct API up front.
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    // Validate value if updating System table
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    final String value = values.getAsString(Settings.NameValueTable.VALUE);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        validateSystemSettingNameValue(name, value);
    } else if (CMDatabaseHelper.CMTableNames.TABLE_SECURE.equals(tableName)) {
        validateSecureSettingNameValue(name, value);
    }
    int callingUserId = UserHandle.getCallingUserId();
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, callingUserId));
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    int numRowsAffected = db.update(tableName, values, selection, selectionArgs);
    if (numRowsAffected > 0) {
        notifyChange(uri, tableName, callingUserId);
        if (LOCAL_LOGV)
            Log.d(TAG, tableName + ": " + numRowsAffected + " row(s) updated");
    }
    return numRowsAffected;
}
#method_after
@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    // be done by system code, and that code should be using the correct API up front.
    if (uri == null) {
        throw new IllegalArgumentException("Uri cannot be null");
    }
    if (values == null) {
        throw new IllegalArgumentException("ContentValues cannot be null");
    }
    String tableName = getTableNameFromUri(uri);
    checkWritePermissions(tableName);
    // Validate value if updating System table
    final String name = values.getAsString(Settings.NameValueTable.NAME);
    final String value = values.getAsString(Settings.NameValueTable.VALUE);
    if (CMDatabaseHelper.CMTableNames.TABLE_SYSTEM.equals(tableName)) {
        validateSystemSettingNameValue(name, value);
    } else if (CMDatabaseHelper.CMTableNames.TABLE_SECURE.equals(tableName)) {
        validateSecureSettingValue(name, value);
    }
    int callingUserId = UserHandle.getCallingUserId();
    CMDatabaseHelper dbHelper = getOrEstablishDatabase(getUserIdForTable(tableName, callingUserId));
    SQLiteDatabase db = dbHelper.getWritableDatabase();
    int numRowsAffected = db.update(tableName, values, selection, selectionArgs);
    if (numRowsAffected > 0) {
        notifyChange(uri, tableName, callingUserId);
        if (LOCAL_LOGV)
            Log.d(TAG, tableName + ": " + numRowsAffected + " row(s) updated");
    }
    return numRowsAffected;
}
#end_block

#method_before
public void setThirdPartyKeyguard(ComponentName component) throws PackageManager.NameNotFoundException {
    if (component != null) {
        // Check that the package this component belongs to has the third party keyguard perm
        final PackageManager pm = mContext.getPackageManager();
        PackageInfo pi = pm.getPackageInfo(component.getPackageName(), PackageManager.GET_PERMISSIONS);
        boolean hasThirdPartyKeyguardPermission = false;
        for (String perm : pi.requestedPermissions) {
            if (Manifest.permission.THIRD_PARTY_KEYGUARD.equals(perm)) {
                hasThirdPartyKeyguardPermission = true;
                break;
            }
        }
        if (!hasThirdPartyKeyguardPermission) {
            throw new SecurityException("Package " + component.getPackageName() + " does not" + "have " + Manifest.permission.THIRD_PARTY_KEYGUARD);
        }
    }
    setString(THIRD_PARTY_KEYGUARD_COMPONENT, component != null ? component.flattenToString() : "", getCurrentUser());
}
#method_after
public void setThirdPartyKeyguard(ComponentName component) throws PackageManager.NameNotFoundException {
    if (component != null) {
        // Check that the package this component belongs to has the third party keyguard perm
        final PackageManager pm = mContext.getPackageManager();
        final boolean hasThirdPartyKeyguardPermission = pm.checkPermission(Manifest.permission.THIRD_PARTY_KEYGUARD, component.getPackageName()) == PackageManager.PERMISSION_GRANTED;
        if (!hasThirdPartyKeyguardPermission) {
            throw new SecurityException("Package " + component.getPackageName() + " does not" + "have " + Manifest.permission.THIRD_PARTY_KEYGUARD);
        }
    }
    setString(THIRD_PARTY_KEYGUARD_COMPONENT, component != null ? component.flattenToString() : "", getCurrentUser());
}
#end_block

#method_before
final int getWindowType() {
    return WindowManager.LayoutParams.TYPE_KEYGUARD_PANEL;
}
#method_after
int getWindowType() {
    return WindowManager.LayoutParams.TYPE_KEYGUARD_PANEL;
}
#end_block

#method_before
final int getWindowFlags() {
    return WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_FULLSCREEN;
}
#method_after
int getWindowFlags() {
    return WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_FULLSCREEN;
}
#end_block

#method_before
private void initialize(boolean skipFile) {
    mTriggerHelper = new ProfileTriggerHelper(mContext, mHandler, this);
    mProfiles = new HashMap<UUID, Profile>();
    mProfileNames = new HashMap<String, UUID>();
    mGroups = new HashMap<UUID, NotificationGroup>();
    mDirty = false;
    boolean init = skipFile;
    if (!skipFile) {
        try {
            loadFromFile();
        } catch (XmlPullParserException e) {
            init = true;
        } catch (IOException e) {
            init = true;
        }
    }
    if (init) {
        try {
            initialiseStructure();
        } catch (Throwable ex) {
            Log.e(TAG, "Error loading xml from resource: ", ex);
        }
    }
}
#method_after
private void initialize(boolean skipFile) {
    mTriggerHelper = new ProfileTriggerHelper(mContext, mHandler, this);
    mProfiles = new HashMap<UUID, Profile>();
    mProfileNames = new HashMap<String, UUID>();
    mGroups = new HashMap<UUID, NotificationGroup>();
    mEmptyProfile = new Profile("EmptyProfile");
    mDirty = false;
    boolean init = skipFile;
    if (!skipFile) {
        try {
            loadFromFile();
        } catch (XmlPullParserException e) {
            init = true;
        } catch (IOException e) {
            init = true;
        }
    }
    if (init) {
        try {
            initialiseStructure();
        } catch (Throwable ex) {
            Log.e(TAG, "Error loading xml from resource: ", ex);
        }
    }
}
#end_block

#method_before
public Profile getActiveProfile() {
    if (CMSettings.System.getInt(mContext.getContentResolver(), CMSettings.System.SYSTEM_PROFILES_ENABLED, 1) == 1) {
        // Profiles are enabled, return active profile
        try {
            return getService().getActiveProfile();
        } catch (RemoteException e) {
            Log.e(TAG, e.getLocalizedMessage(), e);
        }
        return null;
    } else {
        // Profiles are not enabled, return the empty profile
        return mEmptyProfile;
    }
}
#method_after
public Profile getActiveProfile() {
    try {
        return getService().getActiveProfile();
    } catch (RemoteException e) {
        Log.e(TAG, e.getLocalizedMessage(), e);
    }
    return null;
}
#end_block

#method_before
private boolean setZenModeInternal(int mode, long durationMillis) {
    ContentResolver contentResolver = mContext.getContentResolver();
    int zenModeValue = -1;
    Uri zenModeConditionUri = null;
    switch(mode) {
        case PartnerInterface.ZEN_MODE_IMPORTANT_INTERRUPTIONS:
            zenModeValue = Settings.Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS;
            if (durationMillis > -1 && durationMillis <= PartnerInterface.ZEN_MODE_DURATION_MAX_MS) {
                zenModeConditionUri = createZenModeConditionUri(durationMillis);
            }
            break;
        case PartnerInterface.ZEN_MODE_OFF:
            zenModeValue = Settings.Global.ZEN_MODE_OFF;
            // durationMillis is ignored
            break;
        case PartnerInterface.ZEN_MODE_NO_INTERRUPTIONS:
            zenModeValue = Settings.Global.ZEN_MODE_NO_INTERRUPTIONS;
            if (durationMillis > -1 && durationMillis <= PartnerInterface.ZEN_MODE_DURATION_MAX_MS) {
                zenModeConditionUri = createZenModeConditionUri(durationMillis);
            }
            break;
        default:
            // Invalid mode parameter
            Log.w(TAG, "setZenMode() called with invalid mode: " + mode);
            return false;
    }
    try {
        mNotificationManager.setZenMode(mode, zenModeConditionUri, "setZenMode (PartnerInterface)");
    } catch (RemoteException e) {
        // An error occurred, return false since the
        // condition failed to set.
        Log.e(TAG, "setZenMode() failed for mode: " + mode);
        return false;
    }
    return true;
}
#method_after
private boolean setZenModeInternal(int mode, long durationMillis) {
    int zenModeValue = -1;
    Uri zenModeConditionUri = null;
    switch(mode) {
        case PartnerInterface.ZEN_MODE_IMPORTANT_INTERRUPTIONS:
            zenModeValue = Settings.Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS;
            zenModeConditionUri = createZenModeConditionUri(durationMillis);
            break;
        case PartnerInterface.ZEN_MODE_OFF:
            zenModeValue = Settings.Global.ZEN_MODE_OFF;
            // durationMillis is ignored
            break;
        case PartnerInterface.ZEN_MODE_NO_INTERRUPTIONS:
            zenModeValue = Settings.Global.ZEN_MODE_NO_INTERRUPTIONS;
            zenModeConditionUri = createZenModeConditionUri(durationMillis);
            break;
        default:
            // Invalid mode parameter
            Log.w(TAG, "setZenMode() called with invalid mode: " + mode);
            return false;
    }
    try {
        mNotificationManager.setZenMode(zenModeValue, zenModeConditionUri, "setZenMode (PartnerInterface)");
    } catch (RemoteException e) {
        // An error occurred, return false since the
        // condition failed to set.
        Log.e(TAG, "setZenMode() failed for mode: " + mode);
        return false;
    }
    return true;
}
#end_block

#method_before
private Uri createZenModeConditionUri(long durationMillis) {
    final long endTimeMillis = System.currentTimeMillis() + durationMillis;
    // handle MAX_LONG overflow by turning it into "Indefinite" duration
    if (endTimeMillis < 0) {
        Log.w(TAG, "createZenModeCondition duration exceeds the max numerical limit. Defaulting to Indefinite");
        return null;
    }
    return android.service.notification.ZenModeConfig.toCountdownConditionId(endTimeMillis);
}
#method_after
private Uri createZenModeConditionUri(long durationMillis) {
    // duration values that mean "indefinitely"
    if (durationMillis == Long.MAX_VALUE || durationMillis < 0) {
        return null;
    }
    final long endTimeMillis = System.currentTimeMillis() + durationMillis;
    // long overflow also means "indefinitely"
    if (endTimeMillis < 0) {
        Log.w(TAG, "createZenModeCondition duration exceeds the max numerical limit. Defaulting to Indefinite");
        return null;
    }
    return android.service.notification.ZenModeConfig.toCountdownConditionId(endTimeMillis);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder b = new StringBuilder();
    String NEW_LINE = System.getProperty("line.separator");
    if (onClickUri != null) {
        b.append("onClickUri=" + onClickUri.toString() + NEW_LINE);
    }
    if (onClick != null) {
        b.append("onClick=" + onClick.toString() + NEW_LINE);
    }
    if (onLongClick != null) {
        b.append("onLongClick=" + onLongClick.toString() + NEW_LINE);
        b.append("collapsePanelLongPress=" + collapsePanelLongPress + NEW_LINE);
    }
    if (onSettingsClick != null) {
        b.append("onSettingsClick=" + onSettingsClick.toString() + NEW_LINE);
    }
    if (!TextUtils.isEmpty(label)) {
        b.append("label=" + label + NEW_LINE);
    }
    if (!TextUtils.isEmpty(contentDescription)) {
        b.append("contentDescription=" + contentDescription + NEW_LINE);
    }
    if (expandedStyle != null) {
        b.append("expandedStyle=" + expandedStyle + NEW_LINE);
    }
    b.append("icon=" + icon + NEW_LINE);
    b.append("resourcesPackageName=" + resourcesPackageName + NEW_LINE);
    b.append("collapsePanel=" + collapsePanel + NEW_LINE);
    if (remoteIcon != null) {
        b.append("remoteIcon=" + remoteIcon.getGenerationId() + NEW_LINE);
    }
    if (deleteIntent != null) {
        b.append("deleteIntent=" + deleteIntent.toString() + NEW_LINE);
    }
    b.append("sensitiveData=" + sensitiveData + NEW_LINE);
    return b.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder b = new StringBuilder();
    String NEW_LINE = System.getProperty("line.separator");
    if (onClickUri != null) {
        b.append("onClickUri=" + onClickUri.toString() + NEW_LINE);
    }
    if (onClick != null) {
        b.append("onClick=" + onClick.toString() + NEW_LINE);
    }
    if (onLongClick != null) {
        b.append("onLongClick=" + onLongClick.toString() + NEW_LINE);
    }
    if (onSettingsClick != null) {
        b.append("onSettingsClick=" + onSettingsClick.toString() + NEW_LINE);
    }
    if (!TextUtils.isEmpty(label)) {
        b.append("label=" + label + NEW_LINE);
    }
    if (!TextUtils.isEmpty(contentDescription)) {
        b.append("contentDescription=" + contentDescription + NEW_LINE);
    }
    if (expandedStyle != null) {
        b.append("expandedStyle=" + expandedStyle + NEW_LINE);
    }
    b.append("icon=" + icon + NEW_LINE);
    b.append("resourcesPackageName=" + resourcesPackageName + NEW_LINE);
    b.append("collapsePanel=" + collapsePanel + NEW_LINE);
    if (remoteIcon != null) {
        b.append("remoteIcon=" + remoteIcon.getGenerationId() + NEW_LINE);
    }
    if (deleteIntent != null) {
        b.append("deleteIntent=" + deleteIntent.toString() + NEW_LINE);
    }
    b.append("sensitiveData=" + sensitiveData + NEW_LINE);
    return b.toString();
}
#end_block

#method_before
public void cloneInto(CustomTile that) {
    that.resourcesPackageName = this.resourcesPackageName;
    that.onClick = this.onClick;
    that.onLongClick = this.onLongClick;
    that.onSettingsClick = this.onSettingsClick;
    that.onClickUri = this.onClickUri;
    that.label = this.label;
    that.contentDescription = this.contentDescription;
    that.expandedStyle = this.expandedStyle;
    that.icon = this.icon;
    that.collapsePanel = this.collapsePanel;
    that.collapsePanelLongPress = this.collapsePanelLongPress;
    that.remoteIcon = this.remoteIcon;
    that.deleteIntent = this.deleteIntent;
    that.sensitiveData = this.sensitiveData;
}
#method_after
public void cloneInto(CustomTile that) {
    that.resourcesPackageName = this.resourcesPackageName;
    that.onClick = this.onClick;
    that.onLongClick = this.onLongClick;
    that.onSettingsClick = this.onSettingsClick;
    that.onClickUri = this.onClickUri;
    that.label = this.label;
    that.contentDescription = this.contentDescription;
    that.expandedStyle = this.expandedStyle;
    that.icon = this.icon;
    that.collapsePanel = this.collapsePanel;
    that.remoteIcon = this.remoteIcon;
    that.deleteIntent = this.deleteIntent;
    that.sensitiveData = this.sensitiveData;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel out, int flags) {
    // Write parcelable version, make sure to define explicit changes
    // within {@link Build.PARCELABLE_VERSION);
    out.writeInt(Build.PARCELABLE_VERSION);
    // Inject a placeholder that will store the parcel size from this point on
    // (not including the size itself).
    int sizePosition = out.dataPosition();
    out.writeInt(0);
    int startPosition = out.dataPosition();
    // ==== APRICOT =====
    if (onClick != null) {
        out.writeInt(1);
        onClick.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (onSettingsClick != null) {
        out.writeInt(1);
        onSettingsClick.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (onClickUri != null) {
        out.writeInt(1);
        onClickUri.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (label != null) {
        out.writeInt(1);
        out.writeString(label);
    } else {
        out.writeInt(0);
    }
    if (contentDescription != null) {
        out.writeInt(1);
        out.writeString(contentDescription);
    } else {
        out.writeInt(0);
    }
    if (expandedStyle != null) {
        out.writeInt(1);
        expandedStyle.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    out.writeInt(icon);
    // ==== BOYSENBERRY =====
    out.writeString(resourcesPackageName);
    out.writeInt(collapsePanel ? 1 : 0);
    if (remoteIcon != null) {
        out.writeInt(1);
        remoteIcon.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (deleteIntent != null) {
        out.writeInt(1);
        deleteIntent.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    out.writeInt(sensitiveData ? 1 : 0);
    // ==== DRAGONFRUIT ====
    if (onLongClick != null) {
        out.writeInt(1);
        onLongClick.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    out.writeInt(collapsePanelLongPress ? 1 : 0);
    // Go back and write size
    int parcelableSize = out.dataPosition() - startPosition;
    out.setDataPosition(sizePosition);
    out.writeInt(parcelableSize);
    out.setDataPosition(startPosition + parcelableSize);
}
#method_after
@Override
public void writeToParcel(Parcel out, int flags) {
    // Write parcelable version, make sure to define explicit changes
    // within {@link Build.PARCELABLE_VERSION);
    out.writeInt(Build.PARCELABLE_VERSION);
    // Inject a placeholder that will store the parcel size from this point on
    // (not including the size itself).
    int sizePosition = out.dataPosition();
    out.writeInt(0);
    int startPosition = out.dataPosition();
    // ==== APRICOT =====
    if (onClick != null) {
        out.writeInt(1);
        onClick.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (onSettingsClick != null) {
        out.writeInt(1);
        onSettingsClick.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (onClickUri != null) {
        out.writeInt(1);
        onClickUri.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (label != null) {
        out.writeInt(1);
        out.writeString(label);
    } else {
        out.writeInt(0);
    }
    if (contentDescription != null) {
        out.writeInt(1);
        out.writeString(contentDescription);
    } else {
        out.writeInt(0);
    }
    if (expandedStyle != null) {
        out.writeInt(1);
        expandedStyle.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    out.writeInt(icon);
    // ==== BOYSENBERRY =====
    out.writeString(resourcesPackageName);
    out.writeInt(collapsePanel ? 1 : 0);
    if (remoteIcon != null) {
        out.writeInt(1);
        remoteIcon.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    if (deleteIntent != null) {
        out.writeInt(1);
        deleteIntent.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    out.writeInt(sensitiveData ? 1 : 0);
    // ==== DRAGONFRUIT ====
    if (onLongClick != null) {
        out.writeInt(1);
        onLongClick.writeToParcel(out, 0);
    } else {
        out.writeInt(0);
    }
    // Go back and write size
    int parcelableSize = out.dataPosition() - startPosition;
    out.setDataPosition(sizePosition);
    out.writeInt(parcelableSize);
    out.setDataPosition(startPosition + parcelableSize);
}
#end_block

#method_before
public Builder setOnLongClickIntent(PendingIntent intent, boolean collapseOnLongPress) {
    mOnLongClick = intent;
    mCollapsePanelLongPress = collapseOnLongPress;
    return this;
}
#method_after
public Builder setOnLongClickIntent(PendingIntent intent) {
    mOnLongClick = intent;
    return this;
}
#end_block

#method_before
public CustomTile build() {
    CustomTile tile = new CustomTile();
    tile.resourcesPackageName = mContext.getPackageName();
    tile.onClick = mOnClick;
    tile.onLongClick = mOnLongClick;
    tile.onSettingsClick = mOnSettingsClick;
    tile.onClickUri = mOnClickUri;
    tile.label = mLabel;
    tile.contentDescription = mContentDescription;
    tile.expandedStyle = mExpandedStyle;
    tile.icon = mIcon;
    tile.collapsePanel = mCollapsePanel;
    tile.collapsePanelLongPress = mCollapsePanelLongPress;
    tile.remoteIcon = mRemoteIcon;
    tile.deleteIntent = mDeleteIntent;
    tile.sensitiveData = mSensitiveData;
    return tile;
}
#method_after
public CustomTile build() {
    CustomTile tile = new CustomTile();
    tile.resourcesPackageName = mContext.getPackageName();
    tile.onClick = mOnClick;
    tile.onLongClick = mOnLongClick;
    tile.onSettingsClick = mOnSettingsClick;
    tile.onClickUri = mOnClickUri;
    tile.label = mLabel;
    tile.contentDescription = mContentDescription;
    tile.expandedStyle = mExpandedStyle;
    tile.icon = mIcon;
    tile.collapsePanel = mCollapsePanel;
    tile.remoteIcon = mRemoteIcon;
    tile.deleteIntent = mDeleteIntent;
    tile.sensitiveData = mSensitiveData;
    return tile;
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    // Write parcelable version, make sure to define explicit changes
    // within {@link Build.PARCELABLE_VERSION);
    dest.writeInt(Build.PARCELABLE_VERSION);
    // Inject a placeholder that will store the parcel size from this point on
    // (not including the size itself).
    int sizePosition = dest.dataPosition();
    dest.writeInt(0);
    int startPosition = dest.dataPosition();
    // === BOYSENBERRY ===
    if (!TextUtils.isEmpty(mName)) {
        dest.writeInt(1);
        dest.writeString(mName);
    } else {
        dest.writeInt(0);
    }
    if (mNameResId != 0) {
        dest.writeInt(1);
        dest.writeInt(mNameResId);
    } else {
        dest.writeInt(0);
    }
    if (mUuid != null) {
        dest.writeInt(1);
        new ParcelUuid(mUuid).writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSecondaryUuids != null && !mSecondaryUuids.isEmpty()) {
        ArrayList<ParcelUuid> uuids = new ArrayList<ParcelUuid>(mSecondaryUuids.size());
        for (UUID u : mSecondaryUuids) {
            uuids.add(new ParcelUuid(u));
        }
        dest.writeInt(1);
        dest.writeParcelableArray(uuids.toArray(new Parcelable[uuids.size()]), flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mStatusBarIndicator ? 1 : 0);
    dest.writeInt(mProfileType);
    dest.writeInt(mDirty ? 1 : 0);
    if (profileGroups != null && !profileGroups.isEmpty()) {
        dest.writeInt(1);
        dest.writeTypedArray(profileGroups.values().toArray(new ProfileGroup[0]), flags);
    } else {
        dest.writeInt(0);
    }
    if (streams != null && !streams.isEmpty()) {
        dest.writeInt(1);
        dest.writeTypedArray(streams.values().toArray(new StreamSettings[0]), flags);
    } else {
        dest.writeInt(0);
    }
    if (connections != null && !connections.isEmpty()) {
        dest.writeInt(1);
        dest.writeTypedArray(connections.values().toArray(new ConnectionSettings[0]), flags);
    } else {
        dest.writeInt(0);
    }
    if (mRingMode != null) {
        dest.writeInt(1);
        mRingMode.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mAirplaneMode != null) {
        dest.writeInt(1);
        mAirplaneMode.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mBrightness != null) {
        dest.writeInt(1);
        mBrightness.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mScreenLockMode != null) {
        dest.writeInt(1);
        mScreenLockMode.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    dest.writeTypedArray(mTriggers.values().toArray(new ProfileTrigger[0]), flags);
    dest.writeInt(mExpandedDesktopMode);
    dest.writeInt(mDozeMode);
    dest.writeInt(mNotificationLightMode);
    // Go back and write size
    int parcelableSize = dest.dataPosition() - startPosition;
    dest.setDataPosition(sizePosition);
    dest.writeInt(parcelableSize);
    dest.setDataPosition(startPosition + parcelableSize);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    // Write parcelable version, make sure to define explicit changes
    // within {@link Build.PARCELABLE_VERSION);
    dest.writeInt(Build.PARCELABLE_VERSION);
    // Inject a placeholder that will store the parcel size from this point on
    // (not including the size itself).
    int sizePosition = dest.dataPosition();
    dest.writeInt(0);
    int startPosition = dest.dataPosition();
    // === BOYSENBERRY ===
    if (!TextUtils.isEmpty(mName)) {
        dest.writeInt(1);
        dest.writeString(mName);
    } else {
        dest.writeInt(0);
    }
    if (mNameResId != 0) {
        dest.writeInt(1);
        dest.writeInt(mNameResId);
    } else {
        dest.writeInt(0);
    }
    if (mUuid != null) {
        dest.writeInt(1);
        new ParcelUuid(mUuid).writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mSecondaryUuids != null && !mSecondaryUuids.isEmpty()) {
        ArrayList<ParcelUuid> uuids = new ArrayList<ParcelUuid>(mSecondaryUuids.size());
        for (UUID u : mSecondaryUuids) {
            uuids.add(new ParcelUuid(u));
        }
        dest.writeInt(1);
        dest.writeParcelableArray(uuids.toArray(new Parcelable[uuids.size()]), flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mStatusBarIndicator ? 1 : 0);
    dest.writeInt(mProfileType);
    dest.writeInt(mDirty ? 1 : 0);
    if (profileGroups != null && !profileGroups.isEmpty()) {
        dest.writeInt(1);
        dest.writeTypedArray(profileGroups.values().toArray(new ProfileGroup[0]), flags);
    } else {
        dest.writeInt(0);
    }
    if (streams != null && !streams.isEmpty()) {
        dest.writeInt(1);
        dest.writeTypedArray(streams.values().toArray(new StreamSettings[0]), flags);
    } else {
        dest.writeInt(0);
    }
    if (connections != null && !connections.isEmpty()) {
        dest.writeInt(1);
        dest.writeTypedArray(connections.values().toArray(new ConnectionSettings[0]), flags);
    } else {
        dest.writeInt(0);
    }
    if (mRingMode != null) {
        dest.writeInt(1);
        mRingMode.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mAirplaneMode != null) {
        dest.writeInt(1);
        mAirplaneMode.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mBrightness != null) {
        dest.writeInt(1);
        mBrightness.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    if (mScreenLockMode != null) {
        dest.writeInt(1);
        mScreenLockMode.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    dest.writeTypedArray(mTriggers.values().toArray(new ProfileTrigger[0]), flags);
    dest.writeInt(mExpandedDesktopMode);
    dest.writeInt(mDozeMode);
    // === ELDERBERRY ===
    dest.writeInt(mNotificationLightMode);
    // Go back and write size
    int parcelableSize = dest.dataPosition() - startPosition;
    dest.setDataPosition(sizePosition);
    dest.writeInt(parcelableSize);
    dest.setDataPosition(startPosition + parcelableSize);
}
#end_block

#method_before
public void readFromParcel(Parcel in) {
    // Read parcelable version, make sure to define explicit changes
    // within {@link Build.PARCELABLE_VERSION);
    int parcelableVersion = in.readInt();
    int parcelableSize = in.readInt();
    int startPosition = in.dataPosition();
    // API release to help unravel this parcel
    if (parcelableVersion >= Build.CM_VERSION_CODES.BOYSENBERRY) {
        if (in.readInt() != 0) {
            mName = in.readString();
        }
        if (in.readInt() != 0) {
            mNameResId = in.readInt();
        }
        if (in.readInt() != 0) {
            mUuid = ParcelUuid.CREATOR.createFromParcel(in).getUuid();
        }
        if (in.readInt() != 0) {
            for (Parcelable parcel : in.readParcelableArray(null)) {
                ParcelUuid u = (ParcelUuid) parcel;
                mSecondaryUuids.add(u.getUuid());
            }
        }
        mStatusBarIndicator = (in.readInt() == 1);
        mProfileType = in.readInt();
        mDirty = (in.readInt() == 1);
        if (in.readInt() != 0) {
            for (ProfileGroup group : in.createTypedArray(ProfileGroup.CREATOR)) {
                profileGroups.put(group.getUuid(), group);
                if (group.isDefaultGroup()) {
                    mDefaultGroup = group;
                }
            }
        }
        if (in.readInt() != 0) {
            for (StreamSettings stream : in.createTypedArray(StreamSettings.CREATOR)) {
                streams.put(stream.getStreamId(), stream);
            }
        }
        if (in.readInt() != 0) {
            for (ConnectionSettings connection : in.createTypedArray(ConnectionSettings.CREATOR)) {
                connections.put(connection.getConnectionId(), connection);
            }
        }
        if (in.readInt() != 0) {
            mRingMode = RingModeSettings.CREATOR.createFromParcel(in);
        }
        if (in.readInt() != 0) {
            mAirplaneMode = AirplaneModeSettings.CREATOR.createFromParcel(in);
        }
        if (in.readInt() != 0) {
            mBrightness = BrightnessSettings.CREATOR.createFromParcel(in);
        }
        if (in.readInt() != 0) {
            mScreenLockMode = LockSettings.CREATOR.createFromParcel(in);
        }
        for (ProfileTrigger trigger : in.createTypedArray(ProfileTrigger.CREATOR)) {
            mTriggers.put(trigger.mId, trigger);
        }
        mExpandedDesktopMode = in.readInt();
        mDozeMode = in.readInt();
        mNotificationLightMode = in.readInt();
    }
    in.setDataPosition(startPosition + parcelableSize);
}
#method_after
public void readFromParcel(Parcel in) {
    // Read parcelable version, make sure to define explicit changes
    // within {@link Build.PARCELABLE_VERSION);
    int parcelableVersion = in.readInt();
    int parcelableSize = in.readInt();
    int startPosition = in.dataPosition();
    // API release to help unravel this parcel
    if (parcelableVersion >= Build.CM_VERSION_CODES.BOYSENBERRY) {
        if (in.readInt() != 0) {
            mName = in.readString();
        }
        if (in.readInt() != 0) {
            mNameResId = in.readInt();
        }
        if (in.readInt() != 0) {
            mUuid = ParcelUuid.CREATOR.createFromParcel(in).getUuid();
        }
        if (in.readInt() != 0) {
            for (Parcelable parcel : in.readParcelableArray(null)) {
                ParcelUuid u = (ParcelUuid) parcel;
                mSecondaryUuids.add(u.getUuid());
            }
        }
        mStatusBarIndicator = (in.readInt() == 1);
        mProfileType = in.readInt();
        mDirty = (in.readInt() == 1);
        if (in.readInt() != 0) {
            for (ProfileGroup group : in.createTypedArray(ProfileGroup.CREATOR)) {
                profileGroups.put(group.getUuid(), group);
                if (group.isDefaultGroup()) {
                    mDefaultGroup = group;
                }
            }
        }
        if (in.readInt() != 0) {
            for (StreamSettings stream : in.createTypedArray(StreamSettings.CREATOR)) {
                streams.put(stream.getStreamId(), stream);
            }
        }
        if (in.readInt() != 0) {
            for (ConnectionSettings connection : in.createTypedArray(ConnectionSettings.CREATOR)) {
                connections.put(connection.getConnectionId(), connection);
            }
        }
        if (in.readInt() != 0) {
            mRingMode = RingModeSettings.CREATOR.createFromParcel(in);
        }
        if (in.readInt() != 0) {
            mAirplaneMode = AirplaneModeSettings.CREATOR.createFromParcel(in);
        }
        if (in.readInt() != 0) {
            mBrightness = BrightnessSettings.CREATOR.createFromParcel(in);
        }
        if (in.readInt() != 0) {
            mScreenLockMode = LockSettings.CREATOR.createFromParcel(in);
        }
        for (ProfileTrigger trigger : in.createTypedArray(ProfileTrigger.CREATOR)) {
            mTriggers.put(trigger.mId, trigger);
        }
        mExpandedDesktopMode = in.readInt();
        mDozeMode = in.readInt();
    }
    if (parcelableVersion >= Build.CM_VERSION_CODES.ELDERBERRY) {
        mNotificationLightMode = in.readInt();
    }
    in.setDataPosition(startPosition + parcelableSize);
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    super.onBootPhase(phase);
    if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
        processInstalledThemes();
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    super.onBootPhase(phase);
    if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
        registerAppsFailureReceiver();
        processInstalledThemes();
    }
}
#end_block

#method_before
private void postFailedThemeInstallNotification(String name) {
    NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    Notification notice = new Notification.Builder(mContext).setAutoCancel(true).setOngoing(false).setContentTitle(mContext.getString(com.android.internal.R.string.theme_install_error_title)).setContentText(String.format(mContext.getString(com.android.internal.R.string.theme_install_error_message), name)).setSmallIcon(android.R.drawable.stat_notify_error).setWhen(System.currentTimeMillis()).build();
    nm.notify(name.hashCode(), notice);
}
#method_after
private void postFailedThemeInstallNotification(String name) {
    NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    Notification notice = new Notification.Builder(mContext).setAutoCancel(true).setOngoing(false).setContentTitle(mContext.getString(R.string.theme_install_error_title)).setContentText(String.format(mContext.getString(R.string.theme_install_error_message), name)).setSmallIcon(android.R.drawable.stat_notify_error).setWhen(System.currentTimeMillis()).build();
    nm.notify(name.hashCode(), notice);
}
#end_block

#method_before
@Override
protected void setUp() throws Exception {
    super.setUp();
    mCMPerformanceManager = PerformanceManager.getInstance(mContext);
}
#method_after
@Override
protected void setUp() throws Exception {
    super.setUp();
    mCMPerformanceManager = PerformanceManager.getInstance(mContext);
    // Save the perf profile for later restore.
    mSavedPerfProfile = mCMPerformanceManager.getPowerProfile();
}
#end_block

#method_before
@SmallTest
public void testGetNumberOfPerformanceProfiles() {
    assertTrue(mCMPerformanceManager.getNumberOfProfiles() > 0);
}
#method_after
@SmallTest
public void testGetNumberOfPerformanceProfiles() {
    // Assert that we can even set perf profiles
    assertTrue(mCMPerformanceManager.getNumberOfProfiles() > 0);
}
#end_block

#method_before
@SmallTest
public void testGetPowerProfile() {
    int notExpectedProfile = -1;
    mSavedPerfProfile = mCMPerformanceManager.getPowerProfile();
    assertNotSame(notExpectedProfile, mSavedPerfProfile);
}
#method_after
@SmallTest
public void testGetPowerProfile() {
    assertNotSame(IMPOSSIBLE_POWER_PROFILE, mSavedPerfProfile);
}
#end_block

#method_before
@SmallTest
public void testSetAndGetPowerProfile() {
    int[] expectedStates = new int[] { PerformanceManager.PROFILE_POWER_SAVE, PerformanceManager.PROFILE_BALANCED, PerformanceManager.PROFILE_HIGH_PERFORMANCE };
    // set the state
    for (int profile : expectedStates) {
        boolean success = mCMPerformanceManager.setPowerProfile(profile);
        // verify that it was set correctly.
        if (success) {
            assertEquals(profile, mCMPerformanceManager.getPowerProfile());
        } else {
            Log.w(TAG, "Power profile unchanged");
        }
    }
}
#method_after
@SmallTest
public void testSetAndGetPowerProfile() {
    int[] expectedStates = new int[] { PerformanceManager.PROFILE_POWER_SAVE, PerformanceManager.PROFILE_BALANCED, PerformanceManager.PROFILE_HIGH_PERFORMANCE };
    // Set the state
    for (int profile : expectedStates) {
        // setPowerProfile will noop, ignore that scenario
        if (mCMPerformanceManager.getPowerProfile() != profile) {
            mCMPerformanceManager.setPowerProfile(profile);
            // Verify that it was set correctly.
            assertEquals(profile, mCMPerformanceManager.getPowerProfile());
        }
    }
}
#end_block

#method_before
@Override
protected void tearDown() throws Exception {
    super.tearDown();
    // reset
    mCMPerformanceManager.setPowerProfile(mSavedPerfProfile);
}
#method_after
@Override
protected void tearDown() throws Exception {
    super.tearDown();
    // Reset
    mCMPerformanceManager.setPowerProfile(mSavedPerfProfile);
}
#end_block

#method_before
public void processOverride(Context context) {
    BluetoothAdapter bta = BluetoothAdapter.getDefaultAdapter();
    LocationManager lm = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
    WifiManager wm = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
    TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    NfcAdapter nfcAdapter = null;
    try {
        nfcAdapter = NfcAdapter.getNfcAdapter(context);
    } catch (UnsupportedOperationException e) {
    // Nfc not available
    }
    boolean forcedState = getValue() == 1;
    boolean currentState;
    switch(getConnectionId()) {
        case PROFILE_CONNECTION_MOBILEDATA:
            currentState = tm.getDataEnabled();
            if (forcedState != currentState) {
                int phoneCount = tm.getPhoneCount();
                for (int i = 0; i < phoneCount; i++) {
                    Settings.Global.putInt(context.getContentResolver(), Settings.Global.MOBILE_DATA + i, (forcedState) ? 1 : 0);
                    int[] subId = SubscriptionManager.getSubId(i);
                    tm.setDataEnabled(subId[0], forcedState);
                }
            }
            break;
        case PROFILE_CONNECTION_2G3G4G:
            if (Build.CM_VERSION.SDK_INT >= Build.CM_VERSION_CODES.ELDERBERRY) {
                Intent intent = new Intent(ACTION_MODIFY_NETWORK_MODE);
                intent.putExtra(EXTRA_NETWORK_MODE, getValue());
                intent.putExtra(EXTRA_SUB_ID, getSubId());
                context.sendBroadcast(intent, "com.android.phone.CHANGE_NETWORK_MODE");
            } else {
            // do old code
            }
            break;
        case PROFILE_CONNECTION_BLUETOOTH:
            int btstate = bta.getState();
            if (forcedState && (btstate == BluetoothAdapter.STATE_OFF || btstate == BluetoothAdapter.STATE_TURNING_OFF)) {
                bta.enable();
            } else if (!forcedState && (btstate == BluetoothAdapter.STATE_ON || btstate == BluetoothAdapter.STATE_TURNING_ON)) {
                bta.disable();
            }
            break;
        case PROFILE_CONNECTION_GPS:
            currentState = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
            if (currentState != forcedState) {
                Settings.Secure.setLocationProviderEnabled(context.getContentResolver(), LocationManager.GPS_PROVIDER, forcedState);
            }
            break;
        case PROFILE_CONNECTION_SYNC:
            currentState = ContentResolver.getMasterSyncAutomatically();
            if (forcedState != currentState) {
                ContentResolver.setMasterSyncAutomatically(forcedState);
            }
            break;
        case PROFILE_CONNECTION_WIFI:
            int wifiApState = wm.getWifiApState();
            currentState = wm.isWifiEnabled();
            if (currentState != forcedState) {
                // Disable wifi tether
                if (forcedState && (wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED)) {
                    wm.setWifiApEnabled(null, false);
                }
                wm.setWifiEnabled(forcedState);
            }
            break;
        case PROFILE_CONNECTION_WIFIAP:
            int wifiState = wm.getWifiState();
            currentState = wm.isWifiApEnabled();
            if (currentState != forcedState) {
                // Disable wifi
                if (forcedState && (wifiState == WifiManager.WIFI_STATE_ENABLING) || (wifiState == WifiManager.WIFI_STATE_ENABLED)) {
                    wm.setWifiEnabled(false);
                }
                wm.setWifiApEnabled(null, forcedState);
            }
            break;
        case PROFILE_CONNECTION_WIMAX:
            if (WimaxHelper.isWimaxSupported(context)) {
                currentState = WimaxHelper.isWimaxEnabled(context);
                if (currentState != forcedState) {
                    WimaxHelper.setWimaxEnabled(context, forcedState);
                }
            }
            break;
        case PROFILE_CONNECTION_NFC:
            if (nfcAdapter != null) {
                int adapterState = nfcAdapter.getAdapterState();
                currentState = (adapterState == NfcAdapter.STATE_ON || adapterState == NfcAdapter.STATE_TURNING_ON);
                if (currentState != forcedState) {
                    if (forcedState) {
                        nfcAdapter.enable();
                    } else if (!forcedState && adapterState != NfcAdapter.STATE_TURNING_OFF) {
                        nfcAdapter.disable();
                    }
                }
            }
            break;
    }
}
#method_after
public void processOverride(Context context) {
    BluetoothAdapter bta = BluetoothAdapter.getDefaultAdapter();
    LocationManager lm = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
    WifiManager wm = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
    TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    NfcAdapter nfcAdapter = null;
    try {
        nfcAdapter = NfcAdapter.getNfcAdapter(context);
    } catch (UnsupportedOperationException e) {
    // Nfc not available
    }
    boolean forcedState = getValue() == 1;
    boolean currentState;
    switch(getConnectionId()) {
        case PROFILE_CONNECTION_MOBILEDATA:
            currentState = tm.getDataEnabled();
            if (forcedState != currentState) {
                int phoneCount = tm.getPhoneCount();
                for (int i = 0; i < phoneCount; i++) {
                    Settings.Global.putInt(context.getContentResolver(), Settings.Global.MOBILE_DATA + i, (forcedState) ? 1 : 0);
                    int[] subId = SubscriptionManager.getSubId(i);
                    tm.setDataEnabled(subId[0], forcedState);
                }
            }
            break;
        case PROFILE_CONNECTION_2G3G4G:
            if (Build.CM_VERSION.SDK_INT >= Build.CM_VERSION_CODES.ELDERBERRY) {
                Intent intent = new Intent(ACTION_MODIFY_NETWORK_MODE);
                intent.putExtra(EXTRA_NETWORK_MODE, getValue());
                intent.putExtra(EXTRA_SUB_ID, getSubId());
                context.sendBroadcast(intent, "com.android.phone.CHANGE_NETWORK_MODE");
            } else {
                Intent intent = new Intent(ACTION_MODIFY_NETWORK_MODE);
                switch(getValue()) {
                    case CM_MODE_2G:
                        intent.putExtra(EXTRA_NETWORK_MODE, RILConstants.NETWORK_MODE_GSM_ONLY);
                        break;
                    case CM_MODE_3G:
                        intent.putExtra(EXTRA_NETWORK_MODE, RILConstants.NETWORK_MODE_WCDMA_ONLY);
                        break;
                    case CM_MODE_4G:
                        intent.putExtra(EXTRA_NETWORK_MODE, RILConstants.NETWORK_MODE_LTE_ONLY);
                        break;
                    case CM_MODE_2G3G:
                        intent.putExtra(EXTRA_NETWORK_MODE, RILConstants.NETWORK_MODE_WCDMA_PREF);
                        break;
                    case CM_MODE_ALL:
                        intent.putExtra(EXTRA_NETWORK_MODE, RILConstants.NETWORK_MODE_LTE_GSM_WCDMA);
                        break;
                    default:
                        return;
                }
                context.sendBroadcast(intent);
            }
            break;
        case PROFILE_CONNECTION_BLUETOOTH:
            int btstate = bta.getState();
            if (forcedState && (btstate == BluetoothAdapter.STATE_OFF || btstate == BluetoothAdapter.STATE_TURNING_OFF)) {
                bta.enable();
            } else if (!forcedState && (btstate == BluetoothAdapter.STATE_ON || btstate == BluetoothAdapter.STATE_TURNING_ON)) {
                bta.disable();
            }
            break;
        case PROFILE_CONNECTION_GPS:
            currentState = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
            if (currentState != forcedState) {
                Settings.Secure.setLocationProviderEnabled(context.getContentResolver(), LocationManager.GPS_PROVIDER, forcedState);
            }
            break;
        case PROFILE_CONNECTION_SYNC:
            currentState = ContentResolver.getMasterSyncAutomatically();
            if (forcedState != currentState) {
                ContentResolver.setMasterSyncAutomatically(forcedState);
            }
            break;
        case PROFILE_CONNECTION_WIFI:
            int wifiApState = wm.getWifiApState();
            currentState = wm.isWifiEnabled();
            if (currentState != forcedState) {
                // Disable wifi tether
                if (forcedState && (wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED)) {
                    wm.setWifiApEnabled(null, false);
                }
                wm.setWifiEnabled(forcedState);
            }
            break;
        case PROFILE_CONNECTION_WIFIAP:
            int wifiState = wm.getWifiState();
            currentState = wm.isWifiApEnabled();
            if (currentState != forcedState) {
                // Disable wifi
                if (forcedState && (wifiState == WifiManager.WIFI_STATE_ENABLING) || (wifiState == WifiManager.WIFI_STATE_ENABLED)) {
                    wm.setWifiEnabled(false);
                }
                wm.setWifiApEnabled(null, forcedState);
            }
            break;
        case PROFILE_CONNECTION_WIMAX:
            if (WimaxHelper.isWimaxSupported(context)) {
                currentState = WimaxHelper.isWimaxEnabled(context);
                if (currentState != forcedState) {
                    WimaxHelper.setWimaxEnabled(context, forcedState);
                }
            }
            break;
        case PROFILE_CONNECTION_NFC:
            if (nfcAdapter != null) {
                int adapterState = nfcAdapter.getAdapterState();
                currentState = (adapterState == NfcAdapter.STATE_ON || adapterState == NfcAdapter.STATE_TURNING_ON);
                if (currentState != forcedState) {
                    if (forcedState) {
                        nfcAdapter.enable();
                    } else if (!forcedState && adapterState != NfcAdapter.STATE_TURNING_OFF) {
                        nfcAdapter.disable();
                    }
                }
            }
            break;
    }
}
#end_block

#method_before
public static ICMHardwareService getService() {
    if (sService != null) {
        return sService;
    }
    IBinder b = ServiceManager.getService(CMContextConstants.CM_HARDWARE_SERVICE);
    if (b != null) {
        sService = ICMHardwareService.Stub.asInterface(b);
        return sService;
    }
    Log.w(TAG, "Unable to get CMHardwareService. The service either crashed, " + "was not started, or the interface has been called to early in SystemServer init");
    return null;
}
#method_after
public static ICMHardwareService getService() {
    if (sService != null) {
        return sService;
    }
    IBinder b = ServiceManager.getService(CMContextConstants.CM_HARDWARE_SERVICE);
    if (b != null) {
        sService = ICMHardwareService.Stub.asInterface(b);
        return sService;
    }
    return null;
}
#end_block

#method_before
public boolean writePersistentString(String key, String value) {
    try {
        if (checkService()) {
            return getService().writePersistentBytes(key, value == null ? null : value.getBytes("UTF-8"));
        }
    } catch (RemoteException e) {
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return false;
}
#method_after
public boolean writePersistentString(String key, String value) {
    try {
        if (checkService()) {
            return sService.writePersistentBytes(key, value == null ? null : value.getBytes("UTF-8"));
        }
    } catch (RemoteException e) {
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return false;
}
#end_block

#method_before
public boolean writePersistentInt(String key, int value) {
    try {
        if (checkService()) {
            return getService().writePersistentBytes(key, ByteBuffer.allocate(4).putInt(value).array());
        }
    } catch (RemoteException e) {
    }
    return false;
}
#method_after
public boolean writePersistentInt(String key, int value) {
    try {
        if (checkService()) {
            return sService.writePersistentBytes(key, ByteBuffer.allocate(4).putInt(value).array());
        }
    } catch (RemoteException e) {
    }
    return false;
}
#end_block

#method_before
public boolean writePersistentBytes(String key, byte[] value) {
    try {
        if (checkService()) {
            return getService().writePersistentBytes(key, value);
        }
    } catch (RemoteException e) {
    }
    return false;
}
#method_after
public boolean writePersistentBytes(String key, byte[] value) {
    try {
        if (checkService()) {
            return sService.writePersistentBytes(key, value);
        }
    } catch (RemoteException e) {
    }
    return false;
}
#end_block

#method_before
public String readPersistentString(String key) {
    try {
        if (checkService()) {
            byte[] bytes = getService().readPersistentBytes(key);
            if (bytes != null) {
                return new String(bytes, "UTF-8");
            }
        }
    } catch (RemoteException e) {
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return null;
}
#method_after
public String readPersistentString(String key) {
    try {
        if (checkService()) {
            byte[] bytes = sService.readPersistentBytes(key);
            if (bytes != null) {
                return new String(bytes, "UTF-8");
            }
        }
    } catch (RemoteException e) {
    } catch (UnsupportedEncodingException e) {
        Log.e(TAG, e.getMessage(), e);
    }
    return null;
}
#end_block

#method_before
public int readPersistentInt(String key) {
    try {
        if (checkService()) {
            byte[] bytes = getService().readPersistentBytes(key);
            if (bytes != null) {
                return ByteBuffer.wrap(bytes).getInt();
            }
        }
    } catch (RemoteException e) {
    }
    return 0;
}
#method_after
public int readPersistentInt(String key) {
    try {
        if (checkService()) {
            byte[] bytes = sService.readPersistentBytes(key);
            if (bytes != null) {
                return ByteBuffer.wrap(bytes).getInt();
            }
        }
    } catch (RemoteException e) {
    }
    return 0;
}
#end_block

#method_before
public byte[] readPersistentBytes(String key) {
    try {
        if (checkService()) {
            return getService().readPersistentBytes(key);
        }
    } catch (RemoteException e) {
    }
    return null;
}
#method_after
public byte[] readPersistentBytes(String key) {
    try {
        if (checkService()) {
            return sService.readPersistentBytes(key);
        }
    } catch (RemoteException e) {
    }
    return null;
}
#end_block

#method_before
public boolean deletePersistentObject(String key) {
    try {
        if (checkService()) {
            return getService().writePersistentBytes(key, null);
        }
    } catch (RemoteException e) {
    }
    return false;
}
#method_after
public boolean deletePersistentObject(String key) {
    try {
        if (checkService()) {
            return sService.writePersistentBytes(key, null);
        }
    } catch (RemoteException e) {
    }
    return false;
}
#end_block

#method_before
public Builder setWeatherCondition(int code) {
    if (!isValidWeatherCode(code)) {
        throw new IllegalArgumentException("Invalid weather condition code");
    }
    mConditionCode = code;
    return this;
}
#method_after
public Builder setWeatherCondition(int conditionCode) {
    if (!isValidWeatherCode(conditionCode)) {
        throw new IllegalArgumentException("Invalid weather condition code");
    }
    mConditionCode = conditionCode;
    return this;
}
#end_block

#method_before
public DayForecast build() {
    DayForecast forecast = new DayForecast();
    forecast.mLow = this.mLow;
    forecast.mHigh = this.mHigh;
    forecast.mConditionCode = this.mConditionCode;
    forecast.mKey = this.hashCode();
    return forecast;
}
#method_after
public WeatherInfo build() {
    WeatherInfo info = new WeatherInfo();
    info.mCityId = this.mCityId;
    info.mCity = this.mCity;
    info.mConditionCode = this.mConditionCode;
    info.mTemperature = this.mTemperature;
    info.mTempUnit = this.mTempUnit;
    info.mHumidity = this.mHumidity;
    info.mWindSpeed = this.mWindSpeed;
    info.mWindDirection = this.mWindDirection;
    info.mWindSpeedUnit = this.mWindSpeedUnit;
    info.mTimestamp = this.mTimestamp;
    info.mForecastList = this.mForecastList;
    info.mKey = this.hashCode();
    return info;
}
#end_block

#method_before
public void unregisterProcessingListener(ThemeProcessingListener listener) {
    synchronized (mProcessingListeners) {
        mProcessingListeners.remove(listener);
        if (mProcessingListeners.size() == 0) {
            try {
                sService.unregisterThemeProcessingListener(mThemeProcessingListener);
            } catch (RemoteException e) {
                Log.w(TAG, "Unable to unregister listener", e);
            }
        }
    }
}
#method_after
public void unregisterProcessingListener(ThemeChangeListener listener) {
    synchronized (mProcessingListeners) {
        mProcessingListeners.remove(listener);
        if (mProcessingListeners.size() == 0) {
            try {
                sService.unregisterThemeProcessingListener(mThemeProcessingListener);
            } catch (RemoteException e) {
                Log.w(TAG, "Unable to unregister listener", e);
            }
        }
    }
}
#end_block

#method_before
public Builder setLocation(Location location) {
    this.mLocation = location;
    this.mCityName = null;
    this.mWeatherLocation = null;
    this.mRequestType = TYPE_GEO_LOCATION_REQ;
    return this;
}
#method_after
public Builder setLocation(Location location) {
    this.mLocation = new Location(location);
    this.mCityName = null;
    this.mWeatherLocation = null;
    this.mRequestType = TYPE_GEO_LOCATION_REQ;
    return this;
}
#end_block

#method_before
public Builder setCountry(String countyId, String country) {
    if (countyId == null && country == null) {
        throw new IllegalArgumentException("Illegal to set country id AND country to null");
    }
    this.mCountryId = countyId;
    this.mCountry = country;
    return this;
}
#method_after
public Builder setCountry(String countryId, String country) {
    if (countryId == null && country == null) {
        throw new IllegalArgumentException("Illegal to set country id AND country to null");
    }
    this.mCountryId = countryId;
    this.mCountry = country;
    return this;
}
#end_block

#method_before
public DayForecast build() {
    DayForecast forecast = new DayForecast();
    forecast.mLow = this.mLow;
    forecast.mHigh = this.mHigh;
    forecast.mConditionCode = this.mConditionCode;
    forecast.mKey = this.hashCode();
    return forecast;
}
#method_after
public WeatherInfo build() {
    WeatherInfo info = new WeatherInfo();
    info.mCity = this.mCity;
    info.mConditionCode = this.mConditionCode;
    info.mTemperature = this.mTemperature;
    info.mTempUnit = this.mTempUnit;
    info.mHumidity = this.mHumidity;
    info.mWindSpeed = this.mWindSpeed;
    info.mWindDirection = this.mWindDirection;
    info.mWindSpeedUnit = this.mWindSpeedUnit;
    info.mTimestamp = this.mTimestamp == -1 ? System.currentTimeMillis() : this.mTimestamp;
    info.mForecastList = this.mForecastList;
    info.mKey = this.hashCode();
    return info;
}
#end_block

#method_before
void clear() {
    removeMessages(MSG_UPDATE_LUX);
    removeMessages(MSG_TRANSITION);
}
#method_after
void clear() {
    removeCallbacksAndMessages(null);
}
#end_block

#method_before
public synchronized void setTransitionListener(TransitionListener callback) {
    if (callback == null) {
        enableLightSensor(false);
        mCallback = null;
    } else {
        mCallback = callback;
        enableLightSensor(true);
    }
}
#method_after
public synchronized void setTransitionListener(TransitionListener callback) {
    mCallback = callback;
    enableLightSensor(callback != null);
}
#end_block

#method_before
public synchronized float getAverage() {
    expire();
    return mRing.size() == 0 ? mTotal : (mTotal / mRing.size());
}
#method_after
public synchronized float getAverage() {
    expire();
    return mRing.size() == 0 ? 0.0f : (mTotal / mRing.size());
}
#end_block

#method_before
private void expire() {
    while (mRing.size() > 1 && (System.currentTimeMillis() - mRing.peek().mTimestamp > mPeriod)) {
        mTotal -= mRing.pop().mValue;
    }
}
#method_after
private void expire() {
    long now = System.currentTimeMillis();
    while (mRing.size() > 1 && ((now - mRing.peek().mTimestamp) > mPeriod)) {
        mTotal -= mRing.pop().mValue;
    }
}
#end_block

#method_before
@Override
public boolean onStart() {
    final ArrayList<Uri> settings = new ArrayList<Uri>();
    mHardware = CMHardwareManager.getInstance(mContext);
    mUseLowPower = mHardware.isSupported(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT);
    if (mUseLowPower) {
        mLowPower = mHardware.get(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT);
        settings.add(DISPLAY_LOW_POWER);
    }
    mUseColorEnhancement = mHardware.isSupported(CMHardwareManager.FEATURE_COLOR_ENHANCEMENT);
    if (mUseColorEnhancement) {
        mColorEnhancement = mHardware.get(CMHardwareManager.FEATURE_COLOR_ENHANCEMENT);
        settings.add(DISPLAY_COLOR_ENHANCE);
    }
    mUseAutoContrast = mHardware.isSupported(CMHardwareManager.FEATURE_AUTO_CONTRAST);
    if (mUseAutoContrast) {
        mAutoContrast = mHardware.get(CMHardwareManager.FEATURE_AUTO_CONTRAST);
        settings.add(DISPLAY_COLOR_ENHANCE);
    }
    mUseColorAdjustment = mHardware.isSupported(CMHardwareManager.FEATURE_DISPLAY_COLOR_CALIBRATION);
    if (mUseColorAdjustment) {
        settings.add(DISPLAY_COLOR_ADJUSTMENT);
    }
    if (settings.size() == 0) {
        return false;
    }
    registerSettings(settings.toArray(new Uri[settings.size()]));
    return true;
}
#method_after
@Override
public boolean onStart() {
    final ArrayList<Uri> settings = new ArrayList<Uri>();
    mHardware = CMHardwareManager.getInstance(mContext);
    mUseLowPower = mHardware.isSupported(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT);
    if (mUseLowPower) {
        mLowPower = mHardware.get(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT);
        settings.add(DISPLAY_CABC);
    }
    mUseColorEnhancement = mHardware.isSupported(CMHardwareManager.FEATURE_COLOR_ENHANCEMENT);
    if (mUseColorEnhancement) {
        mColorEnhancement = mHardware.get(CMHardwareManager.FEATURE_COLOR_ENHANCEMENT);
        settings.add(DISPLAY_COLOR_ENHANCE);
    }
    mUseAutoContrast = mHardware.isSupported(CMHardwareManager.FEATURE_AUTO_CONTRAST);
    if (mUseAutoContrast) {
        mAutoContrast = mHardware.get(CMHardwareManager.FEATURE_AUTO_CONTRAST);
        settings.add(DISPLAY_AUTO_CONTRAST);
    }
    mUseColorAdjustment = mHardware.isSupported(CMHardwareManager.FEATURE_DISPLAY_COLOR_CALIBRATION);
    if (mUseColorAdjustment) {
        settings.add(DISPLAY_COLOR_ADJUSTMENT);
    }
    if (settings.size() == 0) {
        return false;
    }
    registerSettings(settings.toArray(new Uri[settings.size()]));
    return true;
}
#end_block

#method_before
@Override
public synchronized void onSettingsChanged(Uri uri) {
    if (uri == null || uri.equals(DISPLAY_LOW_POWER)) {
        updateLowPowerMode();
    }
    if (uri == null || uri.equals(DISPLAY_AUTO_CONTRAST)) {
        updateAutoContrast();
    }
    if (uri == null || uri.equals(DISPLAY_COLOR_ENHANCE)) {
        updateColorEnhancement();
    }
    if (uri == null || uri.equals(DISPLAY_COLOR_ADJUSTMENT)) {
        System.arraycopy(parseColorAdjustment(getString(CMSettings.System.DISPLAY_COLOR_ADJUSTMENT)), 0, mColorAdjustment, 0, 3);
        updateColorAdjustment();
    }
}
#method_after
@Override
public synchronized void onSettingsChanged(Uri uri) {
    if (uri == null || uri.equals(DISPLAY_CABC)) {
        updateLowPowerMode();
    }
    if (uri == null || uri.equals(DISPLAY_AUTO_CONTRAST)) {
        updateAutoContrast();
    }
    if (uri == null || uri.equals(DISPLAY_COLOR_ENHANCE)) {
        updateColorEnhancement();
    }
    if (uri == null || uri.equals(DISPLAY_COLOR_ADJUSTMENT)) {
        System.arraycopy(parseColorAdjustment(getString(CMSettings.System.DISPLAY_COLOR_ADJUSTMENT)), 0, mColorAdjustment, 0, 3);
        updateColorAdjustment();
    }
}
#end_block

#method_before
private synchronized void updateLowPowerMode() {
    if (!mUseLowPower) {
        return;
    }
    boolean value = getInt(CMSettings.System.DISPLAY_LOW_POWER, 1) == 1;
    boolean enabled = !isLowPowerMode() && value;
    if (enabled == mLowPower) {
        return;
    }
    mHardware.set(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT, value);
    mLowPower = value;
}
#method_after
private synchronized void updateLowPowerMode() {
    if (!mUseLowPower) {
        return;
    }
    boolean value = getInt(CMSettings.System.DISPLAY_CABC, 1) == 1;
    boolean enabled = !isLowPowerMode() && value;
    if (enabled == mLowPower) {
        return;
    }
    mHardware.set(CMHardwareManager.FEATURE_ADAPTIVE_BACKLIGHT, value);
    mLowPower = value;
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_BOOT_COMPLETED) {
        mAwaitingNudge = getSunsetCounter() < 1;
        final DisplayHardwareController dhc = new DisplayHardwareController(mContext, mHandler);
        mFeatures.add(dhc);
        mFeatures.add(new ColorTemperatureController(mContext, mHandler, dhc));
        mFeatures.add(new OutdoorModeController(mContext, mHandler));
        for (Iterator<LiveDisplayFeature> it = mFeatures.iterator(); it.hasNext(); ) {
            final LiveDisplayFeature feature = it.next();
            if (feature.onStart()) {
                feature.getCapabilities(mCapabilities);
            } else {
                it.remove();
            }
        }
        mDisplayManager = (DisplayManager) getContext().getSystemService(Context.DISPLAY_SERVICE);
        mDisplayManager.registerDisplayListener(mDisplayListener, null);
        PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
        pmi.registerLowPowerModeObserver(mLowPowerModeListener);
        mTwilightManager = LocalServices.getService(TwilightManager.class);
        mTwilightManager.registerListener(mTwilightListener, mHandler);
        updateTwilight();
        updateDisplayState(mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY).getState());
        mModeObserver = new ModeObserver(mHandler);
        mModeObserver.update();
        mInitialized = true;
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_BOOT_COMPLETED) {
        mAwaitingNudge = getSunsetCounter() < 1;
        final DisplayHardwareController dhc = new DisplayHardwareController(mContext, mHandler);
        mFeatures.add(dhc);
        mFeatures.add(new ColorTemperatureController(mContext, mHandler, dhc));
        mFeatures.add(new OutdoorModeController(mContext, mHandler));
        for (Iterator<LiveDisplayFeature> it = mFeatures.iterator(); it.hasNext(); ) {
            final LiveDisplayFeature feature = it.next();
            if (feature.onStart()) {
                feature.getCapabilities(mCapabilities);
            } else {
                it.remove();
            }
        }
        mCapabilities.set(MODE_OFF);
        mDisplayManager = (DisplayManager) getContext().getSystemService(Context.DISPLAY_SERVICE);
        mDisplayManager.registerDisplayListener(mDisplayListener, null);
        PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
        pmi.registerLowPowerModeObserver(mLowPowerModeListener);
        mTwilightManager = LocalServices.getService(TwilightManager.class);
        mTwilightManager.registerListener(mTwilightListener, mHandler);
        updateTwilight();
        updateDisplayState(mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY).getState());
        mModeObserver = new ModeObserver(mHandler);
        mModeObserver.update();
        mInitialized = true;
    }
}
#end_block

#method_before
private void nudge() {
    final TwilightState twilight = mTwilightManager.getCurrentState();
    if (!mAwaitingNudge || twilight == null) {
        return;
    }
    int counter = getSunsetCounter();
    // check if we should send the hint only once after sunset
    boolean transition = twilight.isNight() && !mSunset;
    mSunset = twilight.isNight();
    if (!transition) {
        return;
    }
    if (counter <= 0) {
        counter++;
        updateSunsetCounter(counter);
    }
    if (counter == 0) {
        // show the notification and don't come back here
        final Intent intent = new Intent("android.settings.LIVEDISPLAY_SETTINGS");
        PendingIntent result = PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
        Notification.Builder builder = new Notification.Builder(mContext).setContentTitle(mContext.getResources().getString(org.cyanogenmod.platform.internal.R.string.live_display_title)).setContentText(mContext.getResources().getString(org.cyanogenmod.platform.internal.R.string.live_display_hint)).setSmallIcon(org.cyanogenmod.platform.internal.R.drawable.ic_livedisplay_notif).setStyle(new Notification.BigTextStyle().bigText(mContext.getResources().getString(org.cyanogenmod.platform.internal.R.string.live_display_hint))).setContentIntent(result).setAutoCancel(true);
        NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
        nm.notifyAsUser(null, 1, builder.build(), UserHandle.CURRENT);
        updateSunsetCounter(1);
    }
}
#method_after
private void nudge() {
    final TwilightState twilight = mTwilightManager.getCurrentState();
    if (!mAwaitingNudge || twilight == null) {
        return;
    }
    int counter = getSunsetCounter();
    // check if we should send the hint only once after sunset
    boolean transition = twilight.isNight() && !mSunset;
    mSunset = twilight.isNight();
    if (!transition) {
        return;
    }
    if (counter <= 0) {
        counter++;
        updateSunsetCounter(counter);
    }
    if (counter == 0) {
        // show the notification and don't come back here
        final Intent intent = new Intent(CMSettings.ACTION_LIVEDISPLAY_SETTINGS);
        PendingIntent result = PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
        Notification.Builder builder = new Notification.Builder(mContext).setContentTitle(mContext.getResources().getString(org.cyanogenmod.platform.internal.R.string.live_display_title)).setContentText(mContext.getResources().getString(org.cyanogenmod.platform.internal.R.string.live_display_hint)).setSmallIcon(org.cyanogenmod.platform.internal.R.drawable.ic_livedisplay_notif).setStyle(new Notification.BigTextStyle().bigText(mContext.getResources().getString(org.cyanogenmod.platform.internal.R.string.live_display_hint))).setContentIntent(result).setAutoCancel(true);
        NotificationManager nm = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
        nm.notifyAsUser(null, 1, builder.build(), UserHandle.CURRENT);
        updateSunsetCounter(1);
    }
}
#end_block

#method_before
public boolean setMode(int mode) {
    if (mode < 0 || mode > MODE_LAST || !mCapabilities.get(mode)) {
        return false;
    }
    putInt(CMSettings.System.DISPLAY_TEMPERATURE_MODE, mode);
    return true;
}
#method_after
public boolean setMode(int mode) {
    if (!hasFeature(mode)) {
        return false;
    }
    putInt(CMSettings.System.DISPLAY_TEMPERATURE_MODE, mode);
    return true;
}
#end_block

#method_before
public boolean isCABCEnabled() {
    return mCapabilities.get(FEATURE_CABC) && getInt(CMSettings.System.DISPLAY_LOW_POWER, 1) == 1;
}
#method_after
public boolean isCABCEnabled() {
    return mCapabilities.get(FEATURE_CABC) && getInt(CMSettings.System.DISPLAY_CABC, 1) == 1;
}
#end_block

#method_before
public boolean setCABCEnabled(boolean enabled) {
    if (!mCapabilities.get(FEATURE_CABC)) {
        return false;
    }
    putInt(CMSettings.System.DISPLAY_LOW_POWER, enabled ? 1 : 0);
    return true;
}
#method_after
public boolean setCABCEnabled(boolean enabled) {
    if (!mCapabilities.get(FEATURE_CABC)) {
        return false;
    }
    putInt(CMSettings.System.DISPLAY_CABC, enabled ? 1 : 0);
    return true;
}
#end_block

#method_before
public int requestWeatherUpdate(@NonNull Location location, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = sWeatherManagerService.getTemperatureUnit();
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setLocation(location).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#method_after
public int requestWeatherUpdate(@NonNull Location location, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = CMSettings.Global.getInt(mContext.getContentResolver(), CMSettings.Global.WEATHER_TEMPERATURE_UNIT, WeatherContract.WeatherColumns.TempUnit.FAHRENHEIT);
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setLocation(location).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#end_block

#method_before
public int requestWeatherUpdate(@NonNull WeatherLocation weatherLocation, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = sWeatherManagerService.getTemperatureUnit();
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setWeatherLocation(weatherLocation).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#method_after
public int requestWeatherUpdate(@NonNull WeatherLocation weatherLocation, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = CMSettings.Global.getInt(mContext.getContentResolver(), CMSettings.Global.WEATHER_TEMPERATURE_UNIT, WeatherContract.WeatherColumns.TempUnit.FAHRENHEIT);
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setWeatherLocation(weatherLocation).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#end_block

#method_before
private boolean canProcessWeatherUpdateRequest(RequestInfo info) {
    final IRequestInfoListener listener = info.getRequestListener();
    if (!mIsWeatherProviderServiceBound) {
        if (listener != null && listener.asBinder().pingBinder()) {
            try {
                listener.onWeatherRequestCompleted(info, CMWeatherManager.WEATHER_REQUEST_FAILED, null);
            } catch (RemoteException e) {
            }
        }
        return false;
    }
    return true;
}
#method_after
private boolean canProcessWeatherUpdateRequest(RequestInfo info) {
    final IRequestInfoListener listener = info.getRequestListener();
    if (!mIsWeatherProviderServiceBound) {
        if (listener != null && listener.asBinder().pingBinder()) {
            try {
                listener.onWeatherRequestCompleted(info, CMWeatherManager.RequestStatus.FAILED, null);
            } catch (RemoteException e) {
            }
        }
        return false;
    }
    return true;
}
#end_block

#method_before
private synchronized void processWeatherUpdateRequest(RequestInfo info) {
    if (!canProcessWeatherUpdateRequest(info))
        return;
    mOutstandingRequestsCount.incrementAndGet();
    try {
        mWeatherProviderService.processWeatherUpdateRequest(info);
    } catch (RemoteException e) {
    }
}
#method_after
private synchronized void processWeatherUpdateRequest(RequestInfo info) {
    if (!canProcessWeatherUpdateRequest(info))
        return;
    try {
        mWeatherProviderService.processWeatherUpdateRequest(info);
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void processCityNameLookupRequest(RequestInfo info) {
    if (!mIsWeatherProviderServiceBound) {
        final IRequestInfoListener listener = info.getRequestListener();
        if (listener != null && listener.asBinder().pingBinder()) {
            try {
                listener.onLookupCityRequestCompleted(info, null);
            } catch (RemoteException e) {
            }
        }
        return;
    }
    mOutstandingRequestsCount.incrementAndGet();
    try {
        mWeatherProviderService.processCityNameLookupRequest(info);
    } catch (RemoteException e) {
    }
}
#method_after
private void processCityNameLookupRequest(RequestInfo info) {
    if (!mIsWeatherProviderServiceBound) {
        final IRequestInfoListener listener = info.getRequestListener();
        if (listener != null && listener.asBinder().pingBinder()) {
            try {
                listener.onLookupCityRequestCompleted(info, CMWeatherManager.RequestStatus.FAILED, null);
            } catch (RemoteException e) {
            }
        }
        return;
    }
    try {
        mWeatherProviderService.processCityNameLookupRequest(info);
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void processCancelRequest(int requestId) {
    if (mIsWeatherProviderServiceBound) {
        try {
            mOutstandingRequestsCount.decrementAndGet();
            mWeatherProviderService.cancelRequest(requestId);
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void processCancelRequest(int requestId) {
    if (mIsWeatherProviderServiceBound) {
        try {
            mWeatherProviderService.cancelRequest(requestId);
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
private synchronized void disconnectClient() {
    if (mIsWeatherProviderServiceBound) {
        final int requests = mOutstandingRequestsCount.getAndSet(0);
        if (requests > 0) {
            try {
                mWeatherProviderService.cancelOngoingRequests();
            } catch (RemoteException e) {
            }
        }
        try {
            mWeatherProviderService.setServiceClient(null);
        } catch (RemoteException e) {
        }
        getContext().unbindService(mWeatherServiceProviderConnection);
        mIsWeatherProviderServiceBound = false;
    }
}
#method_after
private synchronized void disconnectClient() {
    if (mIsWeatherProviderServiceBound) {
        // let's cancel any pending request
        try {
            mWeatherProviderService.cancelOngoingRequests();
        } catch (RemoteException e) {
            Slog.d(TAG, "Error occurred while trying to cancel ongoing requests");
        }
        // Disconnect from client
        try {
            mWeatherProviderService.setServiceClient(null);
        } catch (RemoteException e) {
            Slog.d(TAG, "Error occurred while disconnecting client");
        }
        getContext().unbindService(mWeatherServiceProviderConnection);
        mIsWeatherProviderServiceBound = false;
    }
}
#end_block

#method_before
public int requestWeatherUpdate(@NonNull Location location, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = sWeatherManagerService.getTemperatureUnit();
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setLocation(location).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#method_after
public int requestWeatherUpdate(@NonNull Location location, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = CMSettings.Global.getInt(mContext.getContentResolver(), CMSettings.Global.WEATHER_TEMPERATURE_UNIT, WeatherContract.WeatherColumns.TempUnit.FAHRENHEIT);
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setLocation(location).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#end_block

#method_before
public int requestWeatherUpdate(@NonNull WeatherLocation weatherLocation, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = sWeatherManagerService.getTemperatureUnit();
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setWeatherLocation(weatherLocation).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#method_after
public int requestWeatherUpdate(@NonNull WeatherLocation weatherLocation, @NonNull WeatherUpdateRequestListener listener) {
    if (sWeatherManagerService == null) {
        return -1;
    }
    try {
        int tempUnit = CMSettings.Global.getInt(mContext.getContentResolver(), CMSettings.Global.WEATHER_TEMPERATURE_UNIT, WeatherContract.WeatherColumns.TempUnit.FAHRENHEIT);
        RequestInfo info = new RequestInfo.Builder(mRequestInfoListener).setWeatherLocation(weatherLocation).setTemperatureUnit(tempUnit).build();
        if (listener != null)
            mWeatherUpdateRequestListeners.put(info, listener);
        sWeatherManagerService.updateWeather(info);
        return info.hashCode();
    } catch (RemoteException e) {
        return -1;
    }
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_BOOT_COMPLETED) {
        mAwaitingNudge = getSunsetCounter() < 1;
        mDHC = new DisplayHardwareController(mContext, mHandler);
        mFeatures.add(mDHC);
        mCTC = new ColorTemperatureController(mContext, mHandler, mDHC);
        mFeatures.add(mCTC);
        mOMC = new OutdoorModeController(mContext, mHandler);
        mFeatures.add(mOMC);
        // Call onStart of each feature and get it's capabilities
        final BitSet capabilities = new BitSet();
        for (Iterator<LiveDisplayFeature> it = mFeatures.iterator(); it.hasNext(); ) {
            final LiveDisplayFeature feature = it.next();
            if (feature.onStart()) {
                feature.getCapabilities(capabilities);
            } else {
                it.remove();
            }
        }
        int defaultMode = mContext.getResources().getInteger(org.cyanogenmod.platform.internal.R.integer.config_defaultLiveDisplayMode);
        mConfig = new LiveDisplayConfig(capabilities, defaultMode, mCTC.getDefaultDayTemperature(), mCTC.getDefaultNightTemperature(), mOMC.getDefaultAutoOutdoorMode(), mDHC.getDefaultAutoContrast(), mDHC.getDefaultCABC(), mDHC.getDefaultColorEnhancement());
        mDisplayManager = (DisplayManager) getContext().getSystemService(Context.DISPLAY_SERVICE);
        mDisplayManager.registerDisplayListener(mDisplayListener, null);
        PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
        pmi.registerLowPowerModeObserver(mLowPowerModeListener);
        mTwilightManager = LocalServices.getService(TwilightManager.class);
        mTwilightManager.registerListener(mTwilightListener, mHandler);
        updateTwilight();
        updateDisplayState(mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY).getState());
        mModeObserver = new ModeObserver(mHandler);
        mModeObserver.update();
        mContext.registerReceiver(mNextModeReceiver, new IntentFilter(ACTION_NEXT_MODE));
        publishCustomTile();
        mInitialized = true;
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_BOOT_COMPLETED) {
        mAwaitingNudge = getSunsetCounter() < 1;
        mDHC = new DisplayHardwareController(mContext, mHandler);
        mFeatures.add(mDHC);
        mCTC = new ColorTemperatureController(mContext, mHandler, mDHC);
        mFeatures.add(mCTC);
        mOMC = new OutdoorModeController(mContext, mHandler);
        mFeatures.add(mOMC);
        // Call onStart of each feature and get it's capabilities
        final BitSet capabilities = new BitSet();
        for (Iterator<LiveDisplayFeature> it = mFeatures.iterator(); it.hasNext(); ) {
            final LiveDisplayFeature feature = it.next();
            if (feature.onStart()) {
                feature.getCapabilities(capabilities);
            } else {
                it.remove();
            }
        }
        int defaultMode = mContext.getResources().getInteger(org.cyanogenmod.platform.internal.R.integer.config_defaultLiveDisplayMode);
        mConfig = new LiveDisplayConfig(capabilities, defaultMode, mCTC.getDefaultDayTemperature(), mCTC.getDefaultNightTemperature(), mOMC.getDefaultAutoOutdoorMode(), mDHC.getDefaultAutoContrast(), mDHC.getDefaultCABC(), mDHC.getDefaultColorEnhancement());
        mDisplayManager = (DisplayManager) getContext().getSystemService(Context.DISPLAY_SERVICE);
        mDisplayManager.registerDisplayListener(mDisplayListener, null);
        updateDisplayState(mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY).getState());
        PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
        pmi.registerLowPowerModeObserver(mLowPowerModeListener);
        if (mConfig.hasModeSupport()) {
            mModeObserver = new ModeObserver(mHandler);
            mModeObserver.update();
            mContext.registerReceiver(mNextModeReceiver, new IntentFilter(ACTION_NEXT_MODE));
        }
        mTwilightManager = LocalServices.getService(TwilightManager.class);
        mTwilightManager.registerListener(mTwilightListener, mHandler);
        updateTwilight();
        for (int i = 0; i < mFeatures.size(); i++) {
            mFeatures.get(i).onSettingsChanged(null);
        }
        mInitialized = true;
    }
}
#end_block

#method_before
private int getNextModeIndex() {
    int next = getCurrentModeIndex() + 1;
    if (next >= mTileValues.length) {
        next = 0;
    }
    int nextMode;
    while (true) {
        nextMode = Integer.valueOf(mTileValues[next]);
        if (nextMode == MODE_OUTDOOR) {
            // Only accept outdoor mode if it's supported
            if (mConfig.hasFeature(MODE_OUTDOOR) || mConfig.hasFeature(FEATURE_MANAGED_OUTDOOR_MODE)) {
                break;
            }
        } else if (nextMode == MODE_DAY) {
            // Skip the day setting if it's the same as the off setting
            if (mCTC.getDayColorTemperature() != mConfig.getDefaultDayTemperature()) {
                break;
            }
        } else {
            // every other mode doesn't have any preconstraints
            break;
        }
        // If we come here, we decided to skip the mode
        next++;
        if (next >= mTileValues.length) {
            next = 0;
        }
    }
    return nextMode;
}
#method_after
private int getNextModeIndex() {
    int next = getCurrentModeIndex() + 1;
    if (next >= mTileValues.length) {
        next = 0;
    }
    int nextMode;
    while (true) {
        nextMode = Integer.valueOf(mTileValues[next]);
        if (nextMode == MODE_OUTDOOR) {
            // Only accept outdoor mode if it's supported by the hardware
            if (mConfig.hasFeature(MODE_OUTDOOR) && !mConfig.hasFeature(FEATURE_MANAGED_OUTDOOR_MODE)) {
                break;
            }
        } else if (nextMode == MODE_DAY) {
            // Skip the day setting if it's the same as the off setting
            if (mCTC.getDayColorTemperature() != mConfig.getDefaultDayTemperature()) {
                break;
            }
        } else {
            // every other mode doesn't have any preconstraints
            break;
        }
        // If we come here, we decided to skip the mode
        next++;
        if (next >= mTileValues.length) {
            next = 0;
        }
    }
    return nextMode;
}
#end_block

#method_before
@Override
protected void update() {
    mHandler.obtainMessage(MSG_MODE_CHANGED, getMode(), 0).sendToTarget();
    publishCustomTile();
}
#method_after
@Override
protected void update() {
    mHandler.obtainMessage(MSG_MODE_CHANGED, getMode()).sendToTarget();
    publishCustomTile();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (!mInitialized) {
        return;
    }
    switch(msg.what) {
        case MSG_DISPLAY_CHANGED:
            updateDisplayState(msg.arg1);
            break;
        case MSG_LOW_POWER_MODE_CHANGED:
            updateLowPowerMode(msg.arg1 == 1);
            break;
        case MSG_TWILIGHT_UPDATE:
            updateTwilight();
            nudge();
            break;
        case MSG_MODE_CHANGED:
            stopNudgingMe();
            updateMode(msg.arg1);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (!mInitialized) {
        return;
    }
    switch(msg.what) {
        case MSG_DISPLAY_CHANGED:
            updateDisplayState(msg.arg1);
            break;
        case MSG_LOW_POWER_MODE_CHANGED:
            updateLowPowerMode(msg.arg1 == 1);
            break;
        case MSG_TWILIGHT_UPDATE:
            updateTwilight();
            nudge();
            break;
        case MSG_MODE_CHANGED:
            stopNudgingMe();
            int mode = msg.obj == null ? MODE_OFF : (Integer) msg.obj;
            updateMode(mode);
            break;
    }
}
#end_block

#method_before
@Override
protected synchronized void onScreenStateChanged() {
    if (mUseColorAdjustment) {
        if (mAnimator != null && mAnimator.isRunning() && !isScreenOn()) {
            mAnimator.cancel();
            mDirty = true;
        } else if (mDirty) {
            updateColorAdjustment();
            mDirty = false;
        }
    }
}
#method_after
@Override
protected synchronized void onScreenStateChanged() {
    if (mUseColorAdjustment) {
        if (mAnimator != null && mAnimator.isRunning() && !isScreenOn()) {
            mAnimator.cancel();
            mDirty = true;
        } else if (mDirty && isScreenOn()) {
            updateColorAdjustment();
            mDirty = false;
        }
    }
}
#end_block

#method_before
float[] getColorAdjustment() {
    if (!mUseColorAdjustment) {
        return getDefaultAdjustment();
    }
    final float[] cur = new float[3];
    if (!parseColorAdjustment(getString(CMSettings.System.DISPLAY_COLOR_ADJUSTMENT), cur)) {
        // clear it out if invalid
        cur[0] = cur[1] = cur[2] = 1.0f;
        saveColorAdjustmentString(cur);
    }
    return cur;
}
#method_after
float[] getColorAdjustment() {
    if (!mUseColorAdjustment) {
        return getDefaultAdjustment();
    }
    float[] cur = new float[3];
    if (!parseColorAdjustment(getString(CMSettings.System.DISPLAY_COLOR_ADJUSTMENT), cur)) {
        // clear it out if invalid
        cur = getDefaultAdjustment();
        saveColorAdjustmentString(cur);
    }
    return cur;
}
#end_block

#method_before
private synchronized void updateSensorState() {
    if (!mUseOutdoorMode || mLuxObserver == null) {
        return;
    }
    /* Sensor:
         *  Enabled in day mode
         *  Enabled in auto mode if it's not night
         *  Disabled if outdoor mode explicitly selected
         *  Disabled in low power mode
         *  Disabled if screen is off
         */
    boolean sensorEnabled = !mSelfManaged && !isLowPowerMode() && isScreenOn() && getMode() != MODE_OUTDOOR && isAutomaticOutdoorModeEnabled() && ((getMode() == MODE_AUTO && !isNight()) || getMode() == MODE_DAY);
    if (mIsSensorEnabled != sensorEnabled) {
        mIsSensorEnabled = sensorEnabled;
        mLuxObserver.setTransitionListener(sensorEnabled ? mListener : null);
    }
}
#method_after
private synchronized void updateSensorState() {
    if (!mUseOutdoorMode || mLuxObserver == null || mSelfManaged) {
        return;
    }
    /*
         * Light sensor:
         */
    boolean sensorEnabled = false;
    // no sensor if low power mode or when the screen is off
    if (isScreenOn() && !isLowPowerMode()) {
        if (isAutomaticOutdoorModeEnabled()) {
            int mode = getMode();
            if (mode == MODE_DAY) {
                // always turn it on if day mode is selected
                sensorEnabled = true;
            } else if (mode == MODE_AUTO && !isNight()) {
                // in auto mode we turn it on during actual daytime
                sensorEnabled = true;
            }
        }
    }
    if (mIsSensorEnabled != sensorEnabled) {
        mIsSensorEnabled = sensorEnabled;
        mLuxObserver.setTransitionListener(sensorEnabled ? mListener : null);
    }
}
#end_block

#method_before
private synchronized void updateOutdoorMode() {
    if (!mUseOutdoorMode) {
        return;
    }
    /*
         * Hardware toggle:
         *   Enabled if outdoor mode explictly selected
         *   Enabled if outdoor lux exceeded and day mode or auto mode (if not night)
         *   Enabled if backend is self-managed
         */
    if (isScreenOn()) {
        boolean enabled = !isLowPowerMode() && (getMode() == MODE_OUTDOOR || (isAutomaticOutdoorModeEnabled() && (mSelfManaged || mIsOutdoor) && ((getMode() == MODE_AUTO && !isNight()) || getMode() == MODE_DAY)));
        mHardware.set(CMHardwareManager.FEATURE_SUNLIGHT_ENHANCEMENT, enabled);
    }
    updateSensorState();
}
#method_after
private synchronized void updateOutdoorMode() {
    if (!mUseOutdoorMode) {
        return;
    }
    updateSensorState();
    /*
         * Should we turn on outdoor mode or not?
         *
         * Do nothing if the screen is off.
         */
    if (isScreenOn()) {
        boolean enabled = false;
        // turn it off in low power mode
        if (!isLowPowerMode()) {
            int mode = getMode();
            // turn it on if the user manually selected the mode
            if (mode == MODE_OUTDOOR) {
                enabled = true;
            } else if (isAutomaticOutdoorModeEnabled()) {
                // to turn on/off the feature.
                if (mSelfManaged) {
                    enabled = true;
                } else if (mIsOutdoor) {
                    // if we're here, the sensor detects extremely bright light.
                    if (mode == MODE_DAY) {
                        // if the user manually selected day mode, go ahead and
                        // melt their face
                        enabled = true;
                    } else if (mode == MODE_AUTO && !isNight()) {
                        // if we're in auto mode, we should also check if it's
                        // night time, since we don't get much sun at night
                        // on this planet :)
                        enabled = true;
                    }
                }
            }
        }
        mHardware.set(CMHardwareManager.FEATURE_SUNLIGHT_ENHANCEMENT, enabled);
    }
}
#end_block

#method_before
@Override
protected void onScreenStateChanged() {
    if (isScreenOn()) {
    }
}
#method_after
@Override
protected void onScreenStateChanged() {
    // pause/continue transition
    if (mTransitioning) {
        if (isScreenOn()) {
            mHandler.post(mTransitionRunnable);
        } else {
            mHandler.removeCallbacks(mTransitionRunnable);
        }
    }
}
#end_block

#method_before
@Override
public void dump(PrintWriter pw) {
    pw.println();
    pw.println("ColorTemperatureController Configuration:");
    pw.println("  mDayTemperature=" + mDayTemperature);
    pw.println("  mNightTemperature=" + mNightTemperature);
    pw.println();
    pw.println("  ColorTemperatureController State:");
    pw.println("    mColorTemperature=" + mColorTemperature);
    pw.println("    transitioning=" + mHandler.hasCallbacks(mTransitionRunnable));
}
#method_after
@Override
public void dump(PrintWriter pw) {
    pw.println();
    pw.println("ColorTemperatureController Configuration:");
    pw.println("  mDayTemperature=" + mDayTemperature);
    pw.println("  mNightTemperature=" + mNightTemperature);
    pw.println();
    pw.println("  ColorTemperatureController State:");
    pw.println("    mColorTemperature=" + mColorTemperature);
    pw.println("    mTransitioning=" + mTransitioning);
}
#end_block

#method_before
private void publishCustomTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        int idx = getCurrentModeIndex();
        final UserHandle user = new UserHandle(userId);
        final Context resourceContext = QSUtils.getQSTileContext(mContext, userId);
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(mTileEntries[idx]).setContentDescription(mTileDescriptionEntries[idx]).setIcon(mTileEntryIconRes[idx]).setOnLongClickIntent(getCustomTileLongClickPendingIntent()).setOnClickIntent(getCustomTileNextModePendingIntent()).shouldCollapsePanel(false).build();
        statusBarManager.publishTileAsUser(QSConstants.TILE_LIVE_DISPLAY, LiveDisplayService.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
private void publishCustomTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        int idx = getCurrentModeIndex();
        final UserHandle user = new UserHandle(userId);
        final Context resourceContext = QSUtils.getQSTileContext(mContext, userId);
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(mTileEntries[idx]).setContentDescription(mTileDescriptionEntries[idx]).setIcon(mTileEntryIconRes[idx]).setOnLongClickIntent(getCustomTileLongClickPendingIntent()).setOnClickIntent(getCustomTileNextModePendingIntent()).shouldCollapsePanel(false).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_LIVE_DISPLAY, LiveDisplayService.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private void unpublishCustomTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        statusBarManager.removeTileAsUser(QSConstants.TILE_LIVE_DISPLAY, LiveDisplayService.class.hashCode(), new UserHandle(userId));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
private void unpublishCustomTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        statusBarManager.removeTileAsUser(QSConstants.DYNAMIC_TILE_LIVE_DISPLAY, LiveDisplayService.class.hashCode(), new UserHandle(userId));
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
public List<AudioSessionInfo> listAudioSessions(int streamType) {
    if (checkService()) {
        try {
            final List<AudioSessionInfo> sessions = sService.listAudioSessions(streamType);
            if (sessions != null) {
                return Collections.unmodifiableList(sessions);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to list audio sessions!", e);
        }
    }
    return Collections.emptyList();
}
#method_after
public List<AudioSessionInfo> listAudioSessions() {
    return listAudioSessions(-1);
}
#end_block

#method_before
@Override
public void onStart() {
    if (mContext.getPackageManager().hasSystemFeature(CMContextConstants.Features.AUDIO)) {
        if (!sNativeLibraryLoaded) {
            Log.wtf(TAG, "CM Audio service started by system server by native library is" + "unavailable. Service will be unavailable.");
        } else {
            publishBinderService(CMContextConstants.CM_AUDIO_SERVICE, mBinder);
        }
    } else {
        Log.wtf(TAG, "CM Audio service started by system server but feature xml not" + " declared. Not publishing binder service!");
    }
}
#method_after
@Override
public void onStart() {
    if (!mContext.getPackageManager().hasSystemFeature(CMContextConstants.Features.AUDIO)) {
        Log.wtf(TAG, "CM Audio service started by system server but feature xml not" + " declared. Not publishing binder service!");
        return;
    }
    if (!sNativeLibraryLoaded) {
        Log.wtf(TAG, "CM Audio service started by system server by native library is" + "unavailable. Service will be unavailable.");
        return;
    }
    publishBinderService(CMContextConstants.CM_AUDIO_SERVICE, mBinder);
}
#end_block

#method_before
private void sendBroadcastToAll(Intent intent, String receiverPermission) {
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    final long ident = Binder.clearCallingIdentity();
    try {
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, receiverPermission);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
private void sendBroadcastToAll(Intent intent, String receiverPermission) {
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    final long ident = Binder.clearCallingIdentity();
    try {
        if (DEBUG)
            Log.d(TAG, "Sending broadcast: " + intent.toString());
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, receiverPermission);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj == null || !(obj instanceof AudioSessionInfo)) {
        return false;
    }
    // sessions are unique per id
    if (mSessionId == ((AudioSessionInfo) obj).mSessionId) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null || !(obj instanceof AudioSessionInfo)) {
        return false;
    }
    final AudioSessionInfo other = (AudioSessionInfo) obj;
    return this == other || (mSessionId == other.mSessionId && mStream == other.mStream && mFlags == other.mFlags && mChannelMask == other.mChannelMask && mUid == other.mUid);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    // Tell the concierge to prepare the parcel
    ParcelInfo parcelInfo = Concierge.prepareParcel(dest);
    dest.writeInt(mSessionId);
    dest.writeInt(mStream);
    dest.writeInt(mFlags);
    dest.writeInt(mChannelMask);
    dest.writeInt(mUid);
    parcelInfo.complete();
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    // Tell the concierge to prepare the parcel
    ParcelInfo parcelInfo = Concierge.prepareParcel(dest);
    /* -- FIG -- */
    dest.writeInt(mSessionId);
    dest.writeInt(mStream);
    dest.writeInt(mFlags);
    dest.writeInt(mChannelMask);
    dest.writeInt(mUid);
    parcelInfo.complete();
}
#end_block

#method_before
@SmallTest
public void testSetAndGetPowerProfile() {
    // assume what they are and if we can set everything correctly.
    for (int i = 0; i < mCMPerformanceManager.getNumberOfProfiles(); i++) {
        // setPowerProfile will noop, ignore that scenario
        if (mCMPerformanceManager.getPowerProfile() != i) {
            mCMPerformanceManager.setPowerProfile(i);
            // Verify that it was set correctly.
            assertEquals(i, mCMPerformanceManager.getPowerProfile());
        }
    }
}
#method_after
@SmallTest
public void testSetAndGetPowerProfile() {
    // assume what they are and if we can set everything correctly.
    for (int powerProfile = 0; powerProfile < PerformanceManager.POSSIBLE_POWER_PROFILES.length; powerProfile++) {
        if (powerProfile < mCMPerformanceManager.getNumberOfProfiles()) {
            // It is supported, set it and test if it was set
            if (mCMPerformanceManager.getPowerProfile() != powerProfile) {
                mCMPerformanceManager.setPowerProfile(powerProfile);
                // Verify that it was set correctly.
                assertEquals(powerProfile, mCMPerformanceManager.getPowerProfile());
            }
        } else {
            assertFalse(mCMPerformanceManager.setPowerProfile(powerProfile));
        }
    }
}
#end_block

#method_before
private void publishThemesTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        final UserHandle user = new UserHandle(userId);
        final Context resourceContext = QSUtils.getQSTileContext(mContext, userId);
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(R.string.qs_themes_label).setContentDescription(R.string.qs_themes_content_description).setIcon(R.drawable.ic_qs_themes).setOnClickIntent(getThemeChooserPendingIntent()).shouldCollapsePanel(true).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_THEMES, ThemeManagerService.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
private void publishThemesTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        final UserHandle user = new UserHandle(userId);
        final Context resourceContext = QSUtils.getQSTileContext(mContext, userId);
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        final PendingIntent chooserIntent = getThemeChooserPendingIntent();
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(R.string.qs_themes_label).setContentDescription(R.string.qs_themes_content_description).setIcon(R.drawable.ic_qs_themes).setOnClickIntent(chooserIntent).setOnLongClickIntent(chooserIntent).shouldCollapsePanel(true).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_THEMES, ThemeManagerService.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private void cpuBoostInternal(int duration) {
    if (duration > 0 && duration <= MAX_CPU_BOOST_TIME) {
        // Don't send boosts if we're in another power profile
        if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE || mCurrentProfile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
            return;
        }
        mHandler.obtainMessage(MSG_CPU_BOOST, duration, 0).sendToTarget();
        ;
    } else {
        Slog.e(TAG, "Invalid boost duration: " + duration);
    }
}
#method_after
private void cpuBoostInternal(int duration) {
    if (duration > 0 && duration <= MAX_CPU_BOOST_TIME) {
        // Don't send boosts if we're in another power profile
        if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE || mCurrentProfile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
            return;
        }
        mHandler.obtainMessage(MSG_CPU_BOOST, duration, 0).sendToTarget();
    } else {
        Slog.e(TAG, "Invalid boost duration: " + duration);
    }
}
#end_block

#method_before
@Override
public void onStart() {
    if (!sNativeLibraryLoaded) {
        Log.wtf(TAG, "CM Audio service started by system server by native library is" + "unavailable. Service will be unavailable.");
        return;
    }
    publishBinderService(CMContextConstants.CM_AUDIO_SERVICE, mBinder);
}
#method_after
@Override
public void onStart() {
    if (!NativeHelper.isNativeLibraryAvailable()) {
        Log.wtf(TAG, "CM Audio service started by system server by native library is" + "unavailable. Service will be unavailable.");
        return;
    }
    publishBinderService(CMContextConstants.CM_AUDIO_SERVICE, mBinder);
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_BOOT_COMPLETED) {
        if (sNativeLibraryLoaded) {
            native_registerAudioSessionCallback(true);
        }
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_BOOT_COMPLETED) {
        if (NativeHelper.isNativeLibraryAvailable()) {
            native_registerAudioSessionCallback(true);
        }
    }
}
#end_block

#method_before
private void startServices() {
    final Context context = mSystemContext;
    final SystemServiceManager ssm = LocalServices.getService(SystemServiceManager.class);
    String[] externalServices = context.getResources().getStringArray(org.cyanogenmod.platform.internal.R.array.config_externalCMServices);
    for (String service : externalServices) {
        try {
            Slog.i(TAG, "Attempting to start service " + service);
            if (context.getPackageManager().hasSystemFeature(servicesToFeatures.get(service))) {
                Slog.i(TAG, "Starting service " + service);
                ssm.startService(service);
            }
            Slog.i(TAG, "Not starting service " + service + " due to feature not declared on device");
        } catch (Throwable e) {
            reportWtf("starting " + service, e);
        }
    }
}
#method_after
private void startServices() {
    final Context context = mSystemContext;
    final SystemServiceManager ssm = LocalServices.getService(SystemServiceManager.class);
    String[] externalServices = context.getResources().getStringArray(org.cyanogenmod.platform.internal.R.array.config_externalCMServices);
    for (String service : externalServices) {
        try {
            Slog.i(TAG, "Attempting to start service " + service);
            CMSystemService cmSystemService = mSystemServiceHelper.getServiceFor(service);
            if (context.getPackageManager().hasSystemFeature(cmSystemService.getFeatureDeclaration())) {
                Slog.i(TAG, "Starting service " + service);
                ssm.startService(cmSystemService.getClass());
            } else {
                Slog.i(TAG, "Not starting service " + service + " due to feature not declared on device");
            }
        } catch (Throwable e) {
            reportWtf("starting " + service, e);
        }
    }
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    super.onBootPhase(phase);
    if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
        if (!isThemeApiUpToDate()) {
            Log.d(TAG, "The system has been upgraded to a theme new api, " + "checking if currently set theme is compatible");
            removeObsoleteThemeOverlayIfExists();
            updateThemeApi();
        }
        registerAppsFailureReceiver();
        processInstalledThemes();
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    super.onBootPhase(phase);
    if (phase == SystemService.PHASE_ACTIVITY_MANAGER_READY) {
        if (!isThemeApiUpToDate()) {
            Log.d(TAG, "The system has been upgraded to a theme new api, " + "checking if currently set theme is compatible");
            removeObsoleteThemeOverlayIfExists();
            updateThemeApi();
        }
        registerAppsFailureReceiver();
        processInstalledThemes();
    } else if (phase == SystemService.PHASE_BOOT_COMPLETED) {
        publishThemesTile();
    }
}
#end_block

#method_before
private void setDefaultLiveLockScreenInternal(LiveLockScreenInfo llsInfo) {
    if (llsInfo != null && llsInfo.component != null) {
        // Check that the package this component belongs to has the third party keyguard perm
        final PackageManager pm = mContext.getPackageManager();
        final boolean hasThirdPartyKeyguardPermission = pm.checkPermission(Manifest.permission.THIRD_PARTY_KEYGUARD, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED || pm.checkPermission(DEPRECATED_THIRD_PARTY_KEYGUARD_PERMISSION, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED;
        if (!hasThirdPartyKeyguardPermission) {
            Slog.e(TAG, "Package " + llsInfo.component.getPackageName() + " does not have " + Manifest.permission.THIRD_PARTY_KEYGUARD);
            return;
        }
    }
    long token = Binder.clearCallingIdentity();
    try {
        CMSettings.Secure.putString(mContext.getContentResolver(), CMSettings.Secure.DEFAULT_LIVE_LOCK_SCREEN_COMPONENT, (llsInfo != null && llsInfo.component != null) ? llsInfo.component.flattenToString() : "");
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mDefaultLlsInfo = llsInfo;
    try {
        mService.updateDefaultLiveLockScreen(llsInfo);
    } catch (RemoteException e) {
    /* ignore */
    }
}
#method_after
private void setDefaultLiveLockScreenInternal(LiveLockScreenInfo llsInfo) {
    if (llsInfo != null && llsInfo.component != null) {
        // Check that the package this component belongs to has the third party keyguard perm
        final PackageManager pm = mContext.getPackageManager();
        final boolean hasThirdPartyKeyguardPermission = pm.checkPermission(Manifest.permission.THIRD_PARTY_KEYGUARD, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED || pm.checkPermission(DEPRECATED_THIRD_PARTY_KEYGUARD_PERMISSION, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED;
        if (!hasThirdPartyKeyguardPermission) {
            Slog.e(TAG, "Package " + llsInfo.component.getPackageName() + " does not have " + Manifest.permission.THIRD_PARTY_KEYGUARD);
            return;
        }
    }
    long token = Binder.clearCallingIdentity();
    try {
        CMSettings.Secure.putString(mContext.getContentResolver(), CMSettings.Secure.DEFAULT_LIVE_LOCK_SCREEN_COMPONENT, (llsInfo != null && llsInfo.component != null) ? llsInfo.component.flattenToString() : "");
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mDefaultLlsInfo = llsInfo;
    try {
        getServiceGuarded().updateDefaultLiveLockScreen(llsInfo);
    } catch (RemoteException e) {
    /* ignore */
    }
}
#end_block

#method_before
private synchronized boolean setPowerProfileInternal(int profile, boolean fromUser) {
    if (DEBUG) {
        Slog.v(TAG, String.format("setPowerProfileInternal(profile=%d, fromUser=%b)", profile, fromUser));
    }
    if (profile < 0 || profile > mNumProfiles) {
        Slog.e(TAG, "Invalid profile: " + profile);
        return false;
    }
    boolean isProfileSame = profile == mCurrentProfile;
    if (!isProfileSame) {
        if (profile == PerformanceManager.PROFILE_POWER_SAVE) {
            // Handle the case where toggle power saver mode
            // failed
            long token = Binder.clearCallingIdentity();
            try {
                if (!mPm.setPowerSaveMode(true)) {
                    return false;
                }
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE) {
            long token = Binder.clearCallingIdentity();
            mPm.setPowerSaveMode(false);
            Binder.restoreCallingIdentity(token);
        }
    }
    /**
     * It's possible that mCurrrentProfile != getUserProfile() because of a
     * per-app profile. Store the user's profile preference and then bail
     * early if there is no work to be done.
     */
    if (fromUser) {
        CMSettings.Secure.putInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, profile);
    }
    if (isProfileSame) {
        return false;
    }
    // Enforce the performance access permission declared by cm's res package
    mContext.enforceCallingOrSelfPermission(cyanogenmod.platform.Manifest.permission.PERFORMANCE_ACCESS, null);
    long token = Binder.clearCallingIdentity();
    mCurrentProfile = profile;
    mHandler.removeMessages(MSG_CPU_BOOST);
    mHandler.removeMessages(MSG_LAUNCH_BOOST);
    mHandler.sendMessage(Message.obtain(mHandler, MSG_SET_PROFILE, profile, (fromUser ? 1 : 0)));
    Binder.restoreCallingIdentity(token);
    return true;
}
#method_after
private synchronized boolean setPowerProfileInternal(int profile, boolean fromUser) {
    if (DEBUG) {
        Slog.v(TAG, String.format("setPowerProfileInternal(profile=%d, fromUser=%b)", profile, fromUser));
    }
    if (mPm == null) {
        Slog.e(TAG, "System is not ready, dropping profile request");
        return false;
    }
    if (profile < 0 || profile > mNumProfiles) {
        Slog.e(TAG, "Invalid profile: " + profile);
        return false;
    }
    boolean isProfileSame = profile == mCurrentProfile;
    if (!isProfileSame) {
        if (profile == PerformanceManager.PROFILE_POWER_SAVE) {
            // Handle the case where toggle power saver mode
            // failed
            long token = Binder.clearCallingIdentity();
            try {
                if (!mPm.setPowerSaveMode(true)) {
                    return false;
                }
            } finally {
                Binder.restoreCallingIdentity(token);
            }
        } else if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE) {
            long token = Binder.clearCallingIdentity();
            mPm.setPowerSaveMode(false);
            Binder.restoreCallingIdentity(token);
        }
    }
    /**
     * It's possible that mCurrrentProfile != getUserProfile() because of a
     * per-app profile. Store the user's profile preference and then bail
     * early if there is no work to be done.
     */
    if (fromUser) {
        CMSettings.Secure.putInt(mContext.getContentResolver(), CMSettings.Secure.PERFORMANCE_PROFILE, profile);
    }
    if (isProfileSame) {
        return false;
    }
    // Enforce the performance access permission declared by cm's res package
    mContext.enforceCallingOrSelfPermission(cyanogenmod.platform.Manifest.permission.PERFORMANCE_ACCESS, null);
    long token = Binder.clearCallingIdentity();
    mCurrentProfile = profile;
    mHandler.obtainMessage(MSG_SET_PROFILE, profile, (fromUser ? 1 : 0)).sendToTarget();
    Binder.restoreCallingIdentity(token);
    return true;
}
#end_block

#method_before
private void cpuBoostInternal(int duration) {
    if (duration > 0 && duration <= MAX_CPU_BOOST_TIME) {
        // Don't send boosts if we're in another power profile
        if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE || mCurrentProfile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
            return;
        }
        mHandler.removeMessages(MSG_CPU_BOOST);
        mHandler.sendMessage(Message.obtain(mHandler, MSG_CPU_BOOST, duration, 0));
    } else {
        Slog.e(TAG, "Invalid boost duration: " + duration);
    }
}
#method_after
private void cpuBoostInternal(int duration) {
    synchronized (PerformanceManagerService.this) {
        if (mPm == null) {
            Slog.e(TAG, "System is not ready, dropping cpu boost request");
            return;
        }
    }
    if (duration > 0 && duration <= MAX_CPU_BOOST_TIME) {
        // Don't send boosts if we're in another power profile
        if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE || mCurrentProfile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
            return;
        }
        mHandler.obtainMessage(MSG_CPU_BOOST, duration, 0).sendToTarget();
    } else {
        Slog.e(TAG, "Invalid boost duration: " + duration);
    }
}
#end_block

#method_before
@Override
public void launchBoost() {
    // Don't send boosts if we're in another power profile
    if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE || mCurrentProfile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
        return;
    }
    mHandler.removeMessages(MSG_CPU_BOOST);
    mHandler.removeMessages(MSG_LAUNCH_BOOST);
    mHandler.sendEmptyMessage(MSG_LAUNCH_BOOST);
}
#method_after
@Override
public void launchBoost(int pid, String packageName) {
    synchronized (PerformanceManagerService.this) {
        if (mPm == null) {
            Slog.e(TAG, "System is not ready, dropping launch boost request");
            return;
        }
    }
    // Don't send boosts if we're in another power profile
    if (mCurrentProfile == PerformanceManager.PROFILE_POWER_SAVE || mCurrentProfile == PerformanceManager.PROFILE_HIGH_PERFORMANCE) {
        return;
    }
    mHandler.obtainMessage(MSG_LAUNCH_BOOST, pid, 0, packageName).sendToTarget();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_CPU_BOOST:
            mPm.powerHint(POWER_HINT_CPU_BOOST, msg.arg1);
            break;
        case MSG_LAUNCH_BOOST:
            mPm.powerHint(POWER_HINT_LAUNCH_BOOST, 0);
            break;
        case MSG_SET_PROFILE:
            mPm.powerHint(POWER_HINT_SET_PROFILE, msg.arg1);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_CPU_BOOST:
            mPm.powerHint(POWER_HINT_CPU_BOOST, msg.arg1);
            break;
        case MSG_LAUNCH_BOOST:
            int pid = msg.arg1;
            String packageName = (String) msg.obj;
            if (NativeHelper.isNativeLibraryAvailable() && packageName != null) {
                native_launchBoost(pid, packageName);
            }
            break;
        case MSG_SET_PROFILE:
            mPm.powerHint(POWER_HINT_SET_PROFILE, msg.arg1);
            break;
    }
}
#end_block

#method_before
private static <T extends IBinder> String getStubDescriptor(Class<T> stubClass) {
    try {
        T instance = stubClass.newInstance();
        return instance.getInterfaceDescriptor();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
private static <T extends IBinder> String getStubDescriptor(Class<T> stubClass) {
    String descriptor = null;
    try {
        Field f = stubClass.getDeclaredField("DESCRIPTOR");
        f.setAccessible(true);
        descriptor = (String) f.get(stubClass);
    } catch (NoSuchFieldException | IllegalAccessException e) {
        Assert.fail(e.getMessage());
    }
    return descriptor;
}
#end_block

#method_before
public static <T extends IBinder> T getMockInterface(Class<T> stub) {
    String descriptor = getStubDescriptor(stub);
    T mockInterface = Mockito.mock(stub);
    Mockito.doReturn(mockInterface).when(mockInterface).queryLocalInterface(descriptor == null ? Mockito.anyString() : Mockito.eq(descriptor));
    return mockInterface;
}
#method_after
public static <T extends IBinder> T getMockInterface(Class<T> stub) {
    String descriptor = getStubDescriptor(stub);
    T mockInterface = Mockito.mock(stub);
    Mockito.doReturn(mockInterface).when(mockInterface).queryLocalInterface(descriptor == null ? Mockito.anyString() : Mockito.eq(descriptor));
    Mockito.doReturn(Mockito.mock(IBinder.class)).when((IInterface) mockInterface).asBinder();
    return mockInterface;
}
#end_block

#method_before
public void testServiceAndCallbacksRegistered() {
    testValidServiceBind();
    // Ensure a view was asked to be created
    try {
        Mockito.verify(mExternalViewProviderFactory, Mockito.times(1)).createExternalView(Mockito.any(Bundle.class));
    } catch (RemoteException e) {
        e.printStackTrace();
    }
    // Ensure callbacks were registered
    try {
        Mockito.verify(mIKeyguardExternalViewProvider, Mockito.times(1)).registerCallback(Mockito.notNull(IKeyguardExternalViewCallbacks.class));
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
#method_after
public void testServiceAndCallbacksRegistered() throws RemoteException {
    testValidServiceBind();
    // Ensure a view was asked to be created
    Mockito.verify(mExternalViewProviderFactory, Mockito.times(1)).createExternalView(Mockito.any(Bundle.class));
    // Ensure callbacks were registered
    Mockito.verify(mIKeyguardExternalViewProvider, Mockito.times(1)).registerCallback(Mockito.notNull(IKeyguardExternalViewCallbacks.class));
    assertNotNull(mKeyguardCallback);
}
#end_block

#method_before
public void testServiceUnbindAndCallbacksUnRegistered() {
    testServiceAndCallbacksRegistered();
    assertNotNull(mServiceConnection);
    mServiceConnection.onServiceDisconnected(null);
    // Ensure callbacks were registered
    try {
        Mockito.verify(mIKeyguardExternalViewProvider, Mockito.times(1)).unregisterCallback(Mockito.notNull(IKeyguardExternalViewCallbacks.class));
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
#method_after
public void testServiceUnbindAndCallbacksUnRegistered() throws RemoteException {
    testServiceAndCallbacksRegistered();
    assertNotNull(mServiceConnection);
    mServiceConnection.onServiceDisconnected(null);
    // Ensure callbacks were registered
    Mockito.verify(mIKeyguardExternalViewProvider, Mockito.times(1)).unregisterCallback(Mockito.notNull(IKeyguardExternalViewCallbacks.class));
}
#end_block

#method_before
public void testWindowAttachmentCallbacks() {
    testServiceAndCallbacksRegistered();
    assertNotNull(mKeyguardCallback);
    KeyguardExternalView.OnWindowAttachmentChangedListener callback = Mockito.mock(KeyguardExternalView.OnWindowAttachmentChangedListener.class);
    mExternalView.registerOnWindowAttachmentChangedListener(callback);
    try {
        mKeyguardCallback.onAttachedToWindow();
    } catch (RemoteException e) {
        e.printStackTrace();
    }
    Mockito.verify(callback, Mockito.times(1)).onAttachedToWindow();
    Mockito.verifyNoMoreInteractions(callback);
    try {
        mKeyguardCallback.onDetachedFromWindow();
    } catch (RemoteException e) {
        e.printStackTrace();
    }
    Mockito.verify(callback, Mockito.times(1)).onDetachedFromWindow();
    Mockito.verifyNoMoreInteractions(callback);
}
#method_after
public void testWindowAttachmentCallbacks() throws RemoteException {
    testServiceAndCallbacksRegistered();
    KeyguardExternalView.OnWindowAttachmentChangedListener callback = Mockito.mock(KeyguardExternalView.OnWindowAttachmentChangedListener.class);
    mExternalView.registerOnWindowAttachmentChangedListener(callback);
    mKeyguardCallback.onAttachedToWindow();
    Mockito.verify(callback, Mockito.times(1)).onAttachedToWindow();
    Mockito.verifyNoMoreInteractions(callback);
    mKeyguardCallback.onDetachedFromWindow();
    Mockito.verify(callback, Mockito.times(1)).onDetachedFromWindow();
    Mockito.verifyNoMoreInteractions(callback);
}
#end_block

#method_before
public void testKeyguardViewCallbacks() throws RemoteException {
    testServiceAndCallbacksRegistered();
    assertNotNull(mKeyguardCallback);
    KeyguardExternalView.KeyguardExternalViewCallbacks callback = Mockito.mock(KeyguardExternalView.KeyguardExternalViewCallbacks.class);
    mExternalView.registerKeyguardExternalViewCallback(callback);
    mKeyguardCallback.requestDismiss();
    Mockito.verify(callback, Mockito.times(1)).requestDismiss();
    Mockito.verifyNoMoreInteractions(callback);
    Intent i = new Intent();
    mKeyguardCallback.requestDismissAndStartActivity(i);
    Mockito.verify(callback, Mockito.times(1)).requestDismissAndStartActivity(Mockito.eq(i));
    Mockito.verifyNoMoreInteractions(callback);
    mKeyguardCallback.setInteractivity(true);
    assert (mExternalView.isInteractive());
    Mockito.verifyNoMoreInteractions(callback);
    mKeyguardCallback.slideLockscreenIn();
    Mockito.verify(callback, Mockito.times(1)).slideLockscreenIn();
    Mockito.verifyNoMoreInteractions(callback);
    mExternalView.binderDied();
    Mockito.verify(callback, Mockito.times(1)).providerDied();
    Mockito.verifyNoMoreInteractions(callback);
}
#method_after
public void testKeyguardViewCallbacks() throws RemoteException {
    testServiceAndCallbacksRegistered();
    KeyguardExternalView.KeyguardExternalViewCallbacks callback = Mockito.mock(KeyguardExternalView.KeyguardExternalViewCallbacks.class);
    mExternalView.registerKeyguardExternalViewCallback(callback);
    mKeyguardCallback.requestDismiss();
    Mockito.verify(callback, Mockito.times(1)).requestDismiss();
    Mockito.verifyNoMoreInteractions(callback);
    Intent i = new Intent();
    mKeyguardCallback.requestDismissAndStartActivity(i);
    Mockito.verify(callback, Mockito.times(1)).requestDismissAndStartActivity(Mockito.eq(i));
    Mockito.verifyNoMoreInteractions(callback);
    mKeyguardCallback.setInteractivity(true);
    assert (mExternalView.isInteractive());
    Mockito.verifyNoMoreInteractions(callback);
    mKeyguardCallback.slideLockscreenIn();
    Mockito.verify(callback, Mockito.times(1)).slideLockscreenIn();
    Mockito.verifyNoMoreInteractions(callback);
    mExternalView.binderDied();
    Mockito.verify(callback, Mockito.times(1)).providerDied();
    Mockito.verifyNoMoreInteractions(callback);
}
#end_block

#method_before
public static String readOneLine(String fileName) {
    String line = null;
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(fileName), 512);
        line = reader.readLine();
    } catch (IOException e) {
        Log.e(TAG, "Could not read from file " + fileName, e);
    } finally {
        try {
            if (reader != null) {
                reader.close();
            }
        } catch (IOException e) {
        // ignored, not much we can do anyway
        }
    }
    return line;
}
#method_after
public static String readOneLine(String fileName) {
    String line = null;
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(fileName), 512);
        line = reader.readLine();
    } catch (FileNotFoundException e) {
        Log.w(TAG, "No such file " + fileName + " for reading", e);
    } catch (IOException e) {
        Log.e(TAG, "Could not read from file " + fileName, e);
    } finally {
        try {
            if (reader != null) {
                reader.close();
            }
        } catch (IOException e) {
        // Ignored, not much we can do anyway
        }
    }
    return line;
}
#end_block

#method_before
public static boolean writeLine(String fileName, String value) {
    try {
        FileOutputStream fos = new FileOutputStream(fileName);
        fos.write(value.getBytes());
        fos.flush();
        fos.close();
    } catch (FileNotFoundException e) {
        Log.w(TAG, "No such file " + fileName + " for writing", e);
        return false;
    } catch (IOException e) {
        Log.e(TAG, "Could not write to file " + fileName, e);
        return false;
    }
    return true;
}
#method_after
public static boolean writeLine(String fileName, String value) {
    BufferedWriter writer = null;
    try {
        writer = new BufferedWriter(new FileWriter(fileName));
        writer.write(value);
    } catch (FileNotFoundException e) {
        Log.w(TAG, "No such file " + fileName + " for writing", e);
        return false;
    } catch (IOException e) {
        Log.e(TAG, "Could not write to file " + fileName, e);
        return false;
    } finally {
        try {
            if (writer != null) {
                writer.close();
            }
        } catch (IOException e) {
        // Ignored, not much we can do anyway
        }
    }
    return true;
}
#end_block

#method_before
private void maybeApplyActiveProfile() {
    final List<Profile.ProfileTrigger> wiFiTriggers = mActiveProfile.getTriggersFromType(Profile.TriggerType.WIFI);
    final List<Profile.ProfileTrigger> blueToothTriggers = mActiveProfile.getTriggersFromType(Profile.TriggerType.BLUETOOTH);
    boolean selectProfile = false;
    if (wiFiTriggers.size() == 0 && blueToothTriggers.size() == 0) {
        selectProfile = true;
    } else {
        final String activeSSID = getActiveSSID();
        if (activeSSID != null) {
            for (Profile.ProfileTrigger trigger : wiFiTriggers) {
                if (trigger.getState() == Profile.TriggerState.ON_CONNECT && trigger.getId().equals(activeSSID)) {
                    selectProfile = true;
                    break;
                }
            }
        }
        if (!selectProfile) {
            final BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
            final Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
            final Set<String> connectedBTDevices = new ArraySet<>();
            for (BluetoothDevice device : pairedDevices) {
                if (device.isConnected())
                    connectedBTDevices.add(device.getAddress());
            }
            for (Profile.ProfileTrigger trigger : mActiveProfile.getTriggersFromType(Profile.TriggerType.BLUETOOTH)) {
                if (connectedBTDevices.contains(trigger.getId()) && trigger.getState() == Profile.TriggerState.ON_CONNECT) {
                    selectProfile = true;
                    break;
                }
            }
        }
    }
    if (selectProfile)
        mActiveProfile.doSelect(mContext, mKeyguardService);
}
#method_after
private void maybeApplyActiveProfile() {
    final List<Profile.ProfileTrigger> wiFiTriggers = mActiveProfile.getTriggersFromType(Profile.TriggerType.WIFI);
    final List<Profile.ProfileTrigger> blueToothTriggers = mActiveProfile.getTriggersFromType(Profile.TriggerType.BLUETOOTH);
    boolean selectProfile = false;
    if (wiFiTriggers.size() == 0 && blueToothTriggers.size() == 0) {
        selectProfile = true;
    } else {
        final String activeSSID = getActiveSSID();
        if (activeSSID != null) {
            for (Profile.ProfileTrigger trigger : wiFiTriggers) {
                if (trigger.getState() == Profile.TriggerState.ON_CONNECT && trigger.getId().equals(activeSSID)) {
                    selectProfile = true;
                    break;
                }
            }
        }
        if (!selectProfile && blueToothTriggers.size() > 0) {
            final BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
            final Set<BluetoothDevice> pairedDevices = mBluetoothAdapter.getBondedDevices();
            final Set<String> connectedBTDevices = new ArraySet<>();
            for (BluetoothDevice device : pairedDevices) {
                if (device.isConnected())
                    connectedBTDevices.add(device.getAddress());
            }
            for (Profile.ProfileTrigger trigger : blueToothTriggers) {
                if (connectedBTDevices.contains(trigger.getId()) && trigger.getState() == Profile.TriggerState.ON_CONNECT) {
                    selectProfile = true;
                    break;
                }
            }
        }
    }
    if (selectProfile)
        mActiveProfile.doSelect(mContext, mKeyguardService);
}
#end_block

#method_before
@Override
public void enqueueLiveLockScreen(String pkg, int id, LiveLockScreenInfo lls, int[] idReceived, int userId) throws RemoteException {
    ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
    liveLockScreenManagerProvider.enqueueLiveLockScreen(pkg, id, lls, idReceived, userId);
}
#method_after
@Override
public void enqueueLiveLockScreen(String pkg, int id, LiveLockScreenInfo lls, int[] idReceived, int userId) throws RemoteException {
    getBrokeredService().enqueueLiveLockScreen(pkg, id, lls, idReceived, userId);
}
#end_block

#method_before
@Override
public void cancelLiveLockScreen(String pkg, int id, int userId) throws RemoteException {
    ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
    liveLockScreenManagerProvider.cancelLiveLockScreen(pkg, id, userId);
}
#method_after
@Override
public void cancelLiveLockScreen(String pkg, int id, int userId) throws RemoteException {
    getBrokeredService().cancelLiveLockScreen(pkg, id, userId);
}
#end_block

#method_before
@Override
public LiveLockScreenInfo getCurrentLiveLockScreen() throws RemoteException {
    ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
    return liveLockScreenManagerProvider.getCurrentLiveLockScreen();
}
#method_after
@Override
public LiveLockScreenInfo getCurrentLiveLockScreen() throws RemoteException {
    return getBrokeredService().getCurrentLiveLockScreen();
}
#end_block

#method_before
@Override
public boolean getLiveLockScreenEnabled() throws RemoteException {
    ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
    return liveLockScreenManagerProvider.getLiveLockScreenEnabled();
}
#method_after
@Override
public boolean getLiveLockScreenEnabled() throws RemoteException {
    return getBrokeredService().getLiveLockScreenEnabled();
}
#end_block

#method_before
@Override
public boolean registerChangeListener(ILiveLockScreenChangeListener listener) throws RemoteException {
    ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
    boolean registered = liveLockScreenManagerProvider.registerChangeListener(listener);
    if (registered) {
        mChangeListeners.register(listener);
    }
    return liveLockScreenManagerProvider.registerChangeListener(listener);
}
#method_after
@Override
public boolean registerChangeListener(ILiveLockScreenChangeListener listener) throws RemoteException {
    boolean registered = getBrokeredService().registerChangeListener(listener);
    if (registered) {
        mChangeListeners.register(listener);
    }
    return registered;
}
#end_block

#method_before
@Override
public boolean unregisterChangeListener(ILiveLockScreenChangeListener listener) throws RemoteException {
    ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
    boolean unregistered = liveLockScreenManagerProvider.unregisterChangeListener(listener);
    if (unregistered) {
        mChangeListeners.unregister(listener);
    }
    return unregistered;
}
#method_after
@Override
public boolean unregisterChangeListener(ILiveLockScreenChangeListener listener) throws RemoteException {
    boolean unregistered = getBrokeredService().unregisterChangeListener(listener);
    if (unregistered) {
        mChangeListeners.unregister(listener);
    }
    return unregistered;
}
#end_block

#method_before
@Override
protected ComponentName getServiceComponent() {
    PackageManager pm = mContext.getPackageManager();
    Intent intent = new Intent(LiveLockScreenManager.SERVICE_INTERFACE);
    List<ResolveInfo> resolveInfos = pm.queryIntentServices(intent, 0);
    for (ResolveInfo info : resolveInfos) {
        if (info != null) {
            if (pm.checkPermission(Manifest.permission.LIVE_LOCK_SCREEN_MANAGER_PROVIDER, info.serviceInfo.packageName) == PackageManager.PERMISSION_GRANTED && info.serviceInfo.isEnabled()) {
                return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
            }
        }
    }
    return null;
}
#method_after
@Override
protected ComponentName getServiceComponent() {
    PackageManager pm = mContext.getPackageManager();
    Intent intent = new Intent(LiveLockScreenManager.SERVICE_INTERFACE);
    List<ResolveInfo> resolveInfos = pm.queryIntentServices(intent, 0);
    for (ResolveInfo info : resolveInfos) {
        if (info != null) {
            if (info.serviceInfo.isEnabled()) {
                return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) {
        if (DEBUG)
            Slog.d(TAG, "Third party apps ready");
        // Initialize the default LLS component
        String defComponent = CMSettings.Secure.getString(mContext.getContentResolver(), CMSettings.Secure.DEFAULT_LIVE_LOCK_SCREEN_COMPONENT);
        if (!TextUtils.isEmpty(defComponent)) {
            mDefaultLlsInfo = new LiveLockScreenInfo.Builder().setComponent(ComponentName.unflattenFromString(defComponent)).build();
        }
        // Now that 3rd party apps are ready, try connecting to the backing service
        setBrokeredServiceConnection(mServiceConnection);
        tryConnecting();
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) {
        if (DEBUG)
            Slog.d(TAG, "Third party apps ready");
        // Initialize the default LLS component
        String defComponent = CMSettings.Secure.getString(mContext.getContentResolver(), CMSettings.Secure.DEFAULT_LIVE_LOCK_SCREEN_COMPONENT);
        if (!TextUtils.isEmpty(defComponent)) {
            mDefaultLlsInfo = new LiveLockScreenInfo.Builder().setComponent(ComponentName.unflattenFromString(defComponent)).build();
        }
    }
    super.onBootPhase(phase);
}
#end_block

#method_before
private void setDefaultLiveLockScreenInternal(LiveLockScreenInfo llsInfo) {
    if (llsInfo != null && llsInfo.component != null) {
        // Check that the package this component belongs to has the third party keyguard perm
        final PackageManager pm = mContext.getPackageManager();
        final boolean hasThirdPartyKeyguardPermission = pm.checkPermission(Manifest.permission.THIRD_PARTY_KEYGUARD, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED || pm.checkPermission(DEPRECATED_THIRD_PARTY_KEYGUARD_PERMISSION, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED;
        if (!hasThirdPartyKeyguardPermission) {
            Slog.e(TAG, "Package " + llsInfo.component.getPackageName() + " does not have " + Manifest.permission.THIRD_PARTY_KEYGUARD);
            return;
        }
    }
    long token = Binder.clearCallingIdentity();
    try {
        CMSettings.Secure.putString(mContext.getContentResolver(), CMSettings.Secure.DEFAULT_LIVE_LOCK_SCREEN_COMPONENT, (llsInfo != null && llsInfo.component != null) ? llsInfo.component.flattenToString() : "");
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mDefaultLlsInfo = llsInfo;
    try {
        ILiveLockScreenManagerProvider liveLockScreenManagerProvider = getImplementingServiceGuarded();
        liveLockScreenManagerProvider.updateDefaultLiveLockScreen(llsInfo);
    } catch (RemoteException e) {
    /* ignore */
    }
}
#method_after
private void setDefaultLiveLockScreenInternal(LiveLockScreenInfo llsInfo) {
    if (llsInfo != null && llsInfo.component != null) {
        // Check that the package this component belongs to has the third party keyguard perm
        final PackageManager pm = mContext.getPackageManager();
        final boolean hasThirdPartyKeyguardPermission = pm.checkPermission(Manifest.permission.THIRD_PARTY_KEYGUARD, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED || pm.checkPermission(DEPRECATED_THIRD_PARTY_KEYGUARD_PERMISSION, llsInfo.component.getPackageName()) == PackageManager.PERMISSION_GRANTED;
        if (!hasThirdPartyKeyguardPermission) {
            Slog.e(TAG, "Package " + llsInfo.component.getPackageName() + " does not have " + Manifest.permission.THIRD_PARTY_KEYGUARD);
            return;
        }
    }
    long token = Binder.clearCallingIdentity();
    try {
        CMSettings.Secure.putString(mContext.getContentResolver(), CMSettings.Secure.DEFAULT_LIVE_LOCK_SCREEN_COMPONENT, (llsInfo != null && llsInfo.component != null) ? llsInfo.component.flattenToString() : "");
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    mDefaultLlsInfo = llsInfo;
    try {
        getBrokeredService().updateDefaultLiveLockScreen(llsInfo);
    } catch (RemoteException e) {
    /* ignore */
    }
}
#end_block

#method_before
public void setBrokeredServiceConnection(BrokeredServiceConnection brokeredServiceCn) {
    Slog.e(TAG, "Setting brokered service connection " + brokeredServiceCn.toString());
    mBrokeredServiceConnection = brokeredServiceCn;
}
#method_after
public final void setBrokeredServiceConnection(@NonNull BrokeredServiceConnection brokeredServiceComponent) {
    Preconditions.checkNotNull(brokeredServiceComponent);
    Slog.e(TAG, "Setting brokered service connection " + brokeredServiceComponent.toString());
    mBrokeredServiceConnection = brokeredServiceComponent;
}
#end_block

#method_before
private IInterface getOrConnectService() {
    synchronized (this) {
        if (mImplementingBinderInterface != null) {
            return mImplementingBinderInterface;
        }
        // Service is not connected. Try blocking connecting.
        mConnectionHandler.sendMessage(mConnectionHandler.obtainMessage(MSG_TRY_CONNECTING));
        final long shouldEnd = SystemClock.elapsedRealtime() + SERVICE_CONNECTION_WAIT_TIME_MS;
        long waitTime = SERVICE_CONNECTION_WAIT_TIME_MS;
        while (waitTime > 0) {
            try {
                // TODO: consider using Java concurrent construct instead of raw object wait
                this.wait(waitTime);
            } catch (InterruptedException e) {
                Slog.w(TAG, "Connection wait interrupted", e);
            }
            if (mImplementingBinderInterface != null) {
                // Success
                return mImplementingBinderInterface;
            }
            // Calculate remaining waiting time to make sure we wait the full timeout period
            waitTime = shouldEnd - SystemClock.elapsedRealtime();
        }
        return null;
    }
}
#method_after
private T getOrConnectService() {
    synchronized (this) {
        if (mImplementingBinderInterface != null) {
            return mImplementingBinderInterface;
        }
        // Service is not connected. Try blocking connecting.
        mConnectionHandler.sendMessage(mConnectionHandler.obtainMessage(MSG_TRY_CONNECTING));
        final long shouldEnd = SystemClock.elapsedRealtime() + SERVICE_CONNECTION_WAIT_TIME_MS;
        long waitTime = SERVICE_CONNECTION_WAIT_TIME_MS;
        while (waitTime > 0) {
            try {
                // TODO: consider using Java concurrent construct instead of raw object wait
                this.wait(waitTime);
            } catch (InterruptedException e) {
                Slog.w(TAG, "Connection wait interrupted", e);
            }
            if (mImplementingBinderInterface != null) {
                // Success
                return mImplementingBinderInterface;
            }
            // Calculate remaining waiting time to make sure we wait the full timeout period
            waitTime = shouldEnd - SystemClock.elapsedRealtime();
        }
        return null;
    }
}
#end_block

#method_before
public void tryConnecting() {
    Slog.i(TAG, "Connecting to implementation");
    synchronized (this) {
        if (mImplementingBinderInterface != null) {
            Slog.d(TAG, "Already connected");
            return;
        }
        final Intent intent = new Intent();
        final ComponentName cn = getServiceComponent();
        if (cn == null) {
            Slog.e(TAG, "No implementation service found");
            return;
        }
        intent.setComponent(getServiceComponent());
        try {
            if (!mContext.bindService(intent, mConnection, Context.BIND_AUTO_CREATE)) {
                Slog.e(TAG, "Failed to bind to implementation");
            }
        } catch (SecurityException e) {
            Slog.e(TAG, "Forbidden to bind to implementation", e);
        }
    }
}
#method_after
public final void tryConnecting() {
    Slog.i(TAG, "Connecting to implementation");
    synchronized (this) {
        if (mImplementingBinderInterface != null) {
            Slog.d(TAG, "Already connected");
            return;
        }
        final Intent intent = new Intent();
        final ComponentName cn = getServiceComponent();
        if (cn == null) {
            Slog.e(TAG, "No implementation service found");
            return;
        }
        intent.setComponent(cn);
        try {
            if (mContext.getPackageManager().checkPermission(getComponentFilteringPermission(), cn.getPackageName()) != PackageManager.PERMISSION_GRANTED) {
                Slog.e(TAG, "Target component lacks " + getComponentFilteringPermission() + " service permission, failing " + cn);
                return;
            }
            if (!mContext.bindService(intent, mConnection, Context.BIND_AUTO_CREATE)) {
                Slog.e(TAG, "Failed to bind to implementation " + cn);
            }
        } catch (SecurityException e) {
            Slog.e(TAG, "Forbidden to bind to implementation " + cn, e);
        }
    }
}
#end_block

#method_before
@Override
public void onStart() {
    if (DEBUG)
        Slog.d(TAG, "service started");
    setBrokeredServiceConnection(mServiceConnection);
}
#method_after
@Override
public void onStart() {
    if (DEBUG)
        Slog.d(TAG, "service started");
}
#end_block

#method_before
@Override
protected ICMAudioServiceProvider getIBinderAsIInterface(@NonNull IBinder service) {
    return ICMAudioServiceProvider.Stub.asInterface(service);
}
#method_after
@Override
protected ICMAudioService getIBinderAsIInterface(@NonNull IBinder service) {
    return ICMAudioService.Stub.asInterface(service);
}
#end_block

#method_before
@Override
protected ICMAudioServiceProvider getDefaultImplementation() {
    return mServiceStubForFailure;
}
#method_after
@Override
protected ICMAudioService getDefaultImplementation() {
    return mServiceStubForFailure;
}
#end_block

#method_before
@Override
public List<AudioSessionInfo> listAudioSessions(int streamType) throws RemoteException {
    return getBrokeredService().listAudioSessions(streamType);
}
#method_after
@Override
public List<AudioSessionInfo> listAudioSessions(int streamType) throws RemoteException {
    checkPermission();
    return getBrokeredService().listAudioSessions(streamType);
}
#end_block

#method_before
public boolean isCoreService() {
    return false;
}
#method_after
public boolean isCoreService() {
    return true;
}
#end_block

#method_before
@Override
public void requestThemeChangeUpdates(IThemeChangeListener listener) throws RemoteException {
    getBrokeredService().requestThemeChangeUpdates(listener);
    mChangeListeners.register(listener);
}
#method_after
@Override
public void requestThemeChangeUpdates(IThemeChangeListener listener) throws RemoteException {
    enforcePermission();
    getBrokeredService().requestThemeChangeUpdates(listener);
    mChangeListeners.register(listener);
}
#end_block

#method_before
@Override
public void removeUpdates(IThemeChangeListener listener) throws RemoteException {
    getBrokeredService().removeUpdates(listener);
    mChangeListeners.unregister(listener);
}
#method_after
@Override
public void removeUpdates(IThemeChangeListener listener) throws RemoteException {
    enforcePermission();
    getBrokeredService().removeUpdates(listener);
    mChangeListeners.unregister(listener);
}
#end_block

#method_before
@Override
public void requestThemeChange(ThemeChangeRequest request, boolean removePerAppThemes) throws RemoteException {
    getBrokeredService().requestThemeChange(request, removePerAppThemes);
}
#method_after
@Override
public void requestThemeChange(ThemeChangeRequest request, boolean removePerAppThemes) throws RemoteException {
    enforcePermission();
    getBrokeredService().requestThemeChange(request, removePerAppThemes);
}
#end_block

#method_before
@Override
public void applyDefaultTheme() throws RemoteException {
    getBrokeredService().applyDefaultTheme();
}
#method_after
@Override
public void applyDefaultTheme() throws RemoteException {
    enforcePermission();
    getBrokeredService().applyDefaultTheme();
}
#end_block

#method_before
@Override
public boolean isThemeApplying() throws RemoteException {
    return getBrokeredService().isThemeApplying();
}
#method_after
@Override
public boolean isThemeApplying() throws RemoteException {
    enforcePermission();
    return getBrokeredService().isThemeApplying();
}
#end_block

#method_before
@Override
public int getProgress() throws RemoteException {
    return getBrokeredService().getProgress();
}
#method_after
@Override
public int getProgress() throws RemoteException {
    enforcePermission();
    return getBrokeredService().getProgress();
}
#end_block

#method_before
@Override
public boolean processThemeResources(String themePkgName) throws RemoteException {
    return getBrokeredService().processThemeResources(themePkgName);
}
#method_after
@Override
public boolean processThemeResources(String themePkgName) throws RemoteException {
    enforcePermission();
    return getBrokeredService().processThemeResources(themePkgName);
}
#end_block

#method_before
@Override
public boolean isThemeBeingProcessed(String themePkgName) throws RemoteException {
    return getBrokeredService().isThemeBeingProcessed(themePkgName);
}
#method_after
@Override
public boolean isThemeBeingProcessed(String themePkgName) throws RemoteException {
    enforcePermission();
    return getBrokeredService().isThemeBeingProcessed(themePkgName);
}
#end_block

#method_before
@Override
public void registerThemeProcessingListener(IThemeProcessingListener listener) throws RemoteException {
    getBrokeredService().registerThemeProcessingListener(listener);
    mProcessingListeners.register(listener);
}
#method_after
@Override
public void registerThemeProcessingListener(IThemeProcessingListener listener) throws RemoteException {
    enforcePermission();
    getBrokeredService().registerThemeProcessingListener(listener);
    mProcessingListeners.register(listener);
}
#end_block

#method_before
@Override
public void unregisterThemeProcessingListener(IThemeProcessingListener listener) throws RemoteException {
    getBrokeredService().unregisterThemeProcessingListener(listener);
    mProcessingListeners.unregister(listener);
}
#method_after
@Override
public void unregisterThemeProcessingListener(IThemeProcessingListener listener) throws RemoteException {
    enforcePermission();
    getBrokeredService().unregisterThemeProcessingListener(listener);
    mProcessingListeners.unregister(listener);
}
#end_block

#method_before
@Override
public void rebuildResourceCache() throws RemoteException {
    getBrokeredService().rebuildResourceCache();
}
#method_after
@Override
public void rebuildResourceCache() throws RemoteException {
    enforcePermission();
    getBrokeredService().rebuildResourceCache();
}
#end_block

#method_before
@Override
public long getLastThemeChangeTime() throws RemoteException {
    return getBrokeredService().getLastThemeChangeTime();
}
#method_after
@Override
public long getLastThemeChangeTime() throws RemoteException {
    enforcePermission();
    return getBrokeredService().getLastThemeChangeTime();
}
#end_block

#method_before
@Override
public int getLastThemeChangeRequestType() throws RemoteException {
    return getBrokeredService().getLastThemeChangeRequestType();
}
#method_after
@Override
public int getLastThemeChangeRequestType() throws RemoteException {
    enforcePermission();
    return getBrokeredService().getLastThemeChangeRequestType();
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_ACTIVITY_MANAGER_READY) {
        tryConnecting();
    }
    super.onBootPhase(phase);
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_SYSTEM_SERVICES_READY) {
        // create the main theme directory for brokered service
        createDirIfNotExists(ThemeUtils.SYSTEM_THEME_PATH);
        if (shouldMigrateFilePermissions()) {
            migrateFilePermissions();
        }
    } else if (phase == PHASE_ACTIVITY_MANAGER_READY) {
        tryConnecting();
    }
    super.onBootPhase(phase);
}
#end_block

#method_before
public static BootDexoptDialog create(Context context, int windowType) {
    final PackageManager pm = context.getPackageManager();
    final int theme;
    if (pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION) || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
        theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
    } else if (pm.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
        theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
    } else {
        // set theme to material light to show a full screen dialog
        theme = com.android.internal.R.style.Theme_Material_Light;
    }
    return new BootDexoptDialog(context, theme, windowType);
}
#method_after
public static BootDexoptDialog create(Context context, int windowType) {
    final PackageManager pm = context.getPackageManager();
    final int theme;
    if (pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION) || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
        theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
    } else if (pm.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
        theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
    } else {
        theme = com.android.internal.R.style.Theme_Material_Light;
    }
    return new BootDexoptDialog(context, theme, windowType);
}
#end_block

#method_before
public void setProgress(final ApplicationInfo info, final int current, final int total) {
    // if we initialized with an invalid total, get it from the valid dexopt messages
    if (mTotal != total && total > 0) {
        mTotal = total;
        mBootDexoptProgress.setMax(mTotal);
        mBootDexoptProgress.setSecondaryProgress(mTotal);
    }
    final String msg;
    boolean isApk = false;
    if (info == null) {
        if (current == STAGE_STARTING_APPS) {
            msg = mResources.getString(com.android.internal.R.string.android_upgrading_starting_apps);
        } else if (current == STAGE_FSTRIM) {
            msg = mResources.getString(com.android.internal.R.string.android_upgrading_fstrim);
        } else if (current == STAGE_COMPLETE) {
            msg = mResources.getString(com.android.internal.R.string.android_upgrading_complete);
        } else {
            msg = "";
        }
    } else if (current == STAGE_PREPARING_APPS) {
        final CharSequence label = info.loadLabel(mPackageManager);
        msg = mResources.getString(com.android.internal.R.string.android_preparing_apk, label);
    } else {
        isApk = true;
        msg = mResources.getString(com.android.internal.R.string.android_upgrading_apk, current, total);
        mBootDexoptProgress.setProgress(current);
    }
    // check if the state has changed
    if (mWasApk != isApk) {
        mWasApk = isApk;
        if (isApk) {
            mBootDexoptProgress.setVisibility(View.VISIBLE);
            if (mUseFancyEffects) {
                mBootDexoptMsgDetail.setVisibility(View.VISIBLE);
            }
        } else {
            mBootDexoptProgress.setVisibility(View.INVISIBLE);
            if (mUseFancyEffects) {
                mBootDexoptMsgDetail.setVisibility(View.GONE);
            }
        }
    }
    // if we are processing an apk, load its icon and set the message details
    if (mUseFancyEffects) {
        if (isApk) {
            mBootDexoptIcon.setImageDrawable(info.loadIcon(mPackageManager));
            mBootDexoptMsgDetail.setText(String.format("%s", info.loadLabel(mPackageManager)));
        } else {
            mBootDexoptIcon.setImageDrawable(null);
        }
    }
    mBootDexoptMsg.setText(msg);
}
#method_after
public void setProgress(final int stage, final ApplicationInfo optimizedApp, final int currentAppPos, final int totalAppCount) {
    if (totalAppCount > 0) {
        mProgress.setMax(totalAppCount);
    }
    final Resources res = getContext().getResources();
    final PackageManager pm = getContext().getPackageManager();
    if (optimizedApp != null) {
        if (mHideAppDetails) {
            mMessage.setText(res.getString(R.string.android_preparing_apk_obscured));
            mAppIcon.setImageResource(R.drawable.ic_dexopt_obscured);
        } else {
            final CharSequence label = optimizedApp.loadLabel(pm);
            mMessage.setText(res.getString(R.string.android_preparing_apk, label));
            mAppIcon.setImageDrawable(optimizedApp.loadIcon(pm));
        }
        mDetailMsg.setText(res.getString(R.string.android_upgrading_apk, currentAppPos, totalAppCount));
        mProgress.setProgress(currentAppPos);
        mProgress.setVisibility(View.VISIBLE);
    } else {
        mMessage.setText(res.getString(R.string.android_upgrading_complete));
        mAppIcon.setImageResource(R.drawable.ic_dexopt_starting);
        mProgress.setVisibility(View.INVISIBLE);
        if (stage == IActivityManager.BOOT_STAGE_STARTING_APPS) {
            mDetailMsg.setText(res.getString(R.string.android_upgrading_starting_apps));
        } else if (stage == IActivityManager.BOOT_STAGE_FSTRIM) {
            mDetailMsg.setText(res.getString(R.string.android_upgrading_fstrim));
        } else if (stage == IActivityManager.BOOT_STAGE_COMPLETE) {
            mDetailMsg.setText(res.getString(R.string.android_upgrading_complete_details));
        } else {
            mDetailMsg.setText(null);
        }
    }
}
#end_block

#method_before
@Override
public void onAttached() {
    super.onAttached();
    connectCatalog();
}
#method_after
@Override
public void onAttached() {
    super.onAttached();
    getContext().registerReceiver(mPartChangedReceiver, new IntentFilter(ACTION_PART_CHANGED));
}
#end_block

#method_before
@Override
public void onDetached() {
    super.onDetached();
    disconnectCatalog();
}
#method_after
@Override
public void onDetached() {
    super.onDetached();
    getContext().unregisterReceiver(mPartChangedReceiver);
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("PartInfo=[ name=%s title=%s summary=%s ]", mName, mTitle, mSummary);
}
#method_after
@Override
public String toString() {
    return String.format("PartInfo=[ name=%s title=%s summary=%s fragment=%s ]", mName, mTitle, mSummary, mFragmentClass);
}
#end_block

#method_before
private void updateProvider(ThemeChangeRequest request, long updateTime) {
    ContentValues values = new ContentValues();
    values.put(MixnMatchColumns.COL_UPDATE_TIME, updateTime);
    Map<String, String> componentMap = request.getThemeComponentsMap();
    for (String component : componentMap.keySet()) {
        values.put(MixnMatchColumns.COL_VALUE, componentMap.get(component));
        String where = MixnMatchColumns.COL_KEY + "=?";
        String[] selectionArgs = { MixnMatchColumns.componentToMixNMatchKey(component) };
        if (selectionArgs[0] == null) {
            // No equivalence between mixnmatch and theme
            continue;
        }
        // Add component ID for multiwallpaper
        if (ThemesColumns.MODIFIES_LAUNCHER.equals(component)) {
            values.put(MixnMatchColumns.COL_COMPONENT_ID, request.getWallpaperId());
        } else {
            values.put(MixnMatchColumns.COL_COMPONENT_ID, CONSTANT_MIXNMATCH);
        }
        mContext.getContentResolver().update(MixnMatchColumns.CONTENT_URI, values, where, selectionArgs);
    }
}
#method_after
private void updateProvider(ThemeChangeRequest request, long updateTime) {
    ContentValues values = new ContentValues();
    values.put(MixnMatchColumns.COL_UPDATE_TIME, updateTime);
    Map<String, String> componentMap = request.getThemeComponentsMap();
    for (String component : componentMap.keySet()) {
        values.put(MixnMatchColumns.COL_VALUE, componentMap.get(component));
        String where = MixnMatchColumns.COL_KEY + "=?";
        String[] selectionArgs = { MixnMatchColumns.componentToMixNMatchKey(component) };
        if (selectionArgs[0] == null) {
            // No equivalence between mixnmatch and theme
            continue;
        }
        // Add component ID for multiwallpaper
        if (ThemesColumns.MODIFIES_LAUNCHER.equals(component)) {
            values.put(MixnMatchColumns.COL_COMPONENT_ID, request.getWallpaperId());
        } else {
            values.put(MixnMatchColumns.COL_COMPONENT_ID, DEFAULT_COMPONENT_ID);
        }
        mContext.getContentResolver().update(MixnMatchColumns.CONTENT_URI, values, where, selectionArgs);
    }
}
#end_block

#method_before
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    if (DBG) {
        log("onPreferenceChange(). preferenece: \"" + preference + "\"" + ", value: \"" + objValue + "\"");
    }
    if (preference == mVibrateWhenRinging) {
        boolean doVibrate = (Boolean) objValue;
        Settings.System.putInt(mPhone.getContext().getContentResolver(), Settings.System.VIBRATE_WHEN_RINGING, doVibrate ? 1 : 0);
    } else if (preference == mButtonDTMF) {
        int index = mButtonDTMF.findIndexOfValue((String) objValue);
        Settings.System.putInt(mPhone.getContext().getContentResolver(), Settings.System.DTMF_TONE_TYPE_WHEN_DIALING, index);
    } else if (preference == mButtonTTY) {
        handleTTYChange(preference, objValue);
    } else if (preference == mVoicemailProviders) {
        final String newProviderKey = (String) objValue;
        if (DBG) {
            log("Voicemail Provider changes from \"" + mPreviousVMProviderKey + "\" to \"" + newProviderKey + "\".");
        }
        // If previous provider key and the new one is same, we don't need to handle it.
        if (mPreviousVMProviderKey.equals(newProviderKey)) {
            if (DBG)
                log("No change is made toward VM provider setting.");
            return true;
        }
        updateVMPreferenceWidgets(newProviderKey);
        final VoiceMailProviderSettings newProviderSettings = loadSettingsForVoiceMailProvider(newProviderKey);
        if (newProviderSettings == null) {
            // Force the user into a configuration of the chosen provider
            Log.w(LOG_TAG, "Saved preferences not found - invoking config");
            mVMProviderSettingsForced = true;
            simulatePreferenceClick(mVoicemailSettings);
        } else {
            if (DBG)
                log("Saved preferences found - switching to them");
            // Set this flag so if we get a failure we revert to previous provider
            mChangingVMorFwdDueToProviderChange = true;
            saveVoiceMailAndForwardingNumber(newProviderKey, newProviderSettings);
        }
    } else if (preference == mButtonSipCallOptions) {
        handleSipCallOptionsChange(objValue);
    } else if (preference == mEnableForwardLookup || preference == mEnablePeopleLookup || preference == mEnableReverseLookup) {
        saveLookupProviderSwitch(preference, (Boolean) objValue);
    } else if (preference == mChooseForwardLookupProvider || preference == mChoosePeopleLookupProvider || preference == mChooseReverseLookupProvider) {
        saveLookupProviderSetting(preference, (String) objValue);
    }
    // always let the preference setting proceed.
    return true;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    if (DBG) {
        log("onPreferenceChange(). preferenece: \"" + preference + "\"" + ", value: \"" + objValue + "\"");
    }
    if (preference == mVibrateWhenRinging) {
        boolean doVibrate = (Boolean) objValue;
        Settings.System.putInt(mPhone.getContext().getContentResolver(), Settings.System.VIBRATE_WHEN_RINGING, doVibrate ? 1 : 0);
    } else if (preference == mButtonDTMF) {
        int index = mButtonDTMF.findIndexOfValue((String) objValue);
        Settings.System.putInt(mPhone.getContext().getContentResolver(), Settings.System.DTMF_TONE_TYPE_WHEN_DIALING, index);
    } else if (preference == mButtonTTY) {
        handleTTYChange(preference, objValue);
    } else if (preference == mVoicemailProviders) {
        final String newProviderKey = (String) objValue;
        if (DBG) {
            log("Voicemail Provider changes from \"" + mPreviousVMProviderKey + "\" to \"" + newProviderKey + "\".");
        }
        // If previous provider key and the new one is same, we don't need to handle it.
        if (mPreviousVMProviderKey.equals(newProviderKey)) {
            if (DBG)
                log("No change is made toward VM provider setting.");
            return true;
        }
        updateVMPreferenceWidgets(newProviderKey);
        final VoiceMailProviderSettings newProviderSettings = loadSettingsForVoiceMailProvider(newProviderKey);
        if (newProviderSettings == null) {
            // Force the user into a configuration of the chosen provider
            Log.w(LOG_TAG, "Saved preferences not found - invoking config");
            mVMProviderSettingsForced = true;
            simulatePreferenceClick(mVoicemailSettings);
        } else {
            if (DBG)
                log("Saved preferences found - switching to them");
            // Set this flag so if we get a failure we revert to previous provider
            mChangingVMorFwdDueToProviderChange = true;
            saveVoiceMailAndForwardingNumber(newProviderKey, newProviderSettings);
        }
    } else if (preference == mButtonSipCallOptions) {
        handleSipCallOptionsChange(objValue);
    } else if (preference == mEnableForwardLookup || preference == mEnablePeopleLookup || preference == mEnableReverseLookup) {
        saveLookupProviderSwitch(preference, (Boolean) objValue);
    } else if (preference == mChooseForwardLookupProvider || preference == mChoosePeopleLookupProvider || preference == mChooseReverseLookupProvider) {
        saveLookupProviderSetting(preference, (String) objValue);
    } else if (preference == mT9SearchInputLocale) {
        saveT9SearchInputLocale(preference, (String) objValue);
    }
    // always let the preference setting proceed.
    return true;
}
#end_block

#method_before
/*
     * Activity class methods
     */
@Override
protected void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    if (DBG)
        log("onCreate(). Intent: " + getIntent());
    mPhone = PhoneGlobals.getPhone();
    addPreferencesFromResource(R.xml.call_feature_setting);
    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    // get buttons
    PreferenceScreen prefSet = getPreferenceScreen();
    mSubMenuVoicemailSettings = (EditPhoneNumberPreference) findPreference(BUTTON_VOICEMAIL_KEY);
    if (mSubMenuVoicemailSettings != null) {
        mSubMenuVoicemailSettings.setParentActivity(this, VOICEMAIL_PREF_ID, this);
        mSubMenuVoicemailSettings.setDialogOnClosedListener(this);
        mSubMenuVoicemailSettings.setDialogTitle(R.string.voicemail_settings_number_label);
    }
    mRingtonePreference = findPreference(BUTTON_RINGTONE_KEY);
    mVibrateWhenRinging = (CheckBoxPreference) findPreference(BUTTON_VIBRATE_ON_RING);
    mPlayDtmfTone = (CheckBoxPreference) findPreference(BUTTON_PLAY_DTMF_TONE);
    mMwiNotification = (CheckBoxPreference) findPreference(BUTTON_MWI_NOTIFICATION_KEY);
    if (mMwiNotification != null) {
        if (getResources().getBoolean(R.bool.sprint_mwi_quirk)) {
            mMwiNotification.setOnPreferenceChangeListener(this);
        } else {
            PreferenceScreen voicemailCategory = (PreferenceScreen) findPreference(BUTTON_VOICEMAIL_CATEGORY_KEY);
            voicemailCategory.removePreference(mMwiNotification);
            mMwiNotification = null;
        }
    }
    mButtonDTMF = (ListPreference) findPreference(BUTTON_DTMF_KEY);
    mButtonAutoRetry = (CheckBoxPreference) findPreference(BUTTON_RETRY_KEY);
    mButtonHAC = (CheckBoxPreference) findPreference(BUTTON_HAC_KEY);
    mButtonTTY = (ListPreference) findPreference(BUTTON_TTY_KEY);
    mButtonNoiseSuppression = (CheckBoxPreference) findPreference(BUTTON_NOISE_SUPPRESSION_KEY);
    mVoicemailProviders = (ListPreference) findPreference(BUTTON_VOICEMAIL_PROVIDER_KEY);
    mButtonBlacklist = (PreferenceScreen) findPreference(BUTTON_BLACKLIST);
    if (mVoicemailProviders != null) {
        mVoicemailProviders.setOnPreferenceChangeListener(this);
        mVoicemailSettings = (PreferenceScreen) findPreference(BUTTON_VOICEMAIL_SETTING_KEY);
        mVoicemailNotificationRingtone = findPreference(BUTTON_VOICEMAIL_NOTIFICATION_RINGTONE_KEY);
        mVoicemailNotificationVibrate = (CheckBoxPreference) findPreference(BUTTON_VOICEMAIL_NOTIFICATION_VIBRATE_KEY);
        initVoiceMailProviders();
    }
    if (mVibrateWhenRinging != null) {
        Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        if (vibrator != null && vibrator.hasVibrator()) {
            mVibrateWhenRinging.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mVibrateWhenRinging);
            mVibrateWhenRinging = null;
        }
    }
    final ContentResolver contentResolver = getContentResolver();
    if (mPlayDtmfTone != null) {
        mPlayDtmfTone.setChecked(Settings.System.getInt(contentResolver, Settings.System.DTMF_TONE_WHEN_DIALING, 1) != 0);
    }
    if (mButtonDTMF != null) {
        if (getResources().getBoolean(R.bool.dtmf_type_enabled)) {
            mButtonDTMF.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonDTMF);
            mButtonDTMF = null;
        }
    }
    if (mButtonAutoRetry != null) {
        if (getResources().getBoolean(R.bool.auto_retry_enabled)) {
            mButtonAutoRetry.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonAutoRetry);
            mButtonAutoRetry = null;
        }
    }
    if (mButtonHAC != null) {
        if (getResources().getBoolean(R.bool.hac_enabled)) {
            mButtonHAC.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonHAC);
            mButtonHAC = null;
        }
    }
    if (mButtonTTY != null) {
        if (getResources().getBoolean(R.bool.tty_enabled)) {
            mButtonTTY.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonTTY);
            mButtonTTY = null;
        }
    }
    if (mButtonNoiseSuppression != null) {
        if (getResources().getBoolean(R.bool.has_in_call_noise_suppression)) {
            mButtonNoiseSuppression.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonNoiseSuppression);
            mButtonNoiseSuppression = null;
        }
    }
    if (!getResources().getBoolean(R.bool.world_phone)) {
        Preference options = prefSet.findPreference(BUTTON_CDMA_OPTIONS);
        if (options != null)
            prefSet.removePreference(options);
        options = prefSet.findPreference(BUTTON_GSM_UMTS_OPTIONS);
        if (options != null)
            prefSet.removePreference(options);
        int phoneType = mPhone.getPhoneType();
        if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
            Preference fdnButton = prefSet.findPreference(BUTTON_FDN_KEY);
            if (fdnButton != null)
                prefSet.removePreference(fdnButton);
            if (!getResources().getBoolean(R.bool.config_voice_privacy_disable)) {
                addPreferencesFromResource(R.xml.cdma_call_privacy);
            }
        } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
            addPreferencesFromResource(R.xml.gsm_umts_call_options);
        } else {
            throw new IllegalStateException("Unexpected phone type: " + phoneType);
        }
    }
    mEnableForwardLookup = (CheckBoxPreference) findPreference(SWITCH_ENABLE_FORWARD_LOOKUP);
    mEnablePeopleLookup = (CheckBoxPreference) findPreference(SWITCH_ENABLE_PEOPLE_LOOKUP);
    mEnableReverseLookup = (CheckBoxPreference) findPreference(SWITCH_ENABLE_REVERSE_LOOKUP);
    mEnableForwardLookup.setOnPreferenceChangeListener(this);
    mEnablePeopleLookup.setOnPreferenceChangeListener(this);
    mEnableReverseLookup.setOnPreferenceChangeListener(this);
    restoreLookupProviderSwitches();
    mChooseForwardLookupProvider = (ListPreference) findPreference(BUTTON_CHOOSE_FORWARD_LOOKUP_PROVIDER);
    mChoosePeopleLookupProvider = (ListPreference) findPreference(BUTTON_CHOOSE_PEOPLE_LOOKUP_PROVIDER);
    mChooseReverseLookupProvider = (ListPreference) findPreference(BUTTON_CHOOSE_REVERSE_LOOKUP_PROVIDER);
    mChooseForwardLookupProvider.setOnPreferenceChangeListener(this);
    mChoosePeopleLookupProvider.setOnPreferenceChangeListener(this);
    mChooseReverseLookupProvider.setOnPreferenceChangeListener(this);
    String[] reverseLookupNames = getResources().getStringArray(R.array.reverse_lookup_provider_names);
    String[] reverseLookupProviders = getResources().getStringArray(R.array.reverse_lookup_providers);
    String cyngnProviderPackage = getString(R.string.cyngn_reverse_lookup_provider_package);
    if (PhoneUtils.isPackageInstalled(this, cyngnProviderPackage)) {
        reverseLookupNames = Arrays.copyOf(reverseLookupNames, reverseLookupNames.length + 1);
        reverseLookupProviders = Arrays.copyOf(reverseLookupProviders, reverseLookupProviders.length + 1);
        reverseLookupNames[reverseLookupNames.length - 1] = getString(R.string.cyngn_reverse_lookup_provider_name);
        reverseLookupProviders[reverseLookupProviders.length - 1] = getString(R.string.cyngn_reverse_lookup_provider_value);
    }
    mChooseReverseLookupProvider.setEntries(reverseLookupNames);
    mChooseReverseLookupProvider.setEntryValues(reverseLookupProviders);
    restoreLookupProviders();
    // create intent to bring up contact list
    mContactListIntent = new Intent(Intent.ACTION_GET_CONTENT);
    mContactListIntent.setType(android.provider.Contacts.Phones.CONTENT_ITEM_TYPE);
    // We only bring up the dialog the first time we are called (not after orientation change)
    if (icicle == null) {
        if (getIntent().getAction().equals(ACTION_ADD_VOICEMAIL) && mVoicemailProviders != null) {
            if (DBG) {
                log("ACTION_ADD_VOICEMAIL Intent is thrown. current VM data size: " + mVMProvidersData.size());
            }
            if (mVMProvidersData.size() > 1) {
                simulatePreferenceClick(mVoicemailProviders);
            } else {
                onPreferenceChange(mVoicemailProviders, DEFAULT_VM_PROVIDER_KEY);
                mVoicemailProviders.setValue(DEFAULT_VM_PROVIDER_KEY);
            }
        }
    }
    updateVoiceNumberField();
    mVMProviderSettingsForced = false;
    createSipCallSettings();
    createImsSettings();
    mRingtoneLookupRunnable = new Runnable() {

        @Override
        public void run() {
            if (mRingtonePreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_RINGTONE, mRingtonePreference, MSG_UPDATE_RINGTONE_SUMMARY);
            }
            if (mVoicemailNotificationRingtone != null) {
                updateRingtoneName(RingtoneManager.TYPE_NOTIFICATION, mVoicemailNotificationRingtone, MSG_UPDATE_VOICEMAIL_RINGTONE_SUMMARY);
            }
        }
    };
    ActionBar actionBar = getActionBar();
    if (actionBar != null) {
        // android.R.id.home will be triggered in onOptionsItemSelected()
        actionBar.setDisplayShowHomeEnabled(true);
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setDisplayShowTitleEnabled(true);
    }
}
#method_after
/*
     * Activity class methods
     */
@Override
protected void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    if (DBG)
        log("onCreate(). Intent: " + getIntent());
    mPhone = PhoneGlobals.getPhone();
    addPreferencesFromResource(R.xml.call_feature_setting);
    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    // get buttons
    PreferenceScreen prefSet = getPreferenceScreen();
    mSubMenuVoicemailSettings = (EditPhoneNumberPreference) findPreference(BUTTON_VOICEMAIL_KEY);
    if (mSubMenuVoicemailSettings != null) {
        mSubMenuVoicemailSettings.setParentActivity(this, VOICEMAIL_PREF_ID, this);
        mSubMenuVoicemailSettings.setDialogOnClosedListener(this);
        mSubMenuVoicemailSettings.setDialogTitle(R.string.voicemail_settings_number_label);
    }
    mRingtonePreference = findPreference(BUTTON_RINGTONE_KEY);
    mVibrateWhenRinging = (CheckBoxPreference) findPreference(BUTTON_VIBRATE_ON_RING);
    mPlayDtmfTone = (CheckBoxPreference) findPreference(BUTTON_PLAY_DTMF_TONE);
    mMwiNotification = (CheckBoxPreference) findPreference(BUTTON_MWI_NOTIFICATION_KEY);
    if (mMwiNotification != null) {
        if (getResources().getBoolean(R.bool.sprint_mwi_quirk)) {
            mMwiNotification.setOnPreferenceChangeListener(this);
        } else {
            PreferenceScreen voicemailCategory = (PreferenceScreen) findPreference(BUTTON_VOICEMAIL_CATEGORY_KEY);
            voicemailCategory.removePreference(mMwiNotification);
            mMwiNotification = null;
        }
    }
    mButtonDTMF = (ListPreference) findPreference(BUTTON_DTMF_KEY);
    mButtonAutoRetry = (CheckBoxPreference) findPreference(BUTTON_RETRY_KEY);
    mButtonHAC = (CheckBoxPreference) findPreference(BUTTON_HAC_KEY);
    mButtonTTY = (ListPreference) findPreference(BUTTON_TTY_KEY);
    mButtonNoiseSuppression = (CheckBoxPreference) findPreference(BUTTON_NOISE_SUPPRESSION_KEY);
    mVoicemailProviders = (ListPreference) findPreference(BUTTON_VOICEMAIL_PROVIDER_KEY);
    mButtonBlacklist = (PreferenceScreen) findPreference(BUTTON_BLACKLIST);
    mT9SearchInputLocale = (ListPreference) findPreference(BUTTON_T9_SEARCH_INPUT_LOCALE);
    if (mVoicemailProviders != null) {
        mVoicemailProviders.setOnPreferenceChangeListener(this);
        mVoicemailSettings = (PreferenceScreen) findPreference(BUTTON_VOICEMAIL_SETTING_KEY);
        mVoicemailNotificationRingtone = findPreference(BUTTON_VOICEMAIL_NOTIFICATION_RINGTONE_KEY);
        mVoicemailNotificationVibrate = (CheckBoxPreference) findPreference(BUTTON_VOICEMAIL_NOTIFICATION_VIBRATE_KEY);
        initVoiceMailProviders();
    }
    if (mT9SearchInputLocale != null) {
        initT9SearchInputPreferenceList();
    }
    if (mVibrateWhenRinging != null) {
        Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        if (vibrator != null && vibrator.hasVibrator()) {
            mVibrateWhenRinging.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mVibrateWhenRinging);
            mVibrateWhenRinging = null;
        }
    }
    final ContentResolver contentResolver = getContentResolver();
    if (mPlayDtmfTone != null) {
        mPlayDtmfTone.setChecked(Settings.System.getInt(contentResolver, Settings.System.DTMF_TONE_WHEN_DIALING, 1) != 0);
    }
    if (mButtonDTMF != null) {
        if (getResources().getBoolean(R.bool.dtmf_type_enabled)) {
            mButtonDTMF.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonDTMF);
            mButtonDTMF = null;
        }
    }
    if (mButtonAutoRetry != null) {
        if (getResources().getBoolean(R.bool.auto_retry_enabled)) {
            mButtonAutoRetry.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonAutoRetry);
            mButtonAutoRetry = null;
        }
    }
    if (mButtonHAC != null) {
        if (getResources().getBoolean(R.bool.hac_enabled)) {
            mButtonHAC.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonHAC);
            mButtonHAC = null;
        }
    }
    if (mButtonTTY != null) {
        if (getResources().getBoolean(R.bool.tty_enabled)) {
            mButtonTTY.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonTTY);
            mButtonTTY = null;
        }
    }
    if (mButtonNoiseSuppression != null) {
        if (getResources().getBoolean(R.bool.has_in_call_noise_suppression)) {
            mButtonNoiseSuppression.setOnPreferenceChangeListener(this);
        } else {
            prefSet.removePreference(mButtonNoiseSuppression);
            mButtonNoiseSuppression = null;
        }
    }
    if (mT9SearchInputLocale != null) {
        // should this be enabled/disabled based on a flag?
        mT9SearchInputLocale.setOnPreferenceChangeListener(this);
    }
    if (!getResources().getBoolean(R.bool.world_phone)) {
        Preference options = prefSet.findPreference(BUTTON_CDMA_OPTIONS);
        if (options != null)
            prefSet.removePreference(options);
        options = prefSet.findPreference(BUTTON_GSM_UMTS_OPTIONS);
        if (options != null)
            prefSet.removePreference(options);
        int phoneType = mPhone.getPhoneType();
        if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
            Preference fdnButton = prefSet.findPreference(BUTTON_FDN_KEY);
            if (fdnButton != null)
                prefSet.removePreference(fdnButton);
            if (!getResources().getBoolean(R.bool.config_voice_privacy_disable)) {
                addPreferencesFromResource(R.xml.cdma_call_privacy);
            }
        } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
            addPreferencesFromResource(R.xml.gsm_umts_call_options);
        } else {
            throw new IllegalStateException("Unexpected phone type: " + phoneType);
        }
    }
    mEnableForwardLookup = (CheckBoxPreference) findPreference(SWITCH_ENABLE_FORWARD_LOOKUP);
    mEnablePeopleLookup = (CheckBoxPreference) findPreference(SWITCH_ENABLE_PEOPLE_LOOKUP);
    mEnableReverseLookup = (CheckBoxPreference) findPreference(SWITCH_ENABLE_REVERSE_LOOKUP);
    mEnableForwardLookup.setOnPreferenceChangeListener(this);
    mEnablePeopleLookup.setOnPreferenceChangeListener(this);
    mEnableReverseLookup.setOnPreferenceChangeListener(this);
    restoreLookupProviderSwitches();
    mChooseForwardLookupProvider = (ListPreference) findPreference(BUTTON_CHOOSE_FORWARD_LOOKUP_PROVIDER);
    mChoosePeopleLookupProvider = (ListPreference) findPreference(BUTTON_CHOOSE_PEOPLE_LOOKUP_PROVIDER);
    mChooseReverseLookupProvider = (ListPreference) findPreference(BUTTON_CHOOSE_REVERSE_LOOKUP_PROVIDER);
    mChooseForwardLookupProvider.setOnPreferenceChangeListener(this);
    mChoosePeopleLookupProvider.setOnPreferenceChangeListener(this);
    mChooseReverseLookupProvider.setOnPreferenceChangeListener(this);
    String[] reverseLookupNames = getResources().getStringArray(R.array.reverse_lookup_provider_names);
    String[] reverseLookupProviders = getResources().getStringArray(R.array.reverse_lookup_providers);
    String cyngnProviderPackage = getString(R.string.cyngn_reverse_lookup_provider_package);
    if (PhoneUtils.isPackageInstalled(this, cyngnProviderPackage)) {
        reverseLookupNames = Arrays.copyOf(reverseLookupNames, reverseLookupNames.length + 1);
        reverseLookupProviders = Arrays.copyOf(reverseLookupProviders, reverseLookupProviders.length + 1);
        reverseLookupNames[reverseLookupNames.length - 1] = getString(R.string.cyngn_reverse_lookup_provider_name);
        reverseLookupProviders[reverseLookupProviders.length - 1] = getString(R.string.cyngn_reverse_lookup_provider_value);
    }
    mChooseReverseLookupProvider.setEntries(reverseLookupNames);
    mChooseReverseLookupProvider.setEntryValues(reverseLookupProviders);
    restoreLookupProviders();
    // create intent to bring up contact list
    mContactListIntent = new Intent(Intent.ACTION_GET_CONTENT);
    mContactListIntent.setType(android.provider.Contacts.Phones.CONTENT_ITEM_TYPE);
    // We only bring up the dialog the first time we are called (not after orientation change)
    if (icicle == null) {
        if (getIntent().getAction().equals(ACTION_ADD_VOICEMAIL) && mVoicemailProviders != null) {
            if (DBG) {
                log("ACTION_ADD_VOICEMAIL Intent is thrown. current VM data size: " + mVMProvidersData.size());
            }
            if (mVMProvidersData.size() > 1) {
                simulatePreferenceClick(mVoicemailProviders);
            } else {
                onPreferenceChange(mVoicemailProviders, DEFAULT_VM_PROVIDER_KEY);
                mVoicemailProviders.setValue(DEFAULT_VM_PROVIDER_KEY);
            }
        }
    }
    updateVoiceNumberField();
    mVMProviderSettingsForced = false;
    createSipCallSettings();
    createImsSettings();
    mRingtoneLookupRunnable = new Runnable() {

        @Override
        public void run() {
            if (mRingtonePreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_RINGTONE, mRingtonePreference, MSG_UPDATE_RINGTONE_SUMMARY);
            }
            if (mVoicemailNotificationRingtone != null) {
                updateRingtoneName(RingtoneManager.TYPE_NOTIFICATION, mVoicemailNotificationRingtone, MSG_UPDATE_VOICEMAIL_RINGTONE_SUMMARY);
            }
        }
    };
    ActionBar actionBar = getActionBar();
    if (actionBar != null) {
        // android.R.id.home will be triggered in onOptionsItemSelected()
        actionBar.setDisplayShowHomeEnabled(true);
        actionBar.setDisplayHomeAsUpEnabled(true);
        actionBar.setDisplayShowTitleEnabled(true);
    }
}
#end_block

#method_before
/**
 * Parcelable implementation
 */
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mCallId);
    dest.writeInt(mState);
    dest.writeString(getDisconnectCause().toString());
    dest.writeInt(getCapabilities());
    dest.writeLong(getConnectTime());
    dest.writeIntArray(Ints.toArray(mChildCallIds));
    dest.writeString(getGatewayNumber());
    dest.writeString(getGatewayPackage());
    dest.writeParcelable(mIdentification, 0);
    dest.writeInt(mForwarded ? 1 : 0);
    dest.writeInt(mHeldRemotely ? 1 : 0);
    int hasSuppServNotification = 0;
    if (mSsNotification != null)
        hasSuppServNotification = 1;
    dest.writeInt(hasSuppServNotification);
    if (hasSuppServNotification == 1) {
        dest.writeInt(mSsNotification.notificationType);
        dest.writeInt(mSsNotification.code);
        dest.writeInt(mSsNotification.index);
        dest.writeInt(mSsNotification.type);
        dest.writeString(mSsNotification.number);
    }
    dest.writeParcelable(mCallDetails, 1);
    dest.writeParcelable(mCallModifyDetails, 2);
    dest.writeInt(mSubscription);
    dest.writeLong(getCreateTime());
}
#method_after
/**
 * Parcelable implementation
 */
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(mCallId);
    dest.writeInt(mState);
    dest.writeString(getDisconnectCause().toString());
    dest.writeInt(getCapabilities());
    dest.writeLong(getCreateTime());
    dest.writeLong(getConnectTime());
    dest.writeIntArray(Ints.toArray(mChildCallIds));
    dest.writeString(getGatewayNumber());
    dest.writeString(getGatewayPackage());
    dest.writeParcelable(mIdentification, 0);
    dest.writeInt(mForwarded ? 1 : 0);
    dest.writeInt(mHeldRemotely ? 1 : 0);
    int hasSuppServNotification = 0;
    if (mSsNotification != null)
        hasSuppServNotification = 1;
    dest.writeInt(hasSuppServNotification);
    if (hasSuppServNotification == 1) {
        dest.writeInt(mSsNotification.notificationType);
        dest.writeInt(mSsNotification.code);
        dest.writeInt(mSsNotification.index);
        dest.writeInt(mSsNotification.type);
        dest.writeString(mSsNotification.number);
    }
    dest.writeParcelable(mCallDetails, 1);
    dest.writeParcelable(mCallModifyDetails, 2);
    dest.writeInt(mSubscription);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle icicle) {
    Intent intent = getIntent();
    if (intent.hasExtra(EXTRA_THEME)) {
        String themeName = intent.getStringExtra(EXTRA_THEME);
        if (themeName != null && !themeName.isEmpty()) {
            int style = getResources().getIdentifier(themeName, "style", getPackageName());
            if (style != 0) {
                setTheme(style);
            }
        }
    } else {
        setTheme(R.style.SettingsLight);
    }
    super.onCreate(icicle);
    if (DBG)
        log("Creating activity");
    setContentView(R.layout.multi_sim_setting);
    TabHost tabHost = getTabHost();
    String pkg = intent.getStringExtra(PACKAGE);
    String targetClass = intent.getStringExtra(TARGET_CLASS);
    int numPhones = TelephonyManager.getDefault().getPhoneCount();
    SubscriptionManager subscriptionManager = SubscriptionManager.from(super.getApplicationContext());
    for (int i = 0; i < numPhones; i++) {
        SubscriptionInfo sir = subscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(i);
        String displayName = ((sir != null)) ? sir.getDisplayName().toString() : tabLabel[i];
        log("Creating SelectSub activity = " + i + " displayName = " + displayName);
        subscriptionPref = tabHost.newTabSpec(Integer.toString(i));
        subscriptionPref.setIndicator(displayName);
        intent = new Intent().setClassName(pkg, targetClass).setAction(intent.getAction());
        if (sir != null) {
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, i, sir.getSubscriptionId());
        } else {
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, i);
        }
        subscriptionPref.setContent(intent);
        tabHost.addTab(subscriptionPref);
    }
}
#method_after
@Override
protected void onCreate(Bundle icicle) {
    Intent intent = getIntent();
    if (intent.hasExtra(EXTRA_THEME)) {
        String themeName = intent.getStringExtra(EXTRA_THEME);
        if (themeName != null && !themeName.isEmpty()) {
            int style = getResources().getIdentifier(themeName, "style", getPackageName());
            if (style != 0) {
                setTheme(style);
            }
        }
    } else {
        setTheme(R.style.SettingsLight);
    }
    super.onCreate(icicle);
    if (DBG)
        log("Creating activity");
    setContentView(R.layout.multi_sim_setting);
    TabHost tabHost = getTabHost();
    String pkg = intent.getStringExtra(PACKAGE);
    String targetClass = intent.getStringExtra(TARGET_CLASS);
    int numPhones = TelephonyManager.getDefault().getPhoneCount();
    SubscriptionManager subscriptionManager = SubscriptionManager.from(super.getApplicationContext());
    for (int i = 0; i < numPhones; i++) {
        SubscriptionInfo sir = subscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(i);
        String displayName = ((sir != null)) ? sir.getDisplayName().toString() : tabLabel[i];
        log("Creating SelectSub activity = " + i + " displayName = " + displayName);
        subscriptionPref = tabHost.newTabSpec(Integer.toString(i));
        subscriptionPref.setIndicator(displayName);
        intent = new Intent().setClassName(pkg, targetClass).setAction(intent.getAction());
        SubscriptionManager.putPhoneIdAndSubIdExtra(intent, i, sir != null ? sir.getSubscriptionId() : -1);
        subscriptionPref.setContent(intent);
        tabHost.addTab(subscriptionPref);
    }
}
#end_block

#method_before
void updateMwi(int subId, boolean visible, boolean enableNotificationSound) {
    if (!PhoneGlobals.sVoiceCapable) {
        // Do not show the message waiting indicator on devices which are not voice capable.
        // These events *should* be blocked at the telephony layer for such devices.
        Log.w(LOG_TAG, "Called updateMwi() on non-voice-capable device! Ignoring...");
        return;
    }
    int[] mwiIcon = { R.drawable.stat_notify_voicemail_sub1, R.drawable.stat_notify_voicemail_sub2 };
    Phone phone = PhoneGlobals.getPhone(subId);
    int phoneId = phone.getPhoneId();
    int notificationId = getNotificationId(VOICEMAIL_NOTIFICATION, phoneId);
    if (visible && phone != null) {
        VoicemailStatusQueryHelper queryHelper = new VoicemailStatusQueryHelper(mContext);
        PhoneAccountHandle phoneAccount = PhoneUtils.makePstnPhoneAccountHandle(phone);
        if (queryHelper.isNotificationsChannelActive(phoneAccount)) {
            Log.v(LOG_TAG, "Notifications channel active for visual voicemail, hiding mwi.");
            visible = false;
        }
    }
    boolean notifProp = mApp.getResources().getBoolean(R.bool.sprint_mwi_quirk);
    boolean notifOption = Settings.System.getInt(mApp.getContentResolver(), Settings.System.ENABLE_MWI_NOTIFICATION, 0) == 1;
    if (notifProp && !notifOption) {
        // sprint_mwi_quirk is true, and ENABLE_MWI_NOTIFICATION is unchecked or unset (false)
        // hide the mwi, but log if we're debugging.
        visible = false;
        if (DBG)
            log("updateMwi(): mwi_notification is disabled. Ignoring...");
        return;
    }
    Log.i(LOG_TAG, "updateMwi(): subId " + subId + " update to " + visible);
    mMwiVisible.put(subId, visible);
    if (visible) {
        if (phone == null) {
            Log.w(LOG_TAG, "Found null phone for: " + subId);
            return;
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        if (subInfo == null) {
            Log.w(LOG_TAG, "Found null subscription info for: " + subId);
            return;
        }
        int resId = android.R.drawable.stat_notify_voicemail;
        if (mTelephonyManager.getPhoneCount() > 1) {
            resId = mwiIcon[phoneId];
        }
        // This Notification can get a lot fancier once we have more
        // information about the current voicemail messages.
        // (For example, the current voicemail system can't tell
        // us the caller-id or timestamp of a message, or tell us the
        // message count.)
        // But for now, the UI is ultra-simple: if the MWI indication
        // is supposed to be visible, just show a single generic
        // notification.
        String notificationTitle = mContext.getString(R.string.notification_voicemail_title);
        String vmNumber = phone.getVoiceMailNumber();
        if (DBG)
            log("- got vm number: '" + vmNumber + "'");
        // SubscriptionListener in CallNotifier will update this once the SIM is loaded.
        if ((vmNumber == null) && !phone.getIccRecordsLoaded()) {
            if (DBG)
                log("- Null vm number: SIM records not loaded (yet)...");
            return;
        }
        if (TelephonyCapabilities.supportsVoiceMessageCount(phone)) {
            int vmCount = phone.getVoiceMessageCount();
            String titleFormat = mContext.getString(R.string.notification_voicemail_title_count);
            notificationTitle = String.format(titleFormat, vmCount);
        }
        // This pathway only applies to PSTN accounts; only SIMS have subscription ids.
        PhoneAccountHandle phoneAccountHandle = PhoneUtils.makePstnPhoneAccountHandle(phone);
        Intent intent;
        String notificationText;
        if (TextUtils.isEmpty(vmNumber)) {
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            // If the voicemail number if unknown, instead of calling voicemail, take the user
            // to the voicemail settings.
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            intent = new Intent(VoicemailSettingsActivity.ACTION_ADD_VOICEMAIL);
            intent.putExtra(SubscriptionInfoHelper.SUB_ID_EXTRA, subId);
            intent.setClass(mContext, VoicemailSettingsActivity.class);
        } else {
            if (mTelephonyManager.getPhoneCount() > 1) {
                notificationText = subInfo.getDisplayName().toString();
            } else {
                notificationText = String.format(mContext.getString(R.string.notification_voicemail_text_format), PhoneNumberUtils.formatNumber(vmNumber));
            }
            intent = new Intent(Intent.ACTION_CALL, Uri.fromParts(PhoneAccount.SCHEME_VOICEMAIL, "", null));
            intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, phoneAccountHandle);
        }
        PendingIntent pendingIntent = PendingIntent.getActivity(mContext, subId, /* requestCode */
        intent, 0);
        Uri ringtoneUri = null;
        if (enableNotificationSound) {
            ringtoneUri = VoicemailNotificationSettingsUtil.getRingtoneUri(mPhone);
        }
        Resources res = mContext.getResources();
        PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
        Notification.Builder builder = new Notification.Builder(mContext);
        builder.setSmallIcon(resId).setWhen(System.currentTimeMillis()).setColor(subInfo.getIconTint()).setContentTitle(notificationTitle).setContentText(notificationText).setContentIntent(pendingIntent).setSound(ringtoneUri).setColor(res.getColor(R.color.dialer_theme_color)).setOngoing(carrierConfig.getBoolean(CarrierConfigManager.KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL));
        if (VoicemailNotificationSettingsUtil.isVibrationEnabled(phone)) {
            builder.setDefaults(Notification.DEFAULT_VIBRATE);
        }
        final Notification notification = builder.build();
        List<UserInfo> users = mUserManager.getUsers(true);
        for (int i = 0; i < users.size(); i++) {
            final UserInfo user = users.get(i);
            final UserHandle userHandle = user.getUserHandle();
            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS, userHandle) && !user.isManagedProfile()) {
                configureLedNotification(mContext, notification);
                mNotificationManager.notifyAsUser(Integer.toString(subId), /* tag */
                notificationId, notification, userHandle);
            }
        }
    } else {
        mNotificationManager.cancelAsUser(Integer.toString(subId), /* tag */
        notificationId, UserHandle.ALL);
    }
}
#method_after
void updateMwi(int subId, boolean visible, boolean enableNotificationSound) {
    if (!PhoneGlobals.sVoiceCapable) {
        // Do not show the message waiting indicator on devices which are not voice capable.
        // These events *should* be blocked at the telephony layer for such devices.
        Log.w(LOG_TAG, "Called updateMwi() on non-voice-capable device! Ignoring...");
        return;
    }
    int[] mwiIcon = { R.drawable.stat_notify_voicemail_sub1, R.drawable.stat_notify_voicemail_sub2 };
    Phone phone = PhoneGlobals.getPhone(subId);
    int phoneId = phone.getPhoneId();
    int notificationId = getNotificationId(VOICEMAIL_NOTIFICATION, phoneId);
    if (visible && phone != null) {
        VoicemailStatusQueryHelper queryHelper = new VoicemailStatusQueryHelper(mContext);
        PhoneAccountHandle phoneAccount = PhoneUtils.makePstnPhoneAccountHandle(phone);
        if (queryHelper.isNotificationsChannelActive(phoneAccount)) {
            Log.v(LOG_TAG, "Notifications channel active for visual voicemail, hiding mwi.");
            visible = false;
        }
    }
    boolean notifProp = mApp.getResources().getBoolean(R.bool.sprint_mwi_quirk);
    boolean notifOption = CMSettings.System.getInt(mApp.getContentResolver(), CMSettings.System.ENABLE_MWI_NOTIFICATION, 0) == 1;
    if (notifProp && !notifOption) {
        // sprint_mwi_quirk is true, and ENABLE_MWI_NOTIFICATION is unchecked or unset (false)
        // hide the mwi, but log if we're debugging.
        visible = false;
        if (DBG)
            log("updateMwi(): mwi_notification is disabled. Ignoring...");
        return;
    }
    Log.i(LOG_TAG, "updateMwi(): subId " + subId + " update to " + visible);
    mMwiVisible.put(subId, visible);
    if (visible) {
        if (phone == null) {
            Log.w(LOG_TAG, "Found null phone for: " + subId);
            return;
        }
        SubscriptionInfo subInfo = mSubscriptionManager.getActiveSubscriptionInfo(subId);
        if (subInfo == null) {
            Log.w(LOG_TAG, "Found null subscription info for: " + subId);
            return;
        }
        int resId = android.R.drawable.stat_notify_voicemail;
        if (showSimSlotIcon()) {
            resId = mwiIcon[phoneId];
        }
        // This Notification can get a lot fancier once we have more
        // information about the current voicemail messages.
        // (For example, the current voicemail system can't tell
        // us the caller-id or timestamp of a message, or tell us the
        // message count.)
        // But for now, the UI is ultra-simple: if the MWI indication
        // is supposed to be visible, just show a single generic
        // notification.
        String notificationTitle = mContext.getString(R.string.notification_voicemail_title);
        String vmNumber = phone.getVoiceMailNumber();
        if (DBG)
            log("- got vm number: '" + vmNumber + "'");
        // SubscriptionListener in CallNotifier will update this once the SIM is loaded.
        if ((vmNumber == null) && !phone.getIccRecordsLoaded()) {
            if (DBG)
                log("- Null vm number: SIM records not loaded (yet)...");
            return;
        }
        if (TelephonyCapabilities.supportsVoiceMessageCount(phone)) {
            int vmCount = phone.getVoiceMessageCount();
            String titleFormat = mContext.getString(R.string.notification_voicemail_title_count);
            notificationTitle = String.format(titleFormat, vmCount);
        }
        // This pathway only applies to PSTN accounts; only SIMS have subscription ids.
        PhoneAccountHandle phoneAccountHandle = PhoneUtils.makePstnPhoneAccountHandle(phone);
        Intent intent;
        String notificationText;
        if (TextUtils.isEmpty(vmNumber)) {
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            // If the voicemail number if unknown, instead of calling voicemail, take the user
            // to the voicemail settings.
            notificationText = mContext.getString(R.string.notification_voicemail_no_vm_number);
            intent = new Intent(VoicemailSettingsActivity.ACTION_ADD_VOICEMAIL);
            intent.putExtra(SubscriptionInfoHelper.SUB_ID_EXTRA, subId);
            intent.setClass(mContext, VoicemailSettingsActivity.class);
        } else {
            if (mTelephonyManager.getPhoneCount() > 1) {
                notificationText = subInfo.getDisplayName().toString();
            } else {
                notificationText = String.format(mContext.getString(R.string.notification_voicemail_text_format), PhoneNumberUtils.formatNumber(vmNumber));
            }
            intent = new Intent(Intent.ACTION_CALL, Uri.fromParts(PhoneAccount.SCHEME_VOICEMAIL, "", null));
            intent.putExtra(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, phoneAccountHandle);
        }
        PendingIntent pendingIntent = PendingIntent.getActivity(mContext, subId, /* requestCode */
        intent, 0);
        Uri ringtoneUri = null;
        if (enableNotificationSound) {
            ringtoneUri = VoicemailNotificationSettingsUtil.getRingtoneUri(mPhone);
        }
        Resources res = mContext.getResources();
        PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
        Notification.Builder builder = new Notification.Builder(mContext);
        builder.setSmallIcon(resId).setWhen(System.currentTimeMillis()).setColor(subInfo.getIconTint()).setContentTitle(notificationTitle).setContentText(notificationText).setContentIntent(pendingIntent).setSound(ringtoneUri).setColor(res.getColor(R.color.dialer_theme_color)).setOngoing(carrierConfig.getBoolean(CarrierConfigManager.KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL));
        if (VoicemailNotificationSettingsUtil.isVibrationEnabled(phone)) {
            builder.setDefaults(Notification.DEFAULT_VIBRATE);
        }
        final Notification notification = builder.build();
        List<UserInfo> users = mUserManager.getUsers(true);
        for (int i = 0; i < users.size(); i++) {
            final UserInfo user = users.get(i);
            final UserHandle userHandle = user.getUserHandle();
            if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS, userHandle) && !user.isManagedProfile()) {
                configureLedNotification(mContext, notification);
                mNotificationManager.notifyAsUser(Integer.toString(subId), /* tag */
                notificationId, notification, userHandle);
            }
        }
    } else {
        mNotificationManager.cancelAsUser(Integer.toString(subId), /* tag */
        notificationId, UserHandle.ALL);
    }
}
#end_block

#method_before
@Override
protected void onResume() {
    super.onResume();
    PreferenceScreen preferenceScreen = getPreferenceScreen();
    if (preferenceScreen != null) {
        preferenceScreen.removeAll();
    }
    addPreferencesFromResource(R.xml.call_feature_setting);
    TelephonyManager telephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
    Preference phoneAccountSettingsPreference = findPreference(PHONE_ACCOUNT_SETTINGS_KEY);
    if (telephonyManager.isMultiSimEnabled() || !SipUtil.isVoipSupported(mPhone.getContext())) {
        getPreferenceScreen().removePreference(phoneAccountSettingsPreference);
    }
    PreferenceScreen prefSet = getPreferenceScreen();
    mVoicemailSettingsScreen = (PreferenceScreen) findPreference(VOICEMAIL_SETTING_SCREEN_PREF_KEY);
    mVoicemailSettingsScreen.setIntent(mSubscriptionInfoHelper.getIntent(VoicemailSettingsActivity.class));
    mButtonAutoRetry = (CheckBoxPreference) findPreference(BUTTON_RETRY_KEY);
    mEnableVideoCalling = (CheckBoxPreference) findPreference(ENABLE_VIDEO_CALLING_KEY);
    PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
    if (carrierConfig.getBoolean(CarrierConfigManager.KEY_AUTO_RETRY_ENABLED_BOOL)) {
        mButtonAutoRetry.setOnPreferenceChangeListener(this);
        int autoretry = Settings.Global.getInt(getContentResolver(), Settings.Global.CALL_AUTO_RETRY, 0);
        mButtonAutoRetry.setChecked(autoretry != 0);
    } else {
        prefSet.removePreference(mButtonAutoRetry);
        mButtonAutoRetry = null;
    }
    Preference cdmaOptions = prefSet.findPreference(BUTTON_CDMA_OPTIONS);
    Preference gsmOptions = prefSet.findPreference(BUTTON_GSM_UMTS_OPTIONS);
    Preference fdnButton = prefSet.findPreference(BUTTON_FDN_KEY);
    fdnButton.setIntent(mSubscriptionInfoHelper.getIntent(FdnSetting.class));
    if (carrierConfig.getBoolean(CarrierConfigManager.KEY_WORLD_PHONE_BOOL)) {
        cdmaOptions.setIntent(mSubscriptionInfoHelper.getIntent(CdmaCallOptions.class));
        gsmOptions.setIntent(mSubscriptionInfoHelper.getIntent(GsmUmtsCallOptions.class));
    } else {
        prefSet.removePreference(cdmaOptions);
        prefSet.removePreference(gsmOptions);
        int phoneType = mPhone.getPhoneType();
        if (carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_CARRIER_NETWORK_SETTINGS_BOOL)) {
            prefSet.removePreference(fdnButton);
        } else {
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                prefSet.removePreference(fdnButton);
                addPreferencesFromResource(R.xml.cdma_call_privacy);
                if (carrierConfig.getBoolean(CarrierConfigManager.KEY_VOICE_PRIVACY_DISABLE_UI_BOOL)) {
                    CdmaVoicePrivacyCheckBoxPreference prefPri = (CdmaVoicePrivacyCheckBoxPreference) prefSet.findPreference("button_voice_privacy_key");
                    if (prefPri != null) {
                        prefSet.removePreference(prefPri);
                    }
                }
                if (carrierConfig.getBoolean(CarrierConfigManager.KEY_CDMA_CW_CF_ENABLED_BOOL) && CdmaCallOptions.isCdmaCallWaitingActivityPresent(mPhone.getContext())) {
                    Log.d(LOG_TAG, "Enabled CW CF");
                    PreferenceScreen prefCW = (PreferenceScreen) prefSet.findPreference("button_cw_key");
                    if (prefCW != null) {
                        prefCW.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

                            @Override
                            public boolean onPreferenceClick(Preference preference) {
                                Intent intent = new Intent(CdmaCallOptions.CALL_WAITING_INTENT);
                                intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mPhone.getSubId());
                                startActivity(intent);
                                return true;
                            }
                        });
                    }
                    PreferenceScreen prefCF = (PreferenceScreen) prefSet.findPreference("button_cf_expand_key");
                    if (prefCF != null) {
                        prefCF.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

                            @Override
                            public boolean onPreferenceClick(Preference preference) {
                                Intent intent = new Intent(CdmaCallOptions.CALL_FORWARD_INTENT);
                                intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mPhone.getSubId());
                                startActivity(intent);
                                return true;
                            }
                        });
                    }
                } else {
                    Log.d(LOG_TAG, "Disabled CW CF");
                    PreferenceScreen prefCW = (PreferenceScreen) prefSet.findPreference("button_cw_key");
                    if (prefCW != null) {
                        prefSet.removePreference(prefCW);
                    }
                    PreferenceScreen prefCF = (PreferenceScreen) prefSet.findPreference("button_cf_expand_key");
                    if (prefCF != null) {
                        prefSet.removePreference(prefCF);
                    }
                }
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                if (carrierConfig.getBoolean(CarrierConfigManager.KEY_ADDITIONAL_CALL_SETTING_BOOL)) {
                    addPreferencesFromResource(R.xml.gsm_umts_call_options);
                    GsmUmtsCallOptions.init(prefSet, mSubscriptionInfoHelper);
                }
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
        }
    }
    if (ImsManager.isVtEnabledByPlatform(mPhone.getContext()) && ImsManager.isVtProvisionedOnDevice(mPhone.getContext()) && mPhone.mDcTracker.isDataEnabled(true)) {
        boolean currentValue = ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext()) ? PhoneGlobals.getInstance().phoneMgr.isVideoCallingEnabled(getOpPackageName()) : false;
        mEnableVideoCalling.setChecked(currentValue);
        mEnableVideoCalling.setOnPreferenceChangeListener(this);
    } else {
        prefSet.removePreference(mEnableVideoCalling);
    }
    if (ImsManager.isVolteEnabledByPlatform(this) && !carrierConfig.getBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    /* tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE); */
    }
    Preference imsSettings = findPreference(IMS_SETTINGS_KEY);
    if (!PackageManagerUtils.isAppInstalled(this, QTI_IMS_PACKAGE_NAME)) {
        prefSet.removePreference(imsSettings);
    }
    Preference wifiCallingSettings = findPreference(getResources().getString(R.string.wifi_calling_settings_key));
    final PhoneAccountHandle simCallManager = mTelecomManager.getSimCallManager();
    if (simCallManager != null) {
        Intent intent = PhoneAccountSettingsFragment.buildPhoneAccountConfigureIntent(this, simCallManager);
        if (intent != null) {
            PackageManager pm = mPhone.getContext().getPackageManager();
            List<ResolveInfo> resolutions = pm.queryIntentActivities(intent, 0);
            if (!resolutions.isEmpty()) {
                wifiCallingSettings.setTitle(resolutions.get(0).loadLabel(pm));
                wifiCallingSettings.setSummary(null);
                wifiCallingSettings.setIntent(intent);
            } else {
                prefSet.removePreference(wifiCallingSettings);
            }
        } else {
            prefSet.removePreference(wifiCallingSettings);
        }
    } else if (!ImsManager.isWfcEnabledByPlatform(mPhone.getContext()) || !ImsManager.isWfcProvisionedOnDevice(mPhone.getContext())) {
        prefSet.removePreference(wifiCallingSettings);
    } else {
        int resId = com.android.internal.R.string.wifi_calling_off_summary;
        if (ImsManager.isWfcEnabledByUser(mPhone.getContext())) {
            int wfcMode = ImsManager.getWfcMode(mPhone.getContext());
            switch(wfcMode) {
                case ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY:
                    resId = com.android.internal.R.string.wfc_mode_wifi_only_summary;
                    break;
                case ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED:
                    resId = com.android.internal.R.string.wfc_mode_cellular_preferred_summary;
                    break;
                case ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED:
                    resId = com.android.internal.R.string.wfc_mode_wifi_preferred_summary;
                    break;
                default:
                    if (DBG)
                        log("Unexpected WFC mode value: " + wfcMode);
            }
        }
        wifiCallingSettings.setSummary(resId);
    }
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    PreferenceScreen preferenceScreen = getPreferenceScreen();
    if (preferenceScreen != null) {
        preferenceScreen.removeAll();
    }
    addPreferencesFromResource(R.xml.call_feature_setting);
    TelephonyManager telephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
    Preference phoneAccountSettingsPreference = findPreference(PHONE_ACCOUNT_SETTINGS_KEY);
    if (telephonyManager.isMultiSimEnabled() || !SipUtil.isVoipSupported(mPhone.getContext())) {
        getPreferenceScreen().removePreference(phoneAccountSettingsPreference);
    }
    PreferenceScreen prefSet = getPreferenceScreen();
    mVoicemailSettingsScreen = (PreferenceScreen) findPreference(VOICEMAIL_SETTING_SCREEN_PREF_KEY);
    mVoicemailSettingsScreen.setIntent(mSubscriptionInfoHelper.getIntent(VoicemailSettingsActivity.class));
    mButtonAutoRetry = (CheckBoxPreference) findPreference(BUTTON_RETRY_KEY);
    mEnableVideoCalling = (CheckBoxPreference) findPreference(ENABLE_VIDEO_CALLING_KEY);
    PersistableBundle carrierConfig = PhoneGlobals.getInstance().getCarrierConfigForSubId(mPhone.getSubId());
    if (carrierConfig.getBoolean(CarrierConfigManager.KEY_AUTO_RETRY_ENABLED_BOOL)) {
        mButtonAutoRetry.setOnPreferenceChangeListener(this);
        int autoretry = Settings.Global.getInt(getContentResolver(), Settings.Global.CALL_AUTO_RETRY, 0);
        mButtonAutoRetry.setChecked(autoretry != 0);
    } else {
        prefSet.removePreference(mButtonAutoRetry);
        mButtonAutoRetry = null;
    }
    Preference cdmaOptions = prefSet.findPreference(BUTTON_CDMA_OPTIONS);
    Preference gsmOptions = prefSet.findPreference(BUTTON_GSM_UMTS_OPTIONS);
    Preference fdnButton = prefSet.findPreference(BUTTON_FDN_KEY);
    fdnButton.setIntent(mSubscriptionInfoHelper.getIntent(FdnSetting.class));
    if (carrierConfig.getBoolean(CarrierConfigManager.KEY_WORLD_PHONE_BOOL)) {
        cdmaOptions.setIntent(mSubscriptionInfoHelper.getIntent(CdmaCallOptions.class));
        gsmOptions.setIntent(mSubscriptionInfoHelper.getIntent(GsmUmtsCallOptions.class));
    } else {
        prefSet.removePreference(cdmaOptions);
        prefSet.removePreference(gsmOptions);
        int phoneType = mPhone.getPhoneType();
        if (carrierConfig.getBoolean(CarrierConfigManager.KEY_HIDE_CARRIER_NETWORK_SETTINGS_BOOL)) {
            prefSet.removePreference(fdnButton);
        } else {
            if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                prefSet.removePreference(fdnButton);
                addPreferencesFromResource(R.xml.cdma_call_privacy);
                if (carrierConfig.getBoolean(CarrierConfigManager.KEY_VOICE_PRIVACY_DISABLE_UI_BOOL)) {
                    CdmaVoicePrivacyCheckBoxPreference prefPri = (CdmaVoicePrivacyCheckBoxPreference) prefSet.findPreference("button_voice_privacy_key");
                    if (prefPri != null) {
                        prefSet.removePreference(prefPri);
                    }
                }
                if (carrierConfig.getBoolean(CarrierConfigManager.KEY_CDMA_CW_CF_ENABLED_BOOL) && CdmaCallOptions.isCdmaCallWaitingActivityPresent(mPhone.getContext())) {
                    Log.d(LOG_TAG, "Enabled CW CF");
                    PreferenceScreen prefCW = (PreferenceScreen) prefSet.findPreference("button_cw_key");
                    if (prefCW != null) {
                        prefCW.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

                            @Override
                            public boolean onPreferenceClick(Preference preference) {
                                Intent intent = new Intent(CdmaCallOptions.CALL_WAITING_INTENT);
                                intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mPhone.getSubId());
                                startActivity(intent);
                                return true;
                            }
                        });
                    }
                    PreferenceScreen prefCF = (PreferenceScreen) prefSet.findPreference("button_cf_expand_key");
                    if (prefCF != null) {
                        prefCF.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

                            @Override
                            public boolean onPreferenceClick(Preference preference) {
                                Intent intent = new Intent(CdmaCallOptions.CALL_FORWARD_INTENT);
                                intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, mPhone.getSubId());
                                startActivity(intent);
                                return true;
                            }
                        });
                    }
                } else {
                    Log.d(LOG_TAG, "Disabled CW CF");
                    PreferenceScreen prefCW = (PreferenceScreen) prefSet.findPreference("button_cw_key");
                    if (prefCW != null) {
                        prefSet.removePreference(prefCW);
                    }
                    PreferenceScreen prefCF = (PreferenceScreen) prefSet.findPreference("button_cf_expand_key");
                    if (prefCF != null) {
                        prefSet.removePreference(prefCF);
                    }
                }
            } else if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                if (carrierConfig.getBoolean(CarrierConfigManager.KEY_ADDITIONAL_CALL_SETTING_BOOL)) {
                    addPreferencesFromResource(R.xml.gsm_umts_call_options);
                    GsmUmtsCallOptions.init(prefSet, mSubscriptionInfoHelper);
                }
            } else {
                throw new IllegalStateException("Unexpected phone type: " + phoneType);
            }
        }
    }
    if (ImsManager.isVtEnabledByPlatform(mPhone.getContext()) && ImsManager.isVtProvisionedOnDevice(mPhone.getContext()) && mPhone.mDcTracker.isDataEnabled(true)) {
        boolean currentValue = ImsManager.isEnhanced4gLteModeSettingEnabledByUser(mPhone.getContext()) ? PhoneGlobals.getInstance().phoneMgr.isVideoCallingEnabled(getOpPackageName()) : false;
        mEnableVideoCalling.setChecked(currentValue);
        mEnableVideoCalling.setOnPreferenceChangeListener(this);
    } else {
        prefSet.removePreference(mEnableVideoCalling);
    }
    if (ImsManager.isVolteEnabledByPlatform(this) && !carrierConfig.getBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_TTY_SUPPORTED_BOOL)) {
        TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    /* tm.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE); */
    }
    if (!PackageManagerUtils.isAppInstalled(this, "com.qualcomm.qti.ims")) {
        prefSet.removePreference(findPreference("ims_settings_key"));
    }
    Preference wifiCallingSettings = findPreference(getResources().getString(R.string.wifi_calling_settings_key));
    final PhoneAccountHandle simCallManager = mTelecomManager.getSimCallManager();
    if (simCallManager != null) {
        Intent intent = PhoneAccountSettingsFragment.buildPhoneAccountConfigureIntent(this, simCallManager);
        if (intent != null) {
            PackageManager pm = mPhone.getContext().getPackageManager();
            List<ResolveInfo> resolutions = pm.queryIntentActivities(intent, 0);
            if (!resolutions.isEmpty()) {
                wifiCallingSettings.setTitle(resolutions.get(0).loadLabel(pm));
                wifiCallingSettings.setSummary(null);
                wifiCallingSettings.setIntent(intent);
            } else {
                prefSet.removePreference(wifiCallingSettings);
            }
        } else {
            prefSet.removePreference(wifiCallingSettings);
        }
    } else if (!ImsManager.isWfcEnabledByPlatform(mPhone.getContext()) || !ImsManager.isWfcProvisionedOnDevice(mPhone.getContext())) {
        prefSet.removePreference(wifiCallingSettings);
    } else {
        int resId = com.android.internal.R.string.wifi_calling_off_summary;
        if (ImsManager.isWfcEnabledByUser(mPhone.getContext())) {
            int wfcMode = ImsManager.getWfcMode(mPhone.getContext());
            switch(wfcMode) {
                case ImsConfig.WfcModeFeatureValueConstants.WIFI_ONLY:
                    resId = com.android.internal.R.string.wfc_mode_wifi_only_summary;
                    break;
                case ImsConfig.WfcModeFeatureValueConstants.CELLULAR_PREFERRED:
                    resId = com.android.internal.R.string.wfc_mode_cellular_preferred_summary;
                    break;
                case ImsConfig.WfcModeFeatureValueConstants.WIFI_PREFERRED:
                    resId = com.android.internal.R.string.wfc_mode_wifi_preferred_summary;
                    break;
                default:
                    if (DBG)
                        log("Unexpected WFC mode value: " + wfcMode);
            }
        }
        wifiCallingSettings.setSummary(resId);
    }
}
#end_block

#method_before
PhoneAccountHandle getUserSelectedOutgoingPhoneAccount() {
    PhoneAccount account = getPhoneAccountCheckCallingUser(mState.defaultOutgoing);
    List<PhoneAccountHandle> allPhoneAccounts = getCallCapablePhoneAccounts("", false);
    if (account != null) {
        return mState.defaultOutgoing;
    }
    if (TelephonyManager.getDefault().getPhoneCount() > 1 && allPhoneAccounts.size() == 1) {
        return getUserSelectedVoicePhoneAccount();
    }
    return null;
}
#method_after
PhoneAccountHandle getUserSelectedOutgoingPhoneAccount() {
    PhoneAccount account = getPhoneAccountCheckCallingUser(mState.defaultOutgoing);
    if (account != null) {
        return mState.defaultOutgoing;
    }
    if (TelephonyManager.getDefault().getPhoneCount() > 1 && getAllPhoneAccounts().size() == 1) {
        return getUserSelectedVoicePhoneAccount();
    }
    return null;
}
#end_block

#method_before
void answerCall(final Call call, final int videoState) {
    answerCall(call, videoState, TelecomManager.CALL_WAITING_RESPONSE_SHOW_POPUP);
}
#method_after
void answerCall(final Call call, final int videoState) {
    answerCall(call, videoState, TelecomManager.CALL_WAITING_RESPONSE_NO_POPUP_END_CALL);
}
#end_block

#method_before
void answerCall(final Call call, final int videoState, final int callWaitingResponseType) {
    if (!mCalls.contains(call)) {
        Log.i(this, "Request to answer a non-existent call %s", call);
    } else {
        final Call activeCall = getFirstCallWithState(call.getTargetPhoneAccount().getId(), CallState.ACTIVE, CallState.DIALING);
        // STATE_DIALING, put it on hold before answering the call.
        if (activeCall != null && activeCall != call && (activeCall.isActive() || activeCall.getState() == CallState.DIALING)) {
            if (0 == (mForegroundCall.getConnectionCapabilities() & Connection.CAPABILITY_HOLD)) {
                // figure out the right states.
                if (activeCall.getConnectionService() != call.getConnectionService()) {
                    activeCall.disconnect();
                }
            } else {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        CallWaitingListener listener = new CallWaitingListener(call, activeCall, videoState, CallsManager.this);
                        if (callWaitingResponseType == TelecomManager.CALL_WAITING_RESPONSE_NO_POPUP_END_CALL) {
                            listener.handleEndCallAndAnswer();
                        } else if (callWaitingResponseType == TelecomManager.CALL_WAITING_RESPONSE_NO_POPUP_HOLD_CALL) {
                            listener.handleHoldCallAndAnswer();
                        } else {
                            Dialog dialog = CallWaitingDialog.createCallWaitingDialog(mContext, call, listener, listener);
                            dialog.show();
                        }
                    }
                });
                return;
            }
        }
        for (CallsManagerListener listener : mListeners) {
            listener.onIncomingCallAnswered(call);
        }
        updateLchStatus(call.getTargetPhoneAccount().getId());
        // We do not update the UI until we get confirmation of the answer() through
        // {@link #markCallAsActive}.
        call.answer(videoState);
        if (isSpeakerphoneAutoEnabled(videoState)) {
            call.setStartWithSpeakerphoneOn(true);
        }
    }
}
#method_after
void answerCall(final Call call, final int videoState, final int callWaitingResponseType) {
    if (!mCalls.contains(call)) {
        Log.i(this, "Request to answer a non-existent call %s", call);
    } else {
        final Call activeCall = getFirstCallWithState(call.getTargetPhoneAccount().getId(), CallState.ACTIVE, CallState.DIALING);
        // STATE_DIALING, put it on hold before answering the call.
        if (activeCall != null && activeCall != call && (activeCall.isActive() || activeCall.getState() == CallState.DIALING)) {
            if (0 == (mForegroundCall.getConnectionCapabilities() & Connection.CAPABILITY_HOLD)) {
                // figure out the right states.
                if (activeCall.getConnectionService() != call.getConnectionService()) {
                    activeCall.disconnect();
                }
            } else {
                switch(callWaitingResponseType) {
                    case TelecomManager.CALL_WAITING_RESPONSE_NO_POPUP_HOLD_CALL:
                        handleHoldCallAndAnswer(call, activeCall, videoState, CallsManager.this);
                        break;
                    case TelecomManager.CALL_WAITING_RESPONSE_NO_POPUP_END_CALL:
                    default:
                        handleEndCallAndAnswer(call, activeCall, videoState, CallsManager.this);
                        break;
                }
                return;
            }
        }
        for (CallsManagerListener listener : mListeners) {
            listener.onIncomingCallAnswered(call);
        }
        updateLchStatus(call.getTargetPhoneAccount().getId());
        // We do not update the UI until we get confirmation of the answer() through
        // {@link #markCallAsActive}.
        call.answer(videoState);
        if (isSpeakerphoneAutoEnabled(videoState)) {
            call.setStartWithSpeakerphoneOn(true);
        }
    }
}
#end_block

#method_before
PhoneAccountHandle getUserSelectedVoicePhoneAccount() {
    long voiceSubId = SubscriptionManager.getDefaultVoiceSubId();
    PhoneAccountHandle prefPhoneAccount = null;
    Log.i(this, "getUserSelVoicePhoneAccount, voice subId = " + voiceSubId);
    for (int i = 0; i < mState.accounts.size(); i++) {
        String id = mState.accounts.get(i).getAccountHandle().getId();
        if (id == null || id.equals("null") || TextUtils.isEmpty(id)) {
            continue;
        }
        // emergency account present return it
        if (id.equals("E")) {
            Log.i(this, "getUserSelVoicePhoneAccount, emergency account ");
            return mState.accounts.get(i).getAccountHandle();
        }
        try {
            long subId = Long.parseLong(id);
            Log.i(this, "getUserSelectedVoicePhoneAccount, voice subId = " + voiceSubId + " subId = " + subId + " mId = " + id);
            if (subId == voiceSubId) {
                prefPhoneAccount = mState.accounts.get(i).getAccountHandle();
                break;
            }
        } catch (IllegalArgumentException e) {
        // Do nothing
        }
    }
    return prefPhoneAccount;
}
#method_after
PhoneAccountHandle getUserSelectedVoicePhoneAccount() {
    long voiceSubId = SubscriptionManager.getDefaultVoiceSubId();
    PhoneAccountHandle prefPhoneAccount = null;
    Log.i(this, "getUserSelVoicePhoneAccount, voice subId = " + voiceSubId);
    for (int i = 0; i < mState.accounts.size(); i++) {
        String id = mState.accounts.get(i).getAccountHandle().getId();
        if (id == null || id.equals("null") || TextUtils.isEmpty(id)) {
            continue;
        }
        // emergency account present return it
        if (id.equals("E")) {
            Log.i(this, "getUserSelVoicePhoneAccount, emergency account ");
            return mState.accounts.get(i).getAccountHandle();
        }
        try {
            long subId = Long.parseLong(id);
            Log.i(this, "getUserSelectedVoicePhoneAccount, voice subId = " + voiceSubId + " subId = " + subId + " mId = " + id);
            if (subId == voiceSubId) {
                prefPhoneAccount = mState.accounts.get(i).getAccountHandle();
                break;
            }
        } catch (IllegalArgumentException e) {
            Log.w(this, "getUserSelectedVoicePhoneAccount, accountHandle ID = " + id);
        }
    }
    return prefPhoneAccount;
}
#end_block

#method_before
public static boolean isLocalEmergencyNumber(Context context, String address) {
    IExtTelephony mIExtTelephony = IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
    boolean result = false;
    try {
        result = mIExtTelephony.isLocalEmergencyNumber(address);
    } catch (RemoteException ex) {
        Log.e(LOG_TAG, ex, "RemoteException");
        result = PhoneNumberUtils.isLocalEmergencyNumber(context, address);
    } catch (NullPointerException ex) {
        Log.e(LOG_TAG, ex, "NullPointerException");
        result = PhoneNumberUtils.isLocalEmergencyNumber(context, address);
    }
    return result;
}
#method_after
public static boolean isLocalEmergencyNumber(Context context, String address) {
    IExtTelephony mIExtTelephony = IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
    if (mIExtTelephony == null) {
        return PhoneNumberUtils.isLocalEmergencyNumber(context, address);
    }
    try {
        return mIExtTelephony.isLocalEmergencyNumber(address);
    } catch (RemoteException ex) {
        Log.e(LOG_TAG, ex, "RemoteException");
        return PhoneNumberUtils.isLocalEmergencyNumber(context, address);
    }
}
#end_block

#method_before
public static boolean isPotentialLocalEmergencyNumber(PhoneNumberUtilsAdapter adapter, Context context, String address) {
    IExtTelephony mIExtTelephony = IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
    boolean result = false;
    try {
        result = mIExtTelephony.isPotentialLocalEmergencyNumber(address);
    } catch (RemoteException ex) {
        Log.e(LOG_TAG, ex, "RemoteException");
        result = adapter.isPotentialLocalEmergencyNumber(context, address);
    } catch (NullPointerException ex) {
        Log.e(LOG_TAG, ex, "NullPointerException");
        result = adapter.isPotentialLocalEmergencyNumber(context, address);
    }
    return result;
}
#method_after
public static boolean isPotentialLocalEmergencyNumber(PhoneNumberUtilsAdapter adapter, Context context, String address) {
    IExtTelephony mIExtTelephony = IExtTelephony.Stub.asInterface(ServiceManager.getService("extphone"));
    if (mIExtTelephony == null) {
        return adapter.isPotentialLocalEmergencyNumber(context, address);
    }
    try {
        return mIExtTelephony.isPotentialLocalEmergencyNumber(address);
    } catch (RemoteException ex) {
        Log.e(LOG_TAG, ex, "RemoteException");
        return adapter.isPotentialLocalEmergencyNumber(context, address);
    }
}
#end_block

#method_before
private void updateWithLocked(Collection<DownloadInfo> downloads) {
    final Resources res = mContext.getResources();
    // Cluster downloads together
    final Multimap<String, DownloadInfo> clustered = ArrayListMultimap.create();
    for (DownloadInfo info : downloads) {
        final String tag = buildNotificationTag(info);
        if (tag != null) {
            clustered.put(tag, info);
        }
    }
    // Build notification for each cluster
    for (String tag : clustered.keySet()) {
        final int type = getNotificationTagType(tag);
        final Collection<DownloadInfo> cluster = clustered.get(tag);
        final Notification.Builder builder = new Notification.Builder(mContext);
        // Use time when cluster was first shown to avoid shuffling
        final long firstShown;
        if (mActiveNotifs.containsKey(tag)) {
            firstShown = mActiveNotifs.get(tag);
        } else {
            firstShown = System.currentTimeMillis();
            mActiveNotifs.put(tag, firstShown);
        }
        builder.setWhen(firstShown);
        // Show relevant icon
        if (type == TYPE_ACTIVE) {
            builder.setSmallIcon(android.R.drawable.stat_sys_download);
        } else if (type == TYPE_WAITING) {
            builder.setSmallIcon(android.R.drawable.stat_sys_warning);
        } else if (type == TYPE_COMPLETE) {
            builder.setSmallIcon(android.R.drawable.stat_sys_download_done);
        }
        // Build action intents
        if (type == TYPE_ACTIVE || type == TYPE_WAITING) {
            // build a synthetic uri for intent identification purposes
            final Uri uri = new Uri.Builder().scheme("active-dl").appendPath(tag).build();
            final Intent intent = new Intent(Constants.ACTION_LIST, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            builder.setOngoing(true);
        } else if (type == TYPE_COMPLETE) {
            final DownloadInfo info = cluster.iterator().next();
            final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);
            builder.setAutoCancel(true);
            final String action;
            if (Downloads.Impl.isStatusError(info.mStatus)) {
                action = Constants.ACTION_LIST;
            } else {
                if (info.mDestination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {
                    action = Constants.ACTION_OPEN;
                } else {
                    action = Constants.ACTION_LIST;
                }
            }
            final Intent intent = new Intent(action, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            final Intent hideIntent = new Intent(Constants.ACTION_HIDE, uri, mContext, DownloadReceiver.class);
            builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, hideIntent, 0));
        }
        // Calculate and show progress
        String remainingText = null;
        String percentText = null;
        String speedText = null;
        if (type == TYPE_ACTIVE) {
            long current = 0;
            long total = 0;
            long speed = 0;
            synchronized (mDownloadSpeed) {
                for (DownloadInfo info : cluster) {
                    if (info.mTotalBytes != -1) {
                        current += info.mCurrentBytes;
                        total += info.mTotalBytes;
                        speed += mDownloadSpeed.get(info.mId);
                    }
                }
            }
            if (total > 0) {
                final int percent = (int) ((current * 100) / total);
                percentText = res.getString(R.string.download_percent, percent);
                if (speed > 0) {
                    // use Formatter interface for determining speed unit
                    speedText = res.getString(R.string.download_speed, Formatter.formatFileSize(mContext, speed));
                    final long remainingMillis = ((total - current) * 1000) / speed;
                    remainingText = res.getString(R.string.download_remaining, DateUtils.formatDuration(remainingMillis));
                }
                builder.setProgress(100, percent, false);
            } else {
                builder.setProgress(100, 0, true);
            }
        }
        // Build titles and description
        final Notification notif;
        if (cluster.size() == 1) {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            final DownloadInfo info = cluster.iterator().next();
            builder.setContentTitle(getDownloadTitle(res, info));
            builder.setContentText(remainingText);
            if (type == TYPE_ACTIVE) {
                if (!TextUtils.isEmpty(info.mDescription)) {
                    inboxStyle.addLine(info.mDescription);
                } else {
                    inboxStyle.addLine(res.getString(R.string.download_running));
                }
                if (TextUtils.isEmpty(speedText)) {
                    inboxStyle.setSummaryText(remainingText);
                } else {
                    inboxStyle.setSummaryText(speedText + ", " + remainingText);
                }
                builder.setContentInfo(percentText);
            } else if (type == TYPE_WAITING) {
                builder.setContentText(res.getString(R.string.notification_need_wifi_for_size));
            } else if (type == TYPE_COMPLETE) {
                if (Downloads.Impl.isStatusError(info.mStatus)) {
                    builder.setContentText(res.getText(R.string.notification_download_failed));
                    inboxStyle.setSummaryText(res.getText(R.string.notification_download_failed));
                } else if (Downloads.Impl.isStatusSuccess(info.mStatus)) {
                    builder.setContentText(res.getText(R.string.notification_download_complete));
                    inboxStyle.setSummaryText(res.getText(R.string.notification_download_complete));
                }
            }
            notif = inboxStyle.build();
        } else {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            for (DownloadInfo info : cluster) {
                inboxStyle.addLine(getDownloadTitle(res, info));
            }
            if (type == TYPE_ACTIVE) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_active, cluster.size(), cluster.size()));
                builder.setContentText(remainingText);
                builder.setContentInfo(percentText);
                if (TextUtils.isEmpty(speedText)) {
                    inboxStyle.setSummaryText(remainingText);
                } else {
                    inboxStyle.setSummaryText(speedText + ", " + remainingText);
                }
            } else if (type == TYPE_WAITING) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));
                builder.setContentText(res.getString(R.string.notification_need_wifi_for_size));
                inboxStyle.setSummaryText(res.getString(R.string.notification_need_wifi_for_size));
            }
            notif = inboxStyle.build();
        }
        mNotifManager.notify(tag, 0, notif);
    }
    // Remove stale tags that weren't renewed
    final Iterator<String> it = mActiveNotifs.keySet().iterator();
    while (it.hasNext()) {
        final String tag = it.next();
        if (!clustered.containsKey(tag)) {
            mNotifManager.cancel(tag, 0);
            it.remove();
        }
    }
}
#method_after
private void updateWithLocked(Collection<DownloadInfo> downloads) {
    final Resources res = mContext.getResources();
    // Cluster downloads together
    final Multimap<String, DownloadInfo> clustered = ArrayListMultimap.create();
    for (DownloadInfo info : downloads) {
        final String tag = buildNotificationTag(info);
        if (tag != null) {
            clustered.put(tag, info);
        }
    }
    // Build notification for each cluster
    for (String tag : clustered.keySet()) {
        final int type = getNotificationTagType(tag);
        final Collection<DownloadInfo> cluster = clustered.get(tag);
        final Notification.Builder builder = new Notification.Builder(mContext);
        // Use time when cluster was first shown to avoid shuffling
        final long firstShown;
        if (mActiveNotifs.containsKey(tag)) {
            firstShown = mActiveNotifs.get(tag);
        } else {
            firstShown = System.currentTimeMillis();
            mActiveNotifs.put(tag, firstShown);
        }
        builder.setWhen(firstShown);
        // Check paused status about these downloads. If exists, will
        // update icon and content title/content text in notification.
        boolean hasPausedStatus = false;
        int pausedStatus = -1;
        for (DownloadInfo info : cluster) {
            if (isPausedStatus(info.mStatus)) {
                hasPausedStatus = true;
                pausedStatus = info.mStatus;
                break;
            }
        }
        // Show relevant icon
        if (type == TYPE_ACTIVE) {
            if (hasPausedStatus) {
                builder.setSmallIcon(R.drawable.download_pause);
            } else {
                builder.setSmallIcon(android.R.drawable.stat_sys_download);
            }
        } else if (type == TYPE_WAITING) {
            builder.setSmallIcon(android.R.drawable.stat_sys_warning);
        } else if (type == TYPE_COMPLETE) {
            builder.setSmallIcon(android.R.drawable.stat_sys_download_done);
        }
        // Build action intents
        if (type == TYPE_ACTIVE || type == TYPE_WAITING) {
            // build a synthetic uri for intent identification purposes
            final Uri uri = new Uri.Builder().scheme("active-dl").appendPath(tag).build();
            final Intent intent = new Intent(Constants.ACTION_LIST, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            builder.setOngoing(true);
        } else if (type == TYPE_COMPLETE) {
            final DownloadInfo info = cluster.iterator().next();
            final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);
            builder.setAutoCancel(true);
            final String action;
            if (Downloads.Impl.isStatusError(info.mStatus)) {
                action = Constants.ACTION_LIST;
            } else {
                if (info.mDestination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {
                    action = Constants.ACTION_OPEN;
                } else {
                    action = Constants.ACTION_LIST;
                }
            }
            final Intent intent = new Intent(action, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            final Intent hideIntent = new Intent(Constants.ACTION_HIDE, uri, mContext, DownloadReceiver.class);
            builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, hideIntent, 0));
        }
        // Calculate and show progress
        String remainingText = null;
        String percentText = null;
        String speedAsSizeText = null;
        if (type == TYPE_ACTIVE) {
            long current = 0;
            long total = 0;
            long speed = 0;
            synchronized (mDownloadSpeed) {
                for (DownloadInfo info : cluster) {
                    if (info.mTotalBytes != -1) {
                        current += info.mCurrentBytes;
                        total += info.mTotalBytes;
                        speed += mDownloadSpeed.get(info.mId);
                    }
                }
            }
            if (total > 0) {
                final int percent = (int) ((current * 100) / total);
                percentText = res.getString(R.string.download_percent, percent);
                if (speed > 0) {
                    final long remainingMillis = ((total - current) * 1000) / speed;
                    final int duration, durationResId;
                    // abbreviated plurals.
                    if (remainingMillis >= DateUtils.HOUR_IN_MILLIS) {
                        duration = (int) ((remainingMillis + 1800000) / DateUtils.HOUR_IN_MILLIS);
                        durationResId = R.plurals.duration_hours;
                    } else if (remainingMillis >= DateUtils.MINUTE_IN_MILLIS) {
                        duration = (int) ((remainingMillis + 30000) / DateUtils.MINUTE_IN_MILLIS);
                        durationResId = R.plurals.duration_minutes;
                    } else {
                        duration = (int) ((remainingMillis + 500) / DateUtils.SECOND_IN_MILLIS);
                        durationResId = R.plurals.duration_seconds;
                    }
                    remainingText = res.getString(R.string.download_remaining, res.getQuantityString(durationResId, duration, duration));
                    speedAsSizeText = Formatter.formatFileSize(mContext, speed);
                }
                builder.setProgress(100, percent, false);
            } else {
                builder.setProgress(100, 0, true);
            }
        }
        // Build titles and description
        final Notification notif;
        if (cluster.size() == 1) {
            final DownloadInfo info = cluster.iterator().next();
            builder.setContentTitle(getDownloadTitle(res, info));
            if (type == TYPE_ACTIVE) {
                if (hasPausedStatus) {
                    if (pausedStatus == Downloads.Impl.STATUS_PAUSED_BY_MANUAL)
                        builder.setContentText(res.getText(R.string.download_paused));
                    else
                        builder.setContentText(res.getText(R.string.download_queued));
                } else if (speedAsSizeText != null) {
                    builder.setContentText(res.getString(R.string.download_speed_text, remainingText, speedAsSizeText));
                }
                builder.setContentInfo(percentText);
            } else if (type == TYPE_WAITING) {
                builder.setContentText(res.getString(R.string.notification_need_wifi_for_size));
            } else if (type == TYPE_COMPLETE) {
                if (Downloads.Impl.isStatusError(info.mStatus)) {
                    builder.setContentText(res.getText(R.string.notification_download_failed));
                } else if (Downloads.Impl.isStatusSuccess(info.mStatus)) {
                    builder.setContentText(res.getText(R.string.notification_download_complete));
                }
            }
            notif = builder.build();
        } else {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            for (DownloadInfo info : cluster) {
                inboxStyle.addLine(getDownloadTitle(res, info));
            }
            if (type == TYPE_ACTIVE) {
                if (hasPausedStatus) {
                    builder.setContentTitle(res.getString(R.string.download_queued));
                } else {
                    builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_active, cluster.size(), cluster.size()));
                }
                builder.setContentText(remainingText);
                builder.setContentInfo(res.getString(R.string.download_speed_text, percentText, speedAsSizeText));
                inboxStyle.setSummaryText(remainingText);
            } else if (type == TYPE_WAITING) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));
                builder.setContentText(res.getString(R.string.notification_need_wifi_for_size));
                inboxStyle.setSummaryText(res.getString(R.string.notification_need_wifi_for_size));
            }
            notif = inboxStyle.build();
        }
        mNotifManager.notify(tag, 0, notif);
    }
    // Remove stale tags that weren't renewed
    final Iterator<String> it = mActiveNotifs.keySet().iterator();
    while (it.hasNext()) {
        final String tag = it.next();
        if (!clustered.containsKey(tag)) {
            mNotifManager.cancel(tag, 0);
            it.remove();
        }
    }
}
#end_block

#method_before
private static boolean isActiveAndVisible(DownloadInfo download) {
    return download.mStatus == STATUS_RUNNING && (download.mVisibility == VISIBILITY_VISIBLE || download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
}
#method_after
private static boolean isActiveAndVisible(DownloadInfo download) {
    return Downloads.Impl.isStatusInformational(download.mStatus) && (download.mVisibility == VISIBILITY_VISIBLE || download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED);
}
#end_block

#method_before
@Override
public void onDismiss(DialogInterface dialog) {
    super.onDismiss(dialog);
    getActivity().finish();
}
#method_after
@Override
public void onDismiss(DialogInterface dialog) {
    super.onDismiss(dialog);
    if (getActivity() != null) {
        getActivity().finish();
    }
}
#end_block

#method_before
@Override
public void onDismiss(DialogInterface dialog) {
    super.onDismiss(dialog);
    getActivity().finish();
}
#method_after
@Override
public void onDismiss(DialogInterface dialog) {
    super.onDismiss(dialog);
    if (getActivity() != null) {
        getActivity().finish();
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int uid = 0;
    String title;
    if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID)) {
        // Settings app uses long, but NetworkPolicyManager uses int
        // I guess UIDs are limited to 32 bits, so casting should not cause a problem
        uid = (int) intent.getLongExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID, 0);
    }
    if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE)) {
        title = intent.getStringExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE);
    } else {
        title = "";
    }
    if (uid == 0) {
        Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
        return;
    }
    if (DataUsageService.HIDE_ACTION.equals(action)) {
        Toast.makeText(context, context.getString(R.string.data_usage_hide_message, title), Toast.LENGTH_LONG).show();
        ContentValues values = new ContentValues();
        values.put(DataUsageContract.ENB, 0);
        values.put(DataUsageContract.ACTIVE, 0);
        values.put(DataUsageContract.BYTES, 0);
        DataUsageUtils.enbApp(context, uid, false);
    } else if (DataUsageService.DISABLE_ACTION.equals(action)) {
        Toast.makeText(context, context.getString(R.string.data_usage_disable_message, title), Toast.LENGTH_LONG).show();
        NetworkPolicyManager policyManager = NetworkPolicyManager.from(context);
        policyManager.addUidPolicy(uid, POLICY_REJECT_APP_METERED_USAGE);
    }
    // cancel the notification
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancel(DataUsageService.DATA_USAGE_SERVICE_NOTIFICATION_ID);
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int uid = 0;
    String title;
    if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID)) {
        // Settings app uses long, but NetworkPolicyManager uses int
        // I guess UIDs are limited to 32 bits, so casting should not cause a problem
        uid = (int) intent.getLongExtra(DataUsageService.DATA_USAGE_NOTIFICATION_UID, 0);
    }
    if (uid == 0) {
        Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
        return;
    }
    if (intent.hasExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE)) {
        title = intent.getStringExtra(DataUsageService.DATA_USAGE_NOTIFICATION_TITLE);
    } else {
        title = "";
    }
    if (DataUsageService.HIDE_ACTION.equals(action)) {
        Toast.makeText(context, context.getString(R.string.data_usage_hide_message, title), Toast.LENGTH_LONG).show();
        ContentValues values = new ContentValues();
        values.put(DataUsageContract.ENABLE, 0);
        values.put(DataUsageContract.ACTIVE, 0);
        values.put(DataUsageContract.BYTES, 0);
        DataUsageUtils.enableApp(context, uid, false);
    } else if (DataUsageService.DISABLE_ACTION.equals(action)) {
        Toast.makeText(context, context.getString(R.string.data_usage_disable_message, title), Toast.LENGTH_LONG).show();
        NetworkPolicyManager policyManager = NetworkPolicyManager.from(context);
        policyManager.addUidPolicy(uid, POLICY_REJECT_ON_DATA);
    }
    // cancel the notification
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.cancel(DataUsageService.DATA_USAGE_SERVICE_NOTIFICATION_ID);
}
#end_block

#method_before
private void dataUsageUpdate() {
    long startTime = 0;
    long endTime = System.currentTimeMillis() * 2;
    mLargest = 0;
    clearStats();
    NetworkStats networkStats = null;
    try {
        if (mStatsSession != null) {
            networkStats = mStatsSession.getSummaryForAllUid(mTemplate, startTime, endTime, false);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException: " + e.getMessage());
    }
    // collect network stats for all app consuming bw
    if (networkStats != null) {
        int size = networkStats.size();
        NetworkStats.Entry entry = null;
        for (int i = 0; i < size; i++) {
            entry = networkStats.getValues(i, entry);
            int collapseKey;
            int category;
            int uid = entry.uid;
            int userId = UserHandle.getUserId(uid);
            if (UserHandle.isApp(uid)) {
                if (mProfiles.contains(new UserHandle(userId))) {
                    if (userId != mCurrentUserId) {
                        // add to a managed user item
                        int managedKey = UidDetailProvider.buildKeyForUser(userId);
                        accumulate(managedKey, entry, AppItem.CATEGORY_USER);
                    }
                    collapseKey = uid;
                    category = AppItem.CATEGORY_APP;
                } else {
                    // if it is a removed user, add it to the removed users' key
                    UserInfo userInfo = mUserManager.getUserInfo(userId);
                    if (userInfo == null) {
                        collapseKey = UID_REMOVED;
                        category = AppItem.CATEGORY_APP;
                    } else {
                        collapseKey = UidDetailProvider.buildKeyForUser(userId);
                        category = AppItem.CATEGORY_USER;
                    }
                }
                accumulate(collapseKey, entry, category);
            }
        }
    }
    boolean appWarnActive = false;
    long appWarnBytes = 0;
    long appWarnUid;
    int appWarnSlowSamples;
    int appWarnFastSamples;
    long appWarnSlowAvg;
    long appWarnFastAvg;
    String appWarnExtra = "";
    // lookup Apps in the DB that have warning enabled
    Cursor cursor = getContentResolver().query(DataUsageContract.CONTENT_URI, // projection - return all
    null, DataUsageContract.ENB + " = ? ", new String[] { "1" }, null);
    if (cursor == null) {
        return;
    }
    while (cursor.moveToNext()) {
        appWarnUid = cursor.getInt(DataUsageContract.COLUMN_OF_UID);
        appWarnActive = cursor.getInt(DataUsageContract.COLUMN_OF_ACTIVE) > 0;
        appWarnBytes = cursor.getLong(DataUsageContract.COLUMN_OF_BYTES);
        appWarnSlowSamples = cursor.getInt(DataUsageContract.COLUMN_OF_SLOW_SAMPLES);
        appWarnSlowAvg = cursor.getLong(DataUsageContract.COLUMN_OF_SLOW_AVG);
        appWarnFastSamples = cursor.getInt(DataUsageContract.COLUMN_OF_FAST_SAMPLES);
        appWarnFastAvg = cursor.getLong(DataUsageContract.COLUMN_OF_FAST_AVG);
        mAppWarnExtra = cursor.getString(DataUsageContract.COLUMN_OF_EXTRA);
        AppItem appItem = mKnownItems.get((int) appWarnUid);
        if (appItem != null) {
            final UidDetail detail = mUidDetailProvider.getUidDetail(appItem.key, true);
            long bytesDelta = appWarnBytes == 0 ? 0 : appItem.total - appWarnBytes;
            if (DEBUG) {
                Log.v(TAG, detail.label.toString() + " cur:" + appItem.total + " prev:" + appWarnBytes + " SlowSamples:" + appWarnSlowSamples + " SlowAvg:" + appWarnSlowAvg + " FastSamples:" + appWarnFastSamples + " FastAvg:" + appWarnFastAvg);
            }
            if (bytesDelta > MAX_IDLE_BW) {
                // enough BW consumed during this sample - evaluate algorithm
                if (appWarnSlowSamples < MIN_SLOW_SAMPLE_COUNT) {
                    // not enough samples acquired for the slow average, keep accumulating
                    // samples
                    appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples, MIN_SLOW_SAMPLE_COUNT, bytesDelta);
                    appWarnSlowSamples++;
                    // we may have accumulated enough or not, need to check
                    if (appWarnFastSamples < MIN_FAST_SAMPLE_COUNT) {
                        // not enough fast samples
                        appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples, MIN_FAST_SAMPLE_COUNT, bytesDelta);
                        appWarnFastSamples++;
                    } else {
                        // enough fast samples
                        appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples, MIN_FAST_SAMPLE_COUNT, bytesDelta);
                    }
                    updateDb(appItem.key, appWarnSlowAvg, appWarnSlowSamples, appWarnFastAvg, appWarnFastSamples, 0, appItem.total);
                } else {
                    // enough samples acquired for the average, evaluate warning algorithm
                    float avgExceedPercent = appWarnFastAvg - appWarnSlowAvg;
                    avgExceedPercent /= appWarnSlowAvg;
                    avgExceedPercent *= 100;
                    if ((appWarnFastAvg > appWarnSlowAvg) && (avgExceedPercent > WARNING_PERCENTAGE)) {
                        genNotification(appItem.key, detail.label.toString(), !appWarnActive);
                        if (!appWarnActive) {
                            appWarnActive = true;
                        }
                    } else {
                        appWarnActive = false;
                    }
                    appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples, MIN_SLOW_SAMPLE_COUNT, bytesDelta);
                    appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples, MIN_FAST_SAMPLE_COUNT, bytesDelta);
                    updateDb(appItem.key, appWarnSlowAvg, appWarnSlowSamples, appWarnFastAvg, appWarnFastSamples, appWarnActive ? 1 : 0, appItem.total);
                }
            } else {
                // not enough BW consumed during this sample - simply update bytes
                updateDb(appItem.key, appItem.total);
            }
        }
    }
    cursor.close();
}
#method_after
private void dataUsageUpdate() {
    long startTime = 0;
    long endTime = System.currentTimeMillis();
    mLargest = 0;
    clearStats();
    NetworkStats networkStats = null;
    try {
        if (mStatsSession != null) {
            networkStats = mStatsSession.getSummaryForAllUid(mTemplate, startTime, endTime, false);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException: " + e.getMessage());
    }
    // collect network stats for all app consuming bw
    if (networkStats != null) {
        int size = networkStats.size();
        NetworkStats.Entry entry = null;
        for (int i = 0; i < size; i++) {
            entry = networkStats.getValues(i, entry);
            int collapseKey;
            int category;
            int uid = entry.uid;
            int userId = UserHandle.getUserId(uid);
            if (UserHandle.isApp(uid)) {
                if (mProfiles.contains(new UserHandle(userId))) {
                    if (userId != mCurrentUserId) {
                        // add to a managed user item
                        int managedKey = UidDetailProvider.buildKeyForUser(userId);
                        accumulate(managedKey, entry, AppItem.CATEGORY_USER);
                    }
                    collapseKey = uid;
                    category = AppItem.CATEGORY_APP;
                } else {
                    // if it is a removed user, add it to the removed users' key
                    UserInfo userInfo = mUserManager.getUserInfo(userId);
                    if (userInfo == null) {
                        collapseKey = UID_REMOVED;
                        category = AppItem.CATEGORY_APP;
                    } else {
                        collapseKey = UidDetailProvider.buildKeyForUser(userId);
                        category = AppItem.CATEGORY_USER;
                    }
                }
                accumulate(collapseKey, entry, category);
            }
        }
    }
    boolean appWarnActive = false;
    long appWarnBytes = 0;
    long appWarnUid;
    int appWarnSlowSamples;
    int appWarnFastSamples;
    long appWarnSlowAvg;
    long appWarnFastAvg;
    String appWarnExtra = "";
    // lookup Apps in the DB that have warning enabled
    Cursor cursor = getContentResolver().query(DataUsageContract.CONTENT_URI, // projection - return all
    null, DataUsageContract.ENABLE + " = ? ", new String[] { "1" }, null);
    if (cursor == null) {
        return;
    }
    while (cursor.moveToNext()) {
        appWarnUid = cursor.getInt(DataUsageContract.COLUMN_OF_UID);
        appWarnActive = cursor.getInt(DataUsageContract.COLUMN_OF_ACTIVE) > 0;
        appWarnBytes = cursor.getLong(DataUsageContract.COLUMN_OF_BYTES);
        appWarnSlowSamples = cursor.getInt(DataUsageContract.COLUMN_OF_SLOW_SAMPLES);
        appWarnSlowAvg = cursor.getLong(DataUsageContract.COLUMN_OF_SLOW_AVG);
        appWarnFastSamples = cursor.getInt(DataUsageContract.COLUMN_OF_FAST_SAMPLES);
        appWarnFastAvg = cursor.getLong(DataUsageContract.COLUMN_OF_FAST_AVG);
        mAppWarnExtra = cursor.getString(DataUsageContract.COLUMN_OF_EXTRA);
        AppItem appItem = mKnownItems.get((int) appWarnUid);
        if (appItem != null) {
            final UidDetail detail = mUidDetailProvider.getUidDetail(appItem.key, true);
            long bytesDelta = appWarnBytes == 0 ? 0 : appItem.total - appWarnBytes;
            if (DEBUG) {
                Log.v(TAG, detail.label.toString() + " cur:" + appItem.total + " prev:" + appWarnBytes + " SlowSamples:" + appWarnSlowSamples + " SlowAvg:" + appWarnSlowAvg + " FastSamples:" + appWarnFastSamples + " FastAvg:" + appWarnFastAvg);
            }
            if (bytesDelta > MAX_IDLE_BW) {
                // enough BW consumed during this sample - evaluate algorithm
                if (appWarnSlowSamples < MIN_SLOW_SAMPLE_COUNT) {
                    // not enough samples acquired for the slow average, keep accumulating
                    // samples
                    appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples, MIN_SLOW_SAMPLE_COUNT, bytesDelta);
                    appWarnSlowSamples++;
                    // we may have accumulated enough or not, need to check
                    if (appWarnFastSamples < MIN_FAST_SAMPLE_COUNT) {
                        // not enough fast samples
                        appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples, MIN_FAST_SAMPLE_COUNT, bytesDelta);
                        appWarnFastSamples++;
                    } else {
                        // enough fast samples
                        appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples, MIN_FAST_SAMPLE_COUNT, bytesDelta);
                    }
                    updateDb(appItem.key, appWarnSlowAvg, appWarnSlowSamples, appWarnFastAvg, appWarnFastSamples, 0, appItem.total);
                } else {
                    // enough samples acquired for the average, evaluate warning algorithm
                    float avgExceedPercent = appWarnFastAvg - appWarnSlowAvg;
                    avgExceedPercent /= appWarnSlowAvg;
                    avgExceedPercent *= 100;
                    if ((appWarnFastAvg > appWarnSlowAvg) && (avgExceedPercent > WARNING_PERCENTAGE)) {
                        genNotification(appItem.key, detail.label.toString(), !appWarnActive);
                        if (!appWarnActive) {
                            appWarnActive = true;
                        }
                    } else {
                        appWarnActive = false;
                    }
                    appWarnSlowAvg = computeAvg(appWarnSlowAvg, appWarnSlowSamples, MIN_SLOW_SAMPLE_COUNT, bytesDelta);
                    appWarnFastAvg = computeAvg(appWarnFastAvg, appWarnFastSamples, MIN_FAST_SAMPLE_COUNT, bytesDelta);
                    updateDb(appItem.key, appWarnSlowAvg, appWarnSlowSamples, appWarnFastAvg, appWarnFastSamples, appWarnActive ? 1 : 0, appItem.total);
                }
            } else {
                // not enough BW consumed during this sample - simply update bytes
                updateDb(appItem.key, appItem.total);
            }
        }
    }
    cursor.close();
}
#end_block

#method_before
private String genExtraInfo(long bytes) {
    Gson gson = new Gson();
    DataUsageExtraInfo extraInfo;
    if (mAppWarnExtra == null || mAppWarnExtra == "") {
        extraInfo = null;
    } else {
        try {
            extraInfo = gson.fromJson(mAppWarnExtra, DataUsageExtraInfo.class);
        } catch (Exception e) {
            extraInfo = null;
        }
    }
    if (extraInfo == null) {
        extraInfo = new DataUsageExtraInfo();
        extraInfo.samples = new ArrayList<Long>();
    }
    if (extraInfo.samples.size() == MAX_EXTRA_SAMPLE_COUNT) {
        extraInfo.samples.remove(0);
    }
    extraInfo.samples.add(bytes);
    String extraInfoJson = gson.toJson(extraInfo);
    return extraInfoJson;
}
#method_after
private String genExtraInfo(long bytes) {
    if (!DEBUG) {
        return "";
    }
    Gson gson = new Gson();
    DataUsageExtraInfo extraInfo;
    if (mAppWarnExtra == null || mAppWarnExtra == "") {
        extraInfo = null;
    } else {
        try {
            extraInfo = gson.fromJson(mAppWarnExtra, DataUsageExtraInfo.class);
        } catch (Exception e) {
            extraInfo = null;
        }
    }
    if (extraInfo == null) {
        extraInfo = new DataUsageExtraInfo();
        extraInfo.samples = new ArrayList<Long>();
    }
    if (extraInfo.samples.size() == MAX_EXTRA_SAMPLE_COUNT) {
        extraInfo.samples.remove(0);
    }
    extraInfo.samples.add(bytes);
    String extraInfoJson = gson.toJson(extraInfo);
    return extraInfoJson;
}
#end_block

#method_before
private void genNotification(long uid, String appTitle, boolean firstTime) {
    Intent hideIntent = new Intent();
    hideIntent.setAction(HIDE_ACTION);
    hideIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
    hideIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
    PendingIntent hidePendingIntent = PendingIntent.getBroadcast(mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, hideIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    Intent disableIntent = new Intent();
    disableIntent.setAction(DISABLE_ACTION);
    disableIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
    disableIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
    PendingIntent disablePendingIntent = PendingIntent.getBroadcast(mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, disableIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    Intent dataUsageIntent = new Intent();
    dataUsageIntent.setAction(cyanogenmod.content.Intent.ACTION_DATA_USAGE);
    dataUsageIntent.addCategory(Intent.CATEGORY_DEFAULT);
    // dataUsageIntent.setData(Uri.parse("package:" + mContext.getPackageName()));
    dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    PendingIntent dataUsagePendingIntent = PendingIntent.getActivity(mContext, 0, dataUsageIntent, 0);
    // NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)
    Notification.Builder builder = new Notification.Builder(mContext).setSmallIcon(R.drawable.data_usage_48dp).setContentTitle(getResources().getString(R.string.data_usage_notify_title)).setAutoCancel(// remove notification when clicked on
    true).setContentText(// non-expanded view message
    appTitle).setColor(mContext.getColor(R.color.data_usage_notification_icon_color)).setStyle(new Notification.BigTextStyle().bigText(getResources().getString(R.string.data_usage_notify_big_text, appTitle)));
    if (firstTime) {
        builder.addAction(// android.R.drawable.stat_sys_data_bluetooth,
        R.drawable.data_usage_disable_24dp, getResources().getString(R.string.data_usage_disable_long), disablePendingIntent);
    } else {
        builder.addAction(// android.R.drawable.stat_sys_data_bluetooth,
        R.drawable.data_usage_disable_24dp, getResources().getString(R.string.data_usage_disable_short), disablePendingIntent);
        builder.addAction(// android.R.drawable.stat_sys_download_done,
        R.drawable.data_usage_hide_24dp, getResources().getString(R.string.data_usage_hide), hidePendingIntent);
    }
    builder.setContentIntent(dataUsagePendingIntent);
    mNotificationManager.notify(DATA_USAGE_SERVICE_NOTIFICATION_ID, builder.build());
}
#method_after
private void genNotification(long uid, String appTitle, boolean firstTime) {
    Intent hideIntent = new Intent();
    hideIntent.setAction(HIDE_ACTION);
    hideIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
    hideIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
    PendingIntent hidePendingIntent = PendingIntent.getBroadcast(mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, hideIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    Intent disableIntent = new Intent();
    disableIntent.setAction(DISABLE_ACTION);
    disableIntent.putExtra(DATA_USAGE_NOTIFICATION_UID, uid);
    disableIntent.putExtra(DATA_USAGE_NOTIFICATION_TITLE, appTitle);
    PendingIntent disablePendingIntent = PendingIntent.getBroadcast(mContext, DATA_USAGE_BROADCAST_REQUEST_CODE, disableIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    Intent dataUsageIntent = new Intent();
    dataUsageIntent.setAction(cyanogenmod.providers.CMSettings.ACTION_DATA_USAGE);
    dataUsageIntent.addCategory(Intent.CATEGORY_DEFAULT);
    dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    dataUsageIntent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
    PendingIntent dataUsagePendingIntent = PendingIntent.getActivity(mContext, 0, dataUsageIntent, 0);
    // NotificationCompat.Builder builder = new NotificationCompat.Builder(mContext)
    Notification.Builder builder = new Notification.Builder(mContext).setSmallIcon(R.drawable.data_usage_48dp).setContentTitle(getResources().getString(R.string.data_usage_notify_title)).setAutoCancel(// remove notification when clicked on
    true).setContentText(// non-expanded view message
    appTitle).setColor(mContext.getColor(R.color.data_usage_notification_icon_color)).setStyle(new Notification.BigTextStyle().bigText(getResources().getString(R.string.data_usage_notify_big_text, appTitle)));
    if (firstTime) {
        builder.addAction(// android.R.drawable.stat_sys_data_bluetooth,
        R.drawable.data_usage_disable_24dp, getResources().getString(R.string.data_usage_disable_long), disablePendingIntent);
    } else {
        builder.addAction(// android.R.drawable.stat_sys_data_bluetooth,
        R.drawable.data_usage_disable_24dp, getResources().getString(R.string.data_usage_disable_short), disablePendingIntent);
        builder.addAction(// android.R.drawable.stat_sys_download_done,
        R.drawable.data_usage_hide_24dp, getResources().getString(R.string.data_usage_hide), hidePendingIntent);
    }
    builder.setContentIntent(dataUsagePendingIntent);
    mNotificationManager.notify(DATA_USAGE_SERVICE_NOTIFICATION_ID, builder.build());
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    DataUsageUtils.startDataUsageServiceIfEnabled(context);
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    boolean qualified = DataUsageUtils.isDataUsageQualified(context);
    // on qualified network and the service itself is enabled from the Settings->DataUsage
    if (qualified) {
        DataUsageUtils.startDataUsageServiceIfEnabled(context);
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    boolean enb = intent.getBooleanExtra("enable", false);
    DataUsageUtils.enbDataUsageService(context, enb);
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    boolean enb = intent.getBooleanExtra("enable", false);
    DataUsageUtils.enableDataUsageService(context, enb);
}
#end_block

#method_before
@Override
public void onCreate(SQLiteDatabase db) {
    // setup database schema
    db.execSQL("CREATE TABLE " + DataUsageContract.DATAUSAGE_TABLE + "(" + DataUsageContract._ID + " INTEGER PRIMARY KEY, " + DataUsageContract.UID + " INTEGER, " + DataUsageContract.ENB + " INTEGER DEFAULT 0, " + DataUsageContract.ACTIVE + " INTEGER DEFAULT 0, " + DataUsageContract.LABEL + " STRING, " + DataUsageContract.BYTES + " INTEGER DEFAULT 0, " + DataUsageContract.SLOW_AVG + " INTEGER DEFAULT 0, " + DataUsageContract.SLOW_SAMPLES + " INTEGER DEFAULT 0, " + DataUsageContract.FAST_AVG + " INTEGER DEFAULT 0, " + DataUsageContract.FAST_SAMPLES + " INTEGER DEFAULT 0, " + DataUsageContract.EXTRA + " STRING );");
}
#method_after
@Override
public void onCreate(SQLiteDatabase db) {
    // setup database schema
    db.execSQL("CREATE TABLE " + DataUsageContract.DATAUSAGE_TABLE + "(" + DataUsageContract._ID + " INTEGER PRIMARY KEY, " + DataUsageContract.UID + " INTEGER, " + DataUsageContract.ENABLE + " INTEGER DEFAULT 0, " + DataUsageContract.ACTIVE + " INTEGER DEFAULT 0, " + DataUsageContract.LABEL + " STRING, " + DataUsageContract.BYTES + " INTEGER DEFAULT 0, " + DataUsageContract.SLOW_AVG + " INTEGER DEFAULT 0, " + DataUsageContract.SLOW_SAMPLES + " INTEGER DEFAULT 0, " + DataUsageContract.FAST_AVG + " INTEGER DEFAULT 0, " + DataUsageContract.FAST_SAMPLES + " INTEGER DEFAULT 0, " + DataUsageContract.EXTRA + " STRING );");
}
#end_block

#method_before
@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    long count = 0;
    int match = sURIMatcher.match(uri);
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    String uid;
    if (DEBUG) {
        Log.v(TAG, "Update uri=" + uri + ", match=" + match);
    }
    switch(match) {
        case DATAUSAGE_ALL:
            uid = selectionArgs[0];
            break;
        case DATAUSAGE_UID:
            if (selection != null || selectionArgs != null) {
                throw new UnsupportedOperationException("Cannot update URI " + uri + " with a select clause");
            }
            selection = DataUsageContract.UID + " = ? ";
            uid = uri.getLastPathSegment();
            selectionArgs = new String[] { uid };
            break;
        default:
            throw new UnsupportedOperationException("Cannot update that URI: " + uri);
    }
    // if no record is found, then perform an insert, so make the db transaction atomic
    if (DEBUG) {
        Log.v(TAG, "Update: Values:" + values.toString() + " selection:" + selection + " " + " selectionArgs:" + selectionArgs[0]);
    }
    // count = db.update(DATAUSAGE_TABLE, values, selection, selectionArgs);
    db.beginTransaction();
    try {
        count = db.update(DataUsageContract.DATAUSAGE_TABLE, values, selection, selectionArgs);
        if (DEBUG) {
            Log.v(TAG, "Update count:" + count);
        }
        if (count == 0) {
            if (DEBUG) {
                Log.v(TAG, "Count==0, Performing Insert");
            }
            values.put(DataUsageContract.UID, uid);
            count = db.insert(DataUsageContract.DATAUSAGE_TABLE, null, values);
        }
        db.setTransactionSuccessful();
    } finally {
        if (DEBUG) {
            Log.v(TAG, "dbEndTransaction");
        }
        db.endTransaction();
    }
    if (DEBUG) {
        Log.v(TAG, "Update result for uri=" + uri + " count=" + count);
    }
    return (int) count;
}
#method_after
@Override
public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
    long count = 0;
    int match = sURIMatcher.match(uri);
    SQLiteDatabase db = mOpenHelper.getWritableDatabase();
    String uid;
    if (DEBUG) {
        Log.v(TAG, "Update uri=" + uri + ", match=" + match);
    }
    switch(match) {
        case DATAUSAGE_ALL:
            uid = selectionArgs[0];
            break;
        case DATAUSAGE_UID:
            if (selection != null || selectionArgs != null) {
                throw new UnsupportedOperationException("Cannot update URI " + uri + " with a select clause");
            }
            selection = DataUsageContract.UID + " = ? ";
            uid = uri.getLastPathSegment();
            selectionArgs = new String[] { uid };
            break;
        default:
            throw new UnsupportedOperationException("Cannot update that URI: " + uri);
    }
    // if no record is found, then perform an insert, so make the db transaction atomic
    if (DEBUG) {
        Log.v(TAG, "Update: Values:" + values.toString() + " selection:" + selection + " " + " selectionArgs:" + selectionArgs[0]);
    }
    db.beginTransaction();
    try {
        count = db.update(DataUsageContract.DATAUSAGE_TABLE, values, selection, selectionArgs);
        if (DEBUG) {
            Log.v(TAG, "Update count:" + count);
        }
        if (count == 0) {
            if (DEBUG) {
                Log.v(TAG, "Count==0, Performing Insert");
            }
            values.put(DataUsageContract.UID, uid);
            count = db.insert(DataUsageContract.DATAUSAGE_TABLE, null, values);
        }
        db.setTransactionSuccessful();
    } finally {
        if (DEBUG) {
            Log.v(TAG, "dbEndTransaction");
        }
        db.endTransaction();
    }
    if (DEBUG) {
        Log.v(TAG, "Update result for uri=" + uri + " count=" + count);
    }
    return (int) count;
}
#end_block

#method_before
@Override
protected void onHandleIntent(Intent intent) {
    String action = intent.getAction();
    Context context = this;
    final boolean added;
    final boolean changed;
    final boolean removed;
    if ("ANDROID.INTENT.ACTION.PACKAGE_ADDED".equalsIgnoreCase(action)) {
        added = true;
        removed = false;
    } else if ("ANDROID.INTENT.ACTION.PACKAGE_CHANGED".equalsIgnoreCase(action)) {
        added = false;
        removed = false;
        changed = true;
    } else if ("ANDROID.INTENT.ACTION.PACKAGE_REPLACED".equalsIgnoreCase(action)) {
        added = false;
        removed = false;
        changed = true;
    } else if ("ANDROID.INTENT.ACTION.PACKAGE_REMOVED".equalsIgnoreCase(action)) {
        added = false;
        removed = true;
    } else if ("ANDROID.INTENT.ACTION.PACKAGE_FULLY_REMOVED".equalsIgnoreCase(action)) {
        added = false;
        removed = true;
    } else {
        Log.e(TAG, "Unknown Action:" + action);
        return;
    }
    int uid = -1;
    if (intent.hasExtra(Intent.EXTRA_UID)) {
        uid = intent.getIntExtra(Intent.EXTRA_UID, 0);
    }
    if (uid <= 0) {
        Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
        return;
    }
    UidDetailProvider uidDetailProvider = new UidDetailProvider(context);
    UidDetail uidDetail = uidDetailProvider.getUidDetail(uid, true);
    String label = "";
    if (uidDetail != null) {
        label = uidDetail.label.toString();
    }
    if (added) {
        if (DEBUG) {
            Log.v(TAG, "Adding " + label + " to DataUsage DB");
        }
        DataUsageUtils.addApp(context, uid, label);
    } else if (removed) {
        if (DEBUG) {
            Log.v(TAG, "Removing " + label + " to DataUsage DB");
        }
        DataUsageUtils.removeApp(context, uid);
    }
}
#method_after
@Override
protected void onHandleIntent(Intent intent) {
    String action = intent.getAction();
    Context context = this;
    final boolean added;
    final boolean removed;
    if (Intent.ACTION_PACKAGE_ADDED.equalsIgnoreCase(action)) {
        added = true;
        removed = false;
    } else if (Intent.ACTION_PACKAGE_CHANGED.equalsIgnoreCase(action)) {
        added = false;
        removed = false;
    } else if (Intent.ACTION_PACKAGE_REPLACED.equalsIgnoreCase(action)) {
        added = false;
        removed = false;
    } else if (Intent.ACTION_PACKAGE_REMOVED.equalsIgnoreCase(action)) {
        added = false;
        removed = true;
    } else if (Intent.ACTION_PACKAGE_FULLY_REMOVED.equalsIgnoreCase(action)) {
        added = false;
        removed = true;
    } else {
        Log.e(TAG, "Unknown Action:" + action);
        return;
    }
    int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);
    if (uid <= 0) {
        Log.e(TAG, "Invalid UID:" + uid + " for Action:" + action);
        return;
    }
    UidDetailProvider uidDetailProvider = new UidDetailProvider(context);
    UidDetail uidDetail = uidDetailProvider.getUidDetail(uid, true);
    String label = "";
    if (uidDetail != null) {
        label = uidDetail.label.toString();
    }
    if (added) {
        if (DEBUG) {
            Log.v(TAG, "Adding " + label + " to DataUsage DB");
        }
        DataUsageUtils.addApp(context, uid, label);
    } else if (removed) {
        if (DEBUG) {
            Log.v(TAG, "Removing " + label + " to DataUsage DB");
        }
        DataUsageUtils.removeApp(context, uid);
    }
}
#end_block

#method_before
public static void startDataUsageService(Context context, boolean enb) {
    Intent dataUsageServiceIntent = new Intent(context, DataUsageService.class);
    PendingIntent alarmIntent = PendingIntent.getService(context, DATAUSAGE_SERVICE_ALARM_ID, dataUsageServiceIntent, 0);
    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    if (enb) {
        alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME, DataUsageService.START_DELAY, DataUsageService.SAMPLE_PERIOD, alarmIntent);
    } else {
        alarmManager.cancel(alarmIntent);
    }
    if (DEBUG) {
        Log.v(TAG, "enbDataUsageService: enb:" + enb);
    }
}
#method_after
public static void startDataUsageService(Context context, boolean enable) {
    Intent dataUsageServiceIntent = new Intent(context, DataUsageService.class);
    PendingIntent alarmIntent = PendingIntent.getService(context, DATAUSAGE_SERVICE_ALARM_ID, dataUsageServiceIntent, 0);
    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    if (enable) {
        alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME, DataUsageService.START_DELAY, DataUsageService.SAMPLE_PERIOD, alarmIntent);
    } else {
        alarmManager.cancel(alarmIntent);
    }
    if (DEBUG) {
        Log.v(TAG, "enableDataUsageService: enable:" + enable);
    }
}
#end_block

#method_before
public static void startDataUsageServiceIfEnabled(Context context) {
    SharedPreferences prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
    boolean enb = prefs.getBoolean(PREF_ENB_DATA_USAGE_NOTIFY, false);
    if (enb) {
        startDataUsageService(context, true);
    }
    if (DEBUG) {
        Log.v(TAG, "startDataUsageServiceIfEnabled: enb: " + enb);
    }
}
#method_after
public static void startDataUsageServiceIfEnabled(Context context) {
    SharedPreferences prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE);
    boolean enable = prefs.getBoolean(PREF_ENABLE_DATA_USAGE_NOTIFY, false);
    if (enable) {
        startDataUsageService(context, true);
    }
    if (DEBUG) {
        Log.v(TAG, "startDataUsageServiceIfEnabled: enable: " + enable);
    }
}
#end_block

