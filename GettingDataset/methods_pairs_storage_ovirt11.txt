1060
#method_before
@Override
public void render(Context context, T value, SafeHtmlBuilder sb, String id) {
    if (isEnabled(value)) {
        enabledIcon.setId(id);
        SafeHtml enabledHtml = SafeHtmlUtils.fromSafeConstant(enabledIcon.toString());
        sb.append(enabledHtml);
    } else {
        disabledIcon.setId(id);
        SafeHtml disabledHtml = SafeHtmlUtils.fromSafeConstant(disabledIcon.toString());
        sb.append(disabledHtml);
    }
}
#method_after
@Override
public void render(Context context, T value, SafeHtmlBuilder sb, String id) {
    Icon icon = new Icon();
    icon.setId(id);
    StyleHelper.addEnumStyleName(icon, iconType);
    // $NON-NLS-1$ //$NON-NLS-2$
    icon.addStyleName(isEnabled(value) ? "icon-enabled" : "icon-disabled");
    sb.append(SafeHtmlUtils.fromSafeConstant(icon.toString()));
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
void initTable() {
    final String elementIdPrefix = getTable().getContentTableElementId();
    ImageResource mask = resources.disabledSmallMask();
    AbstractUserportalMaskedDataurlImageColumn maskedVmImageColumn = new AbstractUserportalMaskedDataurlImageColumn(mask) {

        @Override
        public Guid getIconId(UserPortalItemModel itemModel) {
            return itemModel.getSmallIconId();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(maskedVmImageColumn, constants.empty(), "77px");
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn(), constants.empty(), "55px");
    AbstractCell<UserPortalItemModel> nameAndDescriptionCell = new AbstractCell<UserPortalItemModel>() {

        @Override
        public void render(Context context, UserPortalItemModel item, SafeHtmlBuilder sb, String id) {
            sb.append(templates.vmNameCellItem(id, item.getName()));
            String description = item.getDescription();
            if (description != null && !description.isEmpty()) {
                sb.append(templates.vmDescriptionCellItem(description));
            }
        }
    };
    AbstractColumn<UserPortalItemModel, UserPortalItemModel> nameAndDescriptionColumn = new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(nameAndDescriptionCell) {

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel item) {
            return item;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameAndDescriptionColumn, constants.empty(), "400px");
    ConsoleButtonCell openConsoleCell = new ConsoleButtonCell(resources.sideTabExtendedVmStyle().enabledConsoleButton(), resources.sideTabExtendedVmStyle().disabledConsoleButton(), new AbstractConsoleButtonCell.ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            try {
                if (!model.isPool()) {
                    model.getVmConsoles().connect();
                }
            } catch (VmConsoles.ConsoleConnectException e) {
                errorPopupManager.show(e.getLocalizedErrorMessage());
            }
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.openConsoleLabel());
        }
    };
    openConsoleCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    openConsoleCell.setColumnId("openConsoleButton");
    getTable().addColumn(new AbstractColumn(openConsoleCell) {

        @Override
        public Object getValue(Object object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "100px");
    ConsoleEditButtonCell consoleEditCell = new ConsoleEditButtonCell(resources.sideTabExtendedVmStyle().enabledEditConsoleButton(), resources.sideTabExtendedVmStyle().disabledEditConsoleButton(), new AbstractConsoleButtonCell.ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            getModel().getEditConsoleCommand().execute();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.editConsoleLabel());
        }
    };
    consoleEditCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    consoleEditCell.setColumnId("editConsoleButton");
    getTable().addColumn(new AbstractColumn(consoleEditCell) {

        @Override
        public Object getValue(Object object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    // start
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new // $NON-NLS-1$ //$NON-NLS-2$
    AbstractIconButtonCell<UserPortalItemModel>(// $NON-NLS-1$ //$NON-NLS-2$
    IconType.ARROW_UP, // $NON-NLS-1$ //$NON-NLS-2$
    "#ffffff", // $NON-NLS-1$ //$NON-NLS-2$
    "#888888") {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.isPool() ? value.getTakeVmCommand() : value.getRunCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(value.isPool() ? constants.takeVmLabel() : constants.runVmLabel());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // shutdown
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new // $NON-NLS-1$ //$NON-NLS-2$
    AbstractIconButtonCell<UserPortalItemModel>(// $NON-NLS-1$ //$NON-NLS-2$
    IconType.ARROW_DOWN, // $NON-NLS-1$ //$NON-NLS-2$
    "#ffffff", // $NON-NLS-1$ //$NON-NLS-2$
    "#888888") {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.isPool() ? value.getReturnVmCommand() : value.getShutdownCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(value.isPool() ? constants.returnVmLabel() : constants.shutDownVm());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // suspend
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new // $NON-NLS-1$ //$NON-NLS-2$
    AbstractIconButtonCell<UserPortalItemModel>(// $NON-NLS-1$ //$NON-NLS-2$
    IconType.PAUSE, // $NON-NLS-1$ //$NON-NLS-2$
    "#ffffff", // $NON-NLS-1$ //$NON-NLS-2$
    "#888888") {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.getPauseCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.suspendVmLabel());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // poweroff
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new // $NON-NLS-1$ //$NON-NLS-2$
    AbstractIconButtonCell<UserPortalItemModel>(// $NON-NLS-1$ //$NON-NLS-2$
    IconType.CLOSE, // $NON-NLS-1$ //$NON-NLS-2$
    "#ffffff", // $NON-NLS-1$ //$NON-NLS-2$
    "#888888") {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.getStopCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.powerOffVm());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // reboot
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new // $NON-NLS-1$ //$NON-NLS-2$
    AbstractIconButtonCell<UserPortalItemModel>(// $NON-NLS-1$ //$NON-NLS-2$
    IconType.REFRESH, // $NON-NLS-1$ //$NON-NLS-2$
    "#ffffff", // $NON-NLS-1$ //$NON-NLS-2$
    "#888888") {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.getRebootCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.rebootVm());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewTemplateCommand();
        }
    });
    getTable().setExtraRowStyles(new RowStyles<UserPortalItemModel>() {

        @Override
        public String getStyleNames(UserPortalItemModel row, int rowIndex) {
            if (row == null) {
                return null;
            }
            if (isSelectedRow(row)) {
                return null;
            }
            return row.isVmUp() ? resources.sideTabExtendedVmStyle().vmUpRow() : resources.sideTabExtendedVmStyle().vmDownRow();
        }

        protected boolean isSelectedRow(UserPortalItemModel row) {
            UserPortalItemModel selectedModel = getModel().getSelectedItem();
            if (selectedModel != null) {
                if (modelProvider.getKey(selectedModel).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            List<UserPortalItemModel> selectedModels = getModel().getSelectedItems();
            if (selectedModels == null) {
                return false;
            }
            for (UserPortalItemModel model : selectedModels) {
                if (modelProvider.getKey(model).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            return false;
        }
    });
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
void initTable() {
    final String elementIdPrefix = getTable().getContentTableElementId();
    ImageResource mask = resources.disabledSmallMask();
    AbstractUserportalMaskedDataurlImageColumn maskedVmImageColumn = new AbstractUserportalMaskedDataurlImageColumn(mask) {

        @Override
        public Guid getIconId(UserPortalItemModel itemModel) {
            return itemModel.getSmallIconId();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(maskedVmImageColumn, constants.empty(), "77px");
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn(), constants.empty(), "55px");
    AbstractCell<UserPortalItemModel> nameAndDescriptionCell = new AbstractCell<UserPortalItemModel>() {

        @Override
        public void render(Context context, UserPortalItemModel item, SafeHtmlBuilder sb, String id) {
            sb.append(templates.vmNameCellItem(id, item.getName()));
            String description = item.getDescription();
            if (description != null && !description.isEmpty()) {
                sb.append(templates.vmDescriptionCellItem(description));
            }
        }
    };
    AbstractColumn<UserPortalItemModel, UserPortalItemModel> nameAndDescriptionColumn = new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(nameAndDescriptionCell) {

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel item) {
            return item;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameAndDescriptionColumn, constants.empty(), "400px");
    ConsoleButtonCell openConsoleCell = new ConsoleButtonCell(resources.sideTabExtendedVmStyle().enabledConsoleButton(), resources.sideTabExtendedVmStyle().disabledConsoleButton(), new AbstractConsoleButtonCell.ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            try {
                if (!model.isPool()) {
                    model.getVmConsoles().connect();
                }
            } catch (VmConsoles.ConsoleConnectException e) {
                errorPopupManager.show(e.getLocalizedErrorMessage());
            }
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.openConsoleLabel());
        }
    };
    openConsoleCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    openConsoleCell.setColumnId("openConsoleButton");
    getTable().addColumn(new AbstractColumn(openConsoleCell) {

        @Override
        public Object getValue(Object object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "100px");
    ConsoleEditButtonCell consoleEditCell = new ConsoleEditButtonCell(resources.sideTabExtendedVmStyle().enabledEditConsoleButton(), resources.sideTabExtendedVmStyle().disabledEditConsoleButton(), new AbstractConsoleButtonCell.ConsoleButtonCommand() {

        @Override
        public void execute(UserPortalItemModel model) {
            getModel().getEditConsoleCommand().execute();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.editConsoleLabel());
        }
    };
    consoleEditCell.setElementIdPrefix(elementIdPrefix);
    // $NON-NLS-1$
    consoleEditCell.setColumnId("editConsoleButton");
    getTable().addColumn(new AbstractColumn(consoleEditCell) {

        @Override
        public Object getValue(Object object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    // start
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new AbstractIconButtonCell<UserPortalItemModel>(IconType.PLAY) {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.isPool() ? value.getTakeVmCommand() : value.getRunCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(value.isPool() ? constants.takeVmLabel() : constants.runVmLabel());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // shutdown
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new AbstractIconButtonCell<UserPortalItemModel>(IconType.STOP) {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.isPool() ? value.getReturnVmCommand() : value.getShutdownCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(value.isPool() ? constants.returnVmLabel() : constants.shutDownVm());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // suspend
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new AbstractIconButtonCell<UserPortalItemModel>(IconType.PAUSE) {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.getPauseCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.suspendVmLabel());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // poweroff
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(new AbstractIconButtonCell<UserPortalItemModel>(IconType.POWER_OFF) {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.getStopCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.powerOffVm());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "15px");
    // reboot
    getTable().addColumn(new AbstractColumn<UserPortalItemModel, UserPortalItemModel>(// updated with the latest version of patternfly
    new AbstractIconButtonCell<UserPortalItemModel>(IconType.REFRESH) {

        @Override
        protected UICommand resolveCommand(UserPortalItemModel value) {
            return value.getRebootCommand();
        }
    }) {

        @Override
        public SafeHtml getTooltip(UserPortalItemModel value) {
            return SafeHtmlUtils.fromSafeConstant(constants.rebootVm());
        }

        @Override
        public UserPortalItemModel getValue(UserPortalItemModel object) {
            return object;
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getEditCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.changeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new UserPortalButtonDefinition<UserPortalItemModel>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewTemplateCommand();
        }
    });
    getTable().setExtraRowStyles(new RowStyles<UserPortalItemModel>() {

        @Override
        public String getStyleNames(UserPortalItemModel row, int rowIndex) {
            if (row == null) {
                return null;
            }
            if (isSelectedRow(row)) {
                return null;
            }
            return row.isVmUp() ? resources.sideTabExtendedVmStyle().vmUpRow() : resources.sideTabExtendedVmStyle().vmDownRow();
        }

        protected boolean isSelectedRow(UserPortalItemModel row) {
            UserPortalItemModel selectedModel = getModel().getSelectedItem();
            if (selectedModel != null) {
                if (modelProvider.getKey(selectedModel).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            List<UserPortalItemModel> selectedModels = getModel().getSelectedItems();
            if (selectedModels == null) {
                return false;
            }
            for (UserPortalItemModel model : selectedModels) {
                if (modelProvider.getKey(model).equals(modelProvider.getKey(row))) {
                    return true;
                }
            }
            return false;
        }
    });
}
#end_block

#method_before
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        final Map<String, String> contextSubstitutions = new HashMap<>();
        contextSubstitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        contextSubstitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        setupLogger();
        ArgumentsParser parser;
        final Map<String, String> substitutions = new HashMap<>(contextSubstitutions);
        try (InputStream stream = SsoRegistrationToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        log.debug("Version: {}-{} ({})", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                log.error(t.getMessage());
                log.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        DBUtils dbUtils = new DBUtils();
        log.info("=========================================================================");
        log.info("================== oVirt Sso Client Registration Tool ===================");
        log.info("=========================================================================");
        String clientId = getUserInput("Client Id: ");
        String certificateFile = getUserInput("Certificate File Location: ");
        while (!new File(certificateFile).exists()) {
            System.out.println(String.format("%s is not a valid certificate, please enter path to an existing certificate.", certificateFile));
            certificateFile = getUserInput("Enter Certificate File Location: ");
        }
        String callbackPrefix = getUserInput("Callback Prefix URL: ");
        while (!callbackPrefix.startsWith("http") && !callbackPrefix.startsWith("https")) {
            System.out.println(String.format("%s is not a valid URL, please enter a proper URL.", callbackPrefix));
            callbackPrefix = getUserInput("Enter Callback Prefix URL: ");
        }
        String clientSecret = generateClientSecret();
        String encodedClientSecret = encode(argMap, clientSecret);
        dbUtils.unregisterClient(clientId);
        dbUtils.registerClient(clientId, encodedClientSecret, certificateFile, callbackPrefix);
        String tmpFile = createTmpSsoClientConfFile(clientId, clientSecret, certificateFile, callbackPrefix);
        System.out.println("Client registration completed successfully");
        System.out.println(String.format("Client secret has been written to file %s", tmpFile));
        log.info("========================================================================");
        log.info("========================= Execution Completed ==========================");
        log.info("========================================================================");
        exitStatus = 0;
    } catch (ExitException e) {
        log.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        t.printStackTrace();
        log.error(t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    }
    log.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#method_after
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        final Map<String, String> contextSubstitutions = new HashMap<>();
        contextSubstitutions.put("@ENGINE_ETC@", ENGINE_ETC);
        contextSubstitutions.put("@PROGRAM_NAME@", PROGRAM_NAME);
        setupLogger();
        ArgumentsParser parser;
        final Map<String, String> substitutions = new HashMap<>(contextSubstitutions);
        try (InputStream stream = SsoRegistrationToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
            parser.getSubstitutions().putAll(substitutions);
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        log.debug("Version: {}-{} ({})", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                log.error(t.getMessage());
                log.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        DBUtils dbUtils = new DBUtils();
        log.info("=========================================================================");
        log.info("================== oVirt Sso Client Registration Tool ===================");
        log.info("=========================================================================");
        String clientId = getUserInput("Client Id: ");
        String certificateFile = getUserInput("Client CA Certificate File Location: ");
        while (!new File(certificateFile).exists()) {
            System.out.format("%s is not a valid certificate, please enter path to an existing certificate.%n", certificateFile);
            certificateFile = getUserInput("Enter Client CA Certificate File Location: ");
        }
        String callbackPrefix = getUserInput("Callback Prefix URL: ");
        while (!callbackPrefix.startsWith("http") && !callbackPrefix.startsWith("https")) {
            System.out.format("%s is not a valid URL, please enter a proper URL.%n", callbackPrefix);
            callbackPrefix = getUserInput("Enter Callback Prefix URL: ");
        }
        String clientSecret = generateClientSecret();
        String encodedClientSecret = encode(argMap, clientSecret);
        dbUtils.unregisterClient(clientId);
        dbUtils.registerClient(clientId, encodedClientSecret, certificateFile, callbackPrefix);
        String tmpFile = createTmpSsoClientConfFile(clientId, clientSecret, certificateFile, callbackPrefix);
        System.out.println("Client registration completed successfully");
        System.out.format("Client secret has been written to file %s%n", tmpFile);
        log.info("========================================================================");
        log.info("========================= Execution Completed ==========================");
        log.info("========================================================================");
        exitStatus = 0;
    } catch (ExitException e) {
        log.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        t.printStackTrace();
        log.error(t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    }
    log.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#end_block

#method_before
private static void setupLogger(Map<String, Object> args) throws IOException {
    Logger log = Logger.getLogger("");
    String logfile = (String) args.get("log-file");
    if (logfile != null) {
        FileHandler fh = new FileHandler(new File(EngineLocalConfig.getInstance().getLogDir(), logfile).getAbsolutePath(), true);
        fh.setFormatter(new SimpleFormatter());
        log.addHandler(fh);
    }
    OVIRT_LOGGER.setLevel((Level) args.get("log-level"));
}
#method_after
private static void setupLogger(Map<String, Object> args) throws IOException {
    Logger log = Logger.getLogger("");
    String logfile = (String) args.get("log-file");
    if (logfile != null) {
        FileHandler fh = new FileHandler(new File(SsoLocalConfig.getInstance().getLogDir(), logfile).getAbsolutePath(), true);
        fh.setFormatter(new SimpleFormatter());
        log.addHandler(fh);
    }
    OVIRT_LOGGER.setLevel((Level) args.get("log-level"));
}
#end_block

#method_before
private static String createTmpSsoClientConfFile(String clientId, String clientSecret, String certificateFile, String callbackPrefix) throws FileNotFoundException {
    File tmpFile = new File(EngineLocalConfig.getInstance().getTmpDir(), String.format("99_sso_client_%s.conf", System.currentTimeMillis()));
    try (PrintWriter pw = new PrintWriter(new FileOutputStream(tmpFile))) {
        pw.println(String.format("SSO_CLIENT_ID=%s", clientId));
        pw.println(String.format("SSO_CLIENT_SECRET=%s", clientSecret));
        pw.println(String.format("SSO_CLIENT_CERTIFICATE_FILE=%s", certificateFile));
        pw.println(String.format("SSO_CLIENT_CALLBACK_PREFIX=%s", callbackPrefix));
    }
    return tmpFile.getAbsolutePath();
}
#method_after
private static String createTmpSsoClientConfFile(String clientId, String clientSecret, String certificateFile, String callbackPrefix) throws FileNotFoundException {
    File tmpFile = new File(SsoLocalConfig.getInstance().getTmpDir(), String.format("99_sso_client_%s.conf", System.currentTimeMillis()));
    try (PrintWriter pw = new PrintWriter(new FileOutputStream(tmpFile))) {
        pw.println(String.format("SSO_CLIENT_ID=%s", clientId));
        pw.println(String.format("SSO_CLIENT_SECRET=%s", clientSecret));
        pw.println(String.format("SSO_CLIENT_CERTIFICATE_FILE=%s", certificateFile));
        pw.println(String.format("SSO_CLIENT_CALLBACK_PREFIX=%s", callbackPrefix));
    }
    return tmpFile.getAbsolutePath();
}
#end_block

#method_before
public static String escapeUnderScore(final String customizedValue, final String customizedRelation) {
    String escapedValue = customizedValue;
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        String replaceWith = "_";
        int pgMajorRelease = Config.<Integer>getValue(ConfigValues.PgMajorRelease);
        if (pgMajorRelease == SyntaxChecker.PgMajorRelease.PG8.getValue()) {
            replaceWith = "\\\\_";
        } else if (pgMajorRelease == SyntaxChecker.PgMajorRelease.PG9.getValue()) {
            replaceWith = "\\_";
        }
        escapedValue = customizedValue.replace("_", replaceWith);
    }
    return escapedValue;
}
#method_after
public static String escapeUnderScore(final String customizedValue, final String customizedRelation) {
    String escapedValue = customizedValue;
    if (customizedRelation.equalsIgnoreCase("LIKE") || customizedRelation.equalsIgnoreCase("ILIKE")) {
        // Since '_' is treated in Postgres as '?' when using like, (i.e. match any single character)
        // we have to escape this character in the value to make it treated as a regular character.
        // Due to changes between PG8.x and PG9.x on ESCAPE representation in a string, we should
        // figure out what PG Release is running in order to escape the special character(_) correctly
        // This is done in a IF block and not with Method Factory pattern since this is the only change
        // right now, if we encounter other changes, this will be refactored to use the Method Factory pattern.
        escapedValue = customizedValue.replace("_", getEscapedCharacter("_"));
    }
    return escapedValue;
}
#end_block

#method_before
@Override
protected boolean validate() {
    VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getCustomCompatibilityVersion() != null && !VersionSupport.checkVersionSupported(getVm().getCustomCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_COMATIBILITY_VERSION_NOT_SUPPORTED, String.format("$VmName %1$s", getVm().getName()), String.format("$VmVersion %1$s", getVm().getCustomCompatibilityVersion().toString()), String.format("$DcVersion %1$s", getStoragePool().getCompatibilityVersion()));
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getValidationMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getCluster(), getParameters().isRunInUnknownStatus())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    boolean isWindowsOs = osRepository.isWindows(getVm().getVmOsId());
    boolean isCloudInitEnabled = (!getVm().isInitialized() && getVm().getVmInit() != null && !isWindowsOs) || (getParameters().getInitializationType() == InitializationType.CloudInit);
    if (isCloudInitEnabled && hasMaximumNumberOfDisks()) {
        return failValidation(EngineMessage.VMPAYLOAD_CDROM_OR_CLOUD_INIT_MAXIMUM_DEVICES);
    }
    if (!vmHandler.isCpuSupported(getVm().getVmOsId(), getVm().getCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    try {
        acquireHostDevicesLock();
        if (!checkRequiredHostDevicesAvailability()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
        }
    } finally {
        releaseHostDevicesLock();
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getCustomCompatibilityVersion() != null && vm.getCustomCompatibilityVersion().less(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_COMATIBILITY_VERSION_NOT_SUPPORTED, String.format("$VmName %1$s", getVm().getName()), String.format("$VmVersion %1$s", getVm().getCustomCompatibilityVersion().toString()), String.format("$DcVersion %1$s", getStoragePool().getCompatibilityVersion()));
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getValidationMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getCluster(), getParameters().isRunInUnknownStatus())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    boolean isWindowsOs = osRepository.isWindows(getVm().getVmOsId());
    boolean isCloudInitEnabled = (!getVm().isInitialized() && getVm().getVmInit() != null && !isWindowsOs) || (getParameters().getInitializationType() == InitializationType.CloudInit);
    if (isCloudInitEnabled && hasMaximumNumberOfDisks()) {
        return failValidation(EngineMessage.VMPAYLOAD_CDROM_OR_CLOUD_INIT_MAXIMUM_DEVICES);
    }
    if (!vmHandler.isCpuSupported(getVm().getVmOsId(), getVm().getCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    try {
        acquireHostDevicesLock();
        if (!checkRequiredHostDevicesAvailability()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
        }
    } finally {
        releaseHostDevicesLock();
    }
    return true;
}
#end_block

#method_before
private void initRootNodeTable(EntityModelCellTable<ListModel<LunModel>> table) {
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    }, constants.lunIdSanStorage());
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            // $NON-NLS-1$
            return String.valueOf(model.getSize()) + "GB";
        }
    }, constants.devSizeSanStorage(), // $NON-NLS-1$
    "70px");
    table.addColumn(new AbstractLunAvailableSizeColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    }, constants.devAdditionalSizeSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    }, constants.pathSanStorage(), // $NON-NLS-1$
    "55px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    }, constants.vendorIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    }, constants.productIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    }, constants.serialSanStorage(), // $NON-NLS-1$
    "120px");
}
#method_after
private void initRootNodeTable(EntityModelCellTable<ListModel<LunModel>> table) {
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    }, constants.lunIdSanStorage());
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    }, constants.devSizeSanStorage(), // $NON-NLS-1$
    "70px");
    table.addColumn(new AbstractLunAvailableSizeColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    }, constants.devAdditionalSizeSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    }, constants.pathSanStorage(), // $NON-NLS-1$
    "55px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    }, constants.vendorIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    }, constants.productIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    }, constants.serialSanStorage(), // $NON-NLS-1$
    "120px");
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            // $NON-NLS-1$
            return String.valueOf(model.getSize()) + "GB";
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "120px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%", true);
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(new Handler() {

            @Override
            public void onSelectionChange(SelectionChangeEvent event) {
                SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
                selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
                if (selectedLunModel != null) {
                    updateSelectedLunWarning(selectedLunModel);
                    sortedLeafModel.setSelectedItem(selectedLunModel);
                }
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(new Handler() {

            @Override
            public void onSelectionChange(SelectionChangeEvent event) {
                model.updateLunWarningForDiscardAfterDelete();
            }
        });
    }
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    item.setWidget(panel);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "120px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%", true);
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(new Handler() {

            @Override
            public void onSelectionChange(SelectionChangeEvent event) {
                SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
                selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
                if (selectedLunModel != null) {
                    updateSelectedLunWarning(selectedLunModel);
                    sortedLeafModel.setSelectedItem(selectedLunModel);
                }
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(new Handler() {

            @Override
            public void onSelectionChange(SelectionChangeEvent event) {
                model.updateLunWarningForDiscardAfterDelete();
            }
        });
    }
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    item.setWidget(panel);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    return item;
}
#end_block

#method_before
private void validateDiscardAfterDelete() {
    if (getDiscardAfterDelete().getIsAvailable() && getDiscardAfterDelete().getEntity()) {
        SanStorageModelBase sanStorageModel = (SanStorageModelBase) getCurrentStorageItem();
        Collection<LunModel> luns = sanStorageModel.getAddedLuns();
        if (luns != null && !storageDomainSupportsDiscard(luns)) {
            getDiscardAfterDelete().setIsValid(false);
            getDiscardAfterDelete().getInvalidityReasons().add(constants.discardIsNotSupportedByUnderlyingStorage());
            return;
        }
    }
    getDiscardAfterDelete().setIsValid(true);
}
#method_after
private void validateDiscardAfterDelete() {
    if (getDiscardAfterDelete().getIsAvailable() && getDiscardAfterDelete().getEntity()) {
        SanStorageModelBase sanStorageModel = (SanStorageModelBase) getCurrentStorageItem();
        Collection<LunModel> luns = sanStorageModel.getSelectedLuns();
        if (luns != null && !storageDomainSupportsDiscard(luns)) {
            getDiscardAfterDelete().getInvalidityReasons().add(constants.discardIsNotSupportedByUnderlyingStorage());
            getDiscardAfterDelete().setIsValid(false);
            return;
        }
    }
    getDiscardAfterDelete().setIsValid(true);
}
#end_block

#method_before
private boolean storageDomainSupportsDiscard(Collection<LunModel> luns) {
    for (LunModel lun : luns) {
        Long discardMaxSize = lun.getEntity().getDiscardMaxSize();
        if (discardMaxSize != null && discardMaxSize == 0) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean storageDomainSupportsDiscard(Collection<LunModel> luns) {
    for (LunModel lun : luns) {
        if (!lun.getEntity().supportsDiscard()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void updateLunWarningForDiscardAfterDelete() {
    if (getContainer().getDiscardAfterDelete().getEntity()) {
        for (LunModel lunModel : getAddedLuns()) {
            if (!lunSupportsDiscard(lunModel.getEntity())) {
                setSelectedLunWarning(constants.discardIsNotSupportedByUnderlyingStorage());
                return;
            }
        }
    }
    setSelectedLunWarning(constants.emptyString());
}
#method_after
public void updateLunWarningForDiscardAfterDelete() {
    if (getContainer().getDiscardAfterDelete().getEntity()) {
        for (LunModel lunModel : getSelectedLuns()) {
            if (!lunModel.getEntity().supportsDiscard()) {
                setSelectedLunWarning(constants.discardIsNotSupportedByUnderlyingStorage());
                return;
            }
        }
    }
    setSelectedLunWarning(constants.emptyString());
}
#end_block

#method_before
public ArrayList<LunModel> getAddedLuns() {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (getIsGrouppedByTarget()) {
        List<SanTargetModel> items = (List<SanTargetModel>) getItems();
        for (SanTargetModel item : items) {
            for (LunModel lun : item.getLuns()) {
                if (lun.getIsSelected() && !lun.getIsIncluded() && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
                    luns.add(lun);
                }
            }
        }
    } else {
        List<LunModel> items = (List<LunModel>) getItems();
        for (LunModel lun : items) {
            if (lun.getIsSelected() && !lun.getIsIncluded() && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
                luns.add(lun);
            }
        }
    }
    return luns;
}
#method_after
public ArrayList<LunModel> getAddedLuns() {
    return getLuns(true, false);
}
#end_block

#method_before
public ArrayList<LunModel> getAddedLuns() {
    ArrayList<LunModel> luns = new ArrayList<>();
    if (getIsGrouppedByTarget()) {
        List<SanTargetModel> items = (List<SanTargetModel>) getItems();
        for (SanTargetModel item : items) {
            for (LunModel lun : item.getLuns()) {
                if (lun.getIsSelected() && !lun.getIsIncluded() && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
                    luns.add(lun);
                }
            }
        }
    } else {
        List<LunModel> items = (List<LunModel>) getItems();
        for (LunModel lun : items) {
            if (lun.getIsSelected() && !lun.getIsIncluded() && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
                luns.add(lun);
            }
        }
    }
    return luns;
}
#method_after
private Collection<LunModel> getAddedLuns(List<LunModel> lunModels, boolean selectedLuns, boolean includedLuns) {
    Collection<LunModel> luns = new LinkedList<>();
    for (LunModel lun : lunModels) {
        if (((selectedLuns && lun.getIsSelected() && !lun.getIsIncluded()) || (includedLuns && lun.getIsIncluded() && !lun.getIsSelected())) && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
            luns.add(lun);
        }
    }
    return luns;
}
#end_block

#method_before
public boolean supportsDiscard() {
    return getDiscardMaxSize() != null && getDiscardMaxSize() > 0;
}
#method_after
@JsonIgnore
public boolean supportsDiscard() {
    return getDiscardMaxSize() != null && getDiscardMaxSize() > 0;
}
#end_block

#method_before
public boolean hasDiscardZeroesTheDataSupport() {
    return Boolean.TRUE.equals(getDiscardZeroesData());
}
#method_after
@JsonIgnore
public boolean hasDiscardZeroesTheDataSupport() {
    return Boolean.TRUE.equals(getDiscardZeroesData());
}
#end_block

#method_before
private Collection<LunModel> getAddedLuns(List<LunModel> lunModels, boolean selectedLuns, boolean includedLuns) {
    Collection<LunModel> luns = new LinkedList<>();
    for (LunModel lun : lunModels) {
        if ((selectedLuns && lun.getIsSelected()) || (includedLuns && lun.getIsIncluded()) && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
            luns.add(lun);
        }
    }
    return luns;
}
#method_after
private Collection<LunModel> getAddedLuns(List<LunModel> lunModels, boolean selectedLuns, boolean includedLuns) {
    Collection<LunModel> luns = new LinkedList<>();
    for (LunModel lun : lunModels) {
        if (((selectedLuns && lun.getIsSelected() && !lun.getIsIncluded()) || (includedLuns && lun.getIsIncluded() && !lun.getIsSelected())) && Linq.firstOrNull(luns, new Linq.LunPredicate(lun)) == null) {
            luns.add(lun);
        }
    }
    return luns;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    } else {
        vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    }
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void restoreCommandState() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = !getVmId().equals(Guid.Empty) && getVm() != null;
}
#method_after
private void restoreCommandState() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
}
#end_block

#method_before
@Override
public void beginTree(DetailAST aRootAST) {
    if (!run) {
        return;
    }
    if (!getFileContents().getFileName().matches(".*\\.java")) {
        return;
    }
    if (getFileContents().getFileName().contains("generated-sources")) {
        return;
    }
    int i = 0;
    boolean startAnnotation = false;
    for (String lineText : getLines()) {
        ++i;
        // Ignore strings passed as annotation parameters
        if (lineText.matches("^\\s*@.*")) {
            int parenthesesStart = lineText.indexOf("(");
            while (parenthesesStart != -1 && getFileContents().hasIntersectionWithComment(i, parenthesesStart, i, parenthesesStart)) {
                parenthesesStart = lineText.indexOf("(", parenthesesStart + 1);
            }
            if (parenthesesStart != -1) {
                startAnnotation = true;
            }
        }
        List<QuotedString> stringList = new LinkedList<>();
        Matcher matcher = patternString.matcher(lineText);
        while (matcher.find()) {
            if (getFileContents().hasIntersectionWithComment(i, matcher.start(), i, matcher.end())) {
                continue;
            }
            stringList.add(new QuotedString(matcher.group(), matcher.start(), matcher.end()));
        }
        if (startAnnotation) {
            int endAnno = hasEndAnno(lineText, i, stringList);
            if (endAnno != -1) {
                startAnnotation = false;
                // maybe the rest of the line has quoted string
                List<QuotedString> tmpStringList = new LinkedList<>();
                for (QuotedString quotedString : stringList) {
                    if (quotedString.startIndex > endAnno) {
                        tmpStringList.add(quotedString);
                    }
                }
                stringList = tmpStringList;
            } else {
                continue;
            }
        }
        int j = 0;
        for (QuotedString str : stringList) {
            ++j;
            // $NON-NLS-1$//$NON-NLS-2$
            Pattern patternNls = Pattern.compile("\\$NON-NLS-" + j + "\\$");
            Matcher matcherNls = patternNls.matcher(lineText);
            int matchNum = 0;
            while (matcherNls.find()) {
                ++matchNum;
            }
            if (matchNum != 1) {
                log(i, "String on line " + i + " is non-localized." + "\n Please localize it via Constants/Messages interface or add //$NON-NLS-" + j + "$" + // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
                " comment to indicate that it shouldn't be localized.");
            }
        }
    }
}
#method_after
@Override
public void beginTree(DetailAST aRootAST) {
    if (!run) {
        return;
    }
    if (!getFileContents().getFileName().matches(".*\\.java")) {
        return;
    }
    int i = 0;
    boolean startAnnotation = false;
    for (String lineText : getLines()) {
        ++i;
        // Ignore strings passed as annotation parameters
        if (lineText.matches("^\\s*@.*")) {
            int parenthesesStart = lineText.indexOf("(");
            while (parenthesesStart != -1 && getFileContents().hasIntersectionWithComment(i, parenthesesStart, i, parenthesesStart)) {
                parenthesesStart = lineText.indexOf("(", parenthesesStart + 1);
            }
            if (parenthesesStart != -1) {
                startAnnotation = true;
            }
        }
        List<QuotedString> stringList = new LinkedList<>();
        Matcher matcher = patternString.matcher(lineText);
        while (matcher.find()) {
            if (getFileContents().hasIntersectionWithComment(i, matcher.start(), i, matcher.end())) {
                continue;
            }
            stringList.add(new QuotedString(matcher.group(), matcher.start(), matcher.end()));
        }
        if (startAnnotation) {
            int endAnno = hasEndAnno(lineText, i, stringList);
            if (endAnno != -1) {
                startAnnotation = false;
                // maybe the rest of the line has quoted string
                List<QuotedString> tmpStringList = new LinkedList<>();
                for (QuotedString quotedString : stringList) {
                    if (quotedString.startIndex > endAnno) {
                        tmpStringList.add(quotedString);
                    }
                }
                stringList = tmpStringList;
            } else {
                continue;
            }
        }
        int j = 0;
        for (QuotedString str : stringList) {
            ++j;
            Pattern patternNls = Pattern.compile("\\$NON-NLS-" + j + "\\$");
            Matcher matcherNls = patternNls.matcher(lineText);
            int matchNum = 0;
            while (matcherNls.find()) {
                ++matchNum;
            }
            if (matchNum != 1) {
                log(i, "String on line " + i + " (at index " + str.startIndex + ") is non-localized.\n" + "Please localize it via Constants/Messages interface " + "or use //$NON-NLS-" + j + "$" + " comment to indicate that it shouldn't be localized.");
            }
        }
    }
}
#end_block

#method_before
protected void setQcowCompat(DiskImage diskImage) {
    diskImage.setQcowCompat(QcowCompat.QCOW2_V2);
    if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId(), true);
        if (qemuImageInfo != null) {
            diskImage.setQcowCompat(qemuImageInfo.getQcowCompat());
        }
    }
}
#method_after
protected void setQcowCompat(DiskImage diskImage) {
    diskImage.setQcowCompat(QcowCompat.QCOW2_V2);
    if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId(), null, true);
        if (qemuImageInfo != null) {
            diskImage.setQcowCompat(qemuImageInfo.getQcowCompat());
        }
    }
    imageDao.update(diskImage.getImage());
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (isCopyCollapseOrNoSnapshots()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setVolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            if (VolumeFormat.COW.equals(disk.getVolumeFormat())) {
                setQcowCompat(disk);
            }
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskVmElement(disk.getId(), getVmId(), disk.getDiskVmElementForVm(getParameters().getVmId()));
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            if (VolumeFormat.COW.equals(disk.getVolumeFormat())) {
                setQcowCompat(disk);
            }
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
            saveDiskVmElement(disk.getId(), getVmId(), disk.getDiskVmElementForVm(getParameters().getVmId()));
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
    if (isCopyCollapseOrNoSnapshots()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setVolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskVmElement(disk.getId(), getVmId(), disk.getDiskVmElementForVm(getParameters().getVmId()));
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
            saveDiskVmElement(disk.getId(), getVmId(), disk.getDiskVmElementForVm(getParameters().getVmId()));
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    }
}
#method_after
protected void endActionOnAllImageGroups() {
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        getBackend().endAction(VdcActionType.CopyImageGroup, p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        initQcowVersionForDisks(((MoveOrCopyImageGroupParameters) p).getDestImageGroupId());
    }
}
#end_block

#method_before
public static QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, boolean shouldPrepareAndTeardown) {
    Guid vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#method_after
public static QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, Guid vdsId, boolean shouldPrepareAndTeardown) {
    if (vdsId == null) {
        vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    }
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#end_block

#method_before
public void connect() throws ClientConnectionException {
    if (isOpen()) {
        return;
    }
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (isOpen() && isInInit()) {
            getPostConnectCallback().await(policy.getRetryTimeOut(), policy.getTimeUnit());
        }
        if (isOpen()) {
            return;
        }
        final FutureTask<SocketChannel> task = scheduleTask(new Retryable<>(() -> {
            InetAddress address = InetAddress.getByName(hostname);
            log.info("Connecting to " + address);
            final InetSocketAddress addr = new InetSocketAddress(address, port);
            final SocketChannel socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
            socketChannel.connect(addr);
            return socketChannel;
        }, this.policy));
        this.channel = task.get();
        final long timeout = getTimeout(policy.getRetryTimeOut(), policy.getTimeUnit());
        while (!this.channel.finishConnect()) {
            final FutureTask<SocketChannel> connectTask = scheduleTask(new Retryable<>(() -> {
                if (System.currentTimeMillis() >= timeout) {
                    throw new ConnectException("Connection timeout");
                }
                return null;
            }, this.policy));
            connectTask.get();
        }
        updateLastIncomingHeartbeat();
        updateLastOutgoingHeartbeat();
        if (!isOpen()) {
            throw new ClientConnectionException("Connection failed");
        }
        this.closing.set(false);
        clean();
        postConnect(getPostConnectCallback());
    } catch (InterruptedException | ExecutionException e) {
        logException(log, "Exception during connection", e);
        final String message = "Connection issue " + getRootCause(e).getMessage();
        scheduleClose(message);
        throw new ClientConnectionException(e);
    } catch (IOException e) {
        closeChannel();
        throw new ClientConnectionException("Connection failed", e);
    }
}
#method_after
public void connect() throws ClientConnectionException {
    if (isOpen()) {
        return;
    }
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (isOpen() && isInInit()) {
            getPostConnectCallback().await(policy.getRetryTimeOut(), policy.getTimeUnit());
        }
        if (isOpen()) {
            return;
        }
        final FutureTask<SocketChannel> task = scheduleTask(new Retryable<>(() -> {
            InetAddress address = InetAddress.getByName(hostname);
            log.info("Connecting to " + address);
            final InetSocketAddress addr = new InetSocketAddress(address, port);
            final SocketChannel socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
            socketChannel.connect(addr);
            return socketChannel;
        }, this.policy));
        this.channel = task.get();
        final long timeout = getTimeout(policy.getRetryTimeOut(), policy.getTimeUnit());
        while (!this.channel.finishConnect()) {
            final FutureTask<SocketChannel> connectTask = scheduleTask(new Retryable<>(() -> {
                if (System.currentTimeMillis() >= timeout) {
                    throw new ConnectException("Connection timeout");
                }
                return null;
            }, this.policy));
            connectTask.get();
        }
        updateLastIncomingHeartbeat();
        updateLastOutgoingHeartbeat();
        if (!isOpen()) {
            throw new ClientConnectionException("Connection failed");
        }
        this.closing.set(false);
        clean();
        postConnect(getPostConnectCallback());
    } catch (InterruptedException | ExecutionException e) {
        logException(log, "Exception during connection", e);
        final String message = "Connection issue " + ExceptionUtils.getRootCause(e).getMessage();
        scheduleClose(message);
        throw new ClientConnectionException(e);
    } catch (IOException e) {
        closeChannel();
        throw new ClientConnectionException("Connection failed", e);
    }
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered OAuthTokenInfo QueryString: {}, Parameters : {}", request.getQueryString(), SsoUtils.getRequestParameters(request));
    boolean isValidateRequest = false;
    boolean isSearchAuthzRequest;
    boolean isPublicSearchAuthzRequest;
    try {
        String scope = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_SCOPE, "");
        isValidateRequest = SsoUtils.scopeAsList(scope).contains(SsoConstants.VALIDATE_SCOPE);
        isSearchAuthzRequest = SsoUtils.scopeAsList(scope).contains(SsoConstants.AUTHZ_SEARCH_SCOPE);
        isPublicSearchAuthzRequest = SsoUtils.scopeAsList(scope).contains(SsoConstants.PUBLIC_AUTHZ_SEARCH_SCOPE);
        SsoUtils.validateClientAcceptHeader(request);
        if (isValidateRequest) {
            String token = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_TOKEN);
            SsoUtils.getSsoSession(request, null, token, true);
            SsoUtils.sendJsonData(response, Collections.emptyMap());
        } else {
            String[] clientIdAndSecret = SsoUtils.getClientIdClientSecret(request);
            SsoUtils.validateClientRequest(request, clientIdAndSecret[0], clientIdAndSecret[1], null, null);
            if (isSearchAuthzRequest || isPublicSearchAuthzRequest) {
                validateQueryType(request);
            }
            if (!isPublicSearchAuthzRequest) {
                String token = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_TOKEN);
                SsoUtils.validateRequestScope(request, token, scope);
                SsoUtils.getSsoSession(request, clientIdAndSecret[0], token, true).getAssociatedClientIds().add(clientIdAndSecret[0]);
            }
            log.debug("Sending json response");
            SsoUtils.sendJsonData(response, isSearchAuthzRequest || isPublicSearchAuthzRequest ? buildSearchResponse(request, isPublicSearchAuthzRequest) : buildResponse(request, clientIdAndSecret[0], scope));
        }
    } catch (OAuthException ex) {
        SsoUtils.sendJsonDataWithMessage(response, ex, isValidateRequest);
    } catch (Exception ex) {
        SsoUtils.sendJsonDataWithMessage(response, SsoConstants.ERR_CODE_SERVER_ERROR, ex);
    }
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    log.debug("Entered OAuthTokenInfo QueryString: {}, Parameters : {}", request.getQueryString(), SsoUtils.getRequestParameters(request));
    boolean isValidateRequest = false;
    boolean isSearchAuthzRequest;
    boolean isPublicSearchAuthzRequest;
    try {
        String scope = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_SCOPE, "");
        isValidateRequest = SsoUtils.scopeAsList(scope).contains(SsoConstants.VALIDATE_SCOPE);
        isSearchAuthzRequest = SsoUtils.scopeAsList(scope).contains(SsoConstants.AUTHZ_SEARCH_SCOPE);
        isPublicSearchAuthzRequest = SsoUtils.scopeAsList(scope).contains(SsoConstants.PUBLIC_AUTHZ_SEARCH_SCOPE);
        SsoUtils.validateClientAcceptHeader(request);
        if (isValidateRequest) {
            String token = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_TOKEN);
            SsoUtils.getSsoSession(request, null, token, true);
            log.debug("Sending json response");
            SsoUtils.sendJsonData(response, Collections.emptyMap());
        } else {
            String[] clientIdAndSecret = SsoUtils.getClientIdClientSecret(request);
            SsoUtils.validateClientRequest(request, clientIdAndSecret[0], clientIdAndSecret[1], null, null);
            if (isSearchAuthzRequest || isPublicSearchAuthzRequest) {
                validateQueryType(request);
            }
            if (!isPublicSearchAuthzRequest) {
                String token = SsoUtils.getRequestParameter(request, SsoConstants.HTTP_PARAM_TOKEN);
                SsoUtils.validateRequestScope(request, token, scope);
                SsoUtils.getSsoSession(request, clientIdAndSecret[0], token, true).getAssociatedClientIds().add(clientIdAndSecret[0]);
            }
            log.debug("Sending json response");
            SsoUtils.sendJsonData(response, isSearchAuthzRequest || isPublicSearchAuthzRequest ? buildSearchResponse(request, isPublicSearchAuthzRequest) : buildResponse(request, clientIdAndSecret[0], scope));
        }
    } catch (OAuthException ex) {
        SsoUtils.sendJsonDataWithMessage(response, ex, isValidateRequest);
    } catch (Exception ex) {
        SsoUtils.sendJsonDataWithMessage(response, SsoConstants.ERR_CODE_SERVER_ERROR, ex);
    }
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
public static void initErrataGrid(HasColumns grid) {
    grid.enableColumnResizing();
    AbstractIconTypeColumn<Erratum> errataTypeColumn = new AbstractIconTypeColumn<Erratum>() {

        @Override
        public IconType getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                // $NON-NLS-1$
                getCell().setColor(SafeHtmlUtils.fromTrustedString("ORANGERED"));
                return IconType.BUG;
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                // $NON-NLS-1$
                getCell().setColor(SafeHtmlUtils.fromTrustedString("BLUE"));
                return IconType.PLUS_SQUARE;
            } else if (erratum.getType() == ErrataType.SECURITY) {
                // $NON-NLS-1$
                getCell().setColor(SafeHtmlUtils.fromTrustedString("DARKORANGE"));
                return IconType.WARNING;
            }
            return null;
        }
    };
    errataTypeColumn.makeSortable(new ErrataTypeComparator());
    // $NON-NLS-1$ //$NON-NLS-2$
    grid.addColumn(errataTypeColumn, "", "30px");
    AbstractTextColumn errataTypeTextColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                return constants.bug();
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                return constants.enhancement();
            } else if (erratum.getType() == ErrataType.SECURITY) {
                return constants.security();
            }
            return constants.unknown();
        }
    };
    errataTypeTextColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(errataTypeTextColumn, constants.errataType(), "150px");
    AbstractTextColumn<Erratum> errataSeverityColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getSeverity() == ErrataSeverity.CRITICAL) {
                return constants.critical();
            } else if (erratum.getSeverity() == ErrataSeverity.IMPORTANT) {
                return constants.important();
            } else if (erratum.getSeverity() == ErrataSeverity.MODERATE) {
                return constants.moderate();
            }
            return constants.unknown();
        }
    };
    errataSeverityColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(errataSeverityColumn, constants.errataSeverity(), "150px");
    AbstractFullDateTimeColumn<Erratum> dateIssuedColumn = new AbstractFullDateTimeColumn<Erratum>(false) {

        @Override
        protected Date getRawValue(Erratum erratum) {
            return erratum.getIssued();
        }
    };
    dateIssuedColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(dateIssuedColumn, constants.errataDateIssued(), "100px");
    AbstractTextColumn<Erratum> errataIdColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getId();
        }
    };
    errataIdColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(errataIdColumn, constants.errataId(), "115px");
    AbstractTextColumn<Erratum> titleColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getTitle();
        }
    };
    titleColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(titleColumn, constants.errataTitle(), "290px");
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
public static void initErrataGrid(HasColumns grid) {
    grid.enableColumnResizing();
    AbstractIconTypeColumn<Erratum> errataTypeColumn = new AbstractIconTypeColumn<Erratum>() {

        @Override
        public IconType getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                getCell().setColor(SafeHtmlUtils.fromTrustedString(ErrataType.BUGFIX.getColor()));
                return IconType.BUG;
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                getCell().setColor(SafeHtmlUtils.fromTrustedString(ErrataType.ENHANCEMENT.getColor()));
                return IconType.PLUS_SQUARE;
            } else if (erratum.getType() == ErrataType.SECURITY) {
                getCell().setColor(SafeHtmlUtils.fromTrustedString(ErrataType.SECURITY.getColor()));
                return IconType.WARNING;
            }
            return null;
        }
    };
    errataTypeColumn.makeSortable(new ErrataTypeComparator());
    // $NON-NLS-1$ //$NON-NLS-2$
    grid.addColumn(errataTypeColumn, "", "30px");
    AbstractTextColumn errataTypeTextColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getType() == ErrataType.BUGFIX) {
                return constants.bug();
            } else if (erratum.getType() == ErrataType.ENHANCEMENT) {
                return constants.enhancement();
            } else if (erratum.getType() == ErrataType.SECURITY) {
                return constants.security();
            }
            return constants.unknown();
        }
    };
    errataTypeTextColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(errataTypeTextColumn, constants.errataType(), "150px");
    AbstractTextColumn<Erratum> errataSeverityColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            if (erratum.getSeverity() == ErrataSeverity.CRITICAL) {
                return constants.critical();
            } else if (erratum.getSeverity() == ErrataSeverity.IMPORTANT) {
                return constants.important();
            } else if (erratum.getSeverity() == ErrataSeverity.MODERATE) {
                return constants.moderate();
            }
            return constants.unknown();
        }
    };
    errataSeverityColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(errataSeverityColumn, constants.errataSeverity(), "150px");
    AbstractFullDateTimeColumn<Erratum> dateIssuedColumn = new AbstractFullDateTimeColumn<Erratum>(false) {

        @Override
        protected Date getRawValue(Erratum erratum) {
            return erratum.getIssued();
        }
    };
    dateIssuedColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(dateIssuedColumn, constants.errataDateIssued(), "100px");
    AbstractTextColumn<Erratum> errataIdColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getId();
        }
    };
    errataIdColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(errataIdColumn, constants.errataId(), "115px");
    AbstractTextColumn<Erratum> titleColumn = new AbstractTextColumn<Erratum>() {

        @Override
        public String getValue(Erratum erratum) {
            return erratum.getTitle();
        }
    };
    titleColumn.makeSortable();
    // $NON-NLS-1$
    grid.addColumn(titleColumn, constants.errataTitle(), "290px");
}
#end_block

#method_before
protected SafeHtml getRenderedImage(IconType value, String color) {
    return TEMPLATE.icon(value.getCssName(), color);
}
#method_after
protected SafeHtml getRenderedImage(IconType value, String color) {
    SafeStyles styles = new SafeStylesBuilder().trustedColor(color).toSafeStyles();
    return TEMPLATE.icon(value.getCssName(), styles);
}
#end_block

#method_before
@Override
public void initialize() throws SchedulerConfigException {
    executorService = new ThreadPoolExecutor(10, count, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(queueSize), new SchedulerThreadFactory(this));
}
#method_after
@Override
public void initialize() throws SchedulerConfigException {
    executorService = new ThreadPoolExecutor(10, count, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(queueSize), new SchedulerThreadFactory(this), isReject() ? new ThreadPoolExecutor.AbortPolicy() : new BlockedRejectedExecutionHandler(log));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId(), getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    if (!updateVms()) {
        setSucceeded(false);
        return;
    }
    if (!updateTemplates()) {
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid newMacPoolId = getNewMacPoolId();
    moveMacs.moveMacsOfUpdatedCluster(oldCluster, newMacPoolId, getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    updateVms();
    updateTemplates();
    if (!failedUpgradeEntities.isEmpty()) {
        logFailedUpgrades();
        failValidation(Arrays.asList(EngineMessage.CLUSTER_CANNOT_UPDATE_CLUSTER_FAILED_TO_UPDATE_VMS), "$VmList " + StringUtils.join(failedUpgradeEntities.keySet(), ", "));
        getReturnValue().setValid(false);
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            addCustomValue("VmName", vm.getName());
            addCustomValue("Message", "todo");
            auditLogDirector.log(this, AuditLogType.CLUSTER_CANNOT_UPDATE_VM_COMPATIBILITY_VERSION);
            vm.setCustomCompatibilityVersion(oldCluster.getCompatibilityVersion());
            vmStaticDao.update(vm);
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        updateRngDeviceIfNecessary(vm.getId(), vm.getCustomCompatibilityVersion(), updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type VM");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(vm.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#end_block

#method_before
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        final UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        if (!parameters.isUpdateRngDevice()) {
            continue;
        }
        final VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            addCustomValue("TemplateName", template.getName());
            addCustomValue("Message", "todo");
            auditLogDirector.log(this, AuditLogType.CLUSTER_CANNOT_UPDATE_TEMPLATE_COMPATIBILITY_VERSION);
            template.setCustomCompatibilityVersion(oldCluster.getCompatibilityVersion());
            vmTemplateDao.update(template);
        }
    }
    return true;
}
#method_after
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        updateRngDeviceIfNecessary(template.getId(), template.getCustomCompatibilityVersion(), parameters);
        if (!parameters.isUpdateRngDevice()) {
            continue;
        }
        final VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            List<String> params = new ArrayList<>();
            params.add("$action Update");
            params.add("$type Template");
            params.add(parseErrorMessage(result.getValidationMessages()));
            List<String> messages = Backend.getInstance().getErrorsTranslator().translateErrorText(params);
            failedUpgradeEntities.put(template.getName(), getFailedMessage(messages));
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void init(final ProviderModel model) {
    super.init(model);
    registerHandler(getView().getTestButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getTestCommand().execute();
        }
    }));
    model.getTestResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setTestResultImage(model.getTestResult().getEntity());
        }
    });
    model.getNeutronAgentModel().isPluginConfigurationAvailable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setAgentTabVisibility(model.getNeutronAgentModel().isPluginConfigurationAvailable().getEntity());
        }
    });
    model.getDataCenter().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().updateDataCenterVisible(model.getDataCenter().getIsAvailable());
            }
        }
    });
    model.getKvmPropertiesModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().updateKvmVisible(model.getKvmPropertiesModel().getIsAvailable());
            }
        }
    });
    model.getVmwarePropertiesModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().updateVmwareVisible(model.getVmwarePropertiesModel().getIsAvailable());
            }
        }
    });
    model.getXenPropertiesModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().updateXenVisible(model.getXenPropertiesModel().getIsAvailable());
            }
        }
    });
}
#method_after
@Override
public void init(final ProviderModel model) {
    super.init(model);
    registerHandler(getView().getTestButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getTestCommand().execute();
        }
    }));
    model.getTestResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setTestResultImage(model.getTestResult().getEntity());
        }
    });
    model.getNeutronAgentModel().isPluginConfigurationAvailable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setAgentTabVisibility(model.getNeutronAgentModel().isPluginConfigurationAvailable().getEntity());
        }
    });
    model.getDataCenter().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().setCurrentActiveProviderWidget();
            }
        }
    });
    model.getKvmPropertiesModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().setCurrentActiveProviderWidget();
            }
        }
    });
    model.getVmwarePropertiesModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().setCurrentActiveProviderWidget();
            }
        }
    });
    model.getXenPropertiesModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (IS_AVAILABLE.equals(args.propertyName)) {
                getView().setCurrentActiveProviderWidget();
            }
        }
    });
}
#end_block

#method_before
@Override
public void edit(ProviderModel model) {
    setAgentTabVisibility(model.getNeutronAgentModel().isPluginConfigurationAvailable().getEntity());
    driver.edit(model);
    neutronAgentWidget.edit(model.getNeutronAgentModel());
    vmwarePropertiesWidget.edit(model.getVmwarePropertiesModel());
    kvmPropertiesWidget.edit(model.getKvmPropertiesModel());
    xenPropertiesWidget.edit(model.getXenPropertiesModel());
}
#method_after
@Override
public void edit(ProviderModel model) {
    providerModel = model;
    setAgentTabVisibility(model.getNeutronAgentModel().isPluginConfigurationAvailable().getEntity());
    driver.edit(model);
    neutronAgentWidget.edit(model.getNeutronAgentModel());
    vmwarePropertiesWidget.edit(model.getVmwarePropertiesModel());
    kvmPropertiesWidget.edit(model.getKvmPropertiesModel());
    xenPropertiesWidget.edit(model.getXenPropertiesModel());
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VmTemplate> nameColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameTemplate(), "160px");
    AbstractTextColumn<VmTemplate> versionNameColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            if (object.isBaseTemplate()) {
                // $NON-NLS-1$
                return "";
            }
            return // $NON-NLS-1$
            StringFormat.format(// $NON-NLS-1$
            "%s (%s)", // $NON-NLS-1$
            object.getTemplateVersionName() != null ? object.getTemplateVersionName() : "", object.getTemplateVersionNumber());
        }
    };
    versionNameColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(versionNameColumn, constants.versionTemplate(), "150px");
    AbstractTextColumn<VmTemplate> originColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getOrigin() == null ? messageConstants.notSpecifiedLabel() : object.getOrigin().toString();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originTemplate(), "160px");
    AbstractTextColumn<VmTemplate> memoryColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            // $NON-NLS-1$
            return String.valueOf(object.getMemSizeMb()) + " " + constants.mb();
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryTemplate(), "160px");
    AbstractTextColumn<VmTemplate> cpuColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "160px");
    AbstractTextColumn<VmTemplate> archColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "160px");
    AbstractTextColumn<VmTemplate> diskColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getDiskList().size());
        }
    };
    diskColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(diskColumn, constants.disksTemplate(), "160px");
    AbstractTextColumn<VmTemplate> creationDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getCreationDate();
        }
    };
    creationDateColumn.makeSortable(new Comparator<VmTemplate>() {

        @Override
        public int compare(VmTemplate t1, VmTemplate t2) {
            return t1.getCreationDate().compareTo(t2.getCreationDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateTemplate(), "160px");
    AbstractTextColumn<VmTemplate> exportDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getExportDate();
        }
    };
    exportDateColumn.makeSortable(new Comparator<VmTemplate>() {

        @Override
        public int compare(VmTemplate t1, VmTemplate t2) {
            return t1.getExportDate().compareTo(t2.getExportDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateTemplate(), "160px");
    getTable().addActionButton(new WebAdminButtonDefinition<VmTemplate>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRestoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VmTemplate>(constants.removeTemplate()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
    getTable().showRefreshButton();
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VmTemplate> nameColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameTemplate(), "160px");
    AbstractTextColumn<VmTemplate> versionNameColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            if (object.isBaseTemplate()) {
                // $NON-NLS-1$
                return "";
            }
            return // $NON-NLS-1$
            StringFormat.format(// $NON-NLS-1$
            "%s (%s)", // $NON-NLS-1$
            object.getTemplateVersionName() != null ? object.getTemplateVersionName() : "", object.getTemplateVersionNumber());
        }
    };
    versionNameColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(versionNameColumn, constants.versionTemplate(), "150px");
    AbstractTextColumn<VmTemplate> originColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getOrigin() == null ? messageConstants.notSpecifiedLabel() : object.getOrigin().toString();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originTemplate(), "160px");
    AbstractTextColumn<VmTemplate> memoryColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return messages.megabytes(String.valueOf(object.getMemSizeMb()));
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryTemplate(), "160px");
    AbstractTextColumn<VmTemplate> cpuColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "160px");
    AbstractTextColumn<VmTemplate> archColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "160px");
    AbstractTextColumn<VmTemplate> diskColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getDiskList().size());
        }
    };
    diskColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(diskColumn, constants.disksTemplate(), "160px");
    AbstractTextColumn<VmTemplate> creationDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getCreationDate();
        }
    };
    creationDateColumn.makeSortable(new Comparator<VmTemplate>() {

        @Override
        public int compare(VmTemplate t1, VmTemplate t2) {
            return t1.getCreationDate().compareTo(t2.getCreationDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateTemplate(), "160px");
    AbstractTextColumn<VmTemplate> exportDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getExportDate();
        }
    };
    exportDateColumn.makeSortable(new Comparator<VmTemplate>() {

        @Override
        public int compare(VmTemplate t1, VmTemplate t2) {
            return t1.getExportDate().compareTo(t2.getExportDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateTemplate(), "160px");
    getTable().addActionButton(new WebAdminButtonDefinition<VmTemplate>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRestoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VmTemplate>(constants.removeTemplate()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
    getTable().showRefreshButton();
}
#end_block

#method_before
private void initRootNodeTable(EntityModelCellTable<ListModel<LunModel>> table) {
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    }, constants.lunIdSanStorage());
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            // $NON-NLS-1$
            return String.valueOf(model.getSize()) + constants.gb();
        }
    }, constants.devSizeSanStorage(), // $NON-NLS-1$
    "70px");
    table.addColumn(new AbstractLunAvailableSizeColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    }, constants.devAdditionalSizeSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    }, constants.pathSanStorage(), // $NON-NLS-1$
    "55px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    }, constants.vendorIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    }, constants.productIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    }, constants.serialSanStorage(), // $NON-NLS-1$
    "120px");
}
#method_after
private void initRootNodeTable(EntityModelCellTable<ListModel<LunModel>> table) {
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    }, constants.lunIdSanStorage());
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    }, constants.devSizeSanStorage(), // $NON-NLS-1$
    "70px");
    table.addColumn(new AbstractLunAvailableSizeColumn() {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    }, constants.devAdditionalSizeSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    }, constants.pathSanStorage(), // $NON-NLS-1$
    "55px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    }, constants.vendorIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    }, constants.productIdSanStorage(), // $NON-NLS-1$
    "100px");
    table.addColumn(new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    }, constants.serialSanStorage(), // $NON-NLS-1$
    "120px");
}
#end_block

#method_before
@Override
protected void createEntityTable(RegisterTemplateModel model) {
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return getEntity(object).getName();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return getEntity(object).getOrigin();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            int size = getEntity(object).getMemSizeMb();
            // $NON-NLS-1$
            return size + " " + constants.mb();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            int numOfCpus = getEntity(object).getNumOfCpus();
            return String.valueOf(numOfCpus);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            ArchitectureType clusterArch = getEntity(object).getClusterArch();
            return String.valueOf(clusterArch);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            int numOfDisks = getEntity(object).getDiskTemplateMap().size();
            return String.valueOf(numOfDisks);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(diskColumn, constants.disksVm(), "50px");
    // $NON-NLS-1$
    entityTable.addColumn(getClusterColumn(), constants.clusterVm(), "150px");
    if (model.isQuotaEnabled()) {
        // $NON-NLS-1$
        entityTable.addColumn(getClusterQuotaColumn(), constants.quotaVm(), "150px");
    }
}
#method_after
@Override
protected void createEntityTable(RegisterTemplateModel model) {
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return getEntity(object).getName();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return getEntity(object).getOrigin();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            int size = getEntity(object).getMemSizeMb();
            return messages.megabytes(String.valueOf(size));
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            int numOfCpus = getEntity(object).getNumOfCpus();
            return String.valueOf(numOfCpus);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            ArchitectureType clusterArch = getEntity(object).getClusterArch();
            return String.valueOf(clusterArch);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            int numOfDisks = getEntity(object).getDiskTemplateMap().size();
            return String.valueOf(numOfDisks);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(diskColumn, constants.disksVm(), "50px");
    // $NON-NLS-1$
    entityTable.addColumn(getClusterColumn(), constants.clusterVm(), "150px");
    if (model.isQuotaEnabled()) {
        // $NON-NLS-1$
        entityTable.addColumn(getClusterQuotaColumn(), constants.quotaVm(), "150px");
    }
}
#end_block

#method_before
private TreeItem createDiskItem(DiskImage disk) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, diskRowResources, true);
    Column<EntityModel, EntityModel> diskWithMappingColumn = new Column<EntityModel, EntityModel>(createDiskImageWithMappingComoisiteCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    AbstractTextColumn<EntityModel> paddingColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getDiskAlias();
        }
    };
    AbstractTextColumn<EntityModel> virtualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return asDisk(entity).getSizeInGigabytes() + constants.gb();
        }
    };
    AbstractTextColumn<EntityModel> actualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return ((Double) asDisk(entity).getActualDiskWithSnapshotsSize()).intValue() + constants.gb();
        }
    };
    AbstractTextColumn<EntityModel> snapshotsColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getSnapshots().size() + "";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskWithMappingColumn, "", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(paddingColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "", "31%");
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(disk);
    table.setRowData(Arrays.asList(entityModel));
    return new TreeItem(table);
}
#method_after
private TreeItem createDiskItem(DiskImage disk) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, diskRowResources, true);
    Column<EntityModel, EntityModel> diskWithMappingColumn = new Column<EntityModel, EntityModel>(createDiskImageWithMappingComoisiteCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    AbstractTextColumn<EntityModel> paddingColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getDiskAlias();
        }
    };
    AbstractTextColumn<EntityModel> virtualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return messages.gigabytes(String.valueOf(asDisk(entity).getSizeInGigabytes()));
        }
    };
    AbstractTextColumn<EntityModel> actualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return messages.gigabytes(String.valueOf(((Double) asDisk(entity).getActualDiskWithSnapshotsSize()).intValue()));
        }
    };
    AbstractTextColumn<EntityModel> snapshotsColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            // $NON-NLS-1$
            return asDisk(entity).getSnapshots().size() + "";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskWithMappingColumn, "", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(paddingColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "", "31%");
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(disk);
    table.setRowData(Arrays.asList(entityModel));
    return new TreeItem(table);
}
#end_block

#method_before
private VmTreeItem createVmItem(VM vm) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, vmRowResources, true);
    AbstractColumn<EntityModel, EntityModel> vmImageWithNameColumn = new AbstractColumn<EntityModel, EntityModel>(createVmImageWithNameCompositeCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    AbstractTextColumn<EntityModel> diskSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            ArrayList<DiskImage> diskImages = asVm(entity).getDiskList();
            // $NON-NLS-1$ //$NON-NLS-2$
            return diskImages != null ? diskImages.size() + "" : "0";
        }
    };
    AbstractTextColumn<EntityModel> virtualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return ((Double) asVm(entity).getDiskSize()).intValue() + constants.gb();
        }
    };
    AbstractTextColumn<EntityModel> actualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return ((Double) asVm(entity).getActualDiskWithSnapshotsSize()).intValue() + constants.gb();
        }
    };
    AbstractTextColumn<EntityModel> snapshotsColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            ArrayList<DiskImage> diskImages = asVm(entity).getDiskList();
            return diskImages != null ? diskImages.size() > 0 ? diskImages.get(0).getSnapshots().size() + "" : "0" : // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
            "0";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(vmImageWithNameColumn, "", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "", "31%");
    table.setSelectionModel(vmSelectionModel);
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(vm);
    table.setRowData(Arrays.asList(entityModel));
    return new VmTreeItem(table, vm);
}
#method_after
private VmTreeItem createVmItem(VM vm) {
    EntityModelCellTable<ListModel> table = new EntityModelCellTable<>(false, vmRowResources, true);
    AbstractColumn<EntityModel, EntityModel> vmImageWithNameColumn = new AbstractColumn<EntityModel, EntityModel>(createVmImageWithNameCompositeCell()) {

        @Override
        public EntityModel getValue(EntityModel object) {
            return object;
        }
    };
    AbstractTextColumn<EntityModel> diskSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            ArrayList<DiskImage> diskImages = asVm(entity).getDiskList();
            // $NON-NLS-1$ //$NON-NLS-2$
            return diskImages != null ? diskImages.size() + "" : "0";
        }
    };
    AbstractTextColumn<EntityModel> virtualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return messages.gigabytes(String.valueOf(((Double) asVm(entity).getDiskSize()).intValue()));
        }
    };
    AbstractTextColumn<EntityModel> actualSizeColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            return messages.gigabytes(String.valueOf(((Double) asVm(entity).getActualDiskWithSnapshotsSize()).intValue()));
        }
    };
    AbstractTextColumn<EntityModel> snapshotsColumn = new AbstractTextColumn<EntityModel>() {

        @Override
        public String getValue(EntityModel entity) {
            ArrayList<DiskImage> diskImages = asVm(entity).getDiskList();
            return diskImages != null ? diskImages.size() > 0 ? diskImages.get(0).getSnapshots().size() + "" : "0" : // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
            "0";
        }
    };
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(vmImageWithNameColumn, "", "39%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(diskSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(virtualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(actualSizeColumn, "", "10%");
    // $NON-NLS-1$ //$NON-NLS-2$
    table.addColumn(snapshotsColumn, "", "31%");
    table.setSelectionModel(vmSelectionModel);
    EntityModel entityModel = new EntityModel();
    entityModel.setEntity(vm);
    table.setRowData(Arrays.asList(entityModel));
    return new VmTreeItem(table, vm);
}
#end_block

#method_before
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractCheckboxColumn<ImportVmData> cloneVMColumn = new AbstractCheckboxColumn<ImportVmData>(new FieldUpdater<ImportVmData, Boolean>() {

        @Override
        public void update(int index, ImportVmData model, Boolean value) {
            model.getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(ImportVmData model) {
            return model.getClone().getEntity();
        }

        @Override
        protected boolean canEdit(ImportVmData model) {
            return model.getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(ImportVmData model) {
            return model.getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<ImportVmData> nameColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<ImportVmData> originColumn = new AbstractEnumColumn<ImportVmData, OriginType>() {

        @Override
        protected OriginType getRawValue(ImportVmData object) {
            return object.getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractSafeHtmlColumn<ImportVmData>() {

        @Override
        public SafeHtml getValue(ImportVmData object) {
            return VmTypeColumn.getRenderedValue(object.getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<ImportVmData> memoryColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            // $NON-NLS-1$
            return String.valueOf(object.getVm().getVmMemSizeMb()) + " " + constants.mb();
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<ImportVmData> cpuColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return String.valueOf(object.getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<ImportVmData> archColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return String.valueOf(object.getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<ImportVmData> diskColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return String.valueOf(object.getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#method_after
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractCheckboxColumn<ImportVmData> cloneVMColumn = new AbstractCheckboxColumn<ImportVmData>(new FieldUpdater<ImportVmData, Boolean>() {

        @Override
        public void update(int index, ImportVmData model, Boolean value) {
            model.getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(ImportVmData model) {
            return model.getClone().getEntity();
        }

        @Override
        protected boolean canEdit(ImportVmData model) {
            return model.getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(ImportVmData model) {
            return model.getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<ImportVmData> nameColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<ImportVmData> originColumn = new AbstractEnumColumn<ImportVmData, OriginType>() {

        @Override
        protected OriginType getRawValue(ImportVmData object) {
            return object.getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractSafeHtmlColumn<ImportVmData>() {

        @Override
        public SafeHtml getValue(ImportVmData object) {
            return VmTypeColumn.getRenderedValue(object.getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<ImportVmData> memoryColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return messages.megabytes(String.valueOf(object.getVm().getVmMemSizeMb()));
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<ImportVmData> cpuColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return String.valueOf(object.getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<ImportVmData> archColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return String.valueOf(object.getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<ImportVmData> diskColumn = new AbstractTextColumn<ImportVmData>() {

        @Override
        public String getValue(ImportVmData object) {
            return String.valueOf(object.getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#end_block

#method_before
void initVmTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VM> nameColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "95px");
    AbstractTextColumn<VM> templateColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return vmTemplateNameRenderer.render(object);
        }
    };
    templateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(templateColumn, constants.templateVm(), "95px");
    AbstractTextColumn<VM> originColumn = new AbstractEnumColumn<VM, OriginType>() {

        @Override
        protected OriginType getRawValue(VM object) {
            return object.getOrigin();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "95px");
    AbstractTextColumn<VM> memoryColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            // $NON-NLS-1$
            return String.valueOf(object.getVmMemSizeMb()) + " " + constants.mb();
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "95px");
    AbstractTextColumn<VM> cpuColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "95px");
    AbstractTextColumn<VM> archColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "95px");
    AbstractTextColumn<VM> diskColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getDiskMap().size());
        }
    };
    diskColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(diskColumn, constants.disksVm(), "95px");
    AbstractTextColumn<VM> creationDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getVmCreationDate();
        }
    };
    creationDateColumn.makeSortable(new Comparator<VM>() {

        @Override
        public int compare(VM vm1, VM vm2) {
            return vm1.getVmCreationDate().compareTo(vm2.getVmCreationDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "95px");
    AbstractTextColumn<VM> exportDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getExportDate();
        }
    };
    exportDateColumn.makeSortable(new Comparator<VM>() {

        @Override
        public int compare(VM vm1, VM vm2) {
            return vm1.getExportDate().compareTo(vm2.getExportDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "95px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRestoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
    getTable().showRefreshButton();
}
#method_after
void initVmTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VM> nameColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "95px");
    AbstractTextColumn<VM> templateColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return vmTemplateNameRenderer.render(object);
        }
    };
    templateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(templateColumn, constants.templateVm(), "95px");
    AbstractTextColumn<VM> originColumn = new AbstractEnumColumn<VM, OriginType>() {

        @Override
        protected OriginType getRawValue(VM object) {
            return object.getOrigin();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "95px");
    AbstractTextColumn<VM> memoryColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return messages.megabytes(String.valueOf(object.getVmMemSizeMb()));
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "95px");
    AbstractTextColumn<VM> cpuColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "95px");
    AbstractTextColumn<VM> archColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "95px");
    AbstractTextColumn<VM> diskColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getDiskMap().size());
        }
    };
    diskColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(diskColumn, constants.disksVm(), "95px");
    AbstractTextColumn<VM> creationDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getVmCreationDate();
        }
    };
    creationDateColumn.makeSortable(new Comparator<VM>() {

        @Override
        public int compare(VM vm1, VM vm2) {
            return vm1.getVmCreationDate().compareTo(vm2.getVmCreationDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "95px");
    AbstractTextColumn<VM> exportDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getExportDate();
        }
    };
    exportDateColumn.makeSortable(new Comparator<VM>() {

        @Override
        public int compare(VM vm1, VM vm2) {
            return vm1.getExportDate().compareTo(vm2.getExportDate());
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "95px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRestoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveCommand();
        }
    });
    getTable().showRefreshButton();
}
#end_block

#method_before
@Override
protected void createEntityTable(RegisterVmModel model) {
    entityTable.addColumn(new AbstractImageResourceColumn<RegisterVmData>() {

        @Override
        public ImageResource getValue(RegisterVmData registerVmData) {
            if (registerVmData.getError() != null) {
                return resources.errorImage();
            }
            if (registerVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(RegisterVmData registerVmData) {
            String problem;
            if (registerVmData.getError() != null) {
                problem = registerVmData.getError();
            } else {
                problem = registerVmData.getWarning();
            }
            return problem == null ? null : new SafeHtmlBuilder().appendEscapedLines(problem).toSafeHtml();
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    AbstractTextColumn<RegisterVmData> nameColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            return registerVmData.getVm().getName();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<RegisterVmData> originColumn = new AbstractEnumColumn<RegisterVmData, OriginType>() {

        @Override
        protected OriginType getRawValue(RegisterVmData registerVmData) {
            return registerVmData.getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<RegisterVmData> memoryColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            int size = registerVmData.getVm().getVmMemSizeMb();
            // $NON-NLS-1$
            return size + " " + constants.mb();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<RegisterVmData> cpuColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            int numOfCpus = registerVmData.getVm().getNumOfCpus();
            return String.valueOf(numOfCpus);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<RegisterVmData> archColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            ArchitectureType clusterArch = registerVmData.getVm().getClusterArch();
            return String.valueOf(clusterArch);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<RegisterVmData> diskColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            int numOfDisks = registerVmData.getVm().getDiskMap().size();
            return String.valueOf(numOfDisks);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(diskColumn, constants.disksVm(), "50px");
    // $NON-NLS-1$
    entityTable.addColumn(creatReassignMacsColumn(), new ReassignBadMacsHeader(), "150px");
    // $NON-NLS-1$
    entityTable.addColumn(getClusterColumn(), constants.clusterVm(), "150px");
    if (model.isQuotaEnabled()) {
        // $NON-NLS-1$
        entityTable.addColumn(getClusterQuotaColumn(), constants.quotaVm(), "150px");
    }
}
#method_after
@Override
protected void createEntityTable(RegisterVmModel model) {
    entityTable.addColumn(new AbstractImageResourceColumn<RegisterVmData>() {

        @Override
        public ImageResource getValue(RegisterVmData registerVmData) {
            if (registerVmData.getError() != null) {
                return resources.errorImage();
            }
            if (registerVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(RegisterVmData registerVmData) {
            String problem;
            if (registerVmData.getError() != null) {
                problem = registerVmData.getError();
            } else {
                problem = registerVmData.getWarning();
            }
            return problem == null ? null : new SafeHtmlBuilder().appendEscapedLines(problem).toSafeHtml();
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    AbstractTextColumn<RegisterVmData> nameColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            return registerVmData.getVm().getName();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<RegisterVmData> originColumn = new AbstractEnumColumn<RegisterVmData, OriginType>() {

        @Override
        protected OriginType getRawValue(RegisterVmData registerVmData) {
            return registerVmData.getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<RegisterVmData> memoryColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            int size = registerVmData.getVm().getVmMemSizeMb();
            return messages.megabytes(String.valueOf(size));
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<RegisterVmData> cpuColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            int numOfCpus = registerVmData.getVm().getNumOfCpus();
            return String.valueOf(numOfCpus);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<RegisterVmData> archColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            ArchitectureType clusterArch = registerVmData.getVm().getClusterArch();
            return String.valueOf(clusterArch);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<RegisterVmData> diskColumn = new AbstractTextColumn<RegisterVmData>() {

        @Override
        public String getValue(RegisterVmData registerVmData) {
            int numOfDisks = registerVmData.getVm().getDiskMap().size();
            return String.valueOf(numOfDisks);
        }
    };
    // $NON-NLS-1$
    entityTable.addColumn(diskColumn, constants.disksVm(), "50px");
    // $NON-NLS-1$
    entityTable.addColumn(creatReassignMacsColumn(), new ReassignBadMacsHeader(), "150px");
    // $NON-NLS-1$
    entityTable.addColumn(getClusterColumn(), constants.clusterVm(), "150px");
    if (model.isQuotaEnabled()) {
        // $NON-NLS-1$
        entityTable.addColumn(getClusterQuotaColumn(), constants.quotaVm(), "150px");
    }
}
#end_block

#method_before
@Override
public void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<DiskImage> aliasColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(aliasColumn, constants.aliasDisk(), "150px");
    AbstractTextColumn<DiskImage> provisionedSizeColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            // $NON-NLS-1$
            return String.valueOf(object.getSizeInGigabytes()) + " " + constants.gb();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(provisionedSizeColumn, constants.provisionedSizeDisk(), "150px");
    AbstractDiskSizeColumn<DiskImage> actualSizeColumn = new AbstractDiskSizeColumn<DiskImage>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(DiskImage object) {
            return Math.round(object.getActualDiskWithSnapshotsSize());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(actualSizeColumn, constants.sizeDisk(), "150px");
    AbstractTextColumn<DiskImage> statusColumn = new AbstractEnumColumn<DiskImage, ImageStatus>() {

        @Override
        protected ImageStatus getRawValue(DiskImage object) {
            return object.getImageStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusDisk(), "150px");
    AbstractTextColumn<DiskImage> allocationColumn = new AbstractEnumColumn<DiskImage, VolumeType>() {

        @Override
        protected VolumeType getRawValue(DiskImage object) {
            return VolumeType.forValue(object.getVolumeType().getValue());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(allocationColumn, constants.allocationDisk(), "150px");
    AbstractTextColumn<DiskImage> interfaceColumn = new AbstractEnumColumn<DiskImage, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(DiskImage object) {
            if (object.getDiskVmElements().size() == 1) {
                return object.getDiskVmElements().iterator().next().getDiskInterface();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(interfaceColumn, constants.interfaceDisk(), "150px");
    AbstractTextColumn<DiskImage> dateCreatedColumn = new AbstractFullDateTimeColumn<DiskImage>() {

        @Override
        protected Date getRawValue(DiskImage object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dateCreatedColumn, constants.creationDateDisk(), "150px");
    AbstractTextColumn<DiskImage> descriptionColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionDisk(), "150px");
}
#method_after
@Override
public void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<DiskImage> aliasColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDiskAlias();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(aliasColumn, constants.aliasDisk(), "150px");
    AbstractTextColumn<DiskImage> provisionedSizeColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return messages.gigabytes(String.valueOf(object.getSizeInGigabytes()));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(provisionedSizeColumn, constants.provisionedSizeDisk(), "150px");
    AbstractDiskSizeColumn<DiskImage> actualSizeColumn = new AbstractDiskSizeColumn<DiskImage>(SizeConverter.SizeUnit.GiB) {

        @Override
        protected Long getRawValue(DiskImage object) {
            return Math.round(object.getActualDiskWithSnapshotsSize());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(actualSizeColumn, constants.sizeDisk(), "150px");
    AbstractTextColumn<DiskImage> statusColumn = new AbstractEnumColumn<DiskImage, ImageStatus>() {

        @Override
        protected ImageStatus getRawValue(DiskImage object) {
            return object.getImageStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusDisk(), "150px");
    AbstractTextColumn<DiskImage> allocationColumn = new AbstractEnumColumn<DiskImage, VolumeType>() {

        @Override
        protected VolumeType getRawValue(DiskImage object) {
            return VolumeType.forValue(object.getVolumeType().getValue());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(allocationColumn, constants.allocationDisk(), "150px");
    AbstractTextColumn<DiskImage> interfaceColumn = new AbstractEnumColumn<DiskImage, DiskInterface>() {

        @Override
        protected DiskInterface getRawValue(DiskImage object) {
            if (object.getDiskVmElements().size() == 1) {
                return object.getDiskVmElements().iterator().next().getDiskInterface();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(interfaceColumn, constants.interfaceDisk(), "150px");
    AbstractTextColumn<DiskImage> dateCreatedColumn = new AbstractFullDateTimeColumn<DiskImage>() {

        @Override
        protected Date getRawValue(DiskImage object) {
            return object.getCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dateCreatedColumn, constants.creationDateDisk(), "150px");
    AbstractTextColumn<DiskImage> descriptionColumn = new AbstractTextColumn<DiskImage>() {

        @Override
        public String getValue(DiskImage object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionDisk(), "150px");
}
#end_block

#method_before
@Override
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractCheckboxColumn<Object> cloneTemplateColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportTemplateData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportTemplateData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportTemplateData) model).getClone().getIsChangable();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneTemplateColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return ((ImportTemplateData) object).getTemplate().getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameTemplate(), "150px");
    AbstractTextColumn<Object> versionNameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            VmTemplate template = ((ImportTemplateData) object).getTemplate();
            if (template.isBaseTemplate()) {
                // $NON-NLS-1$
                return "";
            }
            return // $NON-NLS-1$
            StringFormat.format(// $NON-NLS-1$
            "%s (%s)", // $NON-NLS-1$
            template.getTemplateVersionName() != null ? template.getTemplateVersionName() : "", template.getTemplateVersionNumber());
        }
    };
    // $NON-NLS-1$
    table.addColumn(versionNameColumn, constants.versionTemplate(), "150px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportTemplateData) object).getTemplate().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originTemplate(), "100px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            // $NON-NLS-1$
            return String.valueOf(((ImportTemplateData) object).getTemplate().getMemSizeMb()) + " " + constants.mb();
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryTemplate(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportTemplateData) object).getTemplate().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusTemplate(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportTemplateData) object).getTemplate().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureTemplate(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportTemplateData) object).getTemplate().getDiskList().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksTemplate(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportTemplateData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.templateInSetup(), "60px");
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#method_after
@Override
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractCheckboxColumn<Object> cloneTemplateColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportTemplateData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportTemplateData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportTemplateData) model).getClone().getIsChangable();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneTemplateColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return ((ImportTemplateData) object).getTemplate().getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameTemplate(), "150px");
    AbstractTextColumn<Object> versionNameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            VmTemplate template = ((ImportTemplateData) object).getTemplate();
            if (template.isBaseTemplate()) {
                // $NON-NLS-1$
                return "";
            }
            return // $NON-NLS-1$
            StringFormat.format(// $NON-NLS-1$
            "%s (%s)", // $NON-NLS-1$
            template.getTemplateVersionName() != null ? template.getTemplateVersionName() : "", template.getTemplateVersionNumber());
        }
    };
    // $NON-NLS-1$
    table.addColumn(versionNameColumn, constants.versionTemplate(), "150px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportTemplateData) object).getTemplate().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originTemplate(), "100px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return messages.megabytes(String.valueOf(((ImportTemplateData) object).getTemplate().getMemSizeMb()));
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryTemplate(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportTemplateData) object).getTemplate().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusTemplate(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportTemplateData) object).getTemplate().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureTemplate(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportTemplateData) object).getTemplate().getDiskList().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksTemplate(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportTemplateData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.templateInSetup(), "60px");
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VmTemplate> nameColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<VmTemplate> originColumn = new AbstractEnumColumn<VmTemplate, OriginType>() {

        @Override
        protected OriginType getRawValue(VmTemplate object) {
            return object.getOrigin();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<VmTemplate> memoryColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            // $NON-NLS-1$
            return String.valueOf(object.getMemSizeMb()) + " " + constants.mb();
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<VmTemplate> cpuColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    AbstractTextColumn<VmTemplate> archColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<VmTemplate> numOfDisksColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getDiskTemplateMap().size());
        }
    };
    numOfDisksColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(numOfDisksColumn, constants.disksVm(), "100px");
    AbstractTextColumn<VmTemplate> creationDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getCreationDate();
        }
    };
    creationDateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    AbstractTextColumn<VmTemplate> exportDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getExportDate();
        }
    };
    exportDateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<VmTemplate>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getImportCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VmTemplate> nameColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<VmTemplate> originColumn = new AbstractEnumColumn<VmTemplate, OriginType>() {

        @Override
        protected OriginType getRawValue(VmTemplate object) {
            return object.getOrigin();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<VmTemplate> memoryColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return messages.megabytes(String.valueOf(object.getMemSizeMb()));
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<VmTemplate> cpuColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    AbstractTextColumn<VmTemplate> archColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<VmTemplate> numOfDisksColumn = new AbstractTextColumn<VmTemplate>() {

        @Override
        public String getValue(VmTemplate object) {
            return String.valueOf(object.getDiskTemplateMap().size());
        }
    };
    numOfDisksColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(numOfDisksColumn, constants.disksVm(), "100px");
    AbstractTextColumn<VmTemplate> creationDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getCreationDate();
        }
    };
    creationDateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    AbstractTextColumn<VmTemplate> exportDateColumn = new AbstractFullDateTimeColumn<VmTemplate>() {

        @Override
        protected Date getRawValue(VmTemplate object) {
            return object.getExportDate();
        }
    };
    exportDateColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<VmTemplate>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getImportCommand();
        }
    });
}
#end_block

#method_before
private String renderGigabyteSize(long size) {
    long sizeInGB = (unit == SizeUnit.GiB) ? size : SizeConverter.convert(size, unit, SizeUnit.GiB).longValue();
    // $NON-NLS-1$ //$NON-NLS-2$
    return (sizeInGB >= 1 ? sizeInGB : "< 1") + " " + constants.gb();
}
#method_after
private String renderGigabyteSize(long size) {
    long sizeInGB = (unit == SizeUnit.GiB) ? size : SizeConverter.convert(size, unit, SizeUnit.GiB).longValue();
    // $NON-NLS-1$
    return messages.gigabytes(sizeInGB >= 1 ? String.valueOf(sizeInGB) : "< 1");
}
#end_block

#method_before
private String renderHumanReadableSize(long size) {
    long sizeInBytes = SizeConverter.convert(size, unit, SizeUnit.BYTES).longValue();
    if (sizeInBytes > SizeConverter.BYTES_IN_GB) {
        return SizeConverter.convert(sizeInBytes, SizeUnit.BYTES, SizeUnit.GiB).longValue() + " " + // $NON-NLS-1$
        constants.gb();
    } else if (sizeInBytes > SizeConverter.BYTES_IN_MB) {
        return SizeConverter.convert(sizeInBytes, SizeUnit.BYTES, SizeUnit.MiB).longValue() + " " + // $NON-NLS-1$
        constants.mb();
    } else if (sizeInBytes > SizeConverter.BYTES_IN_KB) {
        return SizeConverter.convert(sizeInBytes, SizeUnit.BYTES, SizeUnit.KiB).longValue() + " " + // $NON-NLS-1$
        constants.kb();
    } else {
        // $NON-NLS-1$
        return sizeInBytes + " " + constants.bytes2();
    }
}
#method_after
private String renderHumanReadableSize(long size) {
    long sizeInBytes = SizeConverter.convert(size, unit, SizeUnit.BYTES).longValue();
    if (sizeInBytes > SizeConverter.BYTES_IN_GB) {
        return messages.gigabytes(String.valueOf(SizeConverter.convert(sizeInBytes, SizeUnit.BYTES, SizeUnit.GiB).longValue()));
    } else if (sizeInBytes > SizeConverter.BYTES_IN_MB) {
        return messages.megabytes(String.valueOf(SizeConverter.convert(sizeInBytes, SizeUnit.BYTES, SizeUnit.MiB).longValue()));
    } else if (sizeInBytes > SizeConverter.BYTES_IN_KB) {
        return messages.kilobytes(String.valueOf(SizeConverter.convert(sizeInBytes, SizeUnit.BYTES, SizeUnit.KiB).longValue()));
    } else {
        return messages.bytes(String.valueOf(sizeInBytes));
    }
}
#end_block

#method_before
private void initTable() {
    AbstractEntityModelTextColumn<StorageDomain> nameColumn = new AbstractEntityModelTextColumn<StorageDomain>() {

        @Override
        public String getText(StorageDomain storage) {
            return storage.getStorageName();
        }
    };
    // $NON-NLS-1$
    storageDomainItems.setColumnWidth(nameColumn, "280px");
    storageDomainItems.addColumn(nameColumn, constants.nameStorage());
    AbstractEntityModelTextColumn<StorageDomain> freeSpaceColumn = new AbstractEntityModelTextColumn<StorageDomain>() {

        @Override
        public String getText(StorageDomain storage) {
            if (storage.getAvailableDiskSize() == null || storage.getAvailableDiskSize() < 1) {
                // $NON-NLS-1$
                return "< 1 " + constants.gb();
            }
            // $NON-NLS-1$
            return storage.getAvailableDiskSize() + " " + constants.gb();
        }
    };
    // $NON-NLS-1$
    storageDomainItems.setColumnWidth(freeSpaceColumn, "80px");
    storageDomainItems.addColumn(freeSpaceColumn, constants.freeSpaceStorage());
}
#method_after
private void initTable() {
    AbstractEntityModelTextColumn<StorageDomain> nameColumn = new AbstractEntityModelTextColumn<StorageDomain>() {

        @Override
        public String getText(StorageDomain storage) {
            return storage.getStorageName();
        }
    };
    // $NON-NLS-1$
    storageDomainItems.setColumnWidth(nameColumn, "280px");
    storageDomainItems.addColumn(nameColumn, constants.nameStorage());
    AbstractEntityModelTextColumn<StorageDomain> freeSpaceColumn = new AbstractEntityModelTextColumn<StorageDomain>() {

        @Override
        public String getText(StorageDomain storage) {
            if (storage.getAvailableDiskSize() == null || storage.getAvailableDiskSize() < 1) {
                // $NON-NLS-1$
                return messages.gigabytes("< 1");
            }
            return messages.gigabytes(String.valueOf(storage.getAvailableDiskSize()));
        }
    };
    // $NON-NLS-1$
    storageDomainItems.setColumnWidth(freeSpaceColumn, "80px");
    storageDomainItems.addColumn(freeSpaceColumn, constants.freeSpaceStorage());
}
#end_block

#method_before
private String renderMemory(double memory) {
    if (memory <= 0) {
        // $NON-NLS-1$
        return "0";
    }
    return memory > Math.abs(MB_GB_THRESHOLD * GIGA) ? diskSizeRenderer.render(memory / GIGA) : (int) memory + constants.mb();
}
#method_after
private String renderMemory(double memory) {
    if (memory <= 0) {
        // $NON-NLS-1$
        return "0";
    }
    return memory > Math.abs(MB_GB_THRESHOLD * GIGA) ? diskSizeRenderer.render(memory / GIGA) : messages.megabytes(String.valueOf((int) memory));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            // $NON-NLS-1$
            return String.valueOf(model.getSize()) + constants.gb();
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "120px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%", true);
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(new Handler() {

            @Override
            public void onSelectionChange(SelectionChangeEvent event) {
                SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
                selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
                if (selectedLunModel != null) {
                    updateSelectedLunWarning(selectedLunModel);
                    sortedLeafModel.setSelectedItem(selectedLunModel);
                }
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
    }
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    item.setWidget(panel);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "30px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    table.addColumn(lunIdColumn, constants.lunIdSanStorage());
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "70px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "55px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "100px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "100px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "120px");
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%", true);
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(new Handler() {

            @Override
            public void onSelectionChange(SelectionChangeEvent event) {
                SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
                selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
                if (selectedLunModel != null) {
                    updateSelectedLunWarning(selectedLunModel);
                    sortedLeafModel.setSelectedItem(selectedLunModel);
                }
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
    }
    ScrollPanel panel = new ScrollPanel();
    panel.add(table);
    item.setWidget(panel);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    return item;
}
#end_block

#method_before
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractImageResourceColumn<Object> isProblematicImportVmColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            if (importVmData.getError() != null || importVmData.isNameExistsInTheSystem()) {
                return resources.errorImage();
            }
            if (importVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            String problem = null;
            if (importVmData.getError() != null) {
                problem = importVmData.getError();
            } else {
                problem = importVmData.isNameExistsInTheSystem() ? ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason() : importVmData.getWarning();
            }
            return problem != null ? SafeHtmlUtils.fromSafeConstant(problem) : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isProblematicImportVmColumn, constants.empty(), "20px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            String originalName = ((ImportVmData) object).getName();
            String givenName = ((ImportVmData) object).getVm().getName();
            return originalName.equals(givenName) ? givenName : // $NON-NLS-1$ //$NON-NLS-2$
            givenName + " (" + originalName + ")";
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractCheckboxColumn<Object> collapseSnapshotsColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getCollapseSnapshots().setEntity(value);
            customSelectionCellFormatType.setEnabled(value);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getChangeProhibitionReason();
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            SafeHtml superTooltip = super.getTooltip(object);
            if (superTooltip == null) {
                return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
            }
            return superTooltip;
        }
    };
    // $NON-NLS-1$
    table.addColumn(collapseSnapshotsColumn, constants.collapseSnapshots(), "10px");
    AbstractCheckboxColumn<Object> cloneVMColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportVmData) object).getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractSafeHtmlColumn<Object>() {

        @Override
        public SafeHtml getValue(Object object) {
            return VmTypeColumn.getRenderedValue(((ImportVmData) object).getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            // $NON-NLS-1$
            return String.valueOf(((ImportVmData) object).getVm().getVmMemSizeMb()) + " " + constants.mb();
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportVmData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.vmInSetup(), "60px");
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            ImportVmData selectedObject = ((SingleSelectionModel<ImportVmData>) event.getSource()).getSelectedObject();
            customSelectionCellFormatType.setEnabled(selectedObject.getCollapseSnapshots().getEntity());
        }
    });
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#method_after
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractImageResourceColumn<Object> isProblematicImportVmColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            if (importVmData.getError() != null || importVmData.isNameExistsInTheSystem()) {
                return resources.errorImage();
            }
            if (importVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            ImportVmData importVmData = (ImportVmData) object;
            String problem = null;
            if (importVmData.getError() != null) {
                problem = importVmData.getError();
            } else {
                problem = importVmData.isNameExistsInTheSystem() ? ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason() : importVmData.getWarning();
            }
            return problem != null ? SafeHtmlUtils.fromSafeConstant(problem) : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isProblematicImportVmColumn, constants.empty(), "20px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            String originalName = ((ImportVmData) object).getName();
            String givenName = ((ImportVmData) object).getVm().getName();
            return originalName.equals(givenName) ? givenName : // $NON-NLS-1$ //$NON-NLS-2$
            givenName + " (" + originalName + ")";
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractCheckboxColumn<Object> collapseSnapshotsColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getCollapseSnapshots().setEntity(value);
            customSelectionCellFormatType.setEnabled(value);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getChangeProhibitionReason();
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            SafeHtml superTooltip = super.getTooltip(object);
            if (superTooltip == null) {
                return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
            }
            return superTooltip;
        }
    };
    // $NON-NLS-1$
    table.addColumn(collapseSnapshotsColumn, constants.collapseSnapshots(), "10px");
    AbstractCheckboxColumn<Object> cloneVMColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportVmData) object).getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractSafeHtmlColumn<Object>() {

        @Override
        public SafeHtml getValue(Object object) {
            return VmTypeColumn.getRenderedValue(((ImportVmData) object).getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return messages.megabytes(String.valueOf(((ImportVmData) object).getVm().getVmMemSizeMb()));
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportVmData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.vmInSetup(), "60px");
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            ImportVmData selectedObject = ((SingleSelectionModel<ImportVmData>) event.getSource()).getSelectedObject();
            customSelectionCellFormatType.setEnabled(selectedObject.getCollapseSnapshots().getEntity());
        }
    });
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#end_block

#method_before
protected void addAllocationColumn() {
    ArrayList<String> allocationTypes = new ArrayList<>();
    allocationTypes.add(constants.thinAllocation());
    allocationTypes.add(constants.preallocatedAllocation());
    customSelectionCellFormatType = new CustomSelectionCell(allocationTypes);
    customSelectionCellFormatType.setStyle(style.cellSelectBox());
    AbstractColumn<DiskImage, String> allocationColumn = new AbstractColumn<DiskImage, String>(customSelectionCellFormatType) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            if (importData == null) {
                return "";
            }
            return new EnumRenderer<VolumeType>().render(VolumeType.forValue(importData.getSelectedVolumeType().getValue()));
        }

        @Override
        public SafeHtml getTooltip(DiskImage object) {
            return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
        }
    };
    allocationColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            VolumeType tempVolumeType = VolumeType.Sparse;
            if (value.equals(constants.thinAllocation())) {
                tempVolumeType = VolumeType.Sparse;
            } else if (value.equals(constants.preallocatedAllocation())) {
                tempVolumeType = VolumeType.Preallocated;
            }
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            if (importData != null) {
                importData.setSelectedVolumeType(tempVolumeType);
            }
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(allocationColumn, constants.allocationDisk(), "150px");
}
#method_after
protected void addAllocationColumn() {
    ArrayList<String> allocationTypes = new ArrayList<>();
    allocationTypes.add(constants.thinAllocation());
    allocationTypes.add(constants.preallocatedAllocation());
    customSelectionCellFormatType = new CustomSelectionCell(allocationTypes);
    customSelectionCellFormatType.setStyle(EMPTY_STYLE);
    AbstractColumn<DiskImage, String> allocationColumn = new AbstractColumn<DiskImage, String>(customSelectionCellFormatType) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            if (importData == null) {
                return "";
            }
            return new EnumRenderer<VolumeType>().render(VolumeType.forValue(importData.getSelectedVolumeType().getValue()));
        }

        @Override
        public SafeHtml getTooltip(DiskImage object) {
            return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
        }
    };
    allocationColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            VolumeType tempVolumeType = VolumeType.Sparse;
            if (value.equals(constants.thinAllocation())) {
                tempVolumeType = VolumeType.Sparse;
            } else if (value.equals(constants.preallocatedAllocation())) {
                tempVolumeType = VolumeType.Preallocated;
            }
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            if (importData != null) {
                importData.setSelectedVolumeType(tempVolumeType);
            }
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(allocationColumn, constants.allocationDisk(), "150px");
}
#end_block

#method_before
private void addStorageDomainsColumn() {
    CustomSelectionCell customSelectionCellStorageDomain = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellStorageDomain.setStyle(style.cellSelectBox());
    Column<DiskImage, String> storageDomainsColumn = new Column<DiskImage, String>(customSelectionCellStorageDomain) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageDomainsNameList = new ArrayList<>();
            StorageDomain selectedStorageDomain = null;
            if (importData != null && importData.getStorageDomains() != null) {
                for (StorageDomain storageDomain : importData.getStorageDomains()) {
                    storageDomainsNameList.add(new StorageDomainFreeSpaceRenderer<>().render(storageDomain));
                    if (importData.getSelectedStorageDomain() != null) {
                        if (storageDomain.getId().equals(importData.getSelectedStorageDomain().getId())) {
                            selectedStorageDomain = storageDomain;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageDomainsNameList);
            if (!storageDomainsNameList.isEmpty()) {
                if (selectedStorageDomain != null) {
                    return new StorageDomainFreeSpaceRenderer<>().render(selectedStorageDomain);
                } else {
                    return storageDomainsNameList.get(0);
                }
            }
            return "";
        }
    };
    storageDomainsColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            // $NON-NLS-1$
            String storageDomainName = value.substring(0, value.lastIndexOf(" ("));
            importModel.getDiskImportData(disk.getId()).setSelectedStorageDomainString(storageDomainName);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(storageDomainsColumn, constants.storageDomainDisk(), "180px");
}
#method_after
private void addStorageDomainsColumn() {
    CustomSelectionCell customSelectionCellStorageDomain = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellStorageDomain.setStyle(EMPTY_STYLE);
    Column<DiskImage, String> storageDomainsColumn = new Column<DiskImage, String>(customSelectionCellStorageDomain) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageDomainsNameList = new ArrayList<>();
            StorageDomain selectedStorageDomain = null;
            if (importData != null && importData.getStorageDomains() != null) {
                for (StorageDomain storageDomain : importData.getStorageDomains()) {
                    storageDomainsNameList.add(new StorageDomainFreeSpaceRenderer<>().render(storageDomain));
                    if (importData.getSelectedStorageDomain() != null) {
                        if (storageDomain.getId().equals(importData.getSelectedStorageDomain().getId())) {
                            selectedStorageDomain = storageDomain;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageDomainsNameList);
            if (!storageDomainsNameList.isEmpty()) {
                if (selectedStorageDomain != null) {
                    return new StorageDomainFreeSpaceRenderer<>().render(selectedStorageDomain);
                } else {
                    return storageDomainsNameList.get(0);
                }
            }
            return "";
        }
    };
    storageDomainsColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            // $NON-NLS-1$
            String storageDomainName = value.substring(0, value.lastIndexOf(" ("));
            importModel.getDiskImportData(disk.getId()).setSelectedStorageDomainString(storageDomainName);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(storageDomainsColumn, constants.storageDomainDisk(), "180px");
}
#end_block

#method_before
private void addStorageQuotaColumn() {
    if (!importModel.isQuotaEnabled()) {
        return;
    }
    if (quotaColumn != null) {
        return;
    }
    CustomSelectionCell customSelectionCellQuota = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellQuota.setStyle(style.cellSelectBox());
    quotaColumn = new Column<DiskImage, String>(customSelectionCellQuota) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageQuotaList = new ArrayList<>();
            Quota selectedQuota = null;
            if (importData != null && importData.getQuotaList() != null) {
                for (Quota quota : importData.getQuotaList()) {
                    storageQuotaList.add(quota.getQuotaName());
                    if (importData.getSelectedQuota() != null) {
                        if (quota.getId().equals(importData.getSelectedQuota().getId())) {
                            selectedQuota = quota;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageQuotaList);
            if (!storageQuotaList.isEmpty()) {
                if (selectedQuota != null) {
                    return selectedQuota.getQuotaName();
                } else {
                    return storageQuotaList.get(0);
                }
            }
            return "";
        }
    };
    quotaColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            importModel.getDiskImportData(disk.getId()).setSelectedQuotaString(value);
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(quotaColumn, constants.quota(), "100px");
}
#method_after
private void addStorageQuotaColumn() {
    if (!importModel.isQuotaEnabled()) {
        return;
    }
    if (quotaColumn != null) {
        return;
    }
    CustomSelectionCell customSelectionCellQuota = new CustomSelectionCell(new ArrayList<String>());
    customSelectionCellQuota.setStyle(EMPTY_STYLE);
    quotaColumn = new Column<DiskImage, String>(customSelectionCellQuota) {

        @Override
        public String getValue(DiskImage disk) {
            ImportDiskData importData = importModel.getDiskImportData(disk.getId());
            ArrayList<String> storageQuotaList = new ArrayList<>();
            Quota selectedQuota = null;
            if (importData != null && importData.getQuotaList() != null) {
                for (Quota quota : importData.getQuotaList()) {
                    storageQuotaList.add(quota.getQuotaName());
                    if (importData.getSelectedQuota() != null) {
                        if (quota.getId().equals(importData.getSelectedQuota().getId())) {
                            selectedQuota = quota;
                        }
                    }
                }
            }
            ((CustomSelectionCell) getCell()).setOptions(storageQuotaList);
            if (!storageQuotaList.isEmpty()) {
                if (selectedQuota != null) {
                    return selectedQuota.getQuotaName();
                } else {
                    return storageQuotaList.get(0);
                }
            }
            return "";
        }
    };
    quotaColumn.setFieldUpdater(new FieldUpdater<DiskImage, String>() {

        @Override
        public void update(int index, DiskImage disk, String value) {
            importModel.getDiskImportData(disk.getId()).setSelectedQuotaString(value);
        }
    });
    // $NON-NLS-1$
    diskTable.addColumn(quotaColumn, constants.quota(), "100px");
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void edit(final ImportVmFromExportDomainModel object) {
    this.importModel = object;
    table.asEditor().edit(object);
    addStorageDomainsColumn();
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equals(object.ON_DISK_LOAD)) {
                addStorageQuotaColumn();
                table.redraw();
                diskTable.asEditor().edit(object.getImportDiskListModel());
            } else if (args.propertyName.equals("Message")) {
                // $NON-NLS-1$
                message.setText(object.getMessage());
            } else if (args.propertyName.equals("InvalidVm")) {
                // $NON-NLS-1$
                table.redraw();
            }
        }
    });
    SingleSelectionModel<Object> selectionModel = (SingleSelectionModel<Object>) table.getSelectionModel();
    selectionModel.addSelectionChangeHandler(new Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            if (!firstSelection) {
                object.setActiveDetailModel((HasEntity<?>) object.getDetailModels().get(0));
                setGeneralViewSelection(((ImportEntityData<?>) object.getSelectedItem()).getEntity());
                firstSelection = true;
            }
            splitLayoutPanel.clear();
            splitLayoutPanel.addSouth(subTabLayoutPanel, 230);
            ScrollPanel sp = new ScrollPanel();
            sp.add(table);
            splitLayoutPanel.add(sp);
            table.getElement().getStyle().setPosition(Position.RELATIVE);
        }
    });
    initSubTabLayoutPanel();
    nicTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(1));
    diskTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(2));
    if (object.getDetailModels().size() > 3) {
        appTable.asEditor().edit((VmAppListModel) object.getDetailModels().get(3));
    }
    driver.edit(object);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void edit(final ImportVmFromExportDomainModel object) {
    this.importModel = object;
    table.asEditor().edit(object);
    addStorageDomainsColumn();
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (ImportVmFromExportDomainModel.ON_DISK_LOAD.equals(args.propertyName)) {
                addStorageQuotaColumn();
                table.redraw();
                diskTable.asEditor().edit(object.getImportDiskListModel());
            } else if (args.propertyName.equals("Message")) {
                // $NON-NLS-1$
                message.setText(object.getMessage());
                message.setVisible(StringUtils.isNotEmpty(object.getMessage()));
            } else if (args.propertyName.equals("InvalidVm")) {
                // $NON-NLS-1$
                table.redraw();
            }
        }
    });
    SingleSelectionModel<Object> selectionModel = (SingleSelectionModel<Object>) table.getSelectionModel();
    selectionModel.addSelectionChangeHandler(new Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            if (!firstSelection) {
                object.setActiveDetailModel((HasEntity<?>) object.getDetailModels().get(0));
                setGeneralViewSelection(((ImportEntityData<?>) object.getSelectedItem()).getEntity());
                firstSelection = true;
            }
            splitLayoutPanel.clear();
            splitLayoutPanel.addSouth(subTabLayoutPanel, 230);
            ScrollPanel sp = new ScrollPanel();
            sp.add(table);
            splitLayoutPanel.add(sp);
            table.getElement().getStyle().setPosition(Position.RELATIVE);
        }
    });
    initSubTabLayoutPanel();
    nicTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(1));
    diskTable.asEditor().edit((SearchableListModel) object.getDetailModels().get(2));
    if (object.getDetailModels().size() > 3) {
        appTable.asEditor().edit((VmAppListModel) object.getDetailModels().get(3));
    }
    driver.edit(object);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    QuotaDcStatusColumn dcStatusColumn = new QuotaDcStatusColumn();
    dcStatusColumn.setContextMenuTitle(constants.dcStatusQuota());
    // $NON-NLS-1$
    getTable().addColumn(dcStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<Quota> nameColumn = new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    };
    nameColumn.makeSortable(QuotaConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameQuota(), "120px");
    AbstractTextColumn<Quota> descriptionColumn = new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    };
    descriptionColumn.makeSortable(QuotaConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionQuota(), "120px");
    getTable().addColumn(new AbstractQuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getMemSizeMB();
                used = object.getGlobalQuotaCluster().getMemSizeMBUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_MEM.equals(quotaCluster.getMemSizeMB())) {
                        allocated += quotaCluster.getMemSizeMB() != null ? quotaCluster.getMemSizeMB() : 0;
                        used += quotaCluster.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getMemSizeMB();
                used = object.getGlobalQuotaCluster().getMemSizeMBUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_MEM.equals(quotaCluster.getMemSizeMB())) {
                        allocated += quotaCluster.getMemSizeMB() != null ? quotaCluster.getMemSizeMB() : 0;
                        used += quotaCluster.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 " + constants.mb();
            } else if (value <= 5 * 1024) {
                returnVal = value + constants.mb();
            } else {
                returnVal = decimalFormat.format((double) value / 1024) + constants.gb();
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new AbstractQuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getVirtualCpu() != null ? object.getGlobalQuotaCluster().getVirtualCpu() : 0;
                used = object.getGlobalQuotaCluster().getVirtualCpuUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_VCPU.equals(quotaCluster.getVirtualCpu())) {
                        allocated += quotaCluster.getVirtualCpu();
                        used += quotaCluster.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getVirtualCpu() != null ? object.getGlobalQuotaCluster().getVirtualCpu() : 0;
                used = object.getGlobalQuotaCluster().getVirtualCpuUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_VCPU.equals(quotaCluster.getVirtualCpu())) {
                        allocated += quotaCluster.getVirtualCpu();
                        used += quotaCluster.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new AbstractQuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 " + constants.gb();
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    QuotaDcStatusColumn dcStatusColumn = new QuotaDcStatusColumn();
    dcStatusColumn.setContextMenuTitle(constants.dcStatusQuota());
    // $NON-NLS-1$
    getTable().addColumn(dcStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<Quota> nameColumn = new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    };
    nameColumn.makeSortable(QuotaConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameQuota(), "120px");
    AbstractTextColumn<Quota> descriptionColumn = new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    };
    descriptionColumn.makeSortable(QuotaConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionQuota(), "120px");
    getTable().addColumn(new AbstractQuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getMemSizeMB();
                used = object.getGlobalQuotaCluster().getMemSizeMBUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_MEM.equals(quotaCluster.getMemSizeMB())) {
                        allocated += quotaCluster.getMemSizeMB() != null ? quotaCluster.getMemSizeMB() : 0;
                        used += quotaCluster.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getMemSizeMB();
                used = object.getGlobalQuotaCluster().getMemSizeMBUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_MEM.equals(quotaCluster.getMemSizeMB())) {
                        allocated += quotaCluster.getMemSizeMB() != null ? quotaCluster.getMemSizeMB() : 0;
                        used += quotaCluster.getMemSizeMBUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_MEM;
                        break;
                    }
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = messages.megabytes("0");
            } else if (value <= 5 * 1024) {
                returnVal = messages.megabytes(String.valueOf(value));
            } else {
                returnVal = messages.gigabytes(decimalFormat.format((double) value / 1024));
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new AbstractQuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getVirtualCpu() != null ? object.getGlobalQuotaCluster().getVirtualCpu() : 0;
                used = object.getGlobalQuotaCluster().getVirtualCpuUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_VCPU.equals(quotaCluster.getVirtualCpu())) {
                        allocated += quotaCluster.getVirtualCpu();
                        used += quotaCluster.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaCluster() != null) {
                allocated = object.getGlobalQuotaCluster().getVirtualCpu() != null ? object.getGlobalQuotaCluster().getVirtualCpu() : 0;
                used = object.getGlobalQuotaCluster().getVirtualCpuUsage();
            } else {
                for (QuotaCluster quotaCluster : object.getQuotaClusters()) {
                    if (!QuotaCluster.UNLIMITED_VCPU.equals(quotaCluster.getVirtualCpu())) {
                        allocated += quotaCluster.getVirtualCpu();
                        used += quotaCluster.getVirtualCpuUsage();
                    } else {
                        allocated = QuotaCluster.UNLIMITED_VCPU;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new AbstractQuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new AbstractTextColumn<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    if (!QuotaStorage.UNLIMITED.equals(quotaStorage.getStorageSizeGB())) {
                        allocated += quotaStorage.getStorageSizeGB();
                        used += quotaStorage.getStorageSizeGBUsage();
                    } else {
                        allocated = QuotaStorage.UNLIMITED;
                        break;
                    }
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = messages.gigabytes("0");
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VM> nameColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<VM> originColumn = new AbstractEnumColumn<VM, OriginType>() {

        @Override
        protected OriginType getRawValue(VM object) {
            return object.getOrigin();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<VM> memoryColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            // $NON-NLS-1$
            return String.valueOf(object.getVmMemSizeMb()) + " " + constants.mb();
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<VM> cpuColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    AbstractTextColumn<VM> archColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<VM> numOfDisksColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfDisksColumn, constants.disksVm(), "100px");
    AbstractTextColumn<VM> creationDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getVmCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    AbstractTextColumn<VM> exportDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getExportDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getImportCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VM> nameColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractTextColumn<VM> originColumn = new AbstractEnumColumn<VM, OriginType>() {

        @Override
        protected OriginType getRawValue(VM object) {
            return object.getOrigin();
        }
    };
    originColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(originColumn, constants.originVm(), "100px");
    AbstractTextColumn<VM> memoryColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return messages.megabytes(String.valueOf(object.getVmMemSizeMb()));
        }
    };
    memoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<VM> cpuColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getNumOfCpus());
        }
    };
    cpuColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpusVm(), "100px");
    AbstractTextColumn<VM> archColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getClusterArch());
        }
    };
    archColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(archColumn, constants.architectureVm(), "100px");
    AbstractTextColumn<VM> numOfDisksColumn = new AbstractTextColumn<VM>() {

        @Override
        public String getValue(VM object) {
            return String.valueOf(object.getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfDisksColumn, constants.disksVm(), "100px");
    AbstractTextColumn<VM> creationDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getVmCreationDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(creationDateColumn, constants.creationDateVm(), "200px");
    AbstractTextColumn<VM> exportDateColumn = new AbstractFullDateTimeColumn<VM>() {

        @Override
        protected Date getRawValue(VM object) {
            return object.getExportDate();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(exportDateColumn, constants.exportDateVm(), "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.restoreVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getImportCommand();
        }
    });
}
#end_block

#method_before
@Override
public String render(T sizeInMB) {
    // $NON-NLS-1$
    return sizeInMB != null ? sizeInMB.toString() + " " + constants.mb() : constants.unAvailablePropertyLabel();
}
#method_after
@Override
public String render(T sizeInMB) {
    return sizeInMB != null ? messages.megabytes(sizeInMB.toString()) : constants.unAvailablePropertyLabel();
}
#end_block

#method_before
@Override
public ManagePolicyUnitModel flush() {
    return null;
}
#method_after
@Override
public ManagePolicyUnitModel flush() {
    return model;
}
#end_block

#method_before
@Override
public void cleanup() {
}
#method_after
@Override
public void cleanup() {
    model.cleanup();
}
#end_block

#method_before
private Button createDownButton(final Label weightLabel) {
    // $NON-NLS-1$
    final Button downButton = new Button("");
    downButton.getElement().getStyle().setFloat(Style.Float.LEFT);
    downButton.getElement().getStyle().setPosition(Position.RELATIVE);
    downButton.getElement().getStyle().setTop(1, Unit.PX);
    downButton.setIcon(IconType.MINUS);
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            factor--;
            model.updateFactor(policyUnit, factor);
            weightLabel.setText(String.valueOf(factor));
            if (factor == 1) {
                downButton.setEnabled(false);
            }
        }
    });
    return downButton;
}
#method_after
private Button createDownButton(final Label weightLabel) {
    final Button downButton = new Button("");
    downButton.getElement().getStyle().setFloat(Style.Float.LEFT);
    downButton.getElement().getStyle().setPosition(Position.RELATIVE);
    downButton.getElement().getStyle().setTop(1, Unit.PX);
    downButton.setIcon(IconType.MINUS);
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            factor--;
            model.updateFactor(policyUnit, factor);
            weightLabel.setText(String.valueOf(factor));
            if (factor == 1) {
                downButton.setEnabled(false);
            }
        }
    });
    return downButton;
}
#end_block

#method_before
protected void initWidget(T widget) {
    super.initWidget(widget);
    // All popups are modal by default
    widget.setModal(true);
    // Enable background glass by default
    widget.setGlassEnabled(true);
    // Add popup widget style
    widget.addStyleName(POPUP_CONTENT_STYLE_NAME);
}
#method_after
@Override
protected final void initWidget(IsWidget widget) {
    // $NON-NLS-1$
    throw new IllegalArgumentException("Use initWidget(PopupPanel) instead of initWidget(Widget)");
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    labelEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<org.ovirt.engine.core.common.businessentities.Label>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    initThreadsPerCore();
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.timeZoneVm());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor.hideLabel();
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.hideLabel();
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    migrationModeEditor.hideLabel();
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxEditor(Align.RIGHT, new ModeSwitchingVisibilityRenderer());
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    overrideMigrationPolicyEditor = new EntityModelCheckBoxEditor(Align.RIGHT, new ModeSwitchingVisibilityRenderer());
    migrationPolicyEditor = new ListModelListBoxOnlyEditor<>(new NameRenderer<MigrationPolicy>(), new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor.hideLabel();
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<DataCenterWithCluster>(new NameRenderer<DataCenterWithCluster>()) {

        @Override
        public String getModelLabel(DataCenterWithCluster model) {
            return model.getCluster().getName();
        }

        @Override
        public String getGroupLabel(DataCenterWithCluster model) {
            return messages.hostDataCenter(model.getDataCenter().getName());
        }

        public Comparator<DataCenterWithCluster> getComparator() {
            return new DataCenterWithClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterWithClusterComparator implements Comparator<DataCenterWithCluster> {

            @Override
            public int compare(DataCenterWithCluster clusterWithDc1, DataCenterWithCluster clusterWithDc2) {
                if (clusterWithDc1.getDataCenter().getName() != null && clusterWithDc2.getDataCenter().getName() == null) {
                    return -1;
                } else if (clusterWithDc2.getDataCenter().getName() != null && clusterWithDc1.getDataCenter().getName() == null) {
                    return 1;
                } else if (clusterWithDc1.getDataCenter().getName() == null && clusterWithDc2.getDataCenter().getName() == null) {
                    return 0;
                }
                if (clusterWithDc1.getDataCenter().getName().equals(clusterWithDc2.getDataCenter().getName())) {
                    return clusterWithDc1.getCluster().getName().compareToIgnoreCase(clusterWithDc2.getCluster().getName());
                } else {
                    return clusterWithDc1.getDataCenter().getName().compareToIgnoreCase(clusterWithDc2.getDataCenter().getName());
                }
            }
        }
    });
    quotaEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    labelEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<org.ovirt.engine.core.common.businessentities.Label>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultEmulatedMachineLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = getDefaultCpuTypeLabel();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    initThreadsPerCore();
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    EnableableFormLabel label = new EnableableFormLabel();
    label.setText(constants.timeZoneVm());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    consoleDisconnectActionEditor = new ListModelListBoxEditor<>(new EnumRenderer<ConsoleDisconnectAction>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor.hideLabel();
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    defaultHostEditor.hideLabel();
    migrationModeEditor = new ListModelListBoxEditor<>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    migrationModeEditor.hideLabel();
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxEditor(Align.RIGHT, new ModeSwitchingVisibilityRenderer());
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    overrideMigrationPolicyEditor = new EntityModelCheckBoxEditor(Align.RIGHT, new ModeSwitchingVisibilityRenderer());
    migrationPolicyEditor = new ListModelListBoxOnlyEditor<>(new NameRenderer<MigrationPolicy>(), new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor.hideLabel();
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    providersEditor.setLabel(constants.providerLabel());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
                generalWarningMessage.setVisible(true);
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditorRow, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            changeApplicationLevelVisibility(serialNumberPolicyEditor, true);
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
            updateUrandomLabel(object);
        }
    });
    object.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsChangable".equals(args.propertyName)) {
                // $NON-NLS-1$
                cpuPinningLabel.setStyleName(object.getCpuPinning().getIsChangable() ? OvirtCss.LABEL_ENABLED : OvirtCss.LABEL_DISABLED);
            }
        }
    });
    object.getCustomCompatibilityVersion().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateUrandomLabel(object);
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.asRadioButton().setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
                generalWarningMessage.setVisible(true);
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditorRow, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            changeApplicationLevelVisibility(serialNumberPolicyEditor, true);
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
    object.getDataCenterWithClustersList().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            emulatedMachine.setNullReplacementString(getDefaultEmulatedMachineLabel());
            customCpu.setNullReplacementString(getDefaultCpuTypeLabel());
            updateUrandomLabel(object);
        }
    });
    object.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsChangable".equals(args.propertyName)) {
                // $NON-NLS-1$
                cpuPinningLabel.setStyleName(object.getCpuPinning().getIsChangable() ? OvirtCss.LABEL_ENABLED : OvirtCss.LABEL_DISABLED);
            }
        }
    });
    object.getCustomCompatibilityVersion().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateUrandomLabel(object);
        }
    });
    object.getIsHeadlessModeEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isHeadlessEnabled = object.getIsHeadlessModeEnabled().getEntity();
            ssoMethodLabel.setEnabled(!isHeadlessEnabled);
            monitorsLabel.setEnabled(!isHeadlessEnabled);
            spiceProxyEnabledCheckboxWithInfoIcon.setEnabled(!isHeadlessEnabled);
        }
    });
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                    generalWarningMessage.setVisible(false);
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngSourceUrandom.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceUrandom().setEntity(true);
            vm.getRngSourceHwrng().setEntity(false);
        }
    });
    rngSourceHwrng.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceHwrng().setEntity(true);
            vm.getRngSourceUrandom().setEntity(false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue()) {
                specificHost.setValue(true, true);
            }
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                    generalWarningMessage.setVisible(false);
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.asRadioButton().getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    rngSourceUrandom.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceUrandom().setEntity(true);
            vm.getRngSourceHwrng().setEntity(false);
        }
    });
    rngSourceHwrng.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> booleanValueChangeEvent) {
            vm.getRngSourceHwrng().setEntity(true);
            vm.getRngSourceUrandom().setEntity(false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue()) {
                specificHost.asRadioButton().setValue(true, true);
            }
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    labelEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    maxMemorySizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    isHeadlessModeEnabledEditor.setTabIndex(nextTabIndex++);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceUrandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    labelEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    maxMemorySizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    isHeadlessModeEnabledEditor.setTabIndex(nextTabIndex++);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceUrandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void init(String title, String width, String height, boolean closeIconVisible) {
    asWidget().setWidth(width);
    asWidget().setHeight(height);
    asWidget().setCloseIconButtonVisible(closeIconVisible);
}
#method_after
@Override
public void init(String title, String width, String height, boolean closeIconVisible) {
    dialogPanel.setTitle(title);
    asWidget().setWidth(width);
    asWidget().setHeight(height);
    asWidget().setCloseIconButtonVisible(closeIconVisible);
}
#end_block

#method_before
public void addClickHandler(ClickHandler clickHandler) {
    tabListItem.addClickHandler(clickHandler);
}
#method_after
public HandlerRegistration addClickHandler(ClickHandler clickHandler) {
    return tabListItem.addClickHandler(clickHandler);
}
#end_block

#method_before
private void hideEditorLabels() {
    providersEditor.hideLabel();
    passwordEditor.hideLabel();
    publicKeyEditor.hideLabel();
    consoleAddressEnabled.hideLabel();
    consoleAddress.hideLabel();
}
#method_after
private void hideEditorLabels() {
    providersEditor.hideLabel();
    passwordEditor.hideLabel();
    publicKeyEditor.hideLabel();
    consoleAddress.hideLabel();
    kernelCmdlineText.hideLabel();
}
#end_block

#method_before
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    labelEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<org.ovirt.engine.core.common.businessentities.Label>(), new VisibilityRenderer.SimpleVisibilityRenderer());
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new RadioButton("2");
    // $NON-NLS-1$
    rbProvisionedHost = new RadioButton("2");
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
    hostedEngineDeployActionsEditor = new ListModelListBoxEditor<>(new EnumRenderer<HostedEngineDeployConfiguration.Action>());
}
#method_after
private void initEditors() {
    publicKeyEditor = new StringEntityModelTextAreaLabelEditor();
    // List boxes
    clusterEditor = new GroupedListModelListBoxEditor<>(new GroupedListModelListBox<Cluster>(new NameRenderer<Cluster>()) {

        @Override
        public String getModelLabel(Cluster model) {
            return model.getName();
        }

        @Override
        public String getGroupLabel(Cluster model) {
            return messages.hostDataCenter(model.getStoragePoolName());
        }

        public Comparator<Cluster> getComparator() {
            return new DataCenterClusterComparator();
        }

        /**
         * Comparator that sorts on data center name first, and then cluster name. Ignoring case.
         */
        final class DataCenterClusterComparator implements Comparator<Cluster> {

            @Override
            public int compare(Cluster cluster1, Cluster cluster2) {
                if (cluster1.getStoragePoolName() != null && cluster2.getStoragePoolName() == null) {
                    return -1;
                } else if (cluster2.getStoragePoolName() != null && cluster1.getStoragePoolName() == null) {
                    return 1;
                } else if (cluster1.getStoragePoolName() == null && cluster2.getStoragePoolName() == null) {
                    return 0;
                }
                if (cluster1.getStoragePoolName().equals(cluster2.getStoragePoolName())) {
                    return cluster1.getName().compareToIgnoreCase(cluster2.getName());
                } else {
                    return cluster1.getStoragePoolName().compareToIgnoreCase(cluster2.getStoragePoolName());
                }
            }
        }
    });
    externalHostNameEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    providersEditor = new ListModelListBoxEditor<>(new NameRenderer<Provider<OpenstackNetworkProviderProperties>>());
    externalDiscoveredHostsEditor = getListModelTypeAheadListBoxEditor();
    externalHostGroupsEditor = getListModelTypeAheadListBoxEditor();
    externalComputeResourceEditor = getListModelTypeAheadListBoxEditor();
    labelEditor = new ListModelMultipleSelectListBoxEditor<>(new NameRenderer<org.ovirt.engine.core.common.businessentities.Label>(), new VisibilityRenderer.SimpleVisibilityRenderer());
    // Check boxes
    pmEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmEnabledEditor.setUsePatternFly(true);
    pmKdumpDetectionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    pmKdumpDetectionEditor.setUsePatternFly(true);
    disableAutomaticPowerManagementEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    disableAutomaticPowerManagementEditor.setUsePatternFly(true);
    externalHostProviderEnabledEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    overrideIpTablesEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    rbPassword = new RadioButton("1");
    // $NON-NLS-1$
    rbPublicKey = new RadioButton("1");
    // $NON-NLS-1$
    rbDiscoveredHost = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    rbProvisionedHost = new EntityModelRadioButtonEditor("2");
    kernelCmdlineIommu = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineKvmNested = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlineUnsafeInterrupts = new EntityModelCheckBoxEditor(Align.RIGHT);
    kernelCmdlinePciRealloc = new EntityModelCheckBoxEditor(Align.RIGHT);
    consoleAddressEnabled = new EntityModelCheckBoxEditor(Align.RIGHT);
    hostedEngineDeployActionsEditor = new ListModelListBoxEditor<>(new EnumRenderer<HostedEngineDeployConfiguration.Action>());
}
#end_block

#method_before
void localize() {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    labelEditor.setLabel(constants.affinityLabels());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rootPasswordLabel.setText(constants.hostPopupAuthLabelForExternalHost());
    rbPasswordLabel.setText(constants.hostPopupPasswordLabel());
    rbPublicKeyLabel.setText(constants.hostPopupPublicKeyLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
    hostedEngineTab.setLabel(constants.hostedEngineLabel());
}
#method_after
void localize() {
    // General tab
    generalTab.setLabel(constants.hostPopupGeneralTabLabel());
    clusterEditor.setLabel(constants.hostPopupClusterLabel());
    nameEditor.setLabel(constants.hostPopupNameLabel());
    userNameEditor.setLabel(constants.hostPopupUsernameLabel());
    commentEditor.setLabel(constants.commentLabel());
    labelEditor.setLabel(constants.affinityLabels());
    hostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    authSshPortEditor.setLabel(constants.hostPopupPortLabel());
    authLabel.setText(constants.hostPopupAuthLabel());
    rootPasswordLabel.setText(constants.hostPopupAuthLabelForExternalHost());
    rbPasswordLabel.setText(constants.hostPopupPasswordLabel());
    rbPublicKeyLabel.setText(constants.hostPopupPublicKeyLabel());
    fingerprintLabel.setText(constants.hostPopupHostFingerprintLabel());
    overrideIpTablesEditor.setLabel(constants.hostPopupOverrideIpTablesLabel());
    externalHostProviderEnabledEditor.setLabel(constants.hostPopupEnableExternalHostProvider());
    externalHostNameEditor.setLabel(constants.hostPopupExternalHostName());
    publicKeyEditor.setTitle(constants.publicKeyUsage());
    // Power Management tab
    powerManagementTab.setLabel(constants.hostPopupPowerManagementTabLabel());
    pmEnabledEditor.setLabel(constants.hostPopupPmEnabledLabel());
    // Auto PM
    disableAutomaticPowerManagementEditor.setLabel(constants.hostPopupPmDisableAutoPM());
    pmKdumpDetectionEditor.setLabel(constants.hostPopupPmKdumpDetection());
    // SPM tab
    spmTab.setLabel(constants.spmTestButtonLabel());
    consoleTab.setLabel(constants.consoleButtonLabel());
    // Network Provider Tab
    networkProviderTab.setLabel(constants.networkProviderButtonLabel());
    externalDiscoveredHostsEditor.setLabel(constants.discoveredHostsLabel());
    externalHostGroupsEditor.setLabel(constants.hostGroupsLabel());
    externalComputeResourceEditor.setLabel(constants.computeResourceLabel());
    // Info icons
    kernelCmdlineUnsafeInterruptsInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineUnsafeInterruptsInfoIcon()));
    kernelCmdlineIommuInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineIommuInfoIcon()));
    kernelCmdlineKvmNestedInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineKvmNestedInfoIcon()));
    kernelCmdlinePciReallocInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlinePciReallocInfoIcon()));
    kernelCmdlineInfoIcon.setText(SafeHtmlUtils.fromString(constants.kernelCmdlineInfoIcon()));
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            String fetchResultText = object.getFetchResult().getEntity();
            if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
                fetchResult.addStyleName(style.fetchResultErrorLabel());
            } else {
                fetchResult.removeStyleName(style.fetchResultErrorLabel());
            }
            fetchResult.setText(fetchResultText);
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            boolean doProvisioning = object.externalProvisionEnabled();
            providersEditor.setVisible(showForemanProviders);
            // showing or hiding radio buttons
            provisionedHostSection.setVisible(showForemanProviders && doProvisioning);
            discoveredHostSection.setVisible(showForemanProviders && doProvisioning);
            // disabling ip and name textbox when using provisioned hosts
            hostAddressEditor.setEnabled(!(showForemanProviders && doProvisioning));
            if (showForemanProviders && doProvisioning) {
                object.updateHosts();
                object.getIsDiscoveredHosts().setEntity(true);
            } else {
                if (doProvisioning) {
                    object.cleanHostParametersFields();
                }
                hideProviderWidgets(object);
                object.getIsDiscoveredHosts().setEntity(null);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getIsDiscoveredHosts().getEntity() != null) {
                if (object.getIsDiscoveredHosts().getEntity()) {
                    rbDiscoveredHost.setValue(true);
                    showDiscoveredHostsWidgets(true);
                } else if (!object.getIsDiscoveredHosts().getEntity()) {
                    rbProvisionedHost.setValue(true);
                    showProvisionedHostsWidgets(true);
                }
            }
        }
    });
    nameEditor.asValueBox().addKeyDownHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

                @Override
                public void execute() {
                    if (object.getExternalHostProviderEnabled().getEntity() && Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                        ExternalHostGroup dhg = (ExternalHostGroup) object.getExternalHostGroups().getSelectedItem();
                        if (dhg != null) {
                            String base = nameEditor.asEditor().getSubEditor().getValue();
                            if (base == null) {
                                base = constants.empty();
                            }
                            String generatedHostName = // $NON-NLS-1$
                            base + "." + (dhg.getDomainName() != null ? dhg.getDomainName() : constants.empty());
                            object.getHost().setEntity(generatedHostName);
                        }
                    }
                }
            });
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangeable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    this.fenceAgentsEditor.edit(object.getFenceAgentListModel());
    this.proxySourceEditor.edit(object.getPmProxyPreferencesList());
    addTextAndLinkAlert(fetchPanel, constants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    providerSearchFilterLabel.setText(constants.hostPopupProviderSearchFilter());
    nameEditor.setFocus(true);
    hostedEngineTab.setVisible(object.getIsHeSystem() && object.getIsNew());
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            String fetchResultText = object.getFetchResult().getEntity();
            if (ConstantsManager.getInstance().getConstants().errorLoadingFingerprint().equals(fetchResultText)) {
                fetchResult.addStyleName(style.fetchResultErrorLabel());
            } else {
                fetchResult.removeStyleName(style.fetchResultErrorLabel());
            }
            fetchResult.setText(fetchResultText);
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    object.getProviders().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            object.updateHosts();
        }
    });
    object.getExternalHostProviderEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean showForemanProviders = object.getExternalHostProviderEnabled().getEntity();
            boolean doProvisioning = object.externalProvisionEnabled();
            providersEditor.setVisible(showForemanProviders);
            // showing or hiding radio buttons
            provisionedHostSection.setVisible(showForemanProviders && doProvisioning);
            discoveredHostSection.setVisible(showForemanProviders && doProvisioning);
            // disabling ip and name textbox when using provisioned hosts
            hostAddressEditor.setEnabled(!(showForemanProviders && doProvisioning));
            if (showForemanProviders && doProvisioning) {
                object.updateHosts();
                object.getIsDiscoveredHosts().setEntity(true);
            } else {
                if (doProvisioning) {
                    object.cleanHostParametersFields();
                }
                hideProviderWidgets(object);
                object.getIsDiscoveredHosts().setEntity(null);
            }
        }
    });
    object.getIsDiscoveredHosts().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getIsDiscoveredHosts().getEntity() != null) {
                if (object.getIsDiscoveredHosts().getEntity()) {
                    rbDiscoveredHost.asRadioButton().setValue(true);
                    showDiscoveredHostsWidgets(true);
                } else if (!object.getIsDiscoveredHosts().getEntity()) {
                    rbProvisionedHost.asRadioButton().setValue(true);
                    showProvisionedHostsWidgets(true);
                }
            }
        }
    });
    nameEditor.asValueBox().addKeyDownHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand() {

                @Override
                public void execute() {
                    if (object.getExternalHostProviderEnabled().getEntity() && Boolean.TRUE.equals(object.getIsDiscoveredHosts().getEntity())) {
                        ExternalHostGroup dhg = (ExternalHostGroup) object.getExternalHostGroups().getSelectedItem();
                        if (dhg != null) {
                            String base = nameEditor.asEditor().getSubEditor().getValue();
                            if (base == null) {
                                base = constants.empty();
                            }
                            String generatedHostName = // $NON-NLS-1$
                            base + "." + (dhg.getDomainName() != null ? dhg.getDomainName() : constants.empty());
                            object.getHost().setEntity(generatedHostName);
                        }
                    }
                }
            });
        }
    });
    rbPassword.setValue(true);
    rbPassword.setFocus(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addFocusHandler(new FocusHandler() {

        @Override
        public void onFocus(FocusEvent event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Create SPM related controls.
    IEventListener<EventArgs> spmListener = new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangeable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    this.fenceAgentsEditor.edit(object.getFenceAgentListModel());
    this.proxySourceEditor.edit(object.getPmProxyPreferencesList());
    addTextAndLinkAlert(fetchPanel, constants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    providerSearchFilterLabel.setText(constants.hostPopupProviderSearchFilter());
    nameEditor.setFocus(true);
    hostedEngineTab.setVisible(object.getIsHeSystem() && object.getIsNew());
    object.getHostedEngineWarning().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            EntityModel entity = (EntityModel) sender;
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                hostedEngineWarningLabel.setVisible(entity.getIsAvailable());
            }
        }
    });
}
#end_block

#method_before
private void hideProviderWidgets(final HostModel object) {
    rbProvisionedHost.setValue(false);
    rbDiscoveredHost.setValue(false);
    usualFormToDiscover(false);
    showExternalDiscoveredHost(false);
    setHostProviderVisibility(false);
}
#method_after
private void hideProviderWidgets(final HostModel object) {
    rbProvisionedHost.asRadioButton().setValue(false);
    rbDiscoveredHost.asRadioButton().setValue(false);
    usualFormToDiscover(false);
    showExternalDiscoveredHost(false);
    setHostProviderVisibility(false);
}
#end_block

#method_before
@Override
@UiChild(tagname = "header", limit = 1)
public void setHeader(String headerTitle) {
    // $NON-NLS-1$
    HTMLPanel headerTitlePanel = new HTMLPanel("H4", headerTitle);
    headerTitlePanel.addStyleName(Styles.MODAL_TITLE);
    headerTitlePanel.getElement().getStyle().setFloat(Float.LEFT);
    // Close button and IconType makes 2 widgets
    if (header.getWidgetCount() > 2) {
        header.remove(header.getWidgetCount() - 1);
    }
    header.add(headerTitlePanel);
    addHelpButtonHandler();
    helpIconButtonTooltip.setText(constants.clickForHelp());
}
#method_after
@Override
@UiChild(tagname = "header", limit = 1)
public void setHeader(String headerTitle) {
    // $NON-NLS-1$
    HTMLPanel headerTitlePanel = new HTMLPanel("H4", headerTitle);
    headerTitlePanel.addStyleName(Styles.MODAL_TITLE);
    headerTitlePanel.getElement().getStyle().setFloat(Float.LEFT);
    // Close button and IconType makes 2 widgets
    while (header.getWidgetCount() > 2) {
        header.remove(header.getWidgetCount() - 1);
    }
    header.add(headerTitlePanel);
    addHelpButtonHandler();
    helpIconButtonTooltip.setText(constants.clickForHelp());
}
#end_block

#method_before
@Override
public void show() {
    super.show();
    // 100 pixels is the height of the header and the footer combined. Including the margins.
    contentScrollPanel.getElement().getStyle().setHeight(getOffsetHeight() - 100, Unit.PX);
    // $NON-NLS-1$
    contentPanel.getElement().getStyle().setProperty("minHeight", getOffsetHeight() - 100, Unit.PX);
}
#method_after
@Override
public void show() {
    super.show();
    contentScrollPanel.getElement().getStyle().setHeight(getOffsetHeight() - HEADER_FOOTER_HEIGHT, Unit.PX);
    // $NON-NLS-1$
    contentPanel.getElement().getStyle().setProperty("minHeight", getOffsetHeight() - HEADER_FOOTER_HEIGHT, Unit.PX);
}
#end_block

#method_before
public void setNoScroll(boolean value) {
    if (value) {
        contentScrollPanel.getElement().getStyle().setOverflow(Overflow.VISIBLE);
    }
}
#method_after
public void setNoScroll(boolean value) {
    if (value) {
        contentScrollPanel.getElement().getStyle().setOverflow(Overflow.VISIBLE);
    } else {
        contentScrollPanel.getElement().getStyle().setOverflow(Overflow.AUTO);
    }
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    setVmTemplateId(Guid.newGuid());
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    if (Guid.isNullOrEmpty(getParameters().getVmTemplateId())) {
        setVmTemplateId(Guid.newGuid());
    } else {
        setVmTemplateId(getParameters().getVmTemplateId());
    }
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected Map<Guid, Guid> addAllTemplateDisks() {
    CreateAllTemplateDisksParameters parameters = new CreateAllTemplateDisksParameters(getVm() != null ? getVmId() : Guid.Empty);
    parameters.setVmTemplateId(getVmTemplateId());
    parameters.setVmTemplateName(getVmTemplateName());
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    parameters.setTargetDiskIds(targetDiskIds);
    if (getParameters().isSealTemplate()) {
        parameters.setCopyVolumeType(CopyVolumeType.LeafVol);
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    VdcReturnValueBase returnValue = runInternalAction(getAddAllTemplateDisksActionType(), parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#method_after
protected Map<Guid, Guid> addAllTemplateDisks() {
    VdcReturnValueBase returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#end_block

#method_before
private void assignLegalAndShared(boolean legalAndShared) {
    UpdateAllTemplateDisksParameters parameters = new UpdateAllTemplateDisksParameters(getVmTemplateId(), legalAndShared, legalAndShared ? true : null);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.UpdateAllTemplateDisks, parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
}
#method_after
private void assignLegalAndShared(boolean legalAndShared) {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
private void sealVmTemplate() {
    SealVmTemplateParameters parameters = new SealVmTemplateParameters();
    parameters.setVmTemplateId(getVmTemplateId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.SealVmTemplate, parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
}
#method_after
private void sealVmTemplate() {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
private void restoreCommandState() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
}
#method_after
private void restoreCommandState() {
    setVmId(getVmIdFromImageParameters());
    isVmInDb = !getVmId().equals(Guid.Empty) && getVm() != null;
}
#end_block

#method_before
private void postNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) userPortalListModel.getWindow();
    UserPortalItemModel selectedItem = userPortalListModel.getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    VM newVm = buildVmOnNewTemplate(model, vm);
    newVm.setMigrationDowntime(vm.getMigrationDowntime());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    addVmTemplateParameters.setSealTemplate(model.getSealTemplate().getEntity());
    addVmTemplateParameters.setUpdateRngDevice(true);
    addVmTemplateParameters.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#method_after
private void postNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) userPortalListModel.getWindow();
    UserPortalItemModel selectedItem = userPortalListModel.getSelectedItem();
    VM vm = (VM) selectedItem.getEntity();
    VM newVm = buildVmOnNewTemplate(model, vm);
    newVm.setMigrationDowntime(vm.getMigrationDowntime());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newVm, model.getName().getEntity(), model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse(model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions(model.getCopyPermissions().getEntity());
    addVmTemplateParameters.setSealTemplate(model.getSealTemplate().getEntity());
    addVmTemplateParameters.setUpdateRngDevice(true);
    addVmTemplateParameters.setRngDevice(model.getIsRngEnabled().getEntity() ? model.generateRngDevice() : null);
    if (vm.getDefaultDisplayType() == DisplayType.none) {
        addVmTemplateParameters.getMasterVm().setDefaultDisplayType(DisplayType.none);
    }
    BuilderExecutor.build(model, addVmTemplateParameters, new UnitToGraphicsDeviceParamsBuilder());
    if (model.getIsSubTemplate().getEntity()) {
        addVmTemplateParameters.setBaseTemplateId(model.getBaseTemplate().getSelectedItem().getId());
        addVmTemplateParameters.setTemplateVersionName(model.getTemplateVersionName().getEntity());
    }
    Frontend.getInstance().runAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            stopProgress(result.getState());
            cancel();
        }
    }, this);
}
#end_block

#method_before
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    List<String> changedFields = returnValue.getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, gettempVm()));
                        boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(gettempVm());
                        confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, gettempVm(), isMemoryHotUnplugSupported));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#method_after
public void postVmNameUniqueCheck() {
    final UnitVmModel model = (UnitVmModel) getWindow();
    // Save changes.
    buildVmOnSave(model, gettempVm());
    gettempVm().setCpuPinning(model.getCpuPinning().getEntity());
    gettempVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        saveNewVm(model);
    } else {
        final VM selectedItem = (VM) getSelectedItem().getEntity();
        gettempVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
        if (!selectedItem.isHostedEngine() && selectedItem.isRunningOrPaused()) {
            AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, gettempVm(), getUpdateVmParameters(false), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    List<String> changedFields = returnValue.getReturnValue();
                    if (!changedFields.isEmpty()) {
                        VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                        boolean isHeadlessModeChanged = isHeadlessModeChanged(editedVm, getUpdateVmParameters(false));
                        if (isHeadlessModeChanged) {
                            changedFields.add(constants.headlessMode());
                        }
                        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                        confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                        // $NON-NLS-1$
                        confirmModel.setHashName("edit_next_run_configuration");
                        confirmModel.setChangedFields(changedFields);
                        confirmModel.setCpuPluggable(VmCommonUtils.isCpusToBeHotplugged(selectedItem, gettempVm()));
                        boolean isMemoryHotUnplugSupported = AsyncDataProvider.getInstance().isMemoryHotUnplugSupported(gettempVm());
                        confirmModel.setMemoryPluggable(VmCommonUtils.isMemoryToBeHotplugged(selectedItem, gettempVm(), isMemoryHotUnplugSupported));
                        confirmModel.getCommands().add(// $NON-NLS-1$
                        new UICommand("updateExistingVm", UserPortalListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                        // $NON-NLS-1$
                        confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", UserPortalListModel.this));
                        setConfirmWindow(confirmModel);
                    } else {
                        updateExistingVm(false);
                    }
                }
            }));
        } else {
            updateExistingVm(false);
        }
    }
}
#end_block

#method_before
private void saveNewVm(final UnitVmModel model) {
    setstorageDomain(model.getStorageDomain().getSelectedItem());
    VM vm = gettempVm();
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setMakeCreatorExplicitOwner(true);
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVmLargeIcon(model.getIcon().getEntity().getIcon());
    setRngDeviceToParams(model, parameters);
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
}
#method_after
private void saveNewVm(final UnitVmModel model) {
    setstorageDomain(model.getStorageDomain().getSelectedItem());
    VM vm = gettempVm();
    vm.setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    AddVmParameters parameters = new AddVmParameters(vm);
    parameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    parameters.setMakeCreatorExplicitOwner(true);
    parameters.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
    parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVmLargeIcon(model.getIcon().getEntity().getIcon());
    setRngDeviceToParams(model, parameters);
    if (model.getIsHeadlessModeEnabled().getEntity()) {
        parameters.getVmStaticData().setDefaultDisplayType(DisplayType.none);
    }
    BuilderExecutor.build(model, parameters, new UnitToGraphicsDeviceParamsBuilder());
    if (!StringHelper.isNullOrEmpty(model.getVmId().getEntity())) {
        parameters.setVmId(new Guid(model.getVmId().getEntity()));
    }
    Frontend.getInstance().runAction(model.getProvisioning().getEntity() ? VdcActionType.AddVmFromTemplate : VdcActionType.AddVm, parameters, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
}
#end_block

#method_before
private VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase params = new VmManagementParametersBase(gettempVm());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), gettempVm()), params, new VmIconUnitAndVmToParameterBuilder());
    params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, params);
    params.setApplyChangesLater(applyCpuChangesLater);
    BuilderExecutor.build(model, params, new UnitToGraphicsDeviceParamsBuilder());
    return params;
}
#method_after
private VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase params = new VmManagementParametersBase(gettempVm());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), gettempVm()), params, new VmIconUnitAndVmToParameterBuilder());
    params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    setRngDeviceToParams(model, params);
    params.setApplyChangesLater(applyCpuChangesLater);
    if (model.getIsHeadlessModeEnabled().getEntity()) {
        params.getVmStaticData().setDefaultDisplayType(DisplayType.none);
    }
    BuilderExecutor.build(model, params, new UnitToGraphicsDeviceParamsBuilder());
    return params;
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getOverrideMigrationPolicy().setIsChangeable(false);
        getMigrationPolicies().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceUrandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getMaxMemorySize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getIsHeadlessModeEnabled().setIsChangeable(false);
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getOverrideMigrationPolicy().setIsChangeable(false);
        getMigrationPolicies().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceUrandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceUrandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    initConsoleDisconnectAction();
    updateLabelList();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getMaxMemorySize().setEntity(VmCommonUtils.getMaxMemorySizeDefault(getMemSize().getEntity()));
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsHeadlessModeEnabled().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceUrandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    initConsoleDisconnectAction();
    updateLabelList();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            if (behavior.isCustomCompatibilityVersionChangeInProgress()) {
                return;
            }
            // A workaround for saving the current CustomCompatibilityVersion value for re-setting it after
            // it will be reset by the getTemplateWithVersion event.
            // This is relevant for new VM only
            behavior.setCustomCompatibilityVersionChangeInProgress(true);
            behavior.setSavedCurrentCustomCompatibilityVersion(getCustomCompatibilityVersion().getSelectedItem());
            compatibilityVersionChanged(sender, args);
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            // needs to be first because it affects compatibility version
            behavior.updateCompatibilityVersion();
            compatibilityVersionChanged(sender, args);
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            getBehavior().updateMemoryBalloon();
            headlessModeChanged();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            initGraphicsConsoles();
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getThreadsPerCore()) {
            threadsPerCore_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getMigrationPolicies()) {
            updateMigrationRelatedFields();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        } else if (sender == getCustomCompatibilityVersion()) {
            // window must be updated as if a cluster change occurred because feature availability should be reconsidered
            if (behavior.isCustomCompatibilityVersionChangeInProgress()) {
                return;
            }
            // A workaround for saving the current CustomCompatibilityVersion value for re-setting it after
            // it will be reset by the getTemplateWithVersion event.
            // This is relevant for new VM only
            behavior.setCustomCompatibilityVersionChangeInProgress(true);
            behavior.setSavedCurrentCustomCompatibilityVersion(getCustomCompatibilityVersion().getSelectedItem());
            compatibilityVersionChanged(sender, args);
            headlessModeChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemsChangedEventDefinition)) {
        if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
            behavior.updateHaAvailability();
            behavior.updateMigrationAvailability();
            behavior.updateNumaEnabled();
            headlessModeChanged();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
            behavior.updateMigrationAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getOverrideMigrationPolicy()) {
            overrideMigrationPolicyChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        } else if (sender == getName()) {
            autoSetHostname();
        } else if (sender == getIsHeadlessModeEnabled()) {
            headlessModeChanged();
        }
    }
}
#end_block

#method_before
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
    }
}
#method_after
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
        if (getSysprepEnabled().getEntity()) {
            getVmInitModel().updateSysprepDomain(getVmInitModel().getSysprepDomain().getSelectedItem());
        }
    }
}
#end_block

#method_before
private void initGraphicsAndDisplayListeners() {
    getDisplayType().getSelectedItemChangedEvent().addListener(this);
    getGraphicsType().getSelectedItemChangedEvent().addListener(this);
}
#method_after
private void initGraphicsAndDisplayListeners() {
    getIsHeadlessModeEnabled().getEntityChangedEvent().addListener(this);
    getDisplayType().getSelectedItemChangedEvent().addListener(this);
    getGraphicsType().getSelectedItemChangedEvent().addListener(this);
}
#end_block

#method_before
public void initDisplayModels(List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays) {
    // get supported display types
    Set<DisplayType> displayTypes = new LinkedHashSet<>();
    for (Pair<GraphicsType, DisplayType> graphicsTypeDisplayTypePair : graphicsAndDisplays) {
        displayTypes.add(graphicsTypeDisplayTypePair.getSecond());
    }
    // set items and set selected one
    DisplayType selectedDisplayType = getDisplayType().getSelectedItem();
    if (displayTypes.contains(selectedDisplayType)) {
        getDisplayType().setItems(displayTypes, selectedDisplayType);
    } else if (displayTypes.size() > 0) {
        getDisplayType().setItems(displayTypes, displayTypes.iterator().next());
    }
}
#method_after
public void initDisplayModels(List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays) {
    // get supported display types
    Set<DisplayType> displayTypes = new LinkedHashSet<>();
    for (Pair<GraphicsType, DisplayType> graphicsTypeDisplayTypePair : graphicsAndDisplays) {
        if (graphicsTypeDisplayTypePair.getSecond() != DisplayType.none) {
            displayTypes.add(graphicsTypeDisplayTypePair.getSecond());
        }
    }
    // set items and set selected one
    DisplayType selectedDisplayType = getDisplayType().getSelectedItem();
    if (displayTypes.contains(selectedDisplayType)) {
        getDisplayType().setItems(displayTypes, selectedDisplayType);
    } else if (displayTypes.size() > 0) {
        getDisplayType().setItems(displayTypes, displayTypes.iterator().next());
    }
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    refreshMigrationPolicies();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private void memSize_EntityChanged(Object sender, EventArgs args) {
    behavior.updateMinAllocatedMemory();
}
#method_after
private void memSize_EntityChanged(Object sender, EventArgs args) {
    behavior.updateMinAllocatedMemory();
    behavior.updateMaxMemory();
}
#end_block

#method_before
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!getBehavior().isBlankTemplateBehavior()) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.INITIAL_RUN_TAB, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    fireValidationCompleteEvent();
    return isValid;
}
#method_after
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), createEachDiskAHasStorageDomainValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!getBehavior().isBlankTemplateBehavior()) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.INITIAL_RUN_TAB, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    fireValidationCompleteEvent();
    return isValid;
}
#end_block

#method_before
public boolean validateHwPart() {
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    validateMemoryAlignment(getMemSize());
    if (getIoThreadsEnabled().getEntity()) {
        getNumOfIoThreads().validateEntity(new IValidation[] { new NotNullIntegerValidation(1, AsyncDataProvider.getInstance().getMaxIoThreadsPerVm()) });
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid() && getNumOfIoThreads().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    /*
         * This should be run at very end of the validation process otherwise general validation can override more
         * strict checks in behaviors
         */
    boolean behaviorValid = behavior.validate();
    boolean isValid = behaviorValid && allTabsValid();
    return isValid;
}
#method_after
public boolean validateHwPart() {
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    validateMaxMemorySize();
    validateMemoryAlignment(getMemSize());
    if (getIoThreadsEnabled().getEntity()) {
        getNumOfIoThreads().validateEntity(new IValidation[] { new NotNullIntegerValidation(1, AsyncDataProvider.getInstance().getMaxIoThreadsPerVm()) });
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid() && getNumOfIoThreads().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    /*
         * This should be run at very end of the validation process otherwise general validation can override more
         * strict checks in behaviors
         */
    boolean behaviorValid = behavior.validate();
    boolean isValid = behaviorValid && allTabsValid();
    return isValid;
}
#end_block

#method_before
@Override
protected void build(UnitVmModel source, T destination) {
    destination.setPublicUse(source.getIsTemplatePublic().getEntity());
    destination.setDiskInfoDestinationMap(source.getDisksAllocationModel().getImageToDestinationDomainMap());
    destination.setSoundDeviceEnabled(source.getIsSoundcardEnabled().getEntity());
    destination.setBalloonEnabled(BalloonEnabled.balloonEnabled(source));
    destination.setCopyVmPermissions(source.getCopyPermissions().getEntity());
    destination.setSealTemplate(source.getSealTemplate().getEntity());
    destination.setConsoleEnabled(source.getIsConsoleDeviceEnabled().getEntity());
    if (source.getIsSubTemplate().getEntity()) {
        destination.setBaseTemplateId(source.getBaseTemplate().getSelectedItem().getId());
        destination.setTemplateVersionName(source.getTemplateVersionName().getEntity());
    }
    destination.setVirtioScsiEnabled(source.getIsVirtioScsiEnabled().getEntity());
}
#method_after
@Override
protected void build(UnitVmModel source, T destination) {
    destination.setPublicUse(source.getIsTemplatePublic().getEntity());
    destination.setDiskInfoDestinationMap(source.getDisksAllocationModel().getImageToDestinationDomainMap());
    destination.setSoundDeviceEnabled(source.getIsSoundcardEnabled().getEntity());
    destination.setBalloonEnabled(BalloonEnabled.balloonEnabled(source));
    destination.setCopyVmPermissions(source.getCopyPermissions().getEntity());
    destination.setSealTemplate(source.getSealTemplate().getEntity());
    destination.setConsoleEnabled(source.getIsConsoleDeviceEnabled().getEntity());
    if (source.getIsSubTemplate().getEntity()) {
        destination.setBaseTemplateId(source.getBaseTemplate().getSelectedItem().getId());
        destination.setTemplateVersionName(source.getTemplateVersionName().getEntity());
    }
    destination.setVirtioScsiEnabled(source.getIsVirtioScsiEnabled().getEntity());
    if (source.getIsHeadlessModeEnabled().getEntity()) {
        destination.getMasterVm().setDefaultDisplayType(DisplayType.none);
    }
}
#end_block

#method_before
void addStyle() {
    isTemplatePublicEditor.setContentWidgetContainerStyleName(style.editorLabel());
    copyVmPermissions.setContentWidgetContainerStyleName(style.editorLabel());
    isSubTemplateEditor.setContentWidgetContainerStyleName(style.editorLabel());
}
#method_after
void addStyle() {
    isTemplatePublicEditor.setContentWidgetContainerStyleName(style.editorLabel());
    copyVmPermissions.setContentWidgetContainerStyleName(style.editorLabel());
    sealTemplateEditor.setContentWidgetContainerStyleName(style.editorLabel());
    isSubTemplateEditor.setContentWidgetContainerStyleName(style.editorLabel());
}
#end_block

#method_before
void localize() {
    nameEditor.setLabel(constants.makeTemplatePopupNameLabel());
    descriptionEditor.setLabel(constants.makeTemplatePopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    clusterEditor.setLabel(constants.makeTemplateClusterLabel());
    quotaEditor.setLabel(constants.makeTemplateQuotaLabel());
    isTemplatePublicEditor.setLabel(constants.makeTemplateIsTemplatePublicEditorLabel());
    copyVmPermissions.setLabel(constants.copyVmPermissions());
    sealTemplateEditor.setLabel(constants.sealTemplate());
    disksAllocationLabel.setText(constants.disksAllocation());
    isSubTemplateEditor.setLabel(constants.createAsSubTemplate());
    baseTemplateEditor.setLabel(constants.rootTemplate());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
}
#method_after
void localize() {
    nameEditor.setLabel(constants.makeTemplatePopupNameLabel());
    descriptionEditor.setLabel(constants.makeTemplatePopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    clusterEditor.setLabel(constants.makeTemplateClusterLabel());
    quotaEditor.setLabel(constants.makeTemplateQuotaLabel());
    isTemplatePublicEditor.setLabel(constants.makeTemplateIsTemplatePublicEditorLabel());
    copyVmPermissions.setLabel(constants.copyVmPermissions());
    isSubTemplateEditor.setLabel(constants.createAsSubTemplate());
    baseTemplateEditor.setLabel(constants.rootTemplate());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
}
#end_block

#method_before
private void addDiskAllocation(UnitVmModel model) {
    disksAllocationView.edit(model.getDisksAllocationModel());
    model.getDisksAllocationModel().setDisks(model.getDisks());
}
#method_after
private void addDiskAllocation(UnitVmModel model) {
    if (model.getDisks().size() > 0) {
        disksAllocationView.edit(model.getDisksAllocationModel());
        model.getDisksAllocationModel().setDisks(model.getDisks());
    }
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isVmInDb) {
                if (pendingAsyncTasks) {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE : AuditLogType.USER_FAILED_ADD_VM_TEMPLATE;
                } else {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE;
                }
            } else {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE;
            }
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isVmInDb) {
                if (pendingAsyncTasks) {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE : AuditLogType.USER_FAILED_ADD_VM_TEMPLATE;
                } else {
                    return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
                }
            } else {
                return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_SUCCESS : AuditLogType.USER_ADD_VM_TEMPLATE_FAILURE;
            }
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS : getAuditLogFailureType();
        default:
            return getAuditLogFailureType();
    }
}
#end_block

#method_before
protected Map<Guid, Guid> addAllTemplateDisks() {
    CreateAllTemplateDisksParameters parameters = new CreateAllTemplateDisksParameters(getVm() != null ? getVmId() : Guid.Empty);
    parameters.setVmTemplateId(getVmTemplateId());
    parameters.setVmTemplateName(getVmTemplateName());
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    parameters.setCopyVolumeType(!getParameters().isSealTemplate() ? CopyVolumeType.SharedVol : CopyVolumeType.LeafVol);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    Future<VdcReturnValueBase> futureReturnValue = CommandCoordinatorUtil.executeAsyncCommand(getAddAllTemplateDisksActionType(), parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    try {
        VdcReturnValueBase returnValue = futureReturnValue.get();
        if (!returnValue.getSucceeded()) {
            throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
        }
        return returnValue.getActionReturnValue();
    } catch (InterruptedException | ExecutionException e) {
        throw new EngineException(EngineError.TemplateCreationError);
    }
}
#method_after
protected Map<Guid, Guid> addAllTemplateDisks() {
    VdcReturnValueBase returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (completedChildCount < CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size()) {
        return false;
    }
    switch(getParameters().getPhase()) {
        case CREATE_TEMPLATE:
            if (!getParameters().isSealTemplate()) {
                return true;
            }
            getParameters().setPhase(Phase.ASSIGN_ILLEGAL);
            break;
        case ASSIGN_ILLEGAL:
            getParameters().setPhase(Phase.SEAL);
            break;
        case SEAL:
            getParameters().setPhase(Phase.ASSIGN_LEGAL_SHARED);
            break;
        case ASSIGN_LEGAL_SHARED:
            return true;
    }
    persistCommandIfNeeded();
    executeNextOperation();
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (!getParameters().isSealTemplate()) {
        return false;
    }
    restoreCommandState();
    switch(getParameters().getPhase()) {
        case CREATE_TEMPLATE:
            getParameters().setPhase(Phase.ASSIGN_ILLEGAL);
            break;
        case ASSIGN_ILLEGAL:
            getParameters().setPhase(Phase.SEAL);
            break;
        case SEAL:
            getParameters().setPhase(Phase.ASSIGN_LEGAL_SHARED);
            break;
        case ASSIGN_LEGAL_SHARED:
            return false;
    }
    persistCommandIfNeeded();
    executeNextOperation();
    return true;
}
#end_block

#method_before
private void assignLegalAndShared(boolean legalAndShared) {
    UpdateAllTemplateDisksParameters parameters = new UpdateAllTemplateDisksParameters(getVmTemplateId(), legalAndShared, legalAndShared ? CopyVolumeType.SharedVol : null);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    getBackend().runInternalAction(VdcActionType.UpdateAllTemplateDisks, parameters, cloneContextAndDetachFromParent());
}
#method_after
private void assignLegalAndShared(boolean legalAndShared) {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.UpdateAllTemplateDisks, buildUpdateAllTemplateDisksParameters(legalAndShared), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
private void sealVmTemplate() {
    SealVmTemplateParameters parameters = new SealVmTemplateParameters();
    parameters.setVmTemplateId(getVmTemplateId());
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    getBackend().runInternalAction(VdcActionType.SealVmTemplate, parameters, cloneContextAndDetachFromParent());
}
#method_after
private void sealVmTemplate() {
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.SealVmTemplate, buildSealVmTemplateParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getCluster() == null && !isInstanceType) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!VmHandler.isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (isVmInDb && !isVmStatusValid(getVm().getStatus())) {
        return failValidation(EngineMessage.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemplateWithSameNameExist(getVmTemplateName(), getCluster().getStoragePoolId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failValidation(EngineMessage.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid())) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getMasterVm(), CompatibilityVersionUtils.getEffective(getParameters().getMasterVm(), this::getCluster)))) {
        return false;
    }
    if (getParameters().isSealTemplate() && isWindows()) {
        return failValidation(EngineMessage.VM_TEMPLATE_CANNOT_SEAL_WINDOWS);
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean validate() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getCluster() == null && !isInstanceType) {
        return failValidation(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!VmHandler.isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (isVmInDb && !isVmStatusValid(getVm().getStatus())) {
        return failValidation(EngineMessage.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    // be unique also across datacenters.
    if (!isTemplateVersion()) {
        if (isInstanceType) {
            if (isInstanceWithSameNameExists(getVmTemplateName())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        } else {
            if (isVmTemplateWithSameNameExist(getVmTemplateName(), getCluster().getStoragePoolId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            }
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failValidation(EngineMessage.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getMasterVm().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getMasterVm().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getMasterVm().getLargeIconId(), "Large"))) {
        return false;
    }
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid())) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getMasterVm(), CompatibilityVersionUtils.getEffective(getParameters().getMasterVm(), this::getCluster)))) {
        return false;
    }
    if (getParameters().isSealTemplate() && vmHandler.isWindowsVm(getVm())) {
        return failValidation(EngineMessage.VM_TEMPLATE_CANNOT_SEAL_WINDOWS);
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
protected boolean validateVmNotDuringSnapshot() {
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()));
}
#method_after
protected boolean validateVmNotDuringSnapshot() {
    return validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()));
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), getParameters().getMasterVm().getLeaseStorageDomainId()));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getParameters().getMasterVm().getMaxMemorySizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId(), null));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    vmStaticDao.incrementDbGeneration(getVmTemplateId());
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    restoreCommandState();
    vmStaticDao.incrementDbGeneration(getVmTemplateId());
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            vmTemplateDao.remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        vmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    restoreCommandState();
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            vmTemplateDao.remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        vmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    if (isTemplateVersion()) {
        return Collections.singletonMap(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return super.getSharedLocks();
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    if (isTemplateVersion()) {
        locks.put(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    locks.put(getParameters().getVm().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_CREATED));
    return locks;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    images.addAll(getVmDisksFromDb());
    getParameters().setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    super.init();
    if (getVm() != null) {
        images.addAll(getVmDisksFromDb());
    }
    getParameters().setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
private void addVmTemplateImage(DiskImage diskImage, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    // The return value of this action is the 'copyImage' task GUID:
    VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildCreateImageTemplateCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    DiskImage newImage = returnValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#method_after
private void addVmTemplateImage(DiskImage diskImage, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    // The return value of this action is the 'copyImage' task GUID:
    Guid targetDiskId = getParameters().getTargetDiskIds()[targetDiskIdIndex++];
    VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildCreateImageTemplateCommandParameters(diskImage, targetDiskId), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    getReturnValue().getVdsmTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    DiskImage newImage = returnValue.getActionReturnValue();
    srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
}
#end_block

#method_before
private List<DiskImage> getDiskImages() {
    if (diskImages == null) {
        diskImages = diskDao.getAllForVm(getVmTemplateId()).stream().map(disk -> (DiskImage) disk).collect(Collectors.toList());
    }
    return diskImages;
}
#method_after
private List<DiskImage> getDiskImages() {
    if (diskImages == null) {
        vmTemplateHandler.updateDisksFromDb(getVmTemplate());
        diskImages = DisksFilter.filterImageDisks(getVmTemplate().getDiskTemplateMap().values(), DisksFilter.ONLY_NOT_SHAREABLE);
    }
    return diskImages;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImages().isEmpty()) {
        setSucceeded(true);
        return;
    }
    SealDisksVDSCommandParameters parameters = new SealDisksVDSCommandParameters();
    parameters.setVmId(getParameters().getVmTemplateId());
    parameters.setJobId(getParameters().getHostJobId());
    getDiskImages().forEach(diskImage -> parameters.addVolume(diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
    lockTemplateInDb();
    lockDiskImagesInDb();
    VDSReturnValue vdsReturnValue = VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.SealDisks, parameters, getDiskImages().get(0).getStoragePoolId(), this);
    if (!vdsReturnValue.getSucceeded()) {
        setCommandStatus(CommandStatus.FAILED);
        unlockDiskImagesInDb();
        unlockTemplateInDb();
    }
    setSucceeded(vdsReturnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImages().isEmpty()) {
        setSucceeded(true);
        return;
    }
    VDSReturnValue vdsReturnValue = VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.SealDisks, buildSealDisksVDSCommandParameters(), getDiskImages().get(0).getStoragePoolId(), this);
    if (!vdsReturnValue.getSucceeded()) {
        setCommandStatus(CommandStatus.FAILED);
    }
    setSucceeded(vdsReturnValue.getSucceeded());
}
#end_block

#method_before
@Override
public StatusOnlyReturn sealDisks(String vmId, String jobId, List<Map<String, String>> volumes) {
    JsonRpcRequest request = new RequestBuilder("VM.seal").withParameter("vmID", vmId).withParameter("job_id", jobId).withOptionalParameterAsList("volumes", volumes).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#method_after
@Override
public StatusOnlyReturn sealDisks(String templateId, String jobId, String storagePoolId, List<Map<String, Object>> images) {
    JsonRpcRequest request = new RequestBuilder("VM.seal").withParameter("vmID", templateId).withParameter("job_id", jobId).withParameter("sp_id", storagePoolId).withOptionalParameterAsList("images", images).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().sealDisks(getParameters().getVmId().toString(), getParameters().getJobId().toString(), getParameters().getVolumes().stream().map(this::mapToEndpoint).collect(Collectors.toList()));
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().sealDisks(getParameters().getTemplateId().toString(), getParameters().getJobId().toString(), getParameters().getStoragePoolId().toString(), getParameters().getImages().stream().map(this::mapToEndpoint).collect(Collectors.toList()));
    proceedProxyReturnValue();
}
#end_block

#method_before
private Map<String, String> mapToEndpoint(SealDisksVDSCommandParameters.VolumeAddress volumeAddress) {
    Map<String, String> endpoint = new HashMap<>();
    endpoint.put("sd_id", volumeAddress.getStorageDomainId().toString());
    endpoint.put("img_id", volumeAddress.getImageId().toString());
    endpoint.put("vol_id", volumeAddress.getVolumeId().toString());
    return endpoint;
}
#method_after
private Map<String, Object> mapToEndpoint(LocationInfo locationInfo) {
    return LocationInfoHelper.prepareLocationInfoForVdsCommand(locationInfo);
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("vmId", vmId).append("jobId", jobId).append("volumes", volumes);
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("templateId", templateId).append("jobId", jobId).append("images", images);
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    setVmTemplateId(Guid.newGuid());
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    generateTargetDiskIds();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Command);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = addAllTemplateDisks();
    srcDeviceIdToTargetDeviceIdMapping.forEach((oldImageId, newImageId) -> addTemplateDiskVmElement(newImageId, oldImageId));
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = addAllTemplateDisks();
    srcDeviceIdToTargetDeviceIdMapping.forEach((oldImageId, newImageId) -> addTemplateDiskVmElement(newImageId, oldImageId));
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
protected Map<Guid, Guid> addAllTemplateDisks() {
    CreateAllTemplateDisksParameters parameters = new CreateAllTemplateDisksParameters(getVm() != null ? getVmId() : Guid.Empty);
    parameters.setVmTemplateId(getVmTemplateId());
    parameters.setVmTemplateName(getVmTemplateName());
    parameters.setDiskInfoDestinationMap(diskInfoDestinationMap);
    parameters.setTargetDiskIds(targetDiskIds);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    Future<VdcReturnValueBase> futureReturnValue = CommandCoordinatorUtil.executeAsyncCommand(getAddAllTemplateDisksActionType(), parameters, ExecutionHandler.createDefaultContextForTasks(getContext()));
    try {
        VdcReturnValueBase returnValue = futureReturnValue.get();
        if (!returnValue.getSucceeded()) {
            throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
        }
        return returnValue.getActionReturnValue();
    } catch (InterruptedException | ExecutionException e) {
        throw new EngineException(EngineError.TemplateCreationError);
    }
}
#method_after
protected Map<Guid, Guid> addAllTemplateDisks() {
    VdcReturnValueBase returnValue = runInternalAction(getAddAllTemplateDisksActionType(), buildCreateAllTemplateDisksParameters(), ExecutionHandler.createDefaultContextForTasks(getContext()));
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getFault().getError(), returnValue.getFault().getMessage());
    }
    return returnValue.getActionReturnValue();
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (completedChildCount < CommandCoordinatorUtil.getChildCommandIds(getCommandId()).size()) {
        return true;
    }
    restoreCommandState();
    switch(getParameters().getPhase()) {
        case CREATE_TEMPLATE:
            return false;
    }
    persistCommandIfNeeded();
    executeNextOperation();
    return true;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    return false;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    if (isTemplateVersion()) {
        locks.put(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_VERSION_IS_BEING_CREATED));
    }
    locks.put(getParameters().getVm().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_CREATED_FROM_VM));
    return locks;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    Map<String, Pair<String, String>> locks = new HashMap<>();
    if (isTemplateVersion()) {
        locks.put(getParameters().getBaseTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    locks.put(getParameters().getVm().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM, EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_BEING_CREATED));
    return locks;
}
#end_block

#method_before
@Override
protected Map<Guid, Guid> addAllTemplateDisks() {
    processIllegalDisks();
    Map<Guid, Guid> idMap = super.addAllTemplateDisks();
    if (!idMap.isEmpty()) {
        lockSnapshot();
    }
    return idMap;
}
#method_after
@Override
protected Map<Guid, Guid> addAllTemplateDisks() {
    processIllegalDisks();
    Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = super.addAllTemplateDisks();
    if (!srcDeviceIdToTargetDeviceIdMapping.isEmpty()) {
        lockSnapshot();
    }
    return srcDeviceIdToTargetDeviceIdMapping;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    if (resizeDiskImageRequested()) {
        switch(getOldDisk().getDiskStorageType()) {
            case IMAGE:
                extendDiskImageSize();
                break;
            case CINDER:
                extendCinderDiskSize();
                break;
        }
    } else {
        try {
            performDiskUpdate(false);
        } finally {
            freeLock();
        }
    }
    if (Objects.equals(getOldDisk().getDiskStorageType(), DiskStorageType.IMAGE) && amendDiskRequested()) {
        amendDiskImage();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    if (resizeDiskImageRequested()) {
        switch(getOldDisk().getDiskStorageType()) {
            case IMAGE:
                extendDiskImageSize();
                break;
            case CINDER:
                extendCinderDiskSize();
                break;
        }
    } else {
        try {
            performDiskUpdate(false);
            if (Objects.equals(getOldDisk().getDiskStorageType(), DiskStorageType.IMAGE) && amendDiskRequested()) {
                amendDiskImage();
            }
        } finally {
            freeLock();
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles() && validatePassDiscardSupported(diskVmElementValidator);
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    if (resizeDiskImageRequested() && amendDiskRequested()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_AND_EXTEND_IN_ONE_OPERATION);
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles() && validatePassDiscardSupported(diskVmElementValidator);
}
#end_block

#method_before
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = runInternalActionWithTasksContext(VdcActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#method_after
private void extendDiskImageSize() {
    lockImageInDb();
    VdcReturnValueBase ret = runInternalActionWithTasksContext(VdcActionType.ExtendImageSize, createExtendImageSizeParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
protected void amendDiskImage() {
    VdcReturnValueBase ret = runInternalActionWithTasksContext(VdcActionType.AmendImageGroupVolumes, amendImageGroupVolumesCommandParameters());
    if (ret.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().addAll(ret.getInternalVdsmTaskIdList());
    } else {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#method_after
protected void amendDiskImage() {
    VdcReturnValueBase ret = runInternalActionWithTasksContext(VdcActionType.AmendImageGroupVolumes, amendImageGroupVolumesCommandParameters());
    if (!ret.getSucceeded()) {
        propagateInternalCommandFailure(ret);
        getReturnValue().setFault(ret.getFault());
    }
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
private boolean amendDiskRequested() {
    switch(getNewDisk().getDiskStorageType()) {
        case IMAGE:
            DiskImage oldDisk = (DiskImage) getOldDisk();
            return oldDisk.getVolumeFormat().equals(VolumeFormat.COW) && !Objects.equals(oldDisk.getQcowCompat(), ((DiskImage) getNewDisk()).getQcowCompat().getCompatValue());
    }
    return false;
}
#method_after
protected boolean amendDiskRequested() {
    if (getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        return (oldDisk.getVolumeFormat() == VolumeFormat.COW) && !Objects.equals(oldDisk.getQcowCompat().getCompatValue(), ((DiskImage) getNewDisk()).getQcowCompat().getCompatValue());
    }
    return false;
}
#end_block

#method_before
private AmendImageGroupVolumesCommandParameters amendImageGroupVolumesCommandParameters() {
    DiskImage diskImage = (DiskImage) getNewDisk();
    AmendImageGroupVolumesCommandParameters params = new AmendImageGroupVolumesCommandParameters(diskImage.getId(), diskImage.getQcowCompat());
    return params;
}
#method_after
private AmendImageGroupVolumesCommandParameters amendImageGroupVolumesCommandParameters() {
    DiskImage diskImage = (DiskImage) getNewDisk();
    return new AmendImageGroupVolumesCommandParameters(diskImage.getId(), diskImage.getQcowCompat());
}
#end_block

#method_before
@Test
public void testAmend() {
    DiskImage disk = createDiskImage();
    disk.setVolumeFormat(VolumeFormat.COW);
    disk.setQcowCompat(QcowCompat.QCOW2_V2);
    disk.setDiskAlias("Test");
    disk.setDiskDescription("Test_Desc");
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    disk.setQcowCompat(QcowCompat.QCOW2_V3);
    command.getParameters().setDiskInfo(disk);
    initializeCommand();
    doNothing().when(command).amendDiskImage();
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
}
#method_after
@Test
public void testAmend() {
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVolumeFormat(VolumeFormat.COW);
    oldDisk.setQcowCompat(QcowCompat.QCOW2_V2);
    oldDisk.setDiskAlias("Test");
    oldDisk.setDiskDescription("Test_Desc");
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    DiskImage newDisk = DiskImage.copyOf(oldDisk);
    newDisk.setQcowCompat(QcowCompat.QCOW2_V3);
    command.getParameters().setDiskInfo(newDisk);
    initializeCommand();
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    verify(command, times(1)).amendDiskImage();
}
#end_block

#method_before
@Test
public void testAmendWithPropertyChange() {
    DiskImage disk = createDiskImage();
    disk.setVolumeFormat(VolumeFormat.COW);
    disk.setQcowCompat(QcowCompat.QCOW2_V2);
    disk.setDiskAlias("Test");
    disk.setDiskDescription("Test_Desc");
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    disk.setQcowCompat(QcowCompat.QCOW2_V3);
    disk.setDiskAlias("New Disk Alias");
    command.getParameters().setDiskInfo(disk);
    initializeCommand();
    doNothing().when(command).amendDiskImage();
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
}
#method_after
@Test
public void testAmendWithPropertyChange() {
    DiskImage oldDisk = createDiskImage();
    oldDisk.setVolumeFormat(VolumeFormat.COW);
    oldDisk.setQcowCompat(QcowCompat.QCOW2_V2);
    oldDisk.setDiskAlias("Test");
    oldDisk.setDiskDescription("Test_Desc");
    when(diskDao.get(diskImageGuid)).thenReturn(oldDisk);
    DiskImage newDisk = DiskImage.copyOf(oldDisk);
    newDisk.setQcowCompat(QcowCompat.QCOW2_V3);
    newDisk.setDiskAlias("New Disk Alias");
    command.getParameters().setDiskInfo(newDisk);
    initializeCommand();
    mockVdsCommandSetVolumeDescription();
    command.executeVmCommand();
    verify(command, times(1)).amendDiskImage();
    verify(command, times(1)).setVolumeDescription(any(DiskImage.class), any(StorageDomain.class));
}
#end_block

#method_before
protected void initializeCommand(VM vm) {
    mockGetForDisk(vm);
    mockGetVmsListForDisk(vm);
    doNothing().when(command).reloadDisks();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    when(diskVmElementValidator.isPassDiscardSupported(any(Guid.class))).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVmsStoragePoolInfo(vm);
    mockToUpdateDiskVm(vm);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#method_after
protected void initializeCommand(VM vm) {
    mockGetForDisk(vm);
    mockGetVmsListForDisk(vm);
    doNothing().when(command).reloadDisks();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    when(diskVmElementValidator.isPassDiscardSupported(any(Guid.class))).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVmsStoragePoolInfo(vm);
    mockToUpdateDiskVm(vm);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    VdcReturnValueBase ret = new VdcReturnValueBase();
    ret.setSucceeded(true);
    when(backend.runInternalAction(eq(VdcActionType.AmendImageGroupVolumes), any(StorageDomainParametersBase.class), any(CommandContext.class))).thenReturn(ret);
    command.init();
}
#end_block

#method_before
@Override
public String toString() {
    String prefix = (TotalMilliseconds < 0) ? "-" : "";
    // Ok to use String.format directly since GWT does not use TimeSpan from ui override package
    return String.format("%s%d.%02d:%02d:%02d.%03d", prefix, Days, Hours, Minutes, Seconds, Milliseconds);
}
#method_after
@Override
public String toString() {
    // Ok to use String.format directly since GWT does not use TimeSpan from ui override package
    return String.format("%s%d.%02d:%02d:%02d.%03d", (TotalMilliseconds < 0) ? "-" : "", Days, Hours, Minutes, Seconds, Milliseconds);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (getDestinationDiskImage() != null) {
        removeImage();
        baseDiskDao.remove(getDestinationDiskImage().getId());
        if (diskImageDynamicDao.get(getDestinationDiskImage().getImageId()) != null) {
            diskImageDynamicDao.remove(getDestinationDiskImage().getImageId());
        }
    }
    super.endWithFailure();
}
#method_after
@Override
protected void endWithFailure() {
    if (getDestinationDiskImage() != null) {
        // TODO: removeImage() is under that condition as it  will perform only if the disk exits in the db.
        // The flow should be changed so that the disk is added in transaction and then the copy flow is initiated.
        // The disk should be removed from the db only in case of successful removal (otherwise it should remain
        // illegal to let the user attempt to delete it again).
        removeImage();
        baseDiskDao.remove(getDestinationDiskImage().getId());
        if (diskImageDynamicDao.get(getDestinationDiskImage().getImageId()) != null) {
            diskImageDynamicDao.remove(getDestinationDiskImage().getImageId());
        }
    }
    super.endWithFailure();
}
#end_block

#method_before
private void removeImage() {
    RemoveImageParameters removeImageParams = new RemoveImageParameters(getParameters().getDestinationImageId());
    removeImageParams.setStorageDomainId(getDestinationStorageDomainId());
    removeImageParams.setParentCommand(VdcActionType.RemoveImage);
    removeImageParams.setDbOperationScope(ImageDbOperationScope.NONE);
    removeImageParams.setShouldLockImage(false);
    removeImageParams.setCorrelationId(getParameters().getCorrelationId());
    removeImageParams.setEntityInfo(new EntityInfo(VdcObjectType.Disk, Guid.newGuid()));
    VdcReturnValueBase returnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, removeImageParams);
    if (!returnValue.getSucceeded()) {
        addAuditLogOnRemoveFailure();
    }
}
#method_after
private void removeImage() {
    RemoveImageParameters removeImageParams = new RemoveImageParameters(getParameters().getDestinationImageId());
    removeImageParams.setStorageDomainId(getDestinationStorageDomainId());
    removeImageParams.setDbOperationScope(ImageDbOperationScope.NONE);
    removeImageParams.setShouldLockImage(false);
    removeImageParams.setEntityInfo(new EntityInfo(VdcObjectType.Disk, getDestinationDiskImage().getId()));
    VdcReturnValueBase returnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, removeImageParams);
    if (!returnValue.getSucceeded()) {
        addAuditLogOnRemoveFailure();
    }
}
#end_block

#method_before
@Before
public void setup() {
    validator = new UpgradeHostValidator(host);
}
#method_after
@Before
public void setup() {
    host = new VDS();
    validator = new UpgradeHostValidator(host);
}
#end_block

#method_before
@Test
public void statusSupportedForHostUpgradeInternal() {
    when(host.getStatus()).thenReturn(VDSStatus.Maintenance);
    assertThat(validator.statusSupportedForHostUpgradeInternal(), isValid());
}
#method_after
@Test
public void statusSupportedForHostUpgradeInternal() {
    host.setStatus(VDSStatus.Maintenance);
    assertThat(validator.statusSupportedForHostUpgradeInternal(), isValid());
}
#end_block

#method_before
@Test
public void statusNotSupportedForHostUpgradeInternal() {
    when(host.getStatus()).thenReturn(VDSStatus.Unassigned);
    assertThat(validator.statusSupportedForHostUpgradeInternal(), failsWith(EngineMessage.CANNOT_UPGRADE_HOST_STATUS_ILLEGAL));
}
#method_after
@Test
public void statusNotSupportedForHostUpgradeInternal() {
    host.setStatus(VDSStatus.Unassigned);
    assertThat(validator.statusSupportedForHostUpgradeInternal(), failsWith(EngineMessage.CANNOT_UPGRADE_HOST_STATUS_ILLEGAL));
}
#end_block

#method_before
@Test
public void updatesAvailable() {
    when(host.isUpdateAvailable()).thenReturn(true);
    assertThat(validator.updatesAvailable(), isValid());
}
#method_after
@Test
public void updatesAvailable() {
    host.getDynamicData().setUpdateAvailable(true);
    assertThat(validator.updatesAvailable(), isValid());
}
#end_block

#method_before
private void mockOvirtNode() {
    when(host.isOvirtVintageNode()).thenReturn(true);
}
#method_after
private void mockOvirtNode() {
    host.setVdsType(VDSType.oVirtVintageNode);
}
#end_block

#method_before
@Test
public void hostWasInstalled() {
    when(host.getHostOs()).thenReturn(RandomUtils.instance().nextString(20));
    assertThat(validator.hostWasInstalled(), isValid());
}
#method_after
@Test
public void hostWasInstalled() {
    host.setHostOs(RandomUtils.instance().nextString(20));
    assertThat(validator.hostWasInstalled(), isValid());
}
#end_block

#method_before
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
        if (getSysprepEnabled().getEntity()) {
            getVmInitModel().updateSysprepDomain(null);
        }
    }
}
#method_after
private void vmInitEnabledChanged() {
    if (!getVmInitEnabled().getEntity()) {
        getSysprepEnabled().setEntity(false);
        getCloudInitEnabled().setEntity(false);
    } else {
        getSysprepEnabled().setEntity(getIsWindowsOS());
        // for the "other" also use cloud init
        getCloudInitEnabled().setEntity(!getIsWindowsOS());
        autoSetHostname();
        if (getSysprepEnabled().getEntity()) {
            getVmInitModel().updateSysprepDomain(getVmInitModel().getSysprepDomain().getSelectedItem());
        }
    }
}
#end_block

#method_before
// Sysprep/cloud-init sections displayed only with proper OS type (Windows
// or Linux, respectively) and when proper floppy or CD is attached.
public void updateInitialRunFields() {
    getIsSysprepPossible().setEntity(getIsWindowsOS());
    getIsSysprepEnabled().setEntity(getInitializationType() == InitializationType.Sysprep);
    // also other can be cloud inited
    getIsCloudInitPossible().setEntity(!getIsWindowsOS());
    getIsCloudInitEnabled().setEntity(getInitializationType() == InitializationType.CloudInit);
    getIsCloudInitEnabled().setIsAvailable(!getIsWindowsOS());
    if (getIsSysprepPossible().getEntity() && getIsSysprepEnabled().getEntity()) {
        getVmInitModel().updateSysprepDomain(null);
    }
}
#method_after
// Sysprep/cloud-init sections displayed only with proper OS type (Windows
// or Linux, respectively) and when proper floppy or CD is attached.
public void updateInitialRunFields() {
    getIsSysprepPossible().setEntity(getIsWindowsOS());
    getIsSysprepEnabled().setEntity(getInitializationType() == InitializationType.Sysprep);
    // also other can be cloud inited
    getIsCloudInitPossible().setEntity(!getIsWindowsOS());
    getIsCloudInitEnabled().setEntity(getInitializationType() == InitializationType.CloudInit);
    getIsCloudInitEnabled().setIsAvailable(!getIsWindowsOS());
    if (getIsSysprepPossible().getEntity() && getIsSysprepEnabled().getEntity()) {
        getVmInitModel().updateSysprepDomain(getVmInitModel().getSysprepDomain().getSelectedItem());
    }
}
#end_block

#method_before
private void addMethod(String returnType, String methodNameWithArgs, Object... args) {
    javaBuffer.addLine("default %s %s {", returnType, String.format(methodNameWithArgs, args));
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
}
#method_after
private void addMethod(String returnType, String methodNameWithArgs, Object... args) {
    javaBuffer.addLine("default public %s %s {", returnType, String.format(methodNameWithArgs, args));
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateInterfaceSource(Service service, JavaClassName interfaceName) {
    // Get the name of the service:
    Name name = service.getName();
    // Generate the imports:
    javaBuffer.addImport(Produces.class);
    javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "ApiMediaType");
    // Calculate the "extends" clause of the interface declaration:
    List<String> extendsList = new ArrayList<>();
    Service base = service.getBase();
    if (base != null) {
        JavaClassName baseInterfaceName = jaxrsNames.getInterfaceName(base);
        javaBuffer.addImport(baseInterfaceName);
        extendsList.add(baseInterfaceName.getSimpleName());
    }
    if (ASYNCHRONOUS.contains(name)) {
        javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "AsynchronouslyCreatedResource");
        extendsList.add("AsynchronouslyCreatedResource");
    }
    String extendsClause = extendsList.isEmpty() ? "" : "extends " + String.join(", ", extendsList);
    // add import statement for of the auto-generated 'helper' class for this service
    // (Use copy-constructor to avoid mutating 'name')
    Name helperClassName = new Name(name);
    helperClassName.addWord("Resource");
    helperClassName.addWord("Helper");
    javaBuffer.addImport(javaPackages.getJaxrsPackageName() + "." + javaPackages.getJaxrsHelperPackageSuffix(), javaNames.getJavaClassStyleName(helperClassName));
    // Check if this is the root of the tree of services:
    boolean isRoot = service == service.getModel().getRoot();
    // Generate the interface declaration:
    generateDoc(service);
    if (isRoot) {
        javaBuffer.addImport(Path.class);
        javaBuffer.addLine("@Path(\"/\")");
    }
    javaBuffer.addLine("@Produces({ %s })", generateMediaTypes());
    javaBuffer.addLine("public interface %s %s {", interfaceName.getSimpleName(), extendsClause);
    // The root service needs this additional that can't be represented in the model:
    if (isRoot) {
        javaBuffer.addImport(HEAD.class);
        javaBuffer.addImport(Response.class);
        javaBuffer.addLine("@HEAD");
        javaBuffer.addLine("Response head();");
        javaBuffer.addLine();
    }
    // Generate the methods:
    List<Method> methods = service.getDeclaredMethods();
    Map<Method, Set<Method>> baseMethods = JaxrsGeneratorUtils.getBaseMethodsMap(methods);
    methods.forEach(x -> generateMethod(x, helperClassName, baseMethods));
    // Generate the resource locators:
    List<Locator> locators = service.getDeclaredLocators();
    locators.forEach(x -> generateLocator(x));
    // Find all the action methods and generate the action resource locator:
    List<Method> actions = new ArrayList<>();
    for (Method method : service.getMethods()) {
        Name methodName = method.getName();
        boolean isAction = !JaxrsGeneratorUtils.ADD.equals(methodName) && !JaxrsGeneratorUtils.GET.equals(methodName) && !JaxrsGeneratorUtils.LIST.equals(methodName) && !JaxrsGeneratorUtils.REMOVE.equals(methodName) && !JaxrsGeneratorUtils.UPDATE.equals(methodName);
        if (isAction) {
            actions.add(method);
        }
    }
    if (!actions.isEmpty()) {
        generateActionLocator(actions);
    }
    javaBuffer.addLine("}");
}
#method_after
private void generateInterfaceSource(Service service, JavaClassName interfaceName) {
    // Generate the imports:
    javaBuffer.addImport(Produces.class);
    javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "ApiMediaType");
    // Calculate the "extends" clause of the interface declaration:
    List<String> extendsList = new ArrayList<>();
    Service base = service.getBase();
    if (base != null) {
        JavaClassName baseInterfaceName = jaxrsNames.getInterfaceName(base);
        javaBuffer.addImport(baseInterfaceName);
        extendsList.add(baseInterfaceName.getSimpleName());
    }
    if (ASYNCHRONOUS.contains(service.getName())) {
        javaBuffer.addImport(javaPackages.getJaxrsPackageName(), "AsynchronouslyCreatedResource");
        extendsList.add("AsynchronouslyCreatedResource");
    }
    String extendsClause = extendsList.isEmpty() ? "" : "extends " + String.join(", ", extendsList);
    // add import statement for of the auto-generated 'helper' class for this service
    JavaClassName helperClassName = jaxrsNames.getHelperName(service);
    javaBuffer.addImport(helperClassName);
    // Check if this is the root of the tree of services:
    boolean isRoot = service == service.getModel().getRoot();
    // Generate the interface declaration:
    generateDoc(service);
    if (isRoot) {
        javaBuffer.addImport(Path.class);
        javaBuffer.addLine("@Path(\"/\")");
    }
    javaBuffer.addLine("@Produces({ %s })", generateMediaTypes());
    javaBuffer.addLine("public interface %s %s {", interfaceName.getSimpleName(), extendsClause);
    // The root service needs this additional that can't be represented in the model:
    if (isRoot) {
        javaBuffer.addImport(HEAD.class);
        javaBuffer.addImport(Response.class);
        javaBuffer.addLine("@HEAD");
        javaBuffer.addLine("Response head();");
        javaBuffer.addLine();
    }
    // Generate the methods:
    List<Method> methods = service.getDeclaredMethods();
    Map<Method, Set<Method>> baseMethods = jaxrsGeneratorUtils.getBaseMethodsMap(methods);
    methods.forEach(x -> generateMethod(x, helperClassName, baseMethods));
    // Generate the resource locators:
    List<Locator> locators = service.getDeclaredLocators();
    locators.forEach(x -> generateLocator(x));
    // Find all the action methods and generate the action resource locator:
    List<Method> actions = new ArrayList<>();
    for (Method method : service.getMethods()) {
        if (method.isAction()) {
            actions.add(method);
        }
    }
    if (!actions.isEmpty()) {
        generateActionLocator(actions);
    }
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateMethod(Method method, Name helperClassName, Map<Method, Set<Method>> baseMethods) {
    boolean base = baseMethods.containsKey(method);
    Name name = method.getName();
    if (JaxrsGeneratorUtils.ADD.equals(name)) {
        generateAddMethod(method, helperClassName, base);
    } else if (JaxrsGeneratorUtils.GET.equals(name)) {
        generateGetMethod(method);
    } else if (JaxrsGeneratorUtils.LIST.equals(name)) {
        generateListMethod(method);
    } else if (JaxrsGeneratorUtils.REMOVE.equals(name)) {
        generateRemoveMethod(method);
    } else if (JaxrsGeneratorUtils.UPDATE.equals(name)) {
        generateUpdateMethod(method, helperClassName, base);
    } else if (JaxrsGeneratorUtils.isAddSignature(method)) {
        generateAddSignature(method);
    } else if (JaxrsGeneratorUtils.isUpdateSignature(method)) {
        generateUpdateSignature(method);
    } else if (JaxrsGeneratorUtils.isActionSignature(method)) {
        generateActionSignature(method);
    } else {
        // other options exhausted; must be an action
        generateActionMethod(method, helperClassName, base);
    }
}
#method_after
private void generateMethod(Method method, JavaClassName helperClassName, Map<Method, Set<Method>> baseMethods) {
    boolean base = baseMethods.containsKey(method);
    Name name = method.getName();
    if (JaxrsGeneratorUtils.ADD.equals(name)) {
        generateAddMethod(method, helperClassName, base);
    } else if (JaxrsGeneratorUtils.GET.equals(name)) {
        generateGetMethod(method);
    } else if (JaxrsGeneratorUtils.LIST.equals(name)) {
        generateListMethod(method);
    } else if (JaxrsGeneratorUtils.REMOVE.equals(name)) {
        generateRemoveMethod(method);
    } else if (JaxrsGeneratorUtils.UPDATE.equals(name)) {
        generateUpdateMethod(method, helperClassName, base);
    } else if (jaxrsGeneratorUtils.isAddSignature(method)) {
        generateAddSignature(method);
    } else if (jaxrsGeneratorUtils.isUpdateSignature(method)) {
        generateUpdateSignature(method);
    } else if (jaxrsGeneratorUtils.isActionSignature(method)) {
        generateActionSignature(method);
    } else {
        // other options exhausted; must be an action
        generateActionMethod(method, helperClassName, base);
    }
}
#end_block

#method_before
private void generateActionSignature(Method method) {
    generateDoc(method);
    Name methodName = new Name(method.getBase().getName());
    methodName.addWords(method.getName().getWords());
    javaBuffer.addLine("Response %s(Action action) {", jaxrsNames.getMethodName(methodName));
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
}
#method_after
private void generateActionSignature(Method method) {
    generateDoc(method);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
    Name methodName = new Name(method.getBase().getName());
    methodName.addWords(method.getName().getWords());
    javaBuffer.addLine("default public Response %s(Action action) {", jaxrsNames.getMethodName(methodName));
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateUpdateSignature(Method method) {
    generateDoc(method);
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = JaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    String methodName = concatenateName(method, method.getBase().getName());
    javaBuffer.addLine("default %s " + methodName + "(%s %s) {", mainTypeReference.getText(), mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
}
#method_after
private void generateUpdateSignature(Method method) {
    generateDoc(method);
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = jaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    String methodName = javaNames.getJavaMemberStyleName(names.concatenate(method.getBase().getName(), method.getName()));
    javaBuffer.addLine("default public %s " + methodName + "(%s %s) {", mainTypeReference.getText(), mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateAddSignature(Method method) {
    generateDoc(method);
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = JaxrsGeneratorUtils.getMainAddParameter(method);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    String methodName = concatenateName(method, method.getBase().getName());
    javaBuffer.addLine("default Response " + methodName + "(%s %s) {", mainTypeReference.getText(), parameterName);
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#method_after
private void generateAddSignature(Method method) {
    generateDoc(method);
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = jaxrsGeneratorUtils.getMainAddParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    javaBuffer.addImports(mainTypeReference.getImports());
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    String methodName = javaNames.getJavaMemberStyleName(names.concatenate(method.getBase().getName(), method.getName()));
    javaBuffer.addLine("default public Response %s(%s %s) {", methodName, mainTypeReference.getText(), parameterName);
    javaBuffer.addLine("throw new UnsupportedOperationException();");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateAddMethod(Method method, Name helperClassName, boolean base) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = JaxrsGeneratorUtils.getMainAddParameter(method);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    if (base) {
        javaBuffer.addLine("default Response add(%s %s) {", mainTypeReference.getText(), parameterName);
        writeHelperInvocation(helperClassName, parameterName, method.getName());
        javaBuffer.addLine("}");
    } else {
        addResponseReturnMethod("add(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    }
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#method_after
private void generateAddMethod(Method method, JavaClassName helperClassName, boolean base) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = jaxrsGeneratorUtils.getMainAddParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    if (base) {
        javaBuffer.addLine("default public Response add(%s %s) {", mainTypeReference.getText(), parameterName);
        if (method.isMandatoryAttributeExists()) {
            writeHelperInvocation(helperClassName, parameterName, method.getName());
        } else {
            javaBuffer.addLine("throw new UnsupportedOperationException();");
        // add log message - signatures with only 'optional' attributes indicate bad input
        }
        javaBuffer.addLine("}");
    } else {
        addResponseReturnMethod("add(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void writeHelperInvocation(Name helperClassName, String parameterName, Name methodName) {
    String helperMethodName = "get" + javaNames.getJavaClassStyleName(methodName) + "Signature";
    javaBuffer.addLine("try {");
    javaBuffer.addLine("return (Response)" + javaNames.getJavaClassStyleName(helperClassName) + "." + helperMethodName + "(" + parameterName + ").invoke(this, " + parameterName + ");");
    javaBuffer.addLine("} catch(Exception e) {");
    javaBuffer.addLine("throw new IllegalStateException(\"Failed to find or invoke API method. The failure is in auto-generated code and indicates a bug in the JAX-RS intrafaces generation process\", e);");
    javaBuffer.addLine("}");
}
#method_after
private void writeHelperInvocation(JavaClassName helperClassName, String parameterName, Name methodName) {
    String helperMethodName = "get" + javaNames.getJavaClassStyleName(methodName) + "Signature";
    javaBuffer.addLine("try {");
    javaBuffer.addLine("return (Response)(" + helperClassName.getSimpleName() + "." + helperMethodName + "(" + parameterName + ").invoke(this, " + parameterName + "));");
    javaBuffer.addLine("}");
    javaBuffer.addLine("catch(Exception e) {");
    javaBuffer.addLine("throw new IllegalStateException(\"Failed to find or invoke API method. The failure is in auto-generated code and indicates a bug in the JAX-RS intrafaces generation process\", e);");
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateGetMethod(Method method) {
    Parameter mainParameter = JaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
    // "Response", because it has to be able to return the type declared in the model and also the XML schema and
    // the RSDL.
    Service service = method.getDeclaringService();
    boolean isRoot = service == service.getModel().getRoot();
    generateDoc(method);
    javaBuffer.addImport(GET.class);
    javaBuffer.addLine("@GET");
    if (isRoot) {
        javaBuffer.addImport(Response.class);
        addResponseReturnMethod("get()");
    } else {
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
        javaBuffer.addImports(mainTypeReference.getImports());
        addMethod(mainTypeReference.getText(), "get()");
    }
    javaBuffer.addLine();
}
#method_after
private void generateGetMethod(Method method) {
    Parameter mainParameter = jaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Most "Get" methods return the type that is declared in the model, but the root resource needs to return
    // "Response", because it has to be able to return the type declared in the model and also the XML schema and
    // the RSDL.
    Service service = method.getDeclaringService();
    boolean isRoot = service == service.getModel().getRoot();
    generateDoc(method);
    javaBuffer.addImport(GET.class);
    javaBuffer.addLine("@GET");
    if (isRoot) {
        javaBuffer.addImport(Response.class);
        addResponseReturnMethod("get()");
    } else {
        Type mainType = mainParameter.getType();
        JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
        javaBuffer.addImports(mainTypeReference.getImports());
        addMethod(mainTypeReference.getText(), "get()");
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateListMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof ListType).findFirst().orElse(null);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any list parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(GET.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@GET");
    addMethod(mainTypeReference.getText(), "list()");
    javaBuffer.addLine();
}
#method_after
private void generateListMethod(Method method) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof ListType).findFirst().orElse(null);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any list parameter");
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(GET.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@GET");
    addMethod(mainTypeReference.getText(), "list()");
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateUpdateMethod(Method method, Name helperClassName, boolean base) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = JaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        System.err.println("Method \"" + method + "\" doesn't have any struct parameter");
        return;
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(PUT.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@PUT");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    if (base) {
        javaBuffer.addLine("default %s update(%s %s) {", mainTypeReference.getText(), mainTypeReference.getText(), parameterName);
        writeHelperInvocation(helperClassName, parameterName, method.getName());
        javaBuffer.addLine("}");
    } else {
        addMethod(mainTypeReference.getText(), "update(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    }
    javaBuffer.addLine();
}
#method_after
private void generateUpdateMethod(Method method, JavaClassName helperClassName, boolean base) {
    // Find the main parameter of the method, as this is the only one that appears in the JAX-RS interfaces, the
    // rest of the methods are extracted explicitly by the implementation:
    Parameter mainParameter = jaxrsGeneratorUtils.getMainUpdateParameter(method);
    if (mainParameter == null) {
        throw new IllegalStateException("Method \"" + method + "\" doesn't have any struct parameter");
    }
    // Calculate the Java type of the main parameter:
    Type mainType = mainParameter.getType();
    JavaTypeReference mainTypeReference = schemaNames.getXjcTypeReference(mainType);
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(PUT.class);
    javaBuffer.addImports(mainTypeReference.getImports());
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@PUT");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    String parameterName = javaNames.getJavaMemberStyleName(mainParameter.getName());
    if (base) {
        javaBuffer.addLine("default %s update(%s %s) {", mainTypeReference.getText(), mainTypeReference.getText(), parameterName);
        if (method.isMandatoryAttributeExists()) {
            writeHelperInvocation(helperClassName, parameterName, method.getName());
        } else {
            javaBuffer.addLine("throw new UnsupportedOperationException();");
        // add log message - signatures with only 'optional' attributes indicate bad input
        }
        javaBuffer.addLine("}");
    } else {
        addMethod(mainTypeReference.getText(), "update(%s %s)", mainTypeReference.getText(), javaNames.getJavaMemberStyleName(mainParameter.getName()));
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateActionMethod(Method method, Name helperClassName, boolean base) {
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Path.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Actionable");
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    javaBuffer.addLine("@Actionable");
    javaBuffer.addLine("@Path(\"%s\")", jaxrsNames.getActionPath(method.getName()));
    String methodName = jaxrsNames.getMethodName(method.getName());
    if (base) {
        javaBuffer.addLine("default Response %s(Action action) {", methodName);
        writeHelperInvocation(helperClassName, "action", method.getName());
        javaBuffer.addLine("}");
    } else {
        addResponseReturnMethod(jaxrsNames.getMethodName(method.getName()) + "(Action action)");
    }
    javaBuffer.addLine();
}
#method_after
private void generateActionMethod(Method method, JavaClassName helperClassName, boolean base) {
    // Generate the imports:
    javaBuffer.addImport(Consumes.class);
    javaBuffer.addImport(POST.class);
    javaBuffer.addImport(Path.class);
    javaBuffer.addImport(Response.class);
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Action");
    javaBuffer.addImport(javaPackages.getXjcPackageName(), "Actionable");
    // Generate the method:
    generateDoc(method);
    javaBuffer.addLine("@POST");
    javaBuffer.addLine("@Consumes({ %s })", generateMediaTypes());
    javaBuffer.addLine("@Actionable");
    javaBuffer.addLine("@Path(\"%s\")", jaxrsNames.getActionPath(method.getName()));
    String methodName = jaxrsNames.getMethodName(method.getName());
    if (base) {
        javaBuffer.addLine("default Response %s(Action action) {", methodName);
        if (method.isMandatoryAttributeExists()) {
            writeHelperInvocation(helperClassName, "action", method.getName());
        } else {
            javaBuffer.addLine("throw new UnsupportedOperationException();");
        // add log message - signatures with only 'optional' attributes indicate bad input.
        }
        javaBuffer.addLine("}");
    } else {
        addResponseReturnMethod(jaxrsNames.getMethodName(method.getName()) + "(Action action)");
    }
    javaBuffer.addLine();
}
#end_block

#method_before
private void generateHelper(Service service) {
    // initialize the utility variables. Once initialized, they
    // are regarded as read-only pieces of information.
    initVariables(service);
    // generate helper code for this method
    serviceMethods.forEach(x -> generateHelperCode(x));
    try {
        javaBuffer.write(outDir);
    } catch (IOException exception) {
        exception.printStackTrace();
    }
}
#method_after
private void generateHelper(Service service) {
    // initialize the utility variables. Once initialized, they
    // are regarded as read-only pieces of information.
    initVariables(service);
    // generate class declaration
    javaBuffer.addLine("public class %s {", jaxrsNames.getHelperName(service).getSimpleName());
    // generate helper code for this method
    serviceMethods.forEach(x -> generateHelperCode(x));
    javaBuffer.addLine("}");
    try {
        javaBuffer.write(outDir);
    } catch (IOException exception) {
        exception.printStackTrace();
    }
}
#end_block

#method_before
private void initVariables(Service service) {
    resourceName = jaxrsNames.getInterfaceName(service);
    helperName = new JavaClassName(resourceName.getPackageName(), resourceName.getSimpleName() + "Helper");
    serviceMethods = service.getDeclaredMethods();
    baseMethods = JaxrsGeneratorUtils.getBaseMethodsMap(serviceMethods);
    javaBuffer = new JavaClassBuffer();
    javaBuffer.setClassName(helperName);
    javaBuffer.addImport(resourceName);
}
#method_after
private void initVariables(Service service) {
    resourceName = jaxrsNames.getInterfaceName(service);
    helperName = new JavaClassName(resourceName.getPackageName(), resourceName.getSimpleName() + "Helper");
    serviceMethods = service.getDeclaredMethods();
    baseMethods = jaxrsGeneratorUtils.getBaseMethodsMap(serviceMethods);
    javaBuffer = new JavaClassBuffer();
    javaBuffer.setClassName(helperName);
    javaBuffer.addImport(resourceName);
}
#end_block

#method_before
private void generateHelperCode(Method method) {
    boolean base = baseMethods.containsKey(method);
    Name name = method.getName();
    // (signatures are handled in the context of the base method).
    if (JaxrsGeneratorUtils.GET.equals(name) || JaxrsGeneratorUtils.LIST.equals(name) || JaxrsGeneratorUtils.REMOVE.equals(name) || JaxrsGeneratorUtils.isAddSignature(method) || JaxrsGeneratorUtils.isUpdateSignature(method) || JaxrsGeneratorUtils.isActionSignature(method)) {
        // do nothing.
        return;
    }
    if (JaxrsGeneratorUtils.ADD.equals(name) || JaxrsGeneratorUtils.UPDATE.equals(name)) {
        if (base) {
            generateSignatureDetection(method);
        } else {
            if (JaxrsGeneratorUtils.isMandatoryParametersExist(method)) {
                generateValidation(method);
            } else {
            // do nothing
            }
        }
    } else {
        // other options exhausted, this must be an action.
        if (base) {
            generateActionSignatureDetection(method, serviceMethods);
        } else if (JaxrsGeneratorUtils.isMandatoryParametersExist(method)) {
            if (JaxrsGeneratorUtils.isMandatoryParametersExist(method)) {
                generateActionValidation(method);
            } else {
            // do nothing
            }
        }
    }
}
#method_after
private void generateHelperCode(Method method) {
    boolean base = baseMethods.containsKey(method);
    Name name = method.getName();
    // (signatures are handled in the context of the base method).
    if (JaxrsGeneratorUtils.GET.equals(name) || JaxrsGeneratorUtils.LIST.equals(name) || JaxrsGeneratorUtils.REMOVE.equals(name) || jaxrsGeneratorUtils.isAddSignature(method) || jaxrsGeneratorUtils.isUpdateSignature(method) || jaxrsGeneratorUtils.isActionSignature(method)) {
        // do nothing.
        return;
    }
    if (JaxrsGeneratorUtils.ADD.equals(name) || JaxrsGeneratorUtils.UPDATE.equals(name)) {
        if (base) {
            generateSignatureDetection(method);
        } else {
            generateValidation(method);
        }
    } else {
        // other options exhausted, this must be an action.
        if (base) {
            generateActionSignatureDetection(method);
        } else {
            generateActionValidation(method);
        }
    }
}
#end_block

#method_before
private void generateSignatureDetection(Method method) {
    Parameter parameter = JaxrsGeneratorUtils.getMainAddParameter(method);
    javaBuffer.addImports(schemaNames.getXjcTypeReference(parameter.getType()).getImports());
    Name methodName = getSignatureDetectionMethodName(method);
    Name parameterName = parameter.getName();
    javaBuffer.addLine("public static Method %s(%s %s) throws NoSuchMethodException, SecurityException {", javaNames.getJavaMemberStyleName(methodName), javaNames.getJavaClassStyleName(parameterName), javaNames.getJavaMemberStyleName(parameterName));
    generateParameterValidation(parameter);
    Set<Method> signatures = baseMethods.get(method);
    CyclicIterator iterator = new CyclicIterator(signatures);
    while (iterator.hasNext()) {
        Method signature = iterator.next();
        if (!JaxrsHelperGeneratorUtils.isContained(signature, signatures)) {
            handleSignature(method.getName(), signature, parameterName);
            iterator.remove();
        }
    }
    closeSignatureDetectionMethod();
}
#method_after
private void generateSignatureDetection(Method method) {
    Set<Method> signatures = baseMethods.get(method);
    if (mandatoryAttributeExists(signatures)) {
        javaBuffer.addImport(java.lang.reflect.Method.class);
        Parameter parameter = jaxrsGeneratorUtils.getMainAddParameter(method);
        Name parameterName = parameter.getName();
        javaBuffer.addImports(schemaNames.getXjcTypeReference(parameter.getType()).getImports());
        Name methodName = getSignatureDetectionMethodName(method);
        javaBuffer.addLine("public static Method %s(%s %s) throws NoSuchMethodException, SecurityException {", javaNames.getJavaMemberStyleName(methodName), javaNames.getJavaClassStyleName(parameter.getType().getName()), javaNames.getJavaMemberStyleName(parameterName));
        generateParameterValidation(parameter);
        CyclicIterator iterator = new CyclicIterator(signatures);
        while (iterator.hasNext()) {
            Method signature = iterator.next();
            if (!jaxrsHelperGeneratorUtils.isContained(signature, signatures)) {
                handleSignature(method.getName(), signature, parameterName, parameter.getType());
                iterator.remove();
            }
        }
        closeSignatureDetectionMethod();
    }
// TODO: in the future fail for this
// else {
// throw new IllegalStateException(method.getName() + "'s signatures have 0 mandatory attributes (any signature must have at least 1 mandatory attribute)");
// }
}
#end_block

#method_before
private void handleSignature(Name parentMethodName, Method signature, Name parameterName) {
    javaBuffer.addDocComment(signature.getName().toString());
    Parameter parameter = signature.getParameter(parameterName);
    Iterator<MemberInvolvementTree> iterator = parameter.getMandatoryAttributes().iterator();
    if (iterator.hasNext()) {
        // if there are any mandatory attributes
        javaBuffer.addLine("if (" + javaNames.getJavaMemberStyleName(parameter.getName()) + "!=null");
        while (iterator.hasNext()) {
            MemberInvolvementTree attribute = iterator.next();
            List<MemberInvolvementTree> list = stackAttributeComponents(attribute);
            String attributeCheck = getFullAttributeCheck(javaNames.getJavaMemberStyleName(parameter.getName()), list, Operator.AND);
            if (attribute.getAlternative() != null) {
                // 'or' expression
                list = stackAttributeComponents(attribute.getAlternative());
                String alternativeCheck = getFullAttributeCheck(javaNames.getJavaMemberStyleName(parameter.getName()), list, Operator.AND);
                String fullCheck = mergeChecks(attributeCheck, alternativeCheck);
                javaBuffer.addLine(fullCheck);
            } else {
                javaBuffer.addLine(attributeCheck);
            }
        }
        javaBuffer.addLine(") {");
        javaBuffer.addLine("return " + resourceName.getSimpleName() + ".class.getMethod(\"" + javaNames.getJavaMemberStyleName(parentMethodName) + javaNames.getJavaClassStyleName(signature.getName()) + "\");");
        javaBuffer.addLine("}");
    }
}
#method_after
private void handleSignature(Name parentMethodName, Method signature, Name parameterName, Type parameterType) {
    Parameter parameter = signature.getParameter(parameterName);
    Iterator<MemberInvolvementTree> iterator = parameter.getMandatoryAttributes().iterator();
    if (iterator.hasNext()) {
        // if there are any mandatory attributes
        javaBuffer.addDocComment(signature.getName().toString());
        javaBuffer.addLine("if (" + javaNames.getJavaMemberStyleName(parameter.getName()) + "!=null");
        while (iterator.hasNext()) {
            MemberInvolvementTree attribute = iterator.next();
            List<MemberInvolvementTree> list = stackAttributeComponents(attribute);
            String attributeCheck = getFullAttributeCheck(javaNames.getJavaMemberStyleName(parameter.getName()), list, Operator.AND, true);
            if (attribute.getAlternative() != null) {
                // 'or' expression
                list = stackAttributeComponents(attribute.getAlternative());
                String alternativeCheck = getFullAttributeCheck(javaNames.getJavaMemberStyleName(parameter.getName()), list, Operator.AND, true);
                String fullCheck = mergeChecks(attributeCheck, alternativeCheck);
                javaBuffer.addLine(fullCheck);
            } else {
                javaBuffer.addLine(attributeCheck);
            }
        }
        javaBuffer.addLine(") {");
        javaBuffer.addLine("return " + resourceName.getSimpleName() + ".class.getMethod(\"" + javaNames.getJavaMemberStyleName(parentMethodName) + javaNames.getJavaClassStyleName(signature.getName()) + "\", " + javaNames.getJavaClassStyleName(parameter.getType().getName()) + ".class);");
        javaBuffer.addLine("}");
    }
}
#end_block

#method_before
private String getFullAttributeCheck(String paramName, List<MemberInvolvementTree> list, Operator operator) {
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < list.size(); i++) {
        builder.append(operator.getPaddedSign()).append(paramName).append(getAttributePath(list.subList(0, i + 1)));
        if (!builder.toString().endsWith(".size()!=0")) {
            builder.append(operator.comaprison).append("null");
        }
    }
    return builder.toString();
}
#method_after
private String getFullAttributeCheck(String paramName, List<MemberInvolvementTree> list, Operator operator, boolean startWithOperator) {
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < list.size(); i++) {
        if (i != 0 || startWithOperator) {
            builder.append(operator.getPaddedSign());
        }
        builder.append(paramName).append(getAttributePath(list.subList(0, i + 1)));
        if (!builder.toString().endsWith(".size()!=0")) {
            builder.append(operator.comaprison).append("null");
        }
    }
    return builder.toString();
}
#end_block

#method_before
private String getAttributePath(List<MemberInvolvementTree> list) {
    StringBuilder attributePath = new StringBuilder();
    for (int i = 0; i < list.size(); i++) {
        MemberInvolvementTree current = list.get(i);
        attributePath.append(".get").append(javaNames.getJavaClassStyleName(current.getName())).append("()");
        if (current.isCollection()) {
            if (i == list.size() - 1) {
                // the last element of the expression is a collection
                attributePath.append(".get").append(javaNames.getJavaClassStyleName(current.getName())).append("().size()!=0");
            } else {
                // TODO: !=null and .isEmpty() checks for collections missing at this point due to complexity
                // in adding them. Only the full check is added, e.g:
                // "disk.getTarget().getLogicalUnits().getLogicalUnits().get(0).getLunStorage()!=null"
                // this means the NullPointer or InderOutOfBound exceptions are possible for bad collection input
                attributePath.append(".get").append(javaNames.getJavaClassStyleName(current.getName())).append("().get(0)");
            }
        }
    }
    return attributePath.toString();
}
#method_after
private String getAttributePath(List<MemberInvolvementTree> list) {
    StringBuilder attributePath = new StringBuilder();
    for (int i = 0; i < list.size(); i++) {
        MemberInvolvementTree current = list.get(i);
        attributePath.append(isOrGet(current.getType())).append(javaNames.getJavaClassStyleName(current.getName())).append("()");
        if (current.isCollection()) {
            // TODO: Hard-coded check for an exceptional case because of violation of assumption
            // that the names of array and type in the model are the same. For example:
            // @Link Cdrom[] cdroms(); - good
            // @Link GlusterBrick[] bricks(); - bad
            // This check should be discarded and replaced with a generic solution or
            // enforce compliance with name conventions.
            String getterName = current.getName().toString().equals("bricks") ? "GlusterBricks" : javaNames.getJavaClassStyleName(current.getName());
            if (i == list.size() - 1) {
                // the last element of the expression is a collection
                attributePath.append(".get").append(getterName).append("().size()!=0");
            } else {
                // TODO: !=null and .isEmpty() checks for collections missing at this point due to complexity
                // in adding them. Only the full check is added, e.g:
                // "disk.getTarget().getLogicalUnits().getLogicalUnits().get(0).getLunStorage()!=null"
                // this means the NullPointer or InderOutOfBound exceptions are possible for bad collection input
                attributePath.append(".get").append(getterName).append("().get(0)");
            }
        }
    }
    return attributePath.toString();
}
#end_block

#method_before
private void closeSignatureDetectionMethod() {
    javaBuffer.addLine("else {");
    javaBuffer.addLine("return null;");
    javaBuffer.addLine("}");
    javaBuffer.addLine("}");
}
#method_after
private void closeSignatureDetectionMethod() {
    javaBuffer.addLine("");
    javaBuffer.addLine("throw new IllegalArgumentException(\"No matching signature found, make sure that mandatory attributes are provided.\");");
    javaBuffer.addLine("}");
    javaBuffer.addLine("");
}
#end_block

#method_before
private void generateValidation(Method method) {
    generateValidationMethodName(method);
    for (Parameter parameter : method.getParameters()) {
        generateParameterValidation(parameter);
    }
    // close validation method
    javaBuffer.addLine("}");
}
#method_after
private void generateValidation(Method method) {
    if (method.isMandatoryAttributeExists()) {
        generateValidationMethodName(method);
        for (Parameter parameter : method.getParameters()) {
            generateParameterValidation(parameter);
        }
        // close validation method
        javaBuffer.addLine("}");
        javaBuffer.addLine("");
    }
}
#end_block

#method_before
private void generateValidationMethodName(Method method) {
    Parameter parameter = JaxrsGeneratorUtils.getMainAddParameter(method);
    javaBuffer.addImports(schemaNames.getXjcTypeReference(parameter.getType()).getImports());
    javaBuffer.addLine("public static void validate%s(%s %s) {", javaNames.getJavaClassStyleName(method.getName()), javaNames.getJavaClassStyleName(parameter.getName()), javaNames.getJavaMemberStyleName(parameter.getName()));
}
#method_after
private void generateValidationMethodName(Method method) {
    Parameter parameter = jaxrsGeneratorUtils.getMainAddParameter(method);
    javaBuffer.addImports(schemaNames.getXjcTypeReference(parameter.getType()).getImports());
    javaBuffer.addLine("public static void validate%s(%s %s) {", javaNames.getJavaClassStyleName(method.getName()), javaNames.getJavaClassStyleName(parameter.getType().getName()), javaNames.getJavaMemberStyleName(parameter.getName()));
}
#end_block

#method_before
private void generateParameterValidation(Parameter parameter) {
    for (MemberInvolvementTree attribute : parameter.getMandatoryAttributes()) {
        List<MemberInvolvementTree> list = stackAttributeComponents(attribute);
        String attributePath = getAttributePath(list);
        String name = javaNames.getJavaMemberStyleName(parameter.getName());
        javaBuffer.addLine("if (" + name + "==null");
        javaBuffer.addLine(getFullAttributeCheck(javaNames.getJavaMemberStyleName(parameter.getName()), list, Operator.OR));
        // (TODO: replace line below with invocation of CompletenessAssertor)
        javaBuffer.addLine("throw new IllegalArgumentException(\"Invalid input, " + name + attributePath + " is mandatory\");");
        javaBuffer.addLine("}");
        javaBuffer.addLine();
    }
}
#method_after
private void generateParameterValidation(Parameter parameter) {
    String parameterName = javaNames.getJavaMemberStyleName(parameter.getName());
    List<MemberInvolvementTree> mandatoryAttributes = parameter.getMandatoryAttributes();
    if (parameter.isMandatory() || !mandatoryAttributes.isEmpty()) {
        javaBuffer.addLine("if (" + parameterName + "==null) {");
        javaBuffer.addLine("throw new IllegalArgumentException(\"" + parameterName + " is mandatory but was not provided.\");");
        javaBuffer.addLine("}");
    }
    for (MemberInvolvementTree attribute : mandatoryAttributes) {
        List<MemberInvolvementTree> attributeComponents = stackAttributeComponents(attribute);
        String attributePath = getAttributePath(attributeComponents);
        if (attribute.hasAlternative()) {
            // 'OR' scenario
            generateAlternativesValidation(parameter.getName(), attribute, attributeComponents, attributePath);
        } else {
            javaBuffer.addLine("if (" + getFullAttributeCheck(javaNames.getJavaMemberStyleName(parameter.getName()), attributeComponents, Operator.OR, false) + ") {");
            // (TODO: replace line below with invocation of CompletenessAssertor)
            javaBuffer.addLine("throw new IllegalArgumentException(\"" + parameterName + attributePath + " is mandatory but was not provided.\");");
        }
        javaBuffer.addLine("}");
        javaBuffer.addLine();
    }
}
#end_block

#method_before
private void generateActionValidation(Method method) {
    writeActionValidationMethodName(method);
    for (Parameter parameter : method.getParameters()) {
        generateActionParameterValidation(parameter);
    }
    // close validation method
    javaBuffer.addLine("}");
}
#method_after
private void generateActionValidation(Method method) {
    if (method.isMandatoryAttributeExists()) {
        writeActionValidationMethodName(method);
        validateActionNotNull();
        for (Parameter parameter : method.getParameters()) {
            generateActionParameterValidation(parameter);
        }
        // close validation method
        javaBuffer.addLine("}");
        javaBuffer.addLine("");
    }
}
#end_block

#method_before
private void writeActionValidationMethodName(Method method) {
    // TODO: add import of 'Action' class.
    javaBuffer.addLine("public static void validate%s(Action action) {", javaNames.getJavaClassStyleName(method.getName()));
}
#method_after
private void writeActionValidationMethodName(Method method) {
    javaBuffer.addImports(schemaNames.getXjcTypeReference(ACTION_TYPE).getImports());
    javaBuffer.addLine("public static void validate%s(Action action) {", javaNames.getJavaClassStyleName(method.getName()));
}
#end_block

#method_before
private void generateActionParameterValidation(Parameter parameter) {
    Name paramName = parameter.getName();
    if (parameter.isMandatory()) {
        // a simple parameter being mandatory only happens in 'action's.
        javaBuffer.addLine("if (action.get%s()==null) {", javaNames.getJavaClassStyleName(paramName));
        // (TODO: replace line below with invocation of CompletenessAssertor)
        javaBuffer.addLine("throw new IllegalArgumentException(\"Invalid input, " + paramName + " is mandatory\");");
        javaBuffer.addLine("}");
    } else {
        for (MemberInvolvementTree attribute : parameter.getMandatoryAttributes()) {
            List<MemberInvolvementTree> list = stackAttributeComponents(attribute);
            list.add(0, new MemberInvolvementTree(paramName));
            String attributePath = getAttributePath(list);
            javaBuffer.addLine("if (action==null");
            javaBuffer.addLine(getFullAttributeCheck("action", list, Operator.OR));
            javaBuffer.addLine(") {");
            // (TODO: replace line below with invocation of CompletenessAssertor)
            javaBuffer.addLine("throw new IllegalArgumentException(\"Invalid input, action" + attributePath + " is mandatory\"");
            javaBuffer.addLine("}");
            javaBuffer.addLine("");
        }
    }
}
#method_after
private void generateActionParameterValidation(Parameter parameter) {
    Name paramName = parameter.getName();
    if (parameter.isMandatory()) {
        // a simple parameter being mandatory only happens in 'action's.
        javaBuffer.addLine("if (action%s%s()==null) {", isOrGet(parameter.getType()), javaNames.getJavaClassStyleName(paramName));
        // (TODO: replace line below with invocation of CompletenessAssertor)
        javaBuffer.addLine("throw new IllegalArgumentException(\"" + paramName + " is mandatory but was not provided.\");");
        javaBuffer.addLine("}");
    } else {
        for (MemberInvolvementTree attribute : parameter.getMandatoryAttributes()) {
            List<MemberInvolvementTree> attributeComponents = stackAttributeComponents(attribute);
            MemberInvolvementTree component = new MemberInvolvementTree(new Name(parameter.getName()));
            component.setType(parameter.getType());
            attributeComponents.add(0, component);
            String attributePath = getAttributePath(attributeComponents);
            if (attribute.hasAlternative()) {
                // 'OR' scenario
                List<MemberInvolvementTree> alternativeAttributeComponents = stackAttributeComponents(attribute.getAlternative());
                alternativeAttributeComponents.add(0, component);
                String condition1 = "if ( (" + getFullAttributeCheck(javaNames.getJavaMemberStyleName(new Name("action")), attributeComponents, Operator.OR, false) + ")";
                String condition2 = "(" + getFullAttributeCheck(javaNames.getJavaMemberStyleName(new Name("action")), alternativeAttributeComponents, Operator.OR, false) + ") ) {";
                javaBuffer.addLine(condition1 + " && " + condition2);
                javaBuffer.addLine("throw new IllegalArgumentException(\"" + "action" + attributePath + " or " + "action" + getAttributePath(alternativeAttributeComponents) + " are mandatory but both were not provided.\");");
            } else {
                javaBuffer.addLine("if (" + getFullAttributeCheck("action", attributeComponents, Operator.OR, false) + ") {");
                // (TODO: replace line below with invocation of CompletenessAssertor)
                javaBuffer.addLine("throw new IllegalArgumentException(\"action" + attributePath + " is mandatory but was not provided.\");");
            }
            javaBuffer.addLine("}");
            javaBuffer.addLine("");
        }
    }
}
#end_block

#method_before
private void generateActionSignatureDetection(Method method, List<Method> methods) {
    // TODO: handle import of 'Action' class
    Name methodName = getSignatureDetectionMethodName(method);
    javaBuffer.addLine("public static Method %s(Action action) throws NoSuchMethodException, SecurityException {", javaNames.getJavaMemberStyleName(methodName));
    for (Parameter parameter : method.getParameters()) {
        generateActionParameterValidation(parameter);
    }
    javaBuffer.addLine();
    Set<Method> signatures = baseMethods.get(method);
    for (Method signature : signatures) {
        javaBuffer.addDocComment(signature.getName().toString());
        if (signature.isMandatoryAttributeExists()) {
            javaBuffer.addLine("if (action!=null");
            for (Parameter parameter : signature.getParameters()) {
                if (parameter.isMandatory()) {
                    assert parameter.getType() instanceof EnumType || parameter.getType() instanceof PrimitiveType;
                    javaBuffer.addLine(" && %s!=null", "action.get" + javaNames.getJavaClassStyleName(parameter.getName()) + "()");
                } else {
                    Iterator<MemberInvolvementTree> iterator = parameter.getMandatoryAttributes().iterator();
                    while (iterator.hasNext()) {
                        MemberInvolvementTree attribute = iterator.next();
                        List<MemberInvolvementTree> list = stackAttributeComponents(attribute);
                        list.add(0, new MemberInvolvementTree(parameter.getName()));
                        javaBuffer.addLine(getFullAttributeCheck(javaNames.getJavaMemberStyleName(new Name("action")), list, Operator.AND));
                    }
                }
            }
        }
        javaBuffer.addLine(") {");
        javaBuffer.addLine("return " + resourceName.getSimpleName() + ".class.getMethod(\"" + javaNames.getJavaMemberStyleName(method.getName()) + javaNames.getJavaClassStyleName(signature.getName()) + "\");");
        javaBuffer.addLine("}");
        javaBuffer.addLine();
    }
    closeSignatureDetectionMethod();
}
#method_after
private void generateActionSignatureDetection(Method method) {
    Set<Method> signatures = baseMethods.get(method);
    if (mandatoryAttributeExists(signatures)) {
        // validate that the action object itself is not null
        javaBuffer.addImport(java.lang.reflect.Method.class);
        Name methodName = getSignatureDetectionMethodName(method);
        javaBuffer.addLine("public static Method %s(Action action) throws NoSuchMethodException, SecurityException {", javaNames.getJavaMemberStyleName(methodName));
        validateActionNotNull();
        for (Parameter parameter : method.getParameters()) {
            generateActionParameterValidation(parameter);
        }
        javaBuffer.addLine();
        for (Method signature : signatures) {
            javaBuffer.addDocComment(signature.getName().toString());
            if (signature.isMandatoryAttributeExists()) {
                javaBuffer.addLine("if (action!=null");
                for (Parameter parameter : signature.getParameters()) {
                    if (parameter.isMandatory()) {
                        assert parameter.getType() instanceof EnumType || parameter.getType() instanceof PrimitiveType;
                        javaBuffer.addLine(" && %s!=null", "action" + isOrGet(parameter.getType()) + javaNames.getJavaClassStyleName(parameter.getName()) + "()");
                    } else {
                        Iterator<MemberInvolvementTree> iterator = parameter.getMandatoryAttributes().iterator();
                        while (iterator.hasNext()) {
                            MemberInvolvementTree attribute = iterator.next();
                            List<MemberInvolvementTree> list = stackAttributeComponents(attribute);
                            list.add(0, new MemberInvolvementTree(parameter.getName()));
                            javaBuffer.addLine(getFullAttributeCheck(javaNames.getJavaMemberStyleName(new Name("action")), list, Operator.AND, true));
                        }
                    }
                }
            }
            javaBuffer.addLine(") {");
            javaBuffer.addLine("return " + resourceName.getSimpleName() + ".class.getMethod(\"" + javaNames.getJavaMemberStyleName(method.getName()) + javaNames.getJavaClassStyleName(signature.getName()) + "\", Action.class);");
            javaBuffer.addLine("}");
            javaBuffer.addLine();
        }
        closeSignatureDetectionMethod();
    }
// TODO: in the future fail for this
// else {
// throw new IllegalStateException(method.getName() + "'s signatures have 0 mandatory attributes (any signature must have at least 1 mandatory attribute)");
// }
}
#end_block

#method_before
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated XML and JSON model representations:
    options.addOption(Option.builder().longOpt(XML_DESCRIPTION_OPTION).desc("The location of the generated XML description of the model. If not specified then the XML " + "description isn't generated.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(JSON_DESCRIPTION_OPTION).desc("The location of the generated JSON description of the model. If not specified then the JSON " + "description isn't generated.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    // Options for the location of the input and output XML schemas:
    options.addOption(Option.builder().longOpt(IN_SCHEMA_OPTION).desc("The XML schema input file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(OUT_SCHEMA_OPTION).desc("The XML schema output file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    // Options for the names of generated Java sources:
    options.addOption(Option.builder().longOpt(JAVA_OPTION).desc("The directory where the generated Java source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(JAXRS_OPTION).desc("The directory where the generated JAX-RS source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(JAXRS_PACKAGE_OPTION).desc("The name of the Java package for JAX-RS interfaces.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(XJC_PACKAGE_OPTION).desc("The name of the Java package for classes generated by the XJC compiler.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(TYPES_PACKAGE_OPTION).desc("The name of the Java package for the generated type interfaces.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(CONTAINERS_PACKAGE_OPTION).desc("The name of the Java package for the generated type containers.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(BUILDERS_PACKAGE_OPTION).desc("The name of the Java package for the generated type builders.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(JSON_PACKAGE_OPTION).desc("The name of the Java package for the generated JSON readers and writers.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(XML_PACKAGE_OPTION).desc("The name of the Java package for the generated XML readers and writers.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(VERSION_PREFIX_OPTION).desc("The version prefix to add to the generated Java class names, for example V4.").required(false).hasArg(true).argName("PREFIX").build());
    // Options for the generation of documentation:
    options.addOption(Option.builder().longOpt(DOCS_OPTION).desc("The directory where the generated documentation will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(ADOC_ATTRIBUTE_OPTION).desc("An attribute to be included in the generated AsciiDoc documentation. The value of the argument " + "should be the name attribute, followed by an optional colon and the value of the attribute.").required(false).hasArg(true).argName("ATTRIBUTE").build());
    options.addOption(Option.builder().longOpt(ADOC_SEPARATOR_OPTION).desc("The character to use as the separator of section identifiers in the generated AsciiDoc " + "documentation. If not specified the forward slash character will be used.").required(false).hasArg(true).argName("SEPARATOR").build());
    options.addOption(Option.builder().longOpt(REPORT_OPTION).desc("The file where the documentation report be created.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(RESOURCES_OPTION).desc("The directory where the resources files will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        System.err.println(exception.getMessage());
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("metamodel-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File xmlFile = (File) line.getParsedOptionValue(XML_DESCRIPTION_OPTION);
    File jsonFile = (File) line.getParsedOptionValue(JSON_DESCRIPTION_OPTION);
    File inSchemaFile = (File) line.getParsedOptionValue(IN_SCHEMA_OPTION);
    File outSchemaFile = (File) line.getParsedOptionValue(OUT_SCHEMA_OPTION);
    File jaxrsDir = (File) line.getParsedOptionValue(JAXRS_OPTION);
    File jaxrsHelperDir = new File(jaxrsDir.getAbsoluteFile() + "/helper");
    File javaDir = (File) line.getParsedOptionValue(JAVA_OPTION);
    File docsDir = (File) line.getParsedOptionValue(DOCS_OPTION);
    File reportFile = (File) line.getParsedOptionValue(REPORT_OPTION);
    File resourcesDir = (File) line.getParsedOptionValue(RESOURCES_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Add the built-in types to the model:
    builtinTypes.addBuiltinTypes(model);
    // Extract the version prefix from the command line and copy it to the object that manages names:
    String versionPrefix = line.getOptionValue(VERSION_PREFIX_OPTION);
    if (versionPrefix != null) {
        versionedJavaNames.setVersionPrefix(versionPrefix);
    }
    // Extract the names of the Java packages from the command line and copy them to the object that manages them:
    String[] jaxrsPackages = line.getOptionValues(JAXRS_PACKAGE_OPTION);
    if (jaxrsPackages != null) {
        for (String jaxrsPackage : jaxrsPackages) {
            javaPackages.addJaxrsRule(jaxrsPackage);
        }
    }
    String xjcPackage = line.getOptionValue(XJC_PACKAGE_OPTION);
    if (xjcPackage != null) {
        javaPackages.setXjcPackageName(xjcPackage);
    }
    String typesPackage = line.getOptionValue(TYPES_PACKAGE_OPTION);
    if (typesPackage != null) {
        javaPackages.setTypesPackageName(typesPackage);
    }
    String containersPackage = line.getOptionValue(CONTAINERS_PACKAGE_OPTION);
    if (containersPackage != null) {
        javaPackages.setContainersPackageName(containersPackage);
    }
    String buildersPackage = line.getOptionValue(BUILDERS_PACKAGE_OPTION);
    if (buildersPackage != null) {
        javaPackages.setBuildersPackageName(buildersPackage);
    }
    String jsonPackage = line.getOptionValue(JSON_PACKAGE_OPTION);
    if (jsonPackage != null) {
        javaPackages.setJsonPackageName(jsonPackage);
    }
    String xmlPackage = line.getOptionValue(XML_PACKAGE_OPTION);
    if (xmlPackage != null) {
        javaPackages.setXmlPackageName(xmlPackage);
    }
    // Extract the documentation attributes:
    String[] adocAttributeArgs = line.getOptionValues(ADOC_ATTRIBUTE_OPTION);
    if (adocAttributeArgs != null) {
        for (String adocAttributeArg : adocAttributeArgs) {
            Matcher adocAttributeMatch = ADOC_ATTRIBUTE_RE.matcher(adocAttributeArg);
            if (!adocAttributeMatch.matches()) {
                throw new IllegalArgumentException("The AsciiDoc attribute \"" + adocAttributeArg + "\" doesn't match regular " + "expression \"" + ADOC_ATTRIBUTE_RE.pattern() + "\".");
            }
            String adocAttributeName = adocAttributeMatch.group("name");
            String adocAttributeValue = adocAttributeMatch.group("value");
            adocConfiguration.setAttribute(adocAttributeName, adocAttributeValue);
        }
    }
    // Get the AsciiDoc section id separator:
    String adocSeparator = line.getOptionValue(ADOC_SEPARATOR_OPTION);
    if (adocSeparator != null) {
        adocConfiguration.setSeparator(adocSeparator);
    }
    // Generate the XML representation of the model:
    if (xmlFile != null) {
        File xmlDir = xmlFile.getParentFile();
        FileUtils.forceMkdir(xmlDir);
        xmlDescriptionGenerator.generate(model, xmlFile);
    }
    // Generate the JSON representation of the model:
    if (jsonFile != null) {
        File jsonDir = jsonFile.getParentFile();
        FileUtils.forceMkdir(jsonDir);
        jsonDescriptionGenerator.generate(model, jsonFile);
    }
    // Generate the XML schema:
    if (inSchemaFile != null && outSchemaFile != null) {
        schemaGenerator.setInFile(inSchemaFile);
        schemaGenerator.setOutFile(outSchemaFile);
        schemaGenerator.generate(model);
    }
    // Generate the JAX-RS source:
    if (jaxrsDir != null) {
        FileUtils.forceMkdir(jaxrsDir);
        jaxrsGenerator.setOutDir(jaxrsDir);
        jaxrsGenerator.generate(model);
        // Generate the JAX-RS helper classes):
        if (jaxrsHelperDir != null) {
            FileUtils.forceMkdir(jaxrsHelperDir);
            jaxrsHelperGenerator.setOutDir(jaxrsHelperDir);
            jaxrsHelperGenerator.generate(model);
        }
    }
    // Generate the Java source:
    if (javaDir != null) {
        typesGenerator.setOutDir(javaDir);
        typesGenerator.generate(model);
        // Generate JSON support classes:
        jsonSupportGenerator.setOutDir(javaDir);
        jsonSupportGenerator.generate(model);
        // Generate XML support classes:
        xmlSupportGenerator.setOutDir(javaDir);
        xmlSupportGenerator.setResourcesDir(resourcesDir);
        xmlSupportGenerator.generate(model);
    }
    // Generate the documentation:
    if (docsDir != null) {
        docGenerator.setOutDir(docsDir);
        docGenerator.generate(model);
    }
    if (reportFile != null) {
        reportGenerator.setOutFile(reportFile);
        reportGenerator.generate(model);
    }
}
#method_after
public void run(String[] args) throws Exception {
    // Create the command line options:
    Options options = new Options();
    // Options for the locations of files and directories:
    options.addOption(Option.builder().longOpt(MODEL_OPTION).desc("The directory or .jar file containing the source model files.").type(File.class).required(true).hasArg(true).argName("DIRECTORY|JAR").build());
    // Options for the location of the generated XML and JSON model representations:
    options.addOption(Option.builder().longOpt(XML_DESCRIPTION_OPTION).desc("The location of the generated XML description of the model. If not specified then the XML " + "description isn't generated.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(JSON_DESCRIPTION_OPTION).desc("The location of the generated JSON description of the model. If not specified then the JSON " + "description isn't generated.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    // Options for the location of the input and output XML schemas:
    options.addOption(Option.builder().longOpt(IN_SCHEMA_OPTION).desc("The XML schema input file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(OUT_SCHEMA_OPTION).desc("The XML schema output file.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    // Options for the names of generated Java sources:
    options.addOption(Option.builder().longOpt(JAVA_OPTION).desc("The directory where the generated Java source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(JAXRS_OPTION).desc("The directory where the generated JAX-RS source will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(JAXRS_PACKAGE_OPTION).desc("The name of the Java package for JAX-RS interfaces.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(XJC_PACKAGE_OPTION).desc("The name of the Java package for classes generated by the XJC compiler.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(TYPES_PACKAGE_OPTION).desc("The name of the Java package for the generated type interfaces.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(CONTAINERS_PACKAGE_OPTION).desc("The name of the Java package for the generated type containers.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(BUILDERS_PACKAGE_OPTION).desc("The name of the Java package for the generated type builders.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(JSON_PACKAGE_OPTION).desc("The name of the Java package for the generated JSON readers and writers.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(XML_PACKAGE_OPTION).desc("The name of the Java package for the generated XML readers and writers.").required(false).hasArg(true).argName("PACKAGE").build());
    options.addOption(Option.builder().longOpt(VERSION_PREFIX_OPTION).desc("The version prefix to add to the generated Java class names, for example V4.").required(false).hasArg(true).argName("PREFIX").build());
    // Options for the generation of documentation:
    options.addOption(Option.builder().longOpt(DOCS_OPTION).desc("The directory where the generated documentation will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    options.addOption(Option.builder().longOpt(ADOC_ATTRIBUTE_OPTION).desc("An attribute to be included in the generated AsciiDoc documentation. The value of the argument " + "should be the name attribute, followed by an optional colon and the value of the attribute.").required(false).hasArg(true).argName("ATTRIBUTE").build());
    options.addOption(Option.builder().longOpt(ADOC_SEPARATOR_OPTION).desc("The character to use as the separator of section identifiers in the generated AsciiDoc " + "documentation. If not specified the forward slash character will be used.").required(false).hasArg(true).argName("SEPARATOR").build());
    options.addOption(Option.builder().longOpt(REPORT_OPTION).desc("The file where the documentation report be created.").type(File.class).required(false).hasArg(true).argName("FILE").build());
    options.addOption(Option.builder().longOpt(RESOURCES_OPTION).desc("The directory where the resources files will be created.").type(File.class).required(false).hasArg(true).argName("DIRECTORY").build());
    // Parse the command line:
    CommandLineParser parser = new DefaultParser();
    CommandLine line = null;
    try {
        line = parser.parse(options, args);
    } catch (ParseException exception) {
        System.err.println(exception.getMessage());
        HelpFormatter formatter = new HelpFormatter();
        formatter.setSyntaxPrefix("Usage: ");
        formatter.printHelp("metamodel-tool [OPTIONS]", options);
        System.exit(1);
    }
    // Extract the locations of files and directories from the command line:
    File modelFile = (File) line.getParsedOptionValue(MODEL_OPTION);
    File xmlFile = (File) line.getParsedOptionValue(XML_DESCRIPTION_OPTION);
    File jsonFile = (File) line.getParsedOptionValue(JSON_DESCRIPTION_OPTION);
    File inSchemaFile = (File) line.getParsedOptionValue(IN_SCHEMA_OPTION);
    File outSchemaFile = (File) line.getParsedOptionValue(OUT_SCHEMA_OPTION);
    File jaxrsDir = (File) line.getParsedOptionValue(JAXRS_OPTION);
    File javaDir = (File) line.getParsedOptionValue(JAVA_OPTION);
    File docsDir = (File) line.getParsedOptionValue(DOCS_OPTION);
    File reportFile = (File) line.getParsedOptionValue(REPORT_OPTION);
    File resourcesDir = (File) line.getParsedOptionValue(RESOURCES_OPTION);
    // Analyze the model files:
    Model model = new Model();
    ModelAnalyzer modelAnalyzer = new ModelAnalyzer();
    modelAnalyzer.setModel(model);
    modelAnalyzer.analyzeSource(modelFile);
    // Add the built-in types to the model:
    builtinTypes.addBuiltinTypes(model);
    // Extract the version prefix from the command line and copy it to the object that manages names:
    String versionPrefix = line.getOptionValue(VERSION_PREFIX_OPTION);
    if (versionPrefix != null) {
        versionedJavaNames.setVersionPrefix(versionPrefix);
    }
    // Extract the names of the Java packages from the command line and copy them to the object that manages them:
    String[] jaxrsPackages = line.getOptionValues(JAXRS_PACKAGE_OPTION);
    if (jaxrsPackages != null) {
        for (String jaxrsPackage : jaxrsPackages) {
            javaPackages.addJaxrsRule(jaxrsPackage);
        }
    }
    String xjcPackage = line.getOptionValue(XJC_PACKAGE_OPTION);
    if (xjcPackage != null) {
        javaPackages.setXjcPackageName(xjcPackage);
    }
    String typesPackage = line.getOptionValue(TYPES_PACKAGE_OPTION);
    if (typesPackage != null) {
        javaPackages.setTypesPackageName(typesPackage);
    }
    String containersPackage = line.getOptionValue(CONTAINERS_PACKAGE_OPTION);
    if (containersPackage != null) {
        javaPackages.setContainersPackageName(containersPackage);
    }
    String buildersPackage = line.getOptionValue(BUILDERS_PACKAGE_OPTION);
    if (buildersPackage != null) {
        javaPackages.setBuildersPackageName(buildersPackage);
    }
    String jsonPackage = line.getOptionValue(JSON_PACKAGE_OPTION);
    if (jsonPackage != null) {
        javaPackages.setJsonPackageName(jsonPackage);
    }
    String xmlPackage = line.getOptionValue(XML_PACKAGE_OPTION);
    if (xmlPackage != null) {
        javaPackages.setXmlPackageName(xmlPackage);
    }
    // Extract the documentation attributes:
    String[] adocAttributeArgs = line.getOptionValues(ADOC_ATTRIBUTE_OPTION);
    if (adocAttributeArgs != null) {
        for (String adocAttributeArg : adocAttributeArgs) {
            Matcher adocAttributeMatch = ADOC_ATTRIBUTE_RE.matcher(adocAttributeArg);
            if (!adocAttributeMatch.matches()) {
                throw new IllegalArgumentException("The AsciiDoc attribute \"" + adocAttributeArg + "\" doesn't match regular " + "expression \"" + ADOC_ATTRIBUTE_RE.pattern() + "\".");
            }
            String adocAttributeName = adocAttributeMatch.group("name");
            String adocAttributeValue = adocAttributeMatch.group("value");
            adocConfiguration.setAttribute(adocAttributeName, adocAttributeValue);
        }
    }
    // Get the AsciiDoc section id separator:
    String adocSeparator = line.getOptionValue(ADOC_SEPARATOR_OPTION);
    if (adocSeparator != null) {
        adocConfiguration.setSeparator(adocSeparator);
    }
    // Generate the XML representation of the model:
    if (xmlFile != null) {
        File xmlDir = xmlFile.getParentFile();
        FileUtils.forceMkdir(xmlDir);
        xmlDescriptionGenerator.generate(model, xmlFile);
    }
    // Generate the JSON representation of the model:
    if (jsonFile != null) {
        File jsonDir = jsonFile.getParentFile();
        FileUtils.forceMkdir(jsonDir);
        jsonDescriptionGenerator.generate(model, jsonFile);
    }
    // Generate the XML schema:
    if (inSchemaFile != null && outSchemaFile != null) {
        schemaGenerator.setInFile(inSchemaFile);
        schemaGenerator.setOutFile(outSchemaFile);
        schemaGenerator.generate(model);
    }
    // Generate the JAX-RS source:
    if (jaxrsDir != null) {
        FileUtils.forceMkdir(jaxrsDir);
        jaxrsGenerator.setOutDir(jaxrsDir);
        jaxrsGenerator.generate(model);
        // Generate the JAX-RS helper classes):
        jaxrsHelperGenerator.setOutDir(jaxrsDir);
        jaxrsHelperGenerator.generate(model);
    }
    // Generate the Java source:
    if (javaDir != null) {
        typesGenerator.setOutDir(javaDir);
        typesGenerator.generate(model);
        // Generate JSON support classes:
        jsonSupportGenerator.setOutDir(javaDir);
        jsonSupportGenerator.generate(model);
        // Generate XML support classes:
        xmlSupportGenerator.setOutDir(javaDir);
        xmlSupportGenerator.setResourcesDir(resourcesDir);
        xmlSupportGenerator.generate(model);
    }
    // Generate the documentation:
    if (docsDir != null) {
        docGenerator.setOutDir(docsDir);
        docGenerator.generate(model);
    }
    if (reportFile != null) {
        reportGenerator.setOutFile(reportFile);
        reportGenerator.generate(model);
    }
}
#end_block

#method_before
public static Map<Method, Set<Method>> getBaseMethodsMap(List<Method> methods) {
    Map<Method, Set<Method>> baseMethods = new HashMap<>();
    methods.forEach(x -> updateBaseMethodsMap(x, methods, baseMethods));
    return baseMethods;
}
#method_after
public Map<Method, Set<Method>> getBaseMethodsMap(List<Method> methods) {
    Map<Method, Set<Method>> baseMethods = new HashMap<>();
    methods.forEach(x -> updateBaseMethodsMap(x, methods, baseMethods));
    return baseMethods;
}
#end_block

#method_before
private static void updateBaseMethodsMap(Method method, List<Method> methods, Map<Method, Set<Method>> baseMethods) {
    for (Method currentMethod : methods) {
        if (currentMethod.getBase() != null && currentMethod.getBase().equals(method)) {
            add(baseMethods, method, currentMethod);
        }
    }
}
#method_after
private void updateBaseMethodsMap(Method method, List<Method> methods, Map<Method, Set<Method>> baseMethods) {
    for (Method currentMethod : methods) {
        if (currentMethod.getBase() != null && currentMethod.getBase().equals(method)) {
            add(baseMethods, method, currentMethod);
        }
    }
}
#end_block

#method_before
private static void add(Map<Method, Set<Method>> baseMethods, Method method, Method currentMethod) {
    if (!baseMethods.containsKey(method)) {
        baseMethods.put(method, new HashSet<>());
    }
    Set<Method> signatures = (Set<Method>) (baseMethods.get(method));
    signatures.add(currentMethod);
}
#method_after
private void add(Map<Method, Set<Method>> baseMethods, Method method, Method currentMethod) {
    if (!baseMethods.containsKey(method)) {
        baseMethods.put(method, new HashSet<>());
    }
    Set<Method> signatures = (Set<Method>) (baseMethods.get(method));
    signatures.add(currentMethod);
}
#end_block

#method_before
public static Parameter getMainAddParameter(Method method) {
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType || x.getType() instanceof ListType).findFirst().orElse(null);
    return mainParameter;
}
#method_after
public Parameter getMainAddParameter(Method method) {
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType || x.getType() instanceof ListType).findFirst().orElse(null);
    return mainParameter;
}
#end_block

#method_before
public static Parameter getMainUpdateParameter(Method method) {
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType).findFirst().orElse(null);
    return mainParameter;
}
#method_after
public Parameter getMainUpdateParameter(Method method) {
    Parameter mainParameter = method.getParameters().stream().filter(x -> x.getType() instanceof StructType).findFirst().orElse(null);
    return mainParameter;
}
#end_block

#method_before
public static boolean isAddSignature(Method method) {
    return method.getBase() != null && method.getBase().getName().equals(ADD);
}
#method_after
public boolean isAddSignature(Method method) {
    return method.getBase() != null && method.getBase().getName().equals(ADD);
}
#end_block

#method_before
public static boolean isUpdateSignature(Method method) {
    return method.getBase() != null && method.getBase().getName().equals(UPDATE);
}
#method_after
public boolean isUpdateSignature(Method method) {
    return method.getBase() != null && method.getBase().getName().equals(UPDATE);
}
#end_block

#method_before
public static boolean isActionSignature(Method method) {
    return method.getBase() != null && !method.getBase().getName().equals(ADD) && !method.getBase().getName().equals(UPDATE);
}
#method_after
public boolean isActionSignature(Method method) {
    return method.getBase() != null && !method.getBase().getName().equals(ADD) && !method.getBase().getName().equals(UPDATE);
}
#end_block

#method_before
public static boolean isContained(Method method, Collection<Method> methods) {
    for (Method currentMethod : methods) {
        if (isContained(method, currentMethod)) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean isContained(Method method, Collection<Method> methods) {
    for (Method currentMethod : methods) {
        if (isContained(method, currentMethod)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public static boolean isContained(Method method, Method method2) {
    if (method.getName().equals(method2.getName())) {
        // same method
        return false;
    }
    if (method.getBase() == null || method2.getBase() == null) {
        // no parent, containment irrelevant
        return false;
    }
    if (!method.getBase().getName().equals(method2.getBase().getName())) {
        // different parents, containment irrelevant.
        return false;
    }
    return isParametersContained(method.getMandatoryParameters(), method2.getMandatoryParameters()) && isAttributesContained(method.getMandatoryAttributes(), method2.getMandatoryAttributes());
}
#method_after
public boolean isContained(Method method, Method method2) {
    if (method.getName().equals(method2.getName())) {
        // same method
        return false;
    }
    if (method.getBase() == null || method2.getBase() == null) {
        // no parent, containment irrelevant
        return false;
    }
    if (!method.getBase().getName().equals(method2.getBase().getName())) {
        // different parents, containment irrelevant.
        return false;
    }
    return isParametersContained(method.getMandatoryParameters(), method2.getMandatoryParameters()) && isAttributesContained(method.getMandatoryAttributes(), method2.getMandatoryAttributes());
}
#end_block

#method_before
private static boolean isParametersContained(List<Parameter> mandatoryParameters1, List<Parameter> mandatoryParameters2) {
    List<Name> names1 = new ArrayList<>();
    List<Name> names2 = new ArrayList<>();
    for (Parameter p : mandatoryParameters1) {
        names1.add(p.getName());
    }
    for (Parameter p : mandatoryParameters2) {
        names2.add(p.getName());
    }
    return mandatoryParameters2.containsAll(mandatoryParameters1);
}
#method_after
private boolean isParametersContained(List<Parameter> mandatoryParameters1, List<Parameter> mandatoryParameters2) {
    if (mandatoryParameters1.isEmpty() && mandatoryParameters2.isEmpty()) {
        return false;
    }
    List<Name> names1 = new ArrayList<>();
    List<Name> names2 = new ArrayList<>();
    for (Parameter p : mandatoryParameters1) {
        names1.add(p.getName());
    }
    for (Parameter p : mandatoryParameters2) {
        names2.add(p.getName());
    }
    return names2.containsAll(names1);
}
#end_block

#method_before
private static boolean isAttributesContained(List<MemberInvolvementTree> mandatoryAttributes1, List<MemberInvolvementTree> mandatoryAttributes2) {
    return toNames(mandatoryAttributes2).containsAll(toNames(mandatoryAttributes1));
}
#method_after
private boolean isAttributesContained(List<MemberInvolvementTree> mandatoryAttributes1, List<MemberInvolvementTree> mandatoryAttributes2) {
    if (mandatoryAttributes1.isEmpty() && mandatoryAttributes2.isEmpty()) {
        return false;
    }
    return toNames(mandatoryAttributes2).containsAll(toNames(mandatoryAttributes1));
}
#end_block

#method_before
private static List<Name> toNames(List<MemberInvolvementTree> attributes) {
    List<Name> names = new ArrayList<>();
    for (MemberInvolvementTree attribute : attributes) {
        names.add(attribute.getAlternative() == null ? attribute.shallowToString() : combineAlternatives(attribute));
    }
    return names;
}
#method_after
private List<Name> toNames(List<MemberInvolvementTree> attributes) {
    List<Name> names = new ArrayList<>();
    for (MemberInvolvementTree attribute : attributes) {
        names.add(attribute.getAlternative() == null ? attribute.shallowToString() : combineAlternatives(attribute));
    }
    return names;
}
#end_block

#method_before
private static Name combineAlternatives(MemberInvolvementTree attribute) {
    Name name1 = attribute.shallowToString();
    Name name2 = attribute.getAlternative().shallowToString();
    if (name1.toString().compareTo(name2.toString()) < 0) {
        name1.addWords(name2.getWords());
        return name1;
    } else {
        name2.addWords(name1.getWords());
        return name2;
    }
}
#method_after
private Name combineAlternatives(MemberInvolvementTree attribute) {
    Name name1 = attribute.shallowToString();
    Name name2 = attribute.getAlternative().shallowToString();
    if (name1.compareTo(name2) < 0) {
        return names.concatenate(name1, name2);
    } else {
        return names.concatenate(name2, name1);
    }
}
#end_block

#method_before
public boolean isAction() {
    List<String> nonActionMethodNames = new ArrayList<>(Arrays.asList("add", "get", "list", "update", "remove"));
    if (nonActionMethodNames.contains(getName().toString().toLowerCase()) || (base != null && nonActionMethodNames.contains(base.getName().toString().toLowerCase()))) {
        return false;
    } else {
        return true;
    }
}
#method_after
public boolean isAction() {
    return !(NON_ACTION_METHOD_NAMES.contains(getName()) || (base != null && NON_ACTION_METHOD_NAMES.contains(base.getName())));
}
#end_block

#method_before
private void updateVmTemplate() {
    vmHandler.updateVmInitToDB(getVmTemplate());
    vmTemplateDao.update(getVmTemplate());
    // also update the smartcard device
    getVmDeviceUtils().updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    getVmDeviceUtils().updateSoundDevice(oldTemplate, getVmTemplate(), getVmTemplate().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled());
    getVmDeviceUtils().updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    getVmDeviceUtils().updateUsbSlots(oldTemplate, getVmTemplate());
    getVmDeviceUtils().updateVirtioScsiController(getVmTemplate(), getParameters().isVirtioScsiEnabled());
    if (getParameters().isBalloonEnabled() != null) {
        getVmDeviceUtils().updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
    }
    if (getParameters().getVmTemplateData().getDefaultDisplayType() == DisplayType.none) {
        getVmDeviceUtils().removeVideoDevices(getVmTemplateId());
    }
}
#method_after
private void updateVmTemplate() {
    vmHandler.updateVmInitToDB(getVmTemplate());
    vmTemplateDao.update(getVmTemplate());
    // also update the smartcard device
    getVmDeviceUtils().updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
    // update audio device
    getVmDeviceUtils().updateSoundDevice(oldTemplate, getVmTemplate(), getVmTemplate().getCompatibilityVersion(), getParameters().isSoundDeviceEnabled());
    getVmDeviceUtils().updateConsoleDevice(getVmTemplateId(), getParameters().isConsoleEnabled());
    if (oldTemplate.getUsbPolicy() != getVmTemplate().getUsbPolicy()) {
        getVmDeviceUtils().updateUsbSlots(oldTemplate, getVmTemplate());
    }
    getVmDeviceUtils().updateVirtioScsiController(getVmTemplate(), getParameters().isVirtioScsiEnabled());
    if (getParameters().isBalloonEnabled() != null) {
        getVmDeviceUtils().updateMemoryBalloon(getVmTemplateId(), getParameters().isBalloonEnabled());
    }
    if (getParameters().getVmTemplateData().getDefaultDisplayType() == DisplayType.none) {
        getVmDeviceUtils().removeVideoDevices(getVmTemplateId());
    }
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, Version versionToUpdateRndDeviceWith) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase), versionToUpdateRndDeviceWith);
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, VmBase srcVmBase, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices, Version versionToUpdateRngDeviceWith) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device), dstVmBase.getCustomCompatibilityVersion()).isValid()) {
                    continue;
                }
                final VmRngDevice rngDevice = new VmRngDevice(device);
                if (versionToUpdateRngDeviceWith != null) {
                    rngDevice.updateSourceByVersion(versionToUpdateRngDeviceWith);
                }
                specParams.putAll(rngDevice.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    updateUsbSlots(srcId.equals(Guid.Empty) ? null : srcVmBase, dstVmBase);
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstVmBase, getVmCompatibilityVersion(dstVmBase));
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, Version versionToUpdateRndDeviceWith) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase), versionToUpdateRndDeviceWith);
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, Version versionToUpdateRndDeviceWith) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, srcVmBase, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase), versionToUpdateRndDeviceWith);
}
#end_block

#method_before
private VmBase getVmBase(Guid vmId) {
    VM vm = vmDao.get(vmId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    if (vmBase == null) {
        vmBase = vmTemplateDao.get(vmId);
    }
    return vmBase;
}
#method_after
public VmBase getVmBase(Guid vmId) {
    VM vm = vmDao.get(vmId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    if (vmBase == null) {
        vmBase = vmTemplateDao.get(vmId);
    }
    return vmBase;
}
#end_block

#method_before
@Override
public Vm update(Vm incoming) {
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, // TODO: change 'null' to 'incoming.getVmCompa...' when REST support is added
            new ChangeVMClusterParameters(clusterId, guid, null));
        }
    }
    if (!isFiltered()) {
        if (incoming.isSetPlacementPolicy()) {
            parent.validateAndUpdateHostsInPlacementPolicy(incoming.getPlacementPolicy());
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    Vm vm = performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm, false);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#method_after
@Override
public Vm update(Vm incoming) {
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, // TODO: change 'null' to 'incoming.getVmCompa...' when REST support is added
            new ChangeVMClusterParameters(clusterId, guid, null));
        }
    }
    if (!isFiltered()) {
        if (incoming.isSetPlacementPolicy()) {
            parent.validateAndUpdateHostsInPlacementPolicy(incoming.getPlacementPolicy());
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    VdcQueryType queryType = isNextRunRequested() ? VdcQueryType.GetVmNextRunConfiguration : VdcQueryType.GetVmByVmId;
    Vm vm = performUpdate(incoming, new QueryIdResolver<>(queryType, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm, false);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#end_block

#method_before
@Override
public Response ticket(Action action) {
    GraphicsType graphicsType = deriveGraphicsType();
    if (graphicsType == null) {
        Fault fault = new Fault();
        fault.setReason("Operation Failed");
        fault.setDetail(localize(Messages.CANNOT_GET_TICKET_FOR_DOWN_VM));
        return Response.status(Response.Status.CONFLICT).entity(fault).build();
    }
    String consoleId = BackendGraphicsConsoleHelper.asConsoleId(graphicsType);
    return getGraphicsConsolesResource().getConsoleResource(consoleId).ticket(action);
}
#method_after
@Override
public Response ticket(Action action) {
    return BackendGraphicsConsoleHelper.setTicket(this, action, guid, deriveGraphicsType());
}
#end_block

#method_before
@Before
public void setUp() {
    Map<String, String> headers = new HashMap<>();
    headers.put("my", "value");
    setXmlResponse("clusters", 200, "<clusters/>");
    setXmlResponse("clusters/123", 200, "<cluster id=\"123\"><name>test</name></cluster>");
    startServer();
    connection = (HttpConnection) testConnectionBuilder().headers(headers).build();
    clustersService = connection.systemService().clustersService();
    clusterService = clustersService.clusterService("123");
}
#method_after
@Before
public void setUp() {
    setXmlResponse("clusters", 200, "<clusters/>");
    setXmlResponse("clusters/123", 200, "<cluster id=\"123\"><name>test</name></cluster>");
    startServer();
    connection = (HttpConnection) testConnectionBuilder().header("my", "value").build();
    clustersService = connection.systemService().clustersService();
    clusterService = clustersService.clusterService("123");
}
#end_block

#method_before
@PostConstruct
private void init() {
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    hypervEnabled = osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
}
#method_after
@PostConstruct
private void init() {
    osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    hypervEnabled = osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion());
    cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer = new XmlTextWriter();
    qosCache = new HashMap<>();
}
#end_block

#method_before
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    writer.writeStartElement("devices");
    writeInput(writer, vm);
    writeGuestAgentChannels(writer, vm);
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator(writer, vm);
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    boolean spiceExists = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                writeBalloon(writer, device, vm);
                break;
            case SMARTCARD:
                writeSmartcard(writer, device, vm);
                break;
            case WATCHDOG:
                writeWatchdog(writer, device, vm);
                break;
            case MEMORY:
                writeMemory(writer, device, vm);
                break;
            case VIDEO:
                writeVideo(writer, device, vm);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        device.getSpecParams().put("type", "virtio-serial");
                        writeController(writer, device, vm);
                        break;
                    case "virtio-scsi":
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("type", VdsProperties.Scsi);
                        device.getSpecParams().put("model", "virtio-scsi");
                        writeController(writer, device, vm);
                        break;
                }
                break;
            case GRAPHICS:
                writeGraphics(writer, device, vm);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(writer, device, vm);
                break;
            case RNG:
                writeRng(writer, device, vm);
                break;
            case CONSOLE:
                writeConsole(writer, device, vm);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device, vm);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(writer, device);
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    writeSerialConsole(writer, serialConsolePath);
    writeLease(writer, vm);
    if (spiceExists) {
        writeSpiceVmcChannel(writer);
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(writer, interfaceDevices, vm);
    writeDisks(writer, diskDevices, vm);
    writeCdRom(writer, cdromDevices, vm);
    // TODO floppy
    writer.writeEndElement();
}
#method_after
private void writeDevices() {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vm.getId());
    // replacement of some devices in run-once mode should eventually be done by the run-command
    devices = overrideDevicesForRunOnce(devices);
    writer.writeStartElement("devices");
    writeInput();
    writeGuestAgentChannels();
    if (vm.getClusterArch() == ArchitectureType.ppc64 || vm.getClusterArch() == ArchitectureType.ppc64le) {
        writeEmulator();
    }
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    List<VmDevice> interfaceDevices = new ArrayList<>();
    List<VmDevice> diskDevices = new ArrayList<>();
    List<VmDevice> cdromDevices = new ArrayList<>();
    VmDevice floppyDevice = null;
    boolean spiceExists = false;
    for (VmDevice device : devices) {
        if (!device.isPlugged()) {
            continue;
        }
        switch(device.getType()) {
            case BALLOON:
                writeBalloon(device);
                break;
            case SMARTCARD:
                writeSmartcard(device);
                break;
            case WATCHDOG:
                writeWatchdog(device);
                break;
            case MEMORY:
                writeMemory(device);
                break;
            case VIDEO:
                writeVideo(device);
                break;
            case CONTROLLER:
                switch(device.getDevice()) {
                    case "virtio-serial":
                        device.getSpecParams().put("index", 0);
                        device.getSpecParams().put("ports", 16);
                        device.getSpecParams().put("type", "virtio-serial");
                        writeController(device);
                        break;
                    case "virtio-scsi":
                        device.getSpecParams().put("index", virtioScsiIndex++);
                        device.getSpecParams().put("type", VdsProperties.Scsi);
                        device.getSpecParams().put("model", "virtio-scsi");
                        writeController(device);
                        break;
                }
                break;
            case GRAPHICS:
                writeGraphics(device);
                spiceExists = spiceExists || device.getDevice().equals("spice");
                break;
            case SOUND:
                writeSound(device);
                break;
            case RNG:
                writeRng(device);
                break;
            case CONSOLE:
                writeConsole(device);
                if (device.getSpecParams() != null && "serial".equals(device.getSpecParams().get("consoleType"))) {
                    serialConsolePath = getSerialConsolePath(device);
                }
                break;
            case DISK:
                switch(VmDeviceType.getByName(device.getDevice())) {
                    case CDROM:
                        cdromDevices.add(device);
                        break;
                    case DISK:
                        diskDevices.add(device);
                        break;
                    case FLOPPY:
                        if (floppyDevice == null || !VmPayload.isPayload(floppyDevice.getSpecParams())) {
                            floppyDevice = device;
                        }
                        break;
                    default:
                }
                break;
            case INTERFACE:
                interfaceDevices.add(device);
                break;
            case REDIR:
                writeRedir(device);
                break;
            case CHANNEL:
                break;
            case HOSTDEV:
                break;
            case UNKNOWN:
                break;
            default:
                break;
        }
    }
    writeSerialConsole(serialConsolePath);
    writeLease();
    if (spiceExists) {
        writeSpiceVmcChannel();
    }
    updateBootOrder(diskDevices, cdromDevices, interfaceDevices);
    writeInterfaces(interfaceDevices);
    writeCdRom(cdromDevices);
    writeFloppy(floppyDevice);
    // we must write the disk after writing cd-rom and floppy to know reserved indices
    writeDisks(diskDevices);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeLease(XmlTextWriter writer, VM vm) {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    writer.writeAttributeString("offset", String.format("LEASE-OFFSET:%s:%s", vm.getId(), vm.getLeaseStorageDomainId()));
    writer.writeAttributeString("path", String.format("LEASE-PATH:%s:%s", vm.getId(), vm.getLeaseStorageDomainId()));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeLease() {
    if (vm.getLeaseStorageDomainId() == null) {
        return;
    }
    writer.writeStartElement("lease");
    writer.writeElement("key", vm.getId().toString());
    writer.writeElement("lockspace", vm.getLeaseStorageDomainId().toString());
    writer.writeStartElement("target");
    writer.writeAttributeString("offset", String.format("LEASE-OFFSET:%s:%s", vm.getId(), vm.getLeaseStorageDomainId()));
    writer.writeAttributeString("path", String.format("LEASE-PATH:%s:%s", vm.getId(), vm.getLeaseStorageDomainId()));
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeInterfaces(XmlTextWriter writer, List<VmDevice> devices, VM vm) {
    Map<VmDeviceId, VmNetworkInterface> devIdToNic = vm.getInterfaces().stream().collect(Collectors.toMap(nic -> new VmDeviceId(nic.getId(), nic.getVmId()), nic -> nic));
    devices.forEach(dev -> writeInterface(writer, dev, vm, devIdToNic.get(dev.getId())));
}
#method_after
private void writeInterfaces(List<VmDevice> devices) {
    Map<VmDeviceId, VmNetworkInterface> devIdToNic = vm.getInterfaces().stream().collect(Collectors.toMap(nic -> new VmDeviceId(nic.getId(), nic.getVmId()), nic -> nic));
    devices.forEach(dev -> writeInterface(dev, devIdToNic.get(dev.getId())));
}
#end_block

#method_before
private void writeDisks(XmlTextWriter writer, List<VmDevice> devices, VM vm) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vm)) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        if (device.isManaged()) {
            writeManagedDisk(writer, device, vm, disk);
        }
    // TODO: else
    }
}
#method_after
private void writeDisks(List<VmDevice> devices) {
    Map<VmDeviceId, VmDevice> deviceIdToDevice = devices.stream().collect(Collectors.toMap(VmDevice::getId, dev -> dev));
    int ideIndex = -1;
    int scsiIndex = -1;
    int virtioIndex = -1;
    DiskInterface cdDiskInterface = DiskInterface.forValue(cdInterface);
    for (Disk disk : vmInfoBuildUtils.getSortedDisks(vm)) {
        VmDevice device = deviceIdToDevice.get(new VmDeviceId(disk.getId(), vm.getId()));
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        DiskInterface diskInterface = dve.getDiskInterface();
        int index = 0;
        switch(diskInterface) {
            case IDE:
                ideIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (ideIndex == payloadIndex || ideIndex == cdRomIndex) {
                        ideIndex++;
                    }
                }
                index = ideIndex;
                break;
            case VirtIO:
                virtioIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (virtioIndex == payloadIndex || virtioIndex == cdRomIndex) {
                        virtioIndex++;
                    }
                }
                index = virtioIndex;
                break;
            case SPAPR_VSCSI:
            case VirtIO_SCSI:
                scsiIndex++;
                if (cdDiskInterface == diskInterface) {
                    while (scsiIndex == payloadIndex || scsiIndex == cdRomIndex) {
                        scsiIndex++;
                    }
                }
                index = scsiIndex;
                break;
        }
        if (device.isManaged()) {
            writeManagedDisk(device, disk, dve, index);
        }
    // TODO: else
    }
}
#end_block

#method_before
private void writeConsole(XmlTextWriter writer, VmDevice device, VM vm) {
    // <console type='pty'>
    // <target type='serial' port='0'/>
    // </console>
    // or:
    // <console type='pty'>
    // <target type='virtio' port='0'/>
    // </console>
    // or:
    // <console type='unix'>
    // <source mode='bind' path='/path/to/${vmid}.sock'>
    // <target type='virtio' port='0'/>
    // </console>
    writer.writeStartElement("console");
    String path = getSerialConsolePath(device, vm);
    if (!path.isEmpty()) {
        writer.writeAttributeString("type", "unix");
        writer.writeStartElement("source");
        writer.writeAttributeString("path", path);
        writer.writeAttributeString("mode", "bind");
        writer.writeEndElement();
    } else {
        writer.writeAttributeString("type", "pty");
    }
    writer.writeStartElement("target");
    Object consoleTypeFromSpecParams = device.getSpecParams().get("consoleType");
    String consoleType = consoleTypeFromSpecParams != null ? consoleTypeFromSpecParams.toString() : "virtio";
    writer.writeAttributeString("type", consoleType);
    writer.writeAttributeString("port", "0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeConsole(VmDevice device) {
    // <console type='pty'>
    // <target type='serial' port='0'/>
    // </console>
    // or:
    // <console type='pty'>
    // <target type='virtio' port='0'/>
    // </console>
    // or:
    // <console type='unix'>
    // <source mode='bind' path='/path/to/${vmid}.sock'>
    // <target type='virtio' port='0'/>
    // </console>
    writer.writeStartElement("console");
    String path = getSerialConsolePath(device);
    if (!path.isEmpty()) {
        writer.writeAttributeString("type", "unix");
        writer.writeStartElement("source");
        writer.writeAttributeString("path", path);
        writer.writeAttributeString("mode", "bind");
        writer.writeEndElement();
    } else {
        writer.writeAttributeString("type", "pty");
    }
    writer.writeStartElement("target");
    Object consoleTypeFromSpecParams = device.getSpecParams().get("consoleType");
    String consoleType = consoleTypeFromSpecParams != null ? consoleTypeFromSpecParams.toString() : "virtio";
    writer.writeAttributeString("type", consoleType);
    writer.writeAttributeString("port", "0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
public void writeEmulator(XmlTextWriter writer, VM vm) {
    writer.writeStartElement("emulator");
    writer.writeAttributeString("text", String.format("/usr/bin/qemu-system-%s", vm.getClusterArch()));
    writer.writeEndElement();
}
#method_after
public void writeEmulator() {
    writer.writeStartElement("emulator");
    writer.writeAttributeString("text", String.format("/usr/bin/qemu-system-%s", vm.getClusterArch()));
    writer.writeEndElement();
}
#end_block

#method_before
private void writeSpiceVmcChannel(XmlTextWriter writer) {
    writer.writeStartElement("channel");
    writer.writeAttributeString("type", "spicevmc");
    writer.writeStartElement("target");
    writer.writeAttributeString("type", "virtio");
    writer.writeAttributeString("name", "com.redhat.spice.0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeSpiceVmcChannel() {
    writer.writeStartElement("channel");
    writer.writeAttributeString("type", "spicevmc");
    writer.writeStartElement("target");
    writer.writeAttributeString("type", "virtio");
    writer.writeAttributeString("name", "com.redhat.spice.0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeGuestAgentChannels(XmlTextWriter writer, VM vm) {
    // <channel type='unix'>
    // <target type='virtio' name='org.linux-kvm.port.0'/>
    // <source mode='bind' path='/tmp/socket'/>
    // </channel>
    writer.writeStartElement("channel");
    writer.writeAttributeString("type", "unix");
    writer.writeStartElement("target");
    writer.writeAttributeString("type", "virtio");
    writer.writeAttributeString("name", "com.redhat.rhevm.vdsm");
    writer.writeEndElement();
    writer.writeStartElement("source");
    writer.writeAttributeString("mode", "bind");
    writer.writeAttributeString("path", String.format("/var/lib/libvirt/qemu/channels/%s.com.redhat.rhevm.vdsm", vm.getId()));
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeStartElement("channel");
    writer.writeStartElement("target");
    writer.writeAttributeString("type", "virtio");
    writer.writeAttributeString("name", "org.qemu.guest_agent.0");
    writer.writeEndElement();
    writer.writeStartElement("source");
    writer.writeAttributeString("mode", "bind");
    writer.writeAttributeString("path", String.format("/var/lib/libvirt/qemu/channels/%s.org.qemu.guest_agent.0", vm.getId()));
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeGuestAgentChannels() {
    // <channel type='unix'>
    // <target type='virtio' name='org.linux-kvm.port.0'/>
    // <source mode='bind' path='/tmp/socket'/>
    // </channel>
    writer.writeStartElement("channel");
    writer.writeAttributeString("type", "unix");
    writer.writeStartElement("target");
    writer.writeAttributeString("type", "virtio");
    writer.writeAttributeString("name", "com.redhat.rhevm.vdsm");
    writer.writeEndElement();
    writer.writeStartElement("source");
    writer.writeAttributeString("mode", "bind");
    writer.writeAttributeString("path", String.format("/var/lib/libvirt/qemu/channels/%s.com.redhat.rhevm.vdsm", vm.getId()));
    writer.writeEndElement();
    writer.writeEndElement();
    writer.writeStartElement("channel");
    writer.writeStartElement("target");
    writer.writeAttributeString("type", "virtio");
    writer.writeAttributeString("name", "org.qemu.guest_agent.0");
    writer.writeEndElement();
    writer.writeStartElement("source");
    writer.writeAttributeString("mode", "bind");
    writer.writeAttributeString("path", String.format("/var/lib/libvirt/qemu/channels/%s.org.qemu.guest_agent.0", vm.getId()));
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeSerialConsole(XmlTextWriter writer, String path) {
    if (serialConsolePath == null) {
        return;
    }
    // <serial type='pty'>
    // <target port='0'>
    // </serial>
    // or:
    // <serial type='unix'>
    // <source mode='bind'
    // path='/var/run/ovirt-vmconsole-console/${VMID}.sock'/>
    // <target port='0'/>
    // </serial>
    writer.writeStartElement("serial");
    if (!path.isEmpty()) {
        writer.writeAttributeString("type", "unix");
        writer.writeStartElement("source");
        writer.writeAttributeString("path", path);
        writer.writeAttributeString("mode", "bind");
        writer.writeEndElement();
    } else {
        writer.writeAttributeString("type", "pty");
    }
    writer.writeStartElement("target");
    writer.writeAttributeString("port", "0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeSerialConsole(String path) {
    if (serialConsolePath == null) {
        return;
    }
    // <serial type='pty'>
    // <target port='0'>
    // </serial>
    // or:
    // <serial type='unix'>
    // <source mode='bind'
    // path='/var/run/ovirt-vmconsole-console/${VMID}.sock'/>
    // <target port='0'/>
    // </serial>
    writer.writeStartElement("serial");
    if (!path.isEmpty()) {
        writer.writeAttributeString("type", "unix");
        writer.writeStartElement("source");
        writer.writeAttributeString("path", path);
        writer.writeAttributeString("mode", "bind");
        writer.writeEndElement();
    } else {
        writer.writeAttributeString("type", "pty");
    }
    writer.writeStartElement("target");
    writer.writeAttributeString("port", "0");
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private String getSerialConsolePath(VmDevice device, VM vm) {
    Object enableSocketFromSpecParams = device.getSpecParams().get("enableSocket");
    return enableSocketFromSpecParams != null && Boolean.parseBoolean(enableSocketFromSpecParams.toString()) ? String.format("/var/run/ovirt-vmconsole-console/%s.sock", vm.getId()) : "";
}
#method_after
private String getSerialConsolePath(VmDevice device) {
    Object enableSocketFromSpecParams = device.getSpecParams().get("enableSocket");
    return enableSocketFromSpecParams != null && Boolean.parseBoolean(enableSocketFromSpecParams.toString()) ? String.format("/var/run/ovirt-vmconsole-console/%s.sock", vm.getId()) : "";
}
#end_block

#method_before
private void writeRedir(XmlTextWriter writer, VmDevice device) {
    // <redirdev bus='usb' type='spicevmc'>
    // <address type='usb' bus='0' port='1'/>
    // </redirdev>
    writer.writeStartElement("redirdev");
    writer.writeAttributeString("type", "spicevmc");
    writer.writeAttributeString("bus", "usb");
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeRedir(VmDevice device) {
    // <redirdev bus='usb' type='spicevmc'>
    // <address type='usb' bus='0' port='1'/>
    // </redirdev>
    writer.writeStartElement("redirdev");
    writer.writeAttributeString("type", "spicevmc");
    writer.writeAttributeString("bus", "usb");
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeRng(XmlTextWriter writer, VmDevice device, VM vm) {
    // <rng model='virtio'>
    // <rate period="2000" bytes="1234"/>
    // <backend model='random'>/dev/random</backend>
    // </rng>
    writer.writeStartElement("rng");
    writer.writeAttributeString("model", "virtio");
    Map<String, Object> specParams = device.getSpecParams();
    if (specParams.containsKey("bytes")) {
        writer.writeStartElement("rate");
        writer.writeAttributeString("bytes", specParams.get("bytes").toString());
        if (specParams.containsKey("period")) {
            writer.writeAttributeString("period", specParams.get("period").toString());
        }
        writer.writeEndElement();
    }
    writer.writeStartElement("backend");
    writer.writeAttributeString("model", "random");
    switch(specParams.get("source").toString()) {
        case "random":
            writer.writeRaw("/dev/random");
            break;
        case "urandom":
            writer.writeRaw("/dev/urandom");
            break;
        case "hwrng":
            writer.writeRaw("/dev/hwrng");
            break;
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeRng(VmDevice device) {
    // <rng model='virtio'>
    // <rate period="2000" bytes="1234"/>
    // <backend model='random'>/dev/random</backend>
    // </rng>
    writer.writeStartElement("rng");
    writer.writeAttributeString("model", "virtio");
    Map<String, Object> specParams = device.getSpecParams();
    if (specParams.containsKey("bytes")) {
        writer.writeStartElement("rate");
        writer.writeAttributeString("bytes", specParams.get("bytes").toString());
        if (specParams.containsKey("period")) {
            writer.writeAttributeString("period", specParams.get("period").toString());
        }
        writer.writeEndElement();
    }
    writer.writeStartElement("backend");
    writer.writeAttributeString("model", "random");
    switch(specParams.get("source").toString()) {
        case "random":
            writer.writeRaw("/dev/random");
            break;
        case "urandom":
            writer.writeRaw("/dev/urandom");
            break;
        case "hwrng":
            writer.writeRaw("/dev/hwrng");
            break;
    }
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeSound(XmlTextWriter writer, VmDevice device, VM vm) {
    writer.writeStartElement("sound");
    writer.writeAttributeString("model", device.getDevice());
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeSound(VmDevice device) {
    writer.writeStartElement("sound");
    writer.writeAttributeString("model", device.getDevice());
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeGraphics(XmlTextWriter writer, VmDevice device, VM vm) {
    GraphicsType graphicsType = GraphicsType.fromString(device.getDevice());
    if (graphicsType == null) {
        log.error("Unsupported graphics type: {}", device.getDevice());
        return;
    }
    // <graphics type='spice' port='5900' tlsPort='5901' autoport='yes'
    // listen='0' keymap='en-us'
    // passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // <clipboard copypaste='no'/>
    // </graphics>
    // or:
    // <graphics type='vnc' port='5900' autoport='yes' listen='0'
    // keymap='en-us' passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // </graphics>
    writer.writeStartElement("graphics");
    writer.writeAttributeString("type", device.getDevice());
    writer.writeAttributeString("port", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
    writer.writeAttributeString("autoport", "yes");
    // TODO: defaultMode
    writer.writeAttributeString("passwd", "*****");
    writer.writeAttributeString("passwdValidTo", "1970-01-01T00:00:01");
    Network displayNetwork = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (displayNetwork == null) {
        writer.writeAttributeString("listen", "0");
    }
    switch(graphicsType) {
        case SPICE:
            writer.writeAttributeString("tlsPort", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
            if (!vm.isSpiceFileTransferEnabled()) {
                writer.writeStartElement("filetransfer");
                writer.writeAttributeString("enable", "no");
                writer.writeEndElement();
            }
            if (!vm.isSpiceCopyPasteEnabled()) {
                writer.writeStartElement("clipboard");
                writer.writeAttributeString("copypaste", "no");
                writer.writeEndElement();
            }
            if ((boolean) Config.getValue(ConfigValues.SSLEnabled)) {
                String channels = Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString());
                for (String channel : channels.split(",")) {
                    writer.writeStartElement("channel");
                    writer.writeAttributeString("name", channel);
                    writer.writeAttributeString("mode", "secure");
                    writer.writeEndElement();
                }
            }
            break;
        case VNC:
            writer.writeAttributeString("keymap", vm.getDynamicData().getVncKeyboardLayout() != null ? vm.getDynamicData().getVncKeyboardLayout() : vm.getDefaultVncKeyboardLayout() != null ? vm.getDefaultVncKeyboardLayout() : Config.getValue(ConfigValues.VncKeyboardLayout));
            break;
    }
    if (displayNetwork != null) {
        writer.writeStartElement("listen");
        String displayIp = (String) device.getSpecParams().get("displayIp");
        if (displayIp == null) {
            writer.writeAttributeString("type", "network");
            writer.writeAttributeString("network", String.format("DISPLAY-NETWORK:%s", displayNetwork.getName()));
        } else {
            writer.writeAttributeString("type", "address");
            writer.writeAttributeString("address", displayIp);
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeGraphics(VmDevice device) {
    GraphicsType graphicsType = GraphicsType.fromString(device.getDevice());
    if (graphicsType == null) {
        log.error("Unsupported graphics type: {}", device.getDevice());
        return;
    }
    // <graphics type='spice' port='5900' tlsPort='5901' autoport='yes'
    // listen='0' keymap='en-us'
    // passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // <clipboard copypaste='no'/>
    // </graphics>
    // or:
    // <graphics type='vnc' port='5900' autoport='yes' listen='0'
    // keymap='en-us' passwdValidTo='1970-01-01T00:00:01'>
    // <listen type='address' address='0'/>
    // </graphics>
    writer.writeStartElement("graphics");
    writer.writeAttributeString("type", device.getDevice());
    writer.writeAttributeString("port", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
    writer.writeAttributeString("autoport", "yes");
    // TODO: defaultMode
    writer.writeAttributeString("passwd", "*****");
    writer.writeAttributeString("passwdValidTo", "1970-01-01T00:00:01");
    Network displayNetwork = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (displayNetwork == null) {
        writer.writeAttributeString("listen", "0");
    }
    switch(graphicsType) {
        case SPICE:
            writer.writeAttributeString("tlsPort", String.valueOf(LIBVIRT_PORT_AUTOSELECT));
            if (!vm.isSpiceFileTransferEnabled()) {
                writer.writeStartElement("filetransfer");
                writer.writeAttributeString("enable", "no");
                writer.writeEndElement();
            }
            if (!vm.isSpiceCopyPasteEnabled()) {
                writer.writeStartElement("clipboard");
                writer.writeAttributeString("copypaste", "no");
                writer.writeEndElement();
            }
            if ((boolean) Config.getValue(ConfigValues.SSLEnabled)) {
                String channels = Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString());
                for (String channel : channels.split(",")) {
                    writer.writeStartElement("channel");
                    writer.writeAttributeString("name", channel);
                    writer.writeAttributeString("mode", "secure");
                    writer.writeEndElement();
                }
            }
            break;
        case VNC:
            writer.writeAttributeString("keymap", vm.getDynamicData().getVncKeyboardLayout() != null ? vm.getDynamicData().getVncKeyboardLayout() : vm.getDefaultVncKeyboardLayout() != null ? vm.getDefaultVncKeyboardLayout() : Config.getValue(ConfigValues.VncKeyboardLayout));
            break;
    }
    if (displayNetwork != null) {
        writer.writeStartElement("listen");
        String displayIp = (String) device.getSpecParams().get("displayIp");
        if (displayIp == null) {
            writer.writeAttributeString("type", "network");
            writer.writeAttributeString("network", String.format("DISPLAY-NETWORK:%s", displayNetwork.getName()));
        } else {
            writer.writeAttributeString("type", "address");
            writer.writeAttributeString("address", displayIp);
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeController(XmlTextWriter writer, VmDevice device, VM vm) {
    writer.writeStartElement("controller");
    writer.writeAttributeString("type", device.getSpecParams().get("type").toString());
    if (device.getSpecParams().containsKey(VdsProperties.Model)) {
        writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.Index)) {
        writer.writeAttributeString("index", device.getSpecParams().get(VdsProperties.Index).toString());
    }
    if (device.getSpecParams().containsKey("ports")) {
        writer.writeAttributeString("ports", device.getSpecParams().get("ports").toString());
    }
    // TODO: master??
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeController(VmDevice device) {
    writer.writeStartElement("controller");
    writer.writeAttributeString("type", device.getSpecParams().get("type").toString());
    if (device.getSpecParams().containsKey(VdsProperties.Model)) {
        writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.Index)) {
        writer.writeAttributeString("index", device.getSpecParams().get(VdsProperties.Index).toString());
    }
    if (device.getSpecParams().containsKey("ports")) {
        writer.writeAttributeString("ports", device.getSpecParams().get("ports").toString());
    }
    // TODO: master??
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeManagedDisk(XmlTextWriter writer, VmDevice device, VM vm, Disk disk) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
    writeGeneralDiskAttributes(writer, device, disk, dve);
    writeDiskTarget(writer, dve);
    writeDiskSource(writer, disk);
    writeDiskDriver(writer, device, disk, dve, vm);
    writeDeviceAliasAndAddress(writer, device);
    writeBootOrder(writer, device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune(writer, (DiskImage) disk);
    }
    writer.writeEndElement();
}
#method_after
private void writeManagedDisk(VmDevice device, Disk disk, DiskVmElement dve, int index) {
    // <disk type='file' device='disk' snapshot='no'>
    // <driver name='qemu' type='qcow2' cache='none'/>
    // <source file='/path/to/image'/>
    // <target dev='hda' bus='ide'/>
    // <serial>54-a672-23e5b495a9ea</serial>
    // </disk>
    writer.writeStartElement("disk");
    writeGeneralDiskAttributes(device, disk, dve);
    writeDiskTarget(dve, index);
    writeDiskSource(disk);
    writeDiskDriver(device, disk, dve);
    writeDeviceAliasAndAddress(device);
    writeBootOrder(device.getBootOrder());
    if (disk.getDiskStorageType() != DiskStorageType.LUN) {
        writer.writeElement("serial", disk.getId().toString());
    }
    if (device.getReadOnly()) {
        writer.writeElement("readonly");
    }
    if (device.getSnapshotId() == null && disk.isShareable()) {
        writer.writeElement("shareable");
    }
    if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        writeIoTune((DiskImage) disk);
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeIoTune(XmlTextWriter writer, DiskImage diskImage) {
    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
    }
    StorageQos storageQos = qosCache.get(diskImage.getDiskProfileId());
    if (storageQos == null) {
        return;
    }
    writer.writeStartElement("iotune");
    ioTuneListFrom(storageQos).forEach(pair -> writer.writeAttributeString(pair.getFirst(), pair.getSecond().toString()));
    writer.writeEndElement();
}
#method_after
private void writeIoTune(DiskImage diskImage) {
    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
    }
    StorageQos storageQos = qosCache.get(diskImage.getDiskProfileId());
    if (storageQos == null) {
        return;
    }
    writer.writeStartElement("iotune");
    ioTuneListFrom(storageQos).forEach(pair -> writer.writeAttributeString(pair.getFirst(), pair.getSecond().toString()));
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskDriver(XmlTextWriter writer, VmDevice device, Disk disk, DiskVmElement dve, VM vm) {
    writer.writeStartElement("driver");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            writer.writeAttributeString("name", "qemu");
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
                writer.writeAttributeString("discard", "unmap");
            }
            if (device.getSpecParams().containsKey("pinToIoThread")) {
                writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
            }
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            writer.writeAttributeString("name", "qemu");
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
                writer.writeAttributeString("discard", "unmap");
            }
            if (device.getSpecParams().containsKey("pinToIoThread")) {
                writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
            }
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // TODO
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            // TODO: if custom property is set...
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskDriver(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeStartElement("driver");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            writer.writeAttributeString("name", "qemu");
            writer.writeAttributeString("io", "threads");
            writer.writeAttributeString("type", diskImage.getVolumeFormat() == VolumeFormat.COW ? "qcow2" : "raw");
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
                writer.writeAttributeString("discard", "unmap");
            }
            if (device.getSpecParams().containsKey("pinToIoThread")) {
                writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
            }
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case LUN:
            writer.writeAttributeString("name", "qemu");
            writer.writeAttributeString("io", "native");
            writer.writeAttributeString("type", "raw");
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion()) && dve.isPassDiscard()) {
                writer.writeAttributeString("discard", "unmap");
            }
            if (device.getSpecParams().containsKey("pinToIoThread")) {
                writer.writeAttributeString("iothread", device.getSpecParams().get("pinToIoThread").toString());
            }
            writer.writeAttributeString("error_policy", disk.getPropagateErrors() == PropagateErrors.On ? "enospace" : "stop");
            break;
        case CINDER:
            // TODO
            break;
    }
    if (device.getSnapshotId() != null) {
        // transient disk
        /**
         *            Force the cache to be writethrough, which is qemu's default.
         *            This is done to ensure that we don't ever use cache=none for
         *            transient disks, since we create them in /var/run/vdsm which
         *            may end up on tmpfs and don't support O_DIRECT, and qemu uses
         *            O_DIRECT when cache=none and hence hotplug might fail with
         *            error that one can take eternity to debug the reason behind it!
         */
        writer.writeAttributeString("cache", "writethrough");
    } else {
        switch(dve.getDiskInterface()) {
            case VirtIO:
            // TODO: if custom property is set...
            default:
                writer.writeAttributeString("cache", "none");
        }
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskSource(XmlTextWriter writer, Disk disk) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("file", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // TODO (auth)
            break;
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskSource(Disk disk) {
    writer.writeStartElement("source");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) disk;
            writer.writeAttributeString("file", String.format("/rhev/data-center/%s/%s/images/%s/%s", diskImage.getStoragePoolId(), diskImage.getStorageIds().get(0), diskImage.getId(), diskImage.getImageId()));
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) disk;
            writer.writeAttributeString("file", String.format("/dev/mapper/%s", lunDisk.getLun().getLUNId()));
            break;
        case CINDER:
            // TODO (auth)
            break;
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeDiskTarget(XmlTextWriter writer, DiskVmElement dve) {
    writer.writeStartElement("target");
    switch(dve.getDiskInterface()) {
        case IDE:
            // TODO: device name
            writer.writeAttributeString("dev", "hda");
            writer.writeAttributeString("bus", "ide");
            break;
        case VirtIO:
            // TODO: device name
            writer.writeAttributeString("dev", "sda");
            writer.writeAttributeString("bus", "virtio");
            // TODO: index
            break;
        case VirtIO_SCSI:
            // TODO: device name
            writer.writeAttributeString("dev", "sda");
            writer.writeAttributeString("bus", "scsi");
            // TODO address
            break;
        case SPAPR_VSCSI:
            // TODO address, name
            break;
        default:
            log.error("Unsupported interface type, ISCSI interface type is not supported.");
    }
    writer.writeEndElement();
}
#method_after
private void writeDiskTarget(DiskVmElement dve, int index) {
    writer.writeStartElement("target");
    switch(dve.getDiskInterface()) {
        case IDE:
            writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName("ide", index));
            writer.writeAttributeString("bus", "ide");
            break;
        case VirtIO:
            writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName("virtio", index));
            writer.writeAttributeString("bus", "virtio");
            // TODO: index
            break;
        case VirtIO_SCSI:
            writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName("scsi", index));
            writer.writeAttributeString("bus", "scsi");
            // TODO address
            break;
        case SPAPR_VSCSI:
            // TODO address, name
            break;
        default:
            log.error("Unsupported interface type, ISCSI interface type is not supported.");
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeGeneralDiskAttributes(XmlTextWriter writer, VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeAttributeString("snapshot", "no");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            // TODO type of storage domain
            writer.writeAttributeString("type", "file");
            break;
        case LUN:
            writer.writeAttributeString("type", "block");
            break;
        case CINDER:
            // TODO
            break;
    }
    switch(dve.getDiskInterface()) {
        case VirtIO:
        case IDE:
            writer.writeAttributeString("device", device.getDevice());
            break;
        case VirtIO_SCSI:
            if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                writer.writeAttributeString("device", VmDeviceType.LUN.getName());
                writer.writeAttributeString("sgio", disk.getSgio().toString().toLowerCase());
            } else {
                writer.writeAttributeString("device", device.getDevice());
            }
            // TODO
            break;
        case SPAPR_VSCSI:
            break;
    }
}
#method_after
private void writeGeneralDiskAttributes(VmDevice device, Disk disk, DiskVmElement dve) {
    writer.writeAttributeString("snapshot", "no");
    switch(disk.getDiskStorageType()) {
        case IMAGE:
            // TODO type of storage domain
            writer.writeAttributeString("type", "file");
            break;
        case LUN:
            writer.writeAttributeString("type", "block");
            break;
        case CINDER:
            // TODO
            break;
    }
    switch(dve.getDiskInterface()) {
        case VirtIO:
        case IDE:
            writer.writeAttributeString("device", device.getDevice());
            break;
        case VirtIO_SCSI:
            if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                writer.writeAttributeString("device", VmDeviceType.LUN.getName());
                writer.writeAttributeString("sgio", disk.getSgio().toString().toLowerCase());
            } else {
                writer.writeAttributeString("device", device.getDevice());
            }
            // TODO
            break;
        case SPAPR_VSCSI:
            break;
    }
}
#end_block

#method_before
private void writeCdRom(XmlTextWriter writer, List<VmDevice> devices, VM vm) {
    if (devices.isEmpty()) {
        return;
    }
    // <disk type='file' device='cdrom'>
    // <driver name='qemu' type='raw'/>
    // <source startupPolicy='optional'/>
    // <backingStore/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <alias name='ide0-1-0'/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    // assume only 1 CD
    VmDevice device = devices.get(0);
    writer.writeStartElement("disk");
    writer.writeAttributeString("type", "file");
    writer.writeAttributeString("device", "cdrom");
    writer.writeAttributeString("snapshot", "no");
    writer.writeStartElement("source");
    // TODO: path
    writer.writeAttributeString("file", "");
    writer.writeAttributeString("startupPolicy", "optional");
    writer.writeEndElement();
    String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
    writer.writeStartElement("target");
    // TODO
    writer.writeAttributeString("dev", "hdc");
    writer.writeAttributeString("bus", cdInterface);
    writer.writeEndElement();
    writer.writeElement("readonly");
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeCdRom(List<VmDevice> devices) {
    // <disk type='file' device='cdrom'>
    // <driver name='qemu' type='raw'/>
    // <source startupPolicy='optional'/>
    // <backingStore/>
    // <target dev='hdc' bus='ide'/>
    // <readonly/>
    // <alias name='ide0-1-0'/>
    // <address type='drive' controller='0' bus='1' target='0' unit='0'/>
    // </disk>
    devices.stream().filter(d -> VmPayload.isPayload(d.getSpecParams())).forEach(device -> {
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("source");
        writer.writeAttributeString("file", "PAYLOAD:");
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if ("scsi".equals(cdInterface)) {
            int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
            writeAddress(vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
        writer.writeEndElement();
    });
    VmDevice nonPayload = devices.stream().filter(d -> !VmPayload.isPayload(d.getSpecParams())).findAny().orElse(null);
    if (nonPayload != null || (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath()))) {
        // add a device that points to vm.getCdPath()
        writer.writeStartElement("disk");
        writer.writeAttributeString("type", "file");
        writer.writeAttributeString("device", "cdrom");
        writer.writeAttributeString("snapshot", "no");
        writer.writeStartElement("source");
        writer.writeAttributeString("file", vm.getCdPath());
        writer.writeAttributeString("startupPolicy", "optional");
        writer.writeEndElement();
        cdRomIndex = VmDeviceCommonUtils.getCdDeviceIndex(cdInterface);
        writer.writeStartElement("target");
        writer.writeAttributeString("dev", vmInfoBuildUtils.makeDiskName(cdInterface, cdRomIndex));
        writer.writeAttributeString("bus", cdInterface);
        writer.writeEndElement();
        writer.writeElement("readonly");
        if (nonPayload != null) {
            writeDeviceAliasAndAddress(nonPayload);
            writeBootOrder(nonPayload.getBootOrder());
        }
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInterface(XmlTextWriter writer, VmDevice device, VM vm, VmNetworkInterface nic) {
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    // TODO: driver
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // TODO: OVS
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", nic.getNetworkName());
            writer.writeEndElement();
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
            Network network = networkDao.get(vnicProfile.getNetworkId());
            if (NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            // writer.writeEndElement();
            break;
    }
    writeDeviceAliasAndAddress(writer, device);
    writeBootOrder(writer, device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (device.getSpecParams().containsKey("inbound") || device.getSpecParams().containsKey("outbound")) {
        writer.writeStartElement("bandwidth");
        Map<String, Object> map = new HashMap<>();
        vmInfoBuildUtils.addProfileDataToNic(map, vm, device, nic);
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) map.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", inboundMap.get("average"));
            writer.writeAttributeString("burst", inboundMap.get("burst"));
            writer.writeAttributeString("peak", inboundMap.get("peak"));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) map.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", outboundMap.get("average"));
            writer.writeAttributeString("burst", outboundMap.get("burst"));
            writer.writeAttributeString("peak", outboundMap.get("peak"));
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#method_after
private void writeInterface(VmDevice device, VmNetworkInterface nic) {
    writer.writeStartElement("interface");
    Map<String, String> properties = VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData());
    // TODO: driver
    switch(device.getDevice()) {
        case "bridge":
            writer.writeAttributeString("type", "bridge");
            writer.writeStartElement("model");
            VmInterfaceType ifaceType = nic.getType() != null ? VmInterfaceType.forValue(nic.getType()) : VmInterfaceType.rtl8139;
            writer.writeAttributeString("type", ifaceType == VmInterfaceType.pv ? "virtio" : ifaceType.getInternalName());
            writer.writeEndElement();
            writer.writeStartElement("link");
            writer.writeAttributeString("state", nic.isLinked() ? "up" : "down");
            writer.writeEndElement();
            // TODO: OVS
            writer.writeStartElement("source");
            writer.writeAttributeString("bridge", nic.getNetworkName());
            writer.writeEndElement();
            break;
        case "hostdev":
            writer.writeAttributeString("type", "hostdev");
            writer.writeAttributeString("managed", "no");
            writer.writeStartElement("driver");
            writer.writeAttributeString("name", "vfio");
            writer.writeEndElement();
            VnicProfile vnicProfile = vnicProfileDao.get(nic.getVnicProfileId());
            Network network = networkDao.get(vnicProfile.getNetworkId());
            if (NetworkUtils.isVlan(network)) {
                writer.writeStartElement("vlan");
                writer.writeStartElement("tag");
                writer.writeAttributeString("id", network.getVlanId().toString());
                writer.writeEndElement();
                writer.writeEndElement();
            }
            // writer.writeEndElement();
            break;
    }
    writeDeviceAliasAndAddress(device);
    writeBootOrder(device.getBootOrder());
    writer.writeStartElement("mac");
    writer.writeAttributeString("address", nic.getMacAddress());
    writer.writeEndElement();
    NetworkFilter networkFilter = vmInfoBuildUtils.fetchVnicProfileNetworkFilter(nic);
    if (networkFilter != null) {
        writer.writeStartElement("filterref");
        writer.writeAttributeString("filter", networkFilter.getName());
        writer.writeEndElement();
    }
    if (properties.containsKey("sndbuf")) {
        writer.writeStartElement("tune");
        writer.writeStartElement("sndbuf");
        writer.writeRaw(properties.get("sndbuf"));
        writer.writeEndElement();
        writer.writeEndElement();
    }
    if (device.getSpecParams().containsKey("inbound") || device.getSpecParams().containsKey("outbound")) {
        writer.writeStartElement("bandwidth");
        Map<String, Object> map = new HashMap<>();
        vmInfoBuildUtils.addProfileDataToNic(map, vm, device, nic);
        @SuppressWarnings("unchecked")
        Map<String, String> inboundMap = (Map<String, String>) map.get("inbound");
        if (inboundMap != null && !inboundMap.isEmpty()) {
            writer.writeStartElement("inbound");
            writer.writeAttributeString("average", inboundMap.get("average"));
            writer.writeAttributeString("burst", inboundMap.get("burst"));
            writer.writeAttributeString("peak", inboundMap.get("peak"));
            writer.writeEndElement();
        }
        @SuppressWarnings("unchecked")
        Map<String, String> outboundMap = (Map<String, String>) map.get("outbound");
        if (outboundMap != null && !outboundMap.isEmpty()) {
            writer.writeStartElement("outbound");
            writer.writeAttributeString("average", outboundMap.get("average"));
            writer.writeAttributeString("burst", outboundMap.get("burst"));
            writer.writeAttributeString("peak", outboundMap.get("peak"));
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    writer.writeEndElement();
}
#end_block

#method_before
private void writeBalloon(XmlTextWriter writer, VmDevice device, VM vm) {
    // <memballoon model='virtio'>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    // </memballoon>
    writer.writeStartElement("membaloon");
    writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeBalloon(VmDevice device) {
    // <memballoon model='virtio'>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
    // </memballoon>
    writer.writeStartElement("membaloon");
    writer.writeAttributeString("model", device.getSpecParams().get(VdsProperties.Model).toString());
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeSmartcard(XmlTextWriter writer, VmDevice device, VM vm) {
    // <smartcard mode='passthrough' type='spicevmc'>
    // <address/>
    // </smartcard>
    writer.writeStartElement("smartcard");
    // TODO
    // String mode = device.getSpecParams().get(VdsProperties.Model).toString();
    // writer.writeAttributeString("model", );
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeSmartcard(VmDevice device) {
    // <smartcard mode='passthrough' type='spicevmc'>
    // <address/>
    // </smartcard>
    writer.writeStartElement("smartcard");
    // TODO
    // String mode = device.getSpecParams().get(VdsProperties.Model).toString();
    // writer.writeAttributeString("model", );
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeWatchdog(XmlTextWriter writer, VmDevice device, VM vm) {
    // <watchdog model='i6300esb' action='reset'>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
    // </watchdog>
    writer.writeStartElement("watchdog");
    Object model = device.getSpecParams().get(VdsProperties.Model);
    writer.writeAttributeString("model", model != null ? model.toString() : "i6300esb");
    Object action = device.getSpecParams().get(VdsProperties.action);
    writer.writeAttributeString("action", action != null ? action.toString() : "none");
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeWatchdog(VmDevice device) {
    // <watchdog model='i6300esb' action='reset'>
    // <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
    // </watchdog>
    writer.writeStartElement("watchdog");
    Object model = device.getSpecParams().get(VdsProperties.Model);
    writer.writeAttributeString("model", model != null ? model.toString() : "i6300esb");
    Object action = device.getSpecParams().get(VdsProperties.action);
    writer.writeAttributeString("action", action != null ? action.toString() : "none");
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeMemory(XmlTextWriter writer, VmDevice device, VM vm) {
    // <memory model='dimm'>
    // <target>
    // <size unit='KiB'>524287</size>
    // <node>1</node>
    // </target>
    // </memory>
    writer.writeStartElement("memory");
    writer.writeAttributeString("model", "dimm");
    writer.writeStartElement("target");
    writer.writeStartElement("size");
    writer.writeAttributeString("unit", "KiB");
    writer.writeRaw(String.valueOf(vm.getMemSizeMb() * 1000));
    writer.writeEndElement();
    // TODO
    writer.writeElement("node", "1");
    writer.writeEndElement();
    writer.writeEndElement();
}
#method_after
private void writeMemory(VmDevice device) {
    // <memory model='dimm'>
    // <target>
    // <size unit='KiB'>524287</size>
    // <node>1</node>
    // </target>
    // </memory>
    writer.writeStartElement("memory");
    writer.writeAttributeString("model", "dimm");
    writer.writeStartElement("target");
    writer.writeStartElement("size");
    writer.writeAttributeString("unit", "KiB");
    writer.writeRaw(String.valueOf(vm.getMemSizeMb() * 1000));
    writer.writeEndElement();
    // TODO
    writer.writeElement("node", "1");
    writer.writeEndElement();
    writer.writeEndElement();
}
#end_block

#method_before
private void writeVideo(XmlTextWriter writer, VmDevice device, VM vm) {
    writer.writeStartElement("video");
    writer.writeStartElement("model");
    writer.writeAttributeString("type", device.getDevice());
    Object vram = device.getSpecParams().get(VdsProperties.VIDEO_VRAM);
    writer.writeAttributeString("vram", vram != null ? vram.toString() : "32768");
    Object heads = device.getSpecParams().get(VdsProperties.VIDEO_HEADS);
    writer.writeAttributeString("heads", heads != null ? heads.toString() : "1");
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_RAM)) {
        writer.writeAttributeString("ram", device.getSpecParams().get(VdsProperties.VIDEO_RAM).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_VGAMEM)) {
        writer.writeAttributeString("vgamem", device.getSpecParams().get(VdsProperties.VIDEO_VGAMEM).toString());
    }
    writer.writeEndElement();
    writeDeviceAliasAndAddress(writer, device);
    writer.writeEndElement();
}
#method_after
private void writeVideo(VmDevice device) {
    writer.writeStartElement("video");
    writer.writeStartElement("model");
    writer.writeAttributeString("type", device.getDevice());
    Object vram = device.getSpecParams().get(VdsProperties.VIDEO_VRAM);
    writer.writeAttributeString("vram", vram != null ? vram.toString() : "32768");
    Object heads = device.getSpecParams().get(VdsProperties.VIDEO_HEADS);
    writer.writeAttributeString("heads", heads != null ? heads.toString() : "1");
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_RAM)) {
        writer.writeAttributeString("ram", device.getSpecParams().get(VdsProperties.VIDEO_RAM).toString());
    }
    if (device.getSpecParams().containsKey(VdsProperties.VIDEO_VGAMEM)) {
        writer.writeAttributeString("vgamem", device.getSpecParams().get(VdsProperties.VIDEO_VGAMEM).toString());
    }
    writer.writeEndElement();
    writeDeviceAliasAndAddress(device);
    writer.writeEndElement();
}
#end_block

#method_before
private void writeBootOrder(XmlTextWriter writer, int order) {
    if (order > 0) {
        writer.writeStartElement("boot");
        writer.writeAttributeString("order", String.valueOf(order));
        writer.writeEndElement();
    }
}
#method_after
private void writeBootOrder(int order) {
    if (order > 0) {
        writer.writeStartElement("boot");
        writer.writeAttributeString("order", String.valueOf(order));
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeDeviceAliasAndAddress(XmlTextWriter writer, VmDevice device) {
    Map<String, String> addressMap = StringMapUtils.string2Map(device.getAddress());
    if (!addressMap.isEmpty()) {
        writer.writeStartElement("address");
        addressMap.entrySet().forEach(x -> writer.writeAttributeString(x.getKey(), x.getValue()));
        writer.writeEndElement();
    }
    String alias = device.getAlias();
    if (StringUtils.isNotEmpty(alias)) {
        writer.writeStartElement("alias");
        writer.writeAttributeString("name", alias);
        writer.writeEndElement();
    }
}
#method_after
private void writeDeviceAliasAndAddress(VmDevice device) {
    writeAddress(StringMapUtils.string2Map(device.getAddress()));
    String alias = device.getAlias();
    if (StringUtils.isNotEmpty(alias)) {
        writer.writeStartElement("alias");
        writer.writeAttributeString("name", alias);
        writer.writeEndElement();
    }
}
#end_block

#method_before
private void writeInput(XmlTextWriter writer, VM vm) {
    writer.writeStartElement("input");
    boolean tabletEnable = vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC);
    if (tabletEnable) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "ps2");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "usb");
    }
    writer.writeEndElement();
}
#method_after
private void writeInput() {
    writer.writeStartElement("input");
    boolean tabletEnable = vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC);
    if (tabletEnable) {
        writer.writeAttributeString("type", "tablet");
        writer.writeAttributeString("bus", "usb");
    } else if (vm.getClusterArch().getFamily() == ArchitectureType.x86) {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "ps2");
    } else {
        writer.writeAttributeString("type", "mouse");
        writer.writeAttributeString("bus", "usb");
    }
    writer.writeEndElement();
}
#end_block

#method_before
@Override
public void buildVmGraphicsDevices() {
    boolean graphicsOverridden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    boolean isHeadlessMode = vm.getDefaultDisplayType() == DisplayType.none;
    if (isHeadlessMode) {
        return;
    }
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = null;
    if (infos != null) {
        specParamsFromVm = new HashMap<>();
        addVmGraphicsOptions(infos, specParamsFromVm);
    }
    if (graphicsOverridden) {
        buildVmGraphicsDevicesOverridden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#method_after
@Override
public void buildVmGraphicsDevices() {
    boolean graphicsOverridden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    boolean isHeadlessMode = vm.getDefaultDisplayType() == DisplayType.none;
    if (isHeadlessMode) {
        return;
    }
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = null;
    if (infos != null) {
        specParamsFromVm = new HashMap<>();
        vmInfoBuildUtils.addVmGraphicsOptions(infos, specParamsFromVm, vm);
    }
    if (graphicsOverridden) {
        buildVmGraphicsDevicesOverridden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#end_block

#method_before
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        }
    }
}
#method_after
public void refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
            // save all data to db
            saveDataToDb();
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.debug("Exception", ex);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (vds.getStatus() == VDSStatus.NonOperational && firstStatus != VDSStatus.NonOperational) {
            if (!vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(vds.getId(), vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", vds.getName(), vds.getId(), (vds.getNonOperationalReason() != null) ? vds.getNonOperationalReason().name() : "unknown");
            }
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.error("Exception", ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (vdsMaintenanceTimeoutOccurred) {
            handleVdsMaintenanceTimeout();
        }
        if (vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(vds);
            } catch (RuntimeException ex) {
                log.error("Host encounter a problem moving to maintenance mode, probably error during " + "disconnecting it from pool. The Host will stay in Maintenance: {}", ex.getMessage());
                log.debug("Exception", ex);
            }
        } else if (vds.getStatus() == VDSStatus.NonOperational && firstStatus != VDSStatus.NonOperational) {
            if (!vdsManager.isSetNonOperationalExecuted()) {
                getVdsEventListener().vdsNonOperational(vds.getId(), vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.info("Host '{}'({}) is already in NonOperational status for reason '{}'. SetNonOperationalVds command is skipped.", vds.getName(), vds.getId(), (vds.getNonOperationalReason() != null) ? vds.getNonOperationalReason().name() : "unknown");
            }
        }
    } catch (RuntimeException ex) {
        logFailureMessage("Could not finish afterRefreshTreatment", ex);
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getClusterId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtime info for host '{}': {}", vds.getName(), e.getMessage());
        log.error("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", vds.getName(), e.getMessage());
                log.error("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (vds.getStatus() != VDSStatus.Up) {
        return;
    }
    Map<String, Set<String>> problematicNicsWithNetworks = new HashMap<>();
    try {
        reportNicStatusChanges();
        problematicNicsWithNetworks = NetworkMonitoringHelper.determineProblematicNics(vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(vds.getClusterId()));
    } catch (Exception e) {
        log.error("Failure on checkInterfaces on update runtime info for host '{}': {}", vds.getName(), e.getMessage());
        log.debug("Exception", e);
    } finally {
        if (!problematicNicsWithNetworks.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(vds.getId())) {
                hostDownTimes.put(vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(vds.getId());
            try {
                String problematicNicsWithNetworksString = constructNicsWithNetworksString(problematicNicsWithNetworks);
                vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                vdsManager.setStatus(VDSStatus.NonOperational, vds);
                log.info("Host '{}' moved to Non-Operational state because interface/s which are down are needed by required network/s in the current cluster: '{}'", vds.getName(), problematicNicsWithNetworksString);
                AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
                logable.addCustomValue("NicsWithNetworks", problematicNicsWithNetworksString);
                logable.setCustomId(problematicNicsWithNetworksString);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error("checkInterface: Failure on moving host: '{}' to non-operational: {}", vds.getName(), e.getMessage());
                log.debug("Exception", e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(vds.getId());
        }
    }
}
#end_block

#method_before
public void execute() throws Exception {
    _customizationDialog.addAll(CUSTOMIZATION_DIALOG_PROLOG);
    for (VdsDeployUnit unit : _units) {
        unit.init();
    }
    _customizationDialog.addAll(CUSTOMIZATION_DIALOG_EPILOG);
    _terminationDialog.addAll(TERMINATION_DIALOG_EPILOG);
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        userVisibleLog(Level.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String command = Config.<String>getValue(ConfigValues.BootstrapCommand).replace(BOOTSTRAP_ENTRY_PLACE_HOLDER, _entryPoint).replace(// in future we should set here LANG, LC_ALL
        BOOTSTRAP_CUSTOM_ENVIRONMENT_PLACE_HOLDER, "");
        log.info("Installation of {}. Executing command via SSH {} < {}", _vds.getHostName(), command, s_deployPackage.getFileNoUse());
        try (final InputStream in = new FileInputStream(s_deployPackage.getFile())) {
            _dialog.executeCommand(this, command, new InputStream[] { in });
        }
        if (_failException != null) {
            throw _failException;
        }
        if (_resultError) {
            // This is unlikeley as the ssh command will exit with failure.
            throw new RuntimeException("Installation failed, please refer to installation logs");
        }
    } catch (TimeLimitExceededException e) {
        log.error("Timeout during host {} install: {}", _vds.getHostName(), e.getMessage());
        log.debug("Timeout during host {} install", _vds.getHostName(), e);
        userVisibleLog(Level.SEVERE, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.error("Error during host {} install: {}", _vds.getHostName(), e.getMessage());
        log.debug("Error during host {} install", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            userVisibleLog(Level.SEVERE, e.getMessage());
            log.error("Error during host {} install, prefering first exception: {}", _vds.getHostName(), _failException.getMessage());
            log.debug("Exception", _failException);
            throw _failException;
        }
    }
}
#method_after
public void execute() throws Exception {
    _customizationDialog.addAll(CUSTOMIZATION_DIALOG_PROLOG);
    for (VdsDeployUnit unit : _units) {
        unit.init();
    }
    _customizationDialog.addAll(CUSTOMIZATION_DIALOG_EPILOG);
    _terminationDialog.addAll(TERMINATION_DIALOG_EPILOG);
    try {
        _dialog.setVds(_vds);
        _dialog.connect();
        userVisibleLog(Level.INFO, String.format("Connected to host %1$s with SSH key fingerprint: %2$s", _vds.getHostName(), _dialog.getHostFingerprint()));
        _dialog.authenticate();
        String command = Config.<String>getValue(ConfigValues.BootstrapCommand).replace(BOOTSTRAP_ENTRY_PLACE_HOLDER, _entryPoint).replace(// in future we should set here LANG, LC_ALL
        BOOTSTRAP_CUSTOM_ENVIRONMENT_PLACE_HOLDER, "");
        log.info("Installation of {}. Executing command via SSH {} < {}", _vds.getHostName(), command, s_deployPackage.getFileNoUse());
        try (final InputStream in = new FileInputStream(s_deployPackage.getFile())) {
            _dialog.executeCommand(this, command, new InputStream[] { in });
        }
        if (_failException != null) {
            throw _failException;
        }
        if (_resultError) {
            // This is unlikeley as the ssh command will exit with failure.
            throw new RuntimeException("Installation failed, please refer to installation logs");
        }
    } catch (TimeLimitExceededException e) {
        log.error("Timeout during host {} install: {}", _vds.getHostName(), e.getMessage());
        log.debug("Exception", e);
        userVisibleLog(Level.SEVERE, "Processing stopped due to timeout");
        throw e;
    } catch (Exception e) {
        log.error("Error during host {} install", _vds.getHostName(), e);
        if (_failException == null) {
            throw e;
        } else {
            userVisibleLog(Level.SEVERE, e.getMessage());
            log.error("Error during host {} install, prefering first exception: {}", _vds.getHostName(), _failException.getMessage());
            log.debug("Exception", _failException);
            throw _failException;
        }
    }
}
#end_block

#method_before
@Override
public Vm update(Vm incoming) {
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, // TODO: change 'null' to 'incoming.getVmCompa...' when REST support is added
            new ChangeVMClusterParameters(clusterId, guid, null));
        }
    }
    if (!isFiltered()) {
        if (incoming.isSetPlacementPolicy()) {
            parent.validateAndUpdateHostsInPlacementPolicy(incoming.getPlacementPolicy());
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    Vm vm = performUpdate(incoming, new QueryIdResolver<>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (isNextRunRequested()) {
        org.ovirt.engine.core.common.businessentities.VM entity = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid), id, true);
        vm = addLinks(populate(VmMapper.map(entity, null, false), entity));
    }
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm, false);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#method_after
@Override
public Vm update(Vm incoming) {
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, // TODO: change 'null' to 'incoming.getVmCompa...' when REST support is added
            new ChangeVMClusterParameters(clusterId, guid, null));
        }
    }
    if (!isFiltered()) {
        if (incoming.isSetPlacementPolicy()) {
            parent.validateAndUpdateHostsInPlacementPolicy(incoming.getPlacementPolicy());
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    VdcQueryType queryType = isNextRunRequested() ? VdcQueryType.GetVmNextRunConfiguration : VdcQueryType.GetVmByVmId;
    Vm vm = performUpdate(incoming, new QueryIdResolver<>(queryType, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm, false);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId(), getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    if (!updateVms()) {
        setSucceeded(false);
        return;
    }
    if (!updateTemplates()) {
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).stream().forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    this.moveMacsOfUpdatedCluster.moveMacsOfUpdatedCluster(oldMacPoolId, newMacPoolId, getClusterId(), getContext());
    getCluster().setArchitecture(getArchitecture());
    setDefaultSwitchTypeIfNeeded();
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getParameters().getCluster().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed validate.
        for (VDS vds : allForCluster) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = getEmulatedMachineOfHostInCluster(vds);
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getCluster().setDetectEmulatedMachine(true);
        } else {
            getParameters().getCluster().setEmulatedMachine(emulatedMachine);
        }
    } else if (oldCluster.getArchitecture() != getCluster().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getCluster().setDetectEmulatedMachine(true);
        getParameters().getCluster().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getCluster().setDetectEmulatedMachine(true);
    }
    boolean isKsmPolicyChanged = (getCluster().isKsmMergeAcrossNumaNodes() != getPrevCluster().isKsmMergeAcrossNumaNodes()) || (getCluster().isEnableKsm() != getPrevCluster().isEnableKsm());
    clusterDao.update(getParameters().getCluster());
    addOrUpdateAddtionalClusterFeatures();
    if (!oldCluster.supportsGlusterService() && getCluster().supportsGlusterService()) {
        // update gluster parameters on all hosts
        updateGlusterHosts();
    }
    if (isAddedToStoragePool) {
        for (VDS vds : allForCluster) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        networkClusterDao.save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    if (isKsmPolicyChanged) {
        momPolicyUpdatedEvent.fire(getCluster());
    }
    // Call UpdateVmCommand on all VMs in the cluster to update defaults (i.e. DisplayType)
    if (!updateVms()) {
        setSucceeded(false);
        return;
    }
    if (!updateTemplates()) {
        setSucceeded(false);
        return;
    }
    if (!Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmStaticDao.getAllByCluster(getCluster().getId()).forEach(this::updateClusterVersionInManager);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateGlusterHosts() {
    allForCluster.stream().forEach(glusterCommandHelper::initGlusterHost);
}
#method_after
private void updateGlusterHosts() {
    allForCluster.forEach(glusterCommandHelper::initGlusterHost);
}
#end_block

#method_before
@Test
public void memoryOptimizationWithoutKsmOrBallooning() {
    final Cluster cluster = createDefaultCluster();
    cluster.setMaxVdsMemoryOverCommit(150);
    cluster.setEnableKsm(false);
    cluster.setEnableBallooning(false);
    createCommand(cluster);
    cpuExists();
    validateFailedWithReason(EngineMessage.CLUSTER_TO_ALLOW_MEMORY_OPTIMIZATION_YOU_MUST_ALLOW_KSM_AND_BALLOONING);
}
#method_after
@Test
public void memoryOptimizationWithoutKsmOrBallooning() {
    final Cluster cluster = createDefaultCluster();
    cluster.setMaxVdsMemoryOverCommit(150);
    cluster.setEnableKsm(false);
    cluster.setEnableBallooning(false);
    createCommand(cluster);
    cpuExists();
    validateFailedWithReason(EngineMessage.CLUSTER_TO_ALLOW_MEMORY_OPTIMIZATION_YOU_MUST_ALLOW_KSM_OR_BALLOONING);
}
#end_block

#method_before
@Test
public void memoryOptimizationLowerThenZeroWithoutKsmOrBallooning() {
    final Cluster cluster = createDefaultCluster();
    cluster.setMaxVdsMemoryOverCommit(-52);
    cluster.setEnableKsm(false);
    cluster.setEnableBallooning(false);
    createCommand(cluster);
    cpuExists();
    validateFailedWithReason(EngineMessage.CLUSTER_TO_ALLOW_MEMORY_OPTIMIZATION_YOU_MUST_ALLOW_KSM_AND_BALLOONING);
}
#method_after
@Test
public void memoryOptimizationLowerThenZeroWithoutKsmOrBallooning() {
    final Cluster cluster = createDefaultCluster();
    cluster.setMaxVdsMemoryOverCommit(-52);
    cluster.setEnableKsm(false);
    cluster.setEnableBallooning(false);
    createCommand(cluster);
    cpuExists();
    validateFailedWithReason(EngineMessage.CLUSTER_TO_ALLOW_MEMORY_OPTIMIZATION_YOU_MUST_ALLOW_KSM_OR_BALLOONING);
}
#end_block

#method_before
public ValidationResult memoryOptimizationConfiguration() {
    // so we need to check that as well
    return ValidationResult.failWith(EngineMessage.CLUSTER_TO_ALLOW_MEMORY_OPTIMIZATION_YOU_MUST_ALLOW_KSM_AND_BALLOONING).when((cluster.getMaxVdsMemoryOverCommit() > 100 || cluster.getMaxVdsMemoryOverCommit() <= 0) && !(cluster.isEnableKsm() || cluster.isEnableBallooning()));
}
#method_after
public ValidationResult memoryOptimizationConfiguration() {
    // so we need to check that as well
    return ValidationResult.failWith(EngineMessage.CLUSTER_TO_ALLOW_MEMORY_OPTIMIZATION_YOU_MUST_ALLOW_KSM_OR_BALLOONING).when((cluster.getMaxVdsMemoryOverCommit() > 100 || cluster.getMaxVdsMemoryOverCommit() <= 0) && !(cluster.isEnableKsm() || cluster.isEnableBallooning()));
}
#end_block

#method_before
public VmDevice createVideoDeviceByDisplayType(DisplayType displayType, Guid vmId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(Guid.newGuid(), vmId));
    vmDevice.setType(VmDeviceGeneralType.VIDEO);
    vmDevice.setDevice(displayType.name());
    vmDevice.setPlugged(true);
    vmDevice.setAddress("");
    return vmDevice;
}
#method_after
public VmDevice createVideoDeviceByDisplayType(DisplayType displayType, Guid vmId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(Guid.newGuid(), vmId));
    vmDevice.setType(VmDeviceGeneralType.VIDEO);
    vmDevice.setDevice(displayType.getDefaultVmDeviceType().getName());
    vmDevice.setPlugged(true);
    vmDevice.setAddress("");
    return vmDevice;
}
#end_block

#method_before
private String diskInterfaceToDevName(String iface) {
    switch(iface) {
        case "scsi":
            return "sd";
        case "virtio":
            return "vd";
        case "fdc":
            return "fd";
        case "sata":
            return "sd";
        case "ide":
        default:
            return "hd";
    }
}
#method_after
private String diskInterfaceToDevName(String iface) {
    switch(iface) {
        case "virtio":
            return "vd";
        case "fdc":
            return "fd";
        case "scsi":
        case "sata":
            return "sd";
        case "ide":
        default:
            return "hd";
    }
}
#end_block

#method_before
private List<StoragePool> searchStoragePool() {
    Optional<Version> retVal = Config.<HashSet<Version>>getValue(ConfigValues.SupportedClusterLevels).stream().max(Comparator.naturalOrder());
    List<StoragePool> dataCenters = genericSearch(storagePoolDao, true);
    if (retVal.isPresent()) {
        dataCenters.forEach(dataCenter -> dataCenter.setStoragePoolCompatibilityLevelUpgradeNeeded(retVal.get().compareTo(dataCenter.getCompatibilityVersion()) > 0));
    }
    return dataCenters;
}
#method_after
private List<StoragePool> searchStoragePool() {
    List<StoragePool> dataCenters = genericSearch(storagePoolDao, true);
    dataCenters.forEach(this::setDcSingleMacPoolId);
    setDcCompatibilityLevelUpgradeNeeded(dataCenters);
    return dataCenters;
}
#end_block

#method_before
public ValidationResult passthroughProfileContainsSupportedProperties() {
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_PASSTHROUGH_PROFILE_CONTAINS_NOT_SUPPORTED_PROPERTIES).when(vnicProfile.isPassthrough() && (vnicProfile.isPortMirroring() || vnicProfile.getNetworkQosId() != null));
}
#method_after
public ValidationResult passthroughProfileContainsSupportedProperties(boolean useDefaultNetworkFilterId) {
    boolean nullValuedNetworkFilterWillBeUsed = vnicProfile.getNetworkFilterId() == null && !useDefaultNetworkFilterId;
    boolean conditionOccurs = vnicProfile.isPassthrough() && (vnicProfile.isPortMirroring() || vnicProfile.getNetworkQosId() != null || !nullValuedNetworkFilterWillBeUsed);
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_PASSTHROUGH_PROFILE_CONTAINS_NOT_SUPPORTED_PROPERTIES).when(conditionOccurs);
}
#end_block

#method_before
@Override
protected boolean validate() {
    VnicProfileValidator validator = createVnicProfileValidator();
    boolean useDefaultNetworkFilterId = getParameters().isUseDefaultNetworkFiterId();
    return validate(validator.vnicProfileIsSet()) && validate(validator.networkExists()) && validate(validator.networkQosExistsOrNull()) && validate(validator.vnicProfileForVmNetworkOnly()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughProfileContainsSupportedProperties()) && validate(validator.validUseDefaultNetworkFilterFlag(useDefaultNetworkFilterId)) && validate(validator.validNetworkFilterId()) && validate(validator.validNetworkFilterForPassthroughProfile(useDefaultNetworkFilterId));
}
#method_after
@Override
protected boolean validate() {
    VnicProfileValidator validator = createVnicProfileValidator();
    boolean useDefaultNetworkFilterId = getParameters().isUseDefaultNetworkFiterId();
    return validate(validator.vnicProfileIsSet()) && validate(validator.networkExists()) && validate(validator.networkQosExistsOrNull()) && validate(validator.vnicProfileForVmNetworkOnly()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughProfileContainsSupportedProperties(useDefaultNetworkFilterId)) && validate(validator.validUseDefaultNetworkFilterFlag(useDefaultNetworkFilterId)) && validate(validator.validNetworkFilterId());
}
#end_block

#method_before
@Override
protected boolean validate() {
    VnicProfileValidator validator = createVnicProfileValidator();
    return validate(validator.vnicProfileIsSet()) && validate(validator.vnicProfileExists()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.networkNotChanged()) && validate(validator.networkQosExistsOrNull()) && validate(validator.portMirroringNotChangedIfUsedByVms()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughNotChangedIfUsedByVms()) && validate(validator.passthroughProfileContainsSupportedProperties()) && validate(validator.validNetworkFilterId()) && validate(validator.validNetworkFilterForPassthroughProfile(false));
}
#method_after
@Override
protected boolean validate() {
    VnicProfileValidator validator = createVnicProfileValidator();
    return validate(validator.vnicProfileIsSet()) && validate(validator.vnicProfileExists()) && validate(validator.vnicProfileNameNotUsed()) && validate(validator.networkNotChanged()) && validate(validator.networkQosExistsOrNull()) && validate(validator.portMirroringNotChangedIfUsedByVms()) && validate(validator.portMirroringNotSetIfExternalNetwork()) && validator.validateCustomProperties(getReturnValue().getValidationMessages()) && validate(validator.passthroughNotChangedIfUsedByVms()) && validate(validator.passthroughProfileContainsSupportedProperties(false)) && validate(validator.validNetworkFilterId());
}
#end_block

#method_before
public static Long tryParse(final String value) {
    try {
        return Long.valueOf(value);
    } catch (NumberFormatException e) {
        // eat it, return null
        return null;
    }
}
#method_after
public static Long tryParse(final String value) {
    try {
        return Long.valueOf(value);
    } catch (NumberFormatException e) {
        return null;
    }
}
#end_block

#method_before
public long getMaximum() {
    return privateMaximum;
}
#method_after
public long getMaximum() {
    return maximum;
}
#end_block

#method_before
public void setMaximum(long value) {
    privateMaximum = value;
}
#method_after
public void setMaximum(long maximum) {
    this.maximum = maximum;
}
#end_block

#method_before
public long getMinimum() {
    return privateMinimum;
}
#method_after
public long getMinimum() {
    return minimum;
}
#end_block

#method_before
public void setMinimum(long value) {
    privateMinimum = value;
}
#method_after
public void setMinimum(long minimum) {
    this.minimum = minimum;
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (value != null && ((value instanceof String && !((String) value).equals("")) || value instanceof Long)) {
        // $NON-NLS-1$
        // Do not use org.apache.commons.lang.math.NumberUtils. When the value is invalidation, return null but not
        // default value
        Long longValue = value instanceof String ? LongCompat.tryParse((String) value) : (Long) value;
        // $NON-NLS-1$
        String msg = "";
        String prefixMsg = ConstantsManager.getInstance().getConstants().thisFieldMustContainNumberInvalidReason();
        if (longValue == null) {
            result.setSuccess(false);
            msg = ConstantsManager.getInstance().getMessages().longValidationNumberBetweenInvalidReason(prefixMsg, getMinimum(), getMaximum());
            result.getReasons().add(msg);
        } else if (longValue < getMinimum() || longValue > getMaximum()) {
            if (getMinimum() != Long.MIN_VALUE && getMaximum() != Long.MAX_VALUE) {
                msg = ConstantsManager.getInstance().getMessages().longValidationNumberBetweenInvalidReason(prefixMsg, getMinimum(), getMaximum());
            } else if (getMinimum() != Long.MIN_VALUE) {
                msg = ConstantsManager.getInstance().getMessages().longValidationNumberGreaterInvalidReason(prefixMsg, getMinimum());
            } else if (getMaximum() != Long.MAX_VALUE) {
                msg = ConstantsManager.getInstance().getMessages().longValidationNumberLessInvalidReason(prefixMsg, getMaximum());
            }
            result.setSuccess(false);
            result.getReasons().add(msg);
        }
    }
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (value != null && ((value instanceof String && !"".equals(value)) || value instanceof Long)) {
        // $NON-NLS-1$
        // Do not use org.apache.commons.lang.math.NumberUtils. Null is expected if conversion fails.
        Long longValue = value instanceof String ? LongCompat.tryParse((String) value) : (Long) value;
        // $NON-NLS-1$
        String msg = "";
        String prefixMsg = ConstantsManager.getInstance().getConstants().thisFieldMustContainNumberInvalidReason();
        if (longValue == null) {
            result.setSuccess(false);
            msg = ConstantsManager.getInstance().getMessages().longValidationNumberBetweenInvalidReason(prefixMsg, getMinimum(), getMaximum());
            result.getReasons().add(msg);
        } else if (longValue < getMinimum() || longValue > getMaximum()) {
            if (getMinimum() != Long.MIN_VALUE && getMaximum() != Long.MAX_VALUE) {
                msg = ConstantsManager.getInstance().getMessages().longValidationNumberBetweenInvalidReason(prefixMsg, getMinimum(), getMaximum());
            } else if (getMinimum() != Long.MIN_VALUE) {
                msg = ConstantsManager.getInstance().getMessages().longValidationNumberGreaterInvalidReason(prefixMsg, getMinimum());
            } else if (getMaximum() != Long.MAX_VALUE) {
                msg = ConstantsManager.getInstance().getMessages().longValidationNumberLessInvalidReason(prefixMsg, getMaximum());
            }
            result.setSuccess(false);
            result.getReasons().add(msg);
        }
    }
    return result;
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    Iterator<Entry<Guid, CallbackTiming>> iterator = commandsRepository.getCallbacksTiming().entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CallbackTiming> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CallbackTiming callbackTiming = entry.getValue();
        CommandEntity commandEntity = commandsRepository.getCommandEntity(cmdId);
        if (commandEntity != null && updateCommandWaitingForEvent(commandEntity, callbackTiming)) {
            continue;
        } else {
            // Decrement counter; execute if it reaches 0
            callbackTiming.setRemainingDelay(callbackTiming.getRemainingDelay() - pollingRate);
            if (callbackTiming.getRemainingDelay() > 0) {
                continue;
            }
        }
        CommandCallback callback = callbackTiming.getCallback();
        CorrelationIdTracker.setCorrelationId(commandEntity.getCommandParameters().getCorrelationId());
        CommandStatus status = commandsRepository.getCommandStatus(cmdId);
        boolean runCallbackAgain = false;
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                case SUCCEEDED:
                    runCallbackAgain = endCallback(cmdId, callback, status);
                    break;
                case ACTIVE:
                    if (commandEntity != null && commandEntity.isExecuted()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                case EXECUTION_FAILED:
                    if (callback.pollOnExecutionFailed()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if ((CommandStatus.FAILED == status || (CommandStatus.SUCCEEDED == status && !errorInCallback)) && !runCallbackAgain) {
                commandsRepository.updateCallbackNotified(cmdId);
                iterator.remove();
                CommandEntity cmdEntity = commandsRepository.getCommandEntity(entry.getKey());
                if (cmdEntity != null) {
                    // When a child finishes, its parent's callback should execute shortly thereafter
                    CallbackTiming rootCmdContainer = commandsRepository.getCallbackTiming(cmdEntity.getRootCommandId());
                    if (rootCmdContainer != null) {
                        rootCmdContainer.setInitialDelay(pollingRate);
                        rootCmdContainer.setRemainingDelay(pollingRate);
                    }
                }
            } else if (status != commandsRepository.getCommandStatus(cmdId)) {
                callbackTiming.setInitialDelay(pollingRate);
                callbackTiming.setRemainingDelay(pollingRate);
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                callbackTiming.setInitialDelay(Math.min(maxDelay, callbackTiming.getInitialDelay() * 2));
                callbackTiming.setRemainingDelay(callbackTiming.getInitialDelay());
            }
        }
    }
    commandsRepository.markExpiredCommandsAsFailure();
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    Iterator<Entry<Guid, CallbackTiming>> iterator = commandsRepository.getCallbacksTiming().entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CallbackTiming> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CallbackTiming callbackTiming = entry.getValue();
        CommandEntity commandEntity = commandsRepository.getCommandEntity(cmdId);
        CorrelationIdTracker.setCorrelationId(commandEntity != null ? commandEntity.getCommandParameters().getCorrelationId() : null);
        if (commandEntity != null && updateCommandWaitingForEvent(commandEntity, callbackTiming)) {
            continue;
        } else {
            // Decrement counter; execute if it reaches 0
            callbackTiming.setRemainingDelay(callbackTiming.getRemainingDelay() - pollingRate);
            if (callbackTiming.getRemainingDelay() > 0) {
                continue;
            }
        }
        CommandCallback callback = callbackTiming.getCallback();
        CommandStatus status = commandsRepository.getCommandStatus(cmdId);
        boolean runCallbackAgain = false;
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                case SUCCEEDED:
                    runCallbackAgain = endCallback(cmdId, callback, status);
                    break;
                case ACTIVE:
                    if (commandEntity != null && commandEntity.isExecuted()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                case EXECUTION_FAILED:
                    if (callback.pollOnExecutionFailed()) {
                        callback.doPolling(cmdId, getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if ((CommandStatus.FAILED == status || (CommandStatus.SUCCEEDED == status && !errorInCallback)) && !runCallbackAgain) {
                commandsRepository.updateCallbackNotified(cmdId);
                iterator.remove();
                CommandEntity cmdEntity = commandsRepository.getCommandEntity(entry.getKey());
                if (cmdEntity != null) {
                    // When a child finishes, its parent's callback should execute shortly thereafter
                    CallbackTiming rootCmdContainer = commandsRepository.getCallbackTiming(cmdEntity.getRootCommandId());
                    if (rootCmdContainer != null) {
                        rootCmdContainer.setInitialDelay(pollingRate);
                        rootCmdContainer.setRemainingDelay(pollingRate);
                    }
                }
            } else if (status != commandsRepository.getCommandStatus(cmdId)) {
                callbackTiming.setInitialDelay(pollingRate);
                callbackTiming.setRemainingDelay(pollingRate);
            } else {
                int maxDelay = Config.<Integer>getValue(ConfigValues.AsyncCommandPollingRateInSeconds);
                callbackTiming.setInitialDelay(Math.min(maxDelay, callbackTiming.getInitialDelay() * 2));
                callbackTiming.setRemainingDelay(callbackTiming.getInitialDelay());
            }
        }
    }
    CorrelationIdTracker.setCorrelationId(null);
    commandsRepository.markExpiredCommandsAsFailure();
}
#end_block

#method_before
@Mapping(from = NicConfiguration.class, to = VmInitNetwork.class)
public static VmInitNetwork map(NicConfiguration model, VmInitNetwork template) {
    VmInitNetwork entity = template != null ? template : new VmInitNetwork();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isOnBoot()) {
        entity.setStartOnBoot(model.isOnBoot());
    }
    if (model.isSetBootProtocol()) {
        entity.setBootProtocol(Ipv4BootProtocolMapper.map(model.getBootProtocol()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setIp(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setNetmask(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetIpv6BootProtocol()) {
        entity.setIpv6BootProtocol(Ipv6BootProtocolMapper.map(model.getBootProtocol()));
    }
    if (model.isSetIpv6()) {
        if (model.getIpv6().isSetAddress()) {
            entity.setIpv6Address(model.getIpv6().getAddress());
        }
        if (model.getIpv6().isSetNetmask()) {
            entity.setIpv6Prefix(getIpv6Prefix(model));
        }
        if (model.getIpv6().isSetGateway()) {
            entity.setIpv6Gateway(model.getIpv6().getGateway());
        }
    }
    return entity;
}
#method_after
@Mapping(from = NicConfiguration.class, to = VmInitNetwork.class)
public static VmInitNetwork map(NicConfiguration model, VmInitNetwork template) {
    VmInitNetwork entity = template != null ? template : new VmInitNetwork();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isOnBoot()) {
        entity.setStartOnBoot(model.isOnBoot());
    }
    if (model.isSetBootProtocol()) {
        entity.setBootProtocol(Ipv4BootProtocolMapper.map(model.getBootProtocol()));
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setIp(model.getIp().getAddress());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setNetmask(model.getIp().getNetmask());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
    }
    if (model.isSetIpv6BootProtocol()) {
        entity.setIpv6BootProtocol(Ipv6BootProtocolMapper.map(model.getBootProtocol()));
    }
    if (model.isSetIpv6()) {
        if (model.getIpv6().isSetAddress()) {
            entity.setIpv6Address(model.getIpv6().getAddress());
        }
        if (model.getIpv6().isSetNetmask()) {
            entity.setIpv6Prefix((int) IntegerParser.parseUnsignedInt(model.getIpv6().getNetmask()));
        }
        if (model.getIpv6().isSetGateway()) {
            entity.setIpv6Gateway(model.getIpv6().getGateway());
        }
    }
    return entity;
}
#end_block

#method_before
private static void populateModelWithIpv6Details(VmInitNetwork entity, NicConfiguration model) {
    if (entity.getIpv6BootProtocol() != null) {
        model.setIpv6BootProtocol(Ipv6BootProtocolMapper.map(entity.getIpv6BootProtocol()));
    }
    model.setIp(createIpModel(new VmInitNetworkIpv6InfoFetcher(entity)));
}
#method_after
private static void populateModelWithIpv6Details(VmInitNetwork entity, NicConfiguration model) {
    if (entity.getIpv6BootProtocol() != null) {
        model.setIpv6BootProtocol(Ipv6BootProtocolMapper.map(entity.getIpv6BootProtocol()));
    }
    model.setIpv6(createIpModel(new VmInitNetworkIpv6InfoFetcher(entity)));
}
#end_block

#method_before
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (isMonitoringNeeded(vdsManager.getStatus())) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(vdsManager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            List<VdsmVm> dbVms = getVmsMonitoring().perform(fetcher.getChangedVms(), fetchTime, vdsManager, true);
            processDevices(dbVms.stream(), fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (isMonitoringNeeded(vdsManager.getStatus())) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(vdsManager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring().perform(fetcher.getChangedVms(), fetchTime, vdsManager, true);
            // we only want to monitor vm devices for vms that already exist in the db
            Stream<VdsmVm> vdsmVmsToMonitor = fetcher.getChangedVms().stream().filter(monitoredVm -> monitoredVm.getFirst() != null).map(Pair::getSecond);
            processDevices(vdsmVmsToMonitor, fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#end_block

#method_before
protected <T extends StoragePoolDomainAndGroupIdBaseVDSCommandParameters & PostDeleteAction> T fixDiscardField(T parameters, StorageDomain storageDomain) {
    if (storageDomain.isDiscardAfterDelete()) {
        if (!Boolean.TRUE.equals(storageDomain.getSupportsDiscard())) {
            parameters.setDiscard(false);
            AuditLogableBase auditLog = Injector.injectMembers(new AuditLogableBase());
            auditLog.setStorageDomainId(storageDomain.getId());
            auditLogDirector.log(auditLog, AuditLogType.ILLEGAL_STORAGE_DOMAIN_DISCARD_AFTER_DELETE);
        }
    } else if (diskVmElementWithPassDiscardExists(parameters.getImageGroupId()) && Boolean.TRUE.equals(storageDomain.getSupportsDiscard())) {
        // At least one vm has this disk with pass discard enabled.
        // Thus, although the relevant storage domain's discard after
        // delete value is false, we send discard == true to vdsm.
        parameters.setDiscard(true);
    }
    return parameters;
}
#method_after
protected <T extends StoragePoolDomainAndGroupIdBaseVDSCommandParameters & PostDeleteAction> T fixDiscardField(T parameters, StorageDomain storageDomain) {
    if (storageDomain.isDiscardAfterDelete()) {
        if (!Boolean.TRUE.equals(storageDomain.getSupportsDiscard())) {
            parameters.setDiscard(false);
            AuditLogableBase auditLog = Injector.injectMembers(new AuditLogableBase());
            auditLog.setStorageDomainId(storageDomain.getId());
            auditLogDirector.log(auditLog, AuditLogType.ILLEGAL_STORAGE_DOMAIN_DISCARD_AFTER_DELETE);
        }
    } else if (diskVmElementWithPassDiscardExists(parameters.getImageGroupId()) && Boolean.TRUE.equals(storageDomain.getSupportsDiscard())) {
        // At least one vm has this disk with pass discard enabled.
        // Thus, although the relevant storage domain's discard after
        // delete value is false, we send discard = true to vdsm.
        parameters.setDiscard(true);
    }
    return parameters;
}
#end_block

#method_before
private Guid getStorageDomainId(Disk disk) {
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        return asGuid(disk.getStorageDomains().getStorageDomains().get(0).getId());
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        String storageName = disk.getStorageDomains().getStorageDomains().get(0).getName();
        Guid storageDomainId = getStorageDomainIdByName(storageName);
        if (storageDomainId == null) {
            throw new WebFaultException(null, localize(Messages.BACKEND_FAILED), localize(Messages.ENTITY_NOT_FOUND_TEMPLATE, storageName), Response.Status.NOT_FOUND);
        } else {
            return storageDomainId;
        }
    }
    return null;
}
#method_after
private Guid getStorageDomainId(Disk disk) {
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        return asGuid(disk.getStorageDomains().getStorageDomains().get(0).getId());
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        String storageName = disk.getStorageDomains().getStorageDomains().get(0).getName();
        Guid storageDomainId = getStorageDomainIdByName(storageName);
        if (storageDomainId == null) {
            notFound(storageName);
        } else {
            return storageDomainId;
        }
    }
    return null;
}
#end_block

#method_before
public static Map<String, Object> createVmMemoryDeviceMap(VmDevice vmDevice) {
    Map<String, Object> data = new HashMap<>();
    Map<String, Object> memDeviceData = new HashMap<>();
    data.put("vmId", vmDevice.getVmId().toString());
    memDeviceData.put(VdsProperties.Type, vmDevice.getType().getValue());
    memDeviceData.put(VdsProperties.Device, vmDevice.getDevice());
    if (StringUtils.isNotBlank(vmDevice.getAddress())) {
        memDeviceData.put(VdsProperties.Address, StringMapUtils.string2Map(vmDevice.getAddress()));
    }
    memDeviceData.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    memDeviceData.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    memDeviceData.put("size", vmDevice.getSpecParams().get("size"));
    memDeviceData.put("node", vmDevice.getSpecParams().get("node"));
    data.put("memory", memDeviceData);
    return data;
}
#method_after
public static Map<String, Object> createVmMemoryDeviceMap(VmDevice vmDevice, boolean copyAlias) {
    Map<String, Object> data = new HashMap<>();
    Map<String, Object> memDeviceData = new HashMap<>();
    data.put("vmId", vmDevice.getVmId().toString());
    memDeviceData.put(VdsProperties.Type, vmDevice.getType().getValue());
    memDeviceData.put(VdsProperties.Device, vmDevice.getDevice());
    if (StringUtils.isNotBlank(vmDevice.getAddress())) {
        memDeviceData.put(VdsProperties.Address, StringMapUtils.string2Map(vmDevice.getAddress()));
    }
    memDeviceData.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    memDeviceData.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (copyAlias) {
        memDeviceData.put(VdsProperties.Alias, vmDevice.getAlias());
    }
    memDeviceData.put("size", vmDevice.getSpecParams().get("size"));
    memDeviceData.put("node", vmDevice.getSpecParams().get("node"));
    data.put("memory", memDeviceData);
    return data;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    try {
        status = getBroker().hotplugMemory(MemoryUtils.createVmMemoryDeviceMap(getParameters().getMemoryDevice()));
        proceedProxyReturnValue();
    } catch (RuntimeException e) {
        setVdsRuntimeErrorAndReport(e);
        // prevent exception handler from rethrowing an exception
        getVDSReturnValue().setExceptionString(null);
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    try {
        status = getBroker().hotplugMemory(MemoryUtils.createVmMemoryDeviceMap(getParameters().getMemoryDevice(), false));
        proceedProxyReturnValue();
    } catch (RuntimeException e) {
        setVdsRuntimeErrorAndReport(e);
        // prevent exception handler from rethrowing an exception
        getVDSReturnValue().setExceptionString(null);
    }
}
#end_block

#method_before
private void saveDevicesToDb(Change change) {
    if (!change.getDevicesToUpdate().isEmpty()) {
        getVmDeviceDao().updateAllInBatch(change.getDevicesToUpdate());
    }
    if (!change.getDeviceIdsToRemove().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.getDeviceIdsToRemove());
            return null;
        });
    }
    if (!change.getDevicesToAdd().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.getDevicesToAdd());
            return null;
        });
    }
    if (!change.getVmsToSaveHash().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.getVmsToSaveHash().stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
        for (Guid vmId : change.getVmsToSaveHash()) {
            getVmStaticDao().incrementDbGeneration(vmId);
        }
    }
}
#method_after
private void saveDevicesToDb(Change change) {
    if (!change.getDevicesToUpdate().isEmpty()) {
        getVmDeviceDao().updateAllInBatch(change.getDevicesToUpdate());
    }
    if (!change.getDeviceIdsToRemove().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.getDeviceIdsToRemove());
            return null;
        });
    }
    if (!change.getDevicesToAdd().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.getDevicesToAdd());
            return null;
        });
    }
    if (!change.getVmsToSaveHash().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.getVmsToSaveHash().stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
        getVmStaticDao().incrementDbGenerationForVms(change.getVmsToSaveHash());
    }
}
#end_block

#method_before
@Override
public Guid getHostJobId() {
    return getStorageJobId();
}
#method_after
@JsonIgnore
@Override
public Guid getHostJobId() {
    return getStorageJobId();
}
#end_block

#method_before
protected CommandBase<?> getCommand(Guid cmdId) {
    return CommandCoordinatorUtil.retrieveCommand(cmdId);
}
#method_after
protected CommandBase<? extends HostJobCommandParameters> getCommand(Guid cmdId) {
    return CommandCoordinatorUtil.retrieveCommand(cmdId);
}
#end_block

#method_before
private HostJobInfo.HostJobStatus pollEntity(CommandBase<?> cmd) {
    try {
        return ((EntityPollingCommand) cmd).poll();
    } catch (Exception e) {
        log.error("Command {} id: '{}': failed to poll the command entity", cmd.getActionType(), cmd.getCommandId());
    }
    return null;
}
#method_after
private HostJobStatus pollEntity(CommandBase<?> cmd) {
    try {
        return ((EntityPollingCommand) cmd).poll();
    } catch (Exception e) {
        log.error("Command {} id: '{}': failed to poll the command entity", cmd.getActionType(), cmd.getCommandId());
    }
    return null;
}
#end_block

#method_before
private HostJobInfo.HostJobStatus handleUndeterminedJobStatus(CommandBase<?> cmd, boolean jobsReportedByHost) {
    // If the command supports entity polling, we can use it in order to determine the status.
    if (isEntityPollingSupported(cmd)) {
        log.info("Command {} id: '{}': attempting to determine the job status by polling the entity.", cmd.getActionType(), cmd.getCommandId());
        return pollEntity(cmd);
    }
    // (as the command doesn't support entity polling - so we don't have any way to poll it).
    if (jobsReportedByHost) {
        log.error("Command {} id: '{}': entity polling isn't supported and the job isn't reported by the host," + "assuming it failed so that the command execution will end.", cmd.getActionType(), cmd.getCommandId());
        return HostJobInfo.HostJobStatus.failed;
    }
    // if the job status couldn't have been determined because of a different reason, we'll retry to poll it.
    log.error("Command {} id: '{}': entity polling isn't supported, will retry to poll the job soon", cmd.getActionType(), cmd.getCommandId());
    return null;
}
#method_after
private HostJobStatus handleUndeterminedJobStatus(CommandBase<? extends HostJobCommandParameters> cmd, boolean jobsReportedByHost) {
    // If the command supports entity polling, we can use it in order to determine the status.
    if (isEntityPollingSupported(cmd)) {
        log.info("Command {} id: '{}': attempting to determine the job status by polling the entity.", cmd.getActionType(), cmd.getCommandId());
        HostJobStatus jobStatus = pollEntity(cmd);
        if (jobStatus != null) {
            return jobStatus;
        }
        // If the job status couldn't been detected using entity polling and the command supports job fencing, we
        // can attempt to fence the job - which means that the host will fail to execute it if it attempts to.
        // Note that we may attempt to perform the fencing even if the job failed in case we couldn't determine
        // the job status, that'll confirm the job failure.
        // 
        // Fencing the operation will usually be performed by executing an asynchronous fencing command on the
        // entity the job is supposed to be performed on.
        // If a fencing command was executed, the callback will wait for it to end and then will try to poll the
        // entity again (it'll be detected as a running child command). On synchronous fencing/no fencing we
        // will attempt to poll the entity again.
        ((EntityPollingCommand) cmd).attemptToFenceJob();
        return null;
    }
    if (((HostJobCommand) cmd).failJobWithUndeterminedStatus()) {
        log.error("Command {} id: '{}': failed to determine the actual job status, considering as failed as per" + " the command implementation", cmd.getActionType(), cmd.getCommandId());
        return HostJobStatus.failed;
    }
    // (as the command doesn't support entity polling - so we don't have any way to poll it).
    if (jobsReportedByHost) {
        log.error("Command {} id: '{}': entity polling isn't supported and the job isn't reported by the host," + "assuming it failed so that the command execution will end.", cmd.getActionType(), cmd.getCommandId());
        return HostJobStatus.failed;
    }
    // if we couldn't determine the job status, we'll retry to poll it.
    log.error("Command {} id: '{}': failed to determine the actual job status, will retry to poll the job soon", cmd.getActionType(), cmd.getCommandId());
    return null;
}
#end_block

#method_before
private void syncLunsForBlockStorageDomains() {
    Collection<StorageDomain> unSyncedStorageDomains = syncLunsForStorageDomains(storageDomainDao.getAllForStoragePool(getStoragePoolId()));
    if (!unSyncedStorageDomains.isEmpty()) {
        String unSyncedStorageDomainsList = unSyncedStorageDomains.stream().map(StorageDomain::getId).map(Guid::toString).collect(Collectors.joining(", "));
        addCustomValue("StorageDomainsIds", unSyncedStorageDomainsList);
        auditLogDirector.log(this, AuditLogType.STORAGE_DOMAINS_COULD_NOT_BE_SYNCED);
    }
}
#method_after
private void syncLunsForBlockStorageDomains() {
    if (!FeatureSupported.discardAfterDeleteSupported(getOldStoragePool().getCompatibilityVersion()) && FeatureSupported.discardAfterDeleteSupported(getStoragePool().getCompatibilityVersion())) {
        // Discard was not supported, and now it should be.
        Collection<Guid> unSyncedStorageDomains = syncLunsForStorageDomains(storageDomainDao.getAllForStoragePool(getStoragePoolId()));
        if (!unSyncedStorageDomains.isEmpty()) {
            String unSyncedStorageDomainsList = unSyncedStorageDomains.stream().map(Guid::toString).collect(Collectors.joining(", "));
            addCustomValue("StorageDomainsIds", unSyncedStorageDomainsList);
            auditLogDirector.log(this, AuditLogType.STORAGE_DOMAINS_COULD_NOT_BE_SYNCED);
        }
    }
}
#end_block

#method_before
protected Collection<StorageDomain> syncLunsForStorageDomains(Collection<StorageDomain> storageDomains) {
    /*
        If the storage pool's status is not UP, then all of its hosts are not up.
        In this case, there's no need to sync all the block domains as they will
        be synced when one of the hosts is activated.
         */
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return Collections.emptyList();
    }
    ArrayList<VDS> hosts = new ArrayList<>(vdsDao.getAllForStoragePoolAndStatus(getStoragePool().getId(), VDSStatus.Up));
    if (hosts.isEmpty()) {
        return Collections.emptyList();
    }
    return storageDomains.parallelStream().filter(storageDomain -> StorageDomainStatus.Active == storageDomain.getStatus()).filter(storageDomain -> storageDomain.getStorageType().isBlockDomain()).collect(Collectors.groupingByConcurrent(storageDomain -> syncDomainLuns(storageDomain, hosts.get(new Random().nextInt(hosts.size())).getId()))).getOrDefault(false, Collections.emptyList());
}
#method_after
protected Collection<Guid> syncLunsForStorageDomains(Collection<StorageDomain> storageDomains) {
    List<Callable<Pair<Boolean, Guid>>> syncLunsCommands = storageDomains.stream().filter(storageDomain -> StorageDomainStatus.Active == storageDomain.getStatus()).filter(storageDomain -> storageDomain.getStorageType().isBlockDomain()).map(storageDomain -> (Callable<Pair<Boolean, Guid>>) () -> syncDomainLuns(storageDomain)).collect(Collectors.toList());
    if (syncLunsCommands.isEmpty()) {
        return Collections.emptyList();
    }
    return ThreadPoolUtil.invokeAll(syncLunsCommands).stream().filter(domainSyncedPair -> !domainSyncedPair.getFirst()).map(Pair::getSecond).collect(Collectors.toList());
}
#end_block

#method_before
protected boolean syncDomainLuns(StorageDomain storageDomain, Guid vdsId) {
    return StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).syncDomainInfo(storageDomain, vdsId);
}
#method_after
protected Pair<Boolean, Guid> syncDomainLuns(StorageDomain storageDomain) {
    return new Pair<>(StorageHelperDirector.getInstance().getItem(storageDomain.getStorageType()).syncDomainInfo(storageDomain, null), storageDomain.getId());
}
#end_block

#method_before
@Test
public void syncLunsForStorageDomainsNoActiveDomain() {
    setUpSyncLunsForStorageDomains();
    List<StorageDomain> storageDomains = Arrays.asList(createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Maintenance, false), createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Locked, false));
    assertTrue(isEmpty(cmd.syncLunsForStorageDomains(storageDomains)));
}
#method_after
@Test
public void syncLunsForStorageDomainsNoActiveDomain() {
    List<StorageDomain> storageDomains = Arrays.asList(createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Maintenance, false), createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Locked, false));
    assertTrue(cmd.syncLunsForStorageDomains(storageDomains).isEmpty());
}
#end_block

#method_before
@Test
public void syncLunsForStorageDomainsNoBlockDomain() {
    setUpSyncLunsForStorageDomains();
    List<StorageDomain> storageDomains = Arrays.asList(createStorageDomainForSyncLuns(StorageType.NFS, StorageDomainStatus.Active, false), createStorageDomainForSyncLuns(StorageType.GLANCE, StorageDomainStatus.Active, false));
    assertTrue(isEmpty(cmd.syncLunsForStorageDomains(storageDomains)));
}
#method_after
@Test
public void syncLunsForStorageDomainsNoBlockDomain() {
    List<StorageDomain> storageDomains = Arrays.asList(createStorageDomainForSyncLuns(StorageType.NFS, StorageDomainStatus.Active, false), createStorageDomainForSyncLuns(StorageType.GLANCE, StorageDomainStatus.Active, false));
    assertTrue(cmd.syncLunsForStorageDomains(storageDomains).isEmpty());
}
#end_block

#method_before
@Test
public void syncLunsForStorageDomainsNoDomain() {
    setUpSyncLunsForStorageDomains();
    List<StorageDomain> storageDomains = Collections.emptyList();
    assertTrue(isEmpty(cmd.syncLunsForStorageDomains(storageDomains)));
}
#method_after
@Test
public void syncLunsForStorageDomainsNoDomain() {
    assertTrue(cmd.syncLunsForStorageDomains(Collections.emptyList()).isEmpty());
}
#end_block

#method_before
@Test
public void syncLunsForStorageDomainsWithFailedToSyncDomains() {
    setUpSyncLunsForStorageDomains();
    StorageDomain failedToSyncStorageDomain1 = createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Active, false);
    StorageDomain failedToSyncStorageDomain2 = createStorageDomainForSyncLuns(StorageType.FCP, StorageDomainStatus.Active, false);
    List<StorageDomain> storageDomains = Arrays.asList(failedToSyncStorageDomain1, failedToSyncStorageDomain2, createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Active, true));
    assertTrue(isEqualCollection(cmd.syncLunsForStorageDomains(storageDomains), Arrays.asList(failedToSyncStorageDomain1, failedToSyncStorageDomain2)));
}
#method_after
@Test
public void syncLunsForStorageDomainsWithFailedToSyncDomains() {
    StorageDomain failedToSyncStorageDomain1 = createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Active, false);
    StorageDomain failedToSyncStorageDomain2 = createStorageDomainForSyncLuns(StorageType.FCP, StorageDomainStatus.Active, false);
    List<StorageDomain> storageDomains = Arrays.asList(failedToSyncStorageDomain1, failedToSyncStorageDomain2, createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Active, true));
    assertTrue(isEqualCollection(cmd.syncLunsForStorageDomains(storageDomains), Arrays.asList(failedToSyncStorageDomain1.getId(), failedToSyncStorageDomain2.getId())));
}
#end_block

#method_before
@Test
public void syncLunsForStorageDomainsAllActiveBlockDomainsWereSynced() {
    setUpSyncLunsForStorageDomains();
    List<StorageDomain> storageDomains = Arrays.asList(createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Active, true), createStorageDomainForSyncLuns(StorageType.FCP, StorageDomainStatus.Locked, false), createStorageDomainForSyncLuns(StorageType.FCP, StorageDomainStatus.Active, true));
    assertTrue(isEmpty(cmd.syncLunsForStorageDomains(storageDomains)));
}
#method_after
@Test
public void syncLunsForStorageDomainsAllActiveBlockDomainsWereSynced() {
    List<StorageDomain> storageDomains = Arrays.asList(createStorageDomainForSyncLuns(StorageType.ISCSI, StorageDomainStatus.Active, true), createStorageDomainForSyncLuns(StorageType.FCP, StorageDomainStatus.Locked, false), createStorageDomainForSyncLuns(StorageType.FCP, StorageDomainStatus.Active, true));
    assertTrue(cmd.syncLunsForStorageDomains(storageDomains).isEmpty());
}
#end_block

#method_before
private StorageDomain createStorageDomainForSyncLuns(StorageType storageType, StorageDomainStatus status, boolean canSync) {
    StorageDomain domain = new StorageDomain();
    domain.setId(Guid.newGuid());
    domain.setStorageType(storageType);
    domain.setStatus(status);
    doReturn(canSync).when(cmd).syncDomainLuns(eq(domain), any());
    return domain;
}
#method_after
private StorageDomain createStorageDomainForSyncLuns(StorageType storageType, StorageDomainStatus status, boolean canSync) {
    StorageDomain domain = new StorageDomain();
    domain.setId(Guid.newGuid());
    domain.setStorageType(storageType);
    domain.setStatus(status);
    doReturn(new Pair<>(canSync, domain.getId())).when(cmd).syncDomainLuns(eq(domain));
    return domain;
}
#end_block

#method_before
private static StoragePool cloneStoragePool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setMasterDomainVersion(instance.getMasterDomainVersion());
    obj.setLVER(instance.getLVER());
    obj.setRecoveryMode(instance.getRecoveryMode());
    obj.setSpmVdsId(instance.getSpmVdsId());
    obj.setCompatibilityVersion(instance.getCompatibilityVersion());
    return obj;
}
#method_after
private static StoragePool cloneStoragePool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setMasterDomainVersion(instance.getMasterDomainVersion());
    obj.setLVER(instance.getLVER());
    obj.setRecoveryMode(instance.getRecoveryMode());
    obj.setSpmVdsId(instance.getSpmVdsId());
    obj.setStoragePoolCompatibilityLevelUpgradeNeeded(instance.isStoragePoolCompatibilityLevelUpgradeNeeded());
    obj.setCompatibilityVersion(instance.getCompatibilityVersion());
    return obj;
}
#end_block

#method_before
private static Cluster cloneCluster(Cluster instance) {
    Cluster obj = new Cluster();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setCpuName(instance.getCpuName());
    obj.setCompatibilityVersion(instance.getCompatibilityVersion());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setMaxVdsMemoryOverCommit(instance.getMaxVdsMemoryOverCommit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    return obj;
}
#method_after
private static Cluster cloneCluster(Cluster instance) {
    Cluster obj = new Cluster();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setCpuName(instance.getCpuName());
    obj.setClusterCompatibilityLevelUpgradeNeeded(instance.isClusterCompatibilityLevelUpgradeNeeded());
    obj.setCompatibilityVersion(instance.getCompatibilityVersion());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setMaxVdsMemoryOverCommit(instance.getMaxVdsMemoryOverCommit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    obj.setFencingPolicy(new FencingPolicy(instance.getFencingPolicy()));
    obj.setAutoConverge(instance.getAutoConverge());
    obj.setMigrateCompressed(instance.getMigrateCompressed());
    return obj;
}
#end_block

#method_before
private int calculateValue(NetworkCluster networkCluster) {
    int res = 0;
    if (networkCluster != null) {
        if (networkCluster.isDefaultRoute()) {
            res += 16;
        }
        if (networkCluster.isManagement()) {
            // TODO MMUCHA: Dear code reviewer! These are very nice undocumented magic numbers we have here. 1,2,4 would suggest, that those are binaries (1,10,100,X,10000), and I should add number 16, but value 10 kinda ruins this idea. What are these numbers? Please advise.
            res += 10;
        }
        if (networkCluster.isDisplay()) {
            res += 4;
        }
        if (networkCluster.isMigration()) {
            res += 2;
        }
        if (networkCluster.isGluster()) {
            res += 1;
        }
    }
    return res;
}
#method_after
private int calculateValue(NetworkCluster networkCluster) {
    int res = 0;
    if (networkCluster != null) {
        if (networkCluster.isManagement()) {
            res += 16;
        }
        if (networkCluster.isDefaultRoute()) {
            res += 8;
        }
        if (networkCluster.isDisplay()) {
            res += 4;
        }
        if (networkCluster.isMigration()) {
            res += 2;
        }
        if (networkCluster.isGluster()) {
            res += 1;
        }
    }
    return res;
}
#end_block

#method_before
private void initEntityModelCellTable() {
    networks.enableColumnResizing();
    boolean multiCluster = networks.asEditor().flush().isMultiCluster();
    // $NON-NLS-1$
    networks.addColumn(new NetworkNameTextColumnWithTooltip(), constants.nameNetwork(), "85px");
    networks.addColumn(new AttachedIndicatorCheckboxColumn(new AttachedIndicatorFieldUpdater()), new AttachedIndicatorCheckboxHeader(), // $NON-NLS-1$
    "90px");
    networks.addColumn(new RequiredIndicatorCheckboxColumn(new RequiredIndicatorFieldUpdater()), new RequiredAllCheckboxHeader(), // $NON-NLS-1$
    "110px");
    networks.addColumn(new VmNetworkImageSafeHtmlWithSafeHtmlTooltipColumn(), constants.vmNetwork(), // $NON-NLS-1$
    "80px");
    networks.addColumn(new ManagementNetworkIndicatorCheckboxColumn(multiCluster, new ManagementNetworkIndicatorFieldUpdater()), constants.managementItemInfo(), // $NON-NLS-1$
    "80px");
    networks.addColumn(new DisplayNetworkIndicatorCheckboxColumn(multiCluster, new DisplayNetworkIndicatorFieldUpdater()), new SafeHtmlHeader(SafeHtmlUtils.fromSafeConstant(constants.displayNetwork()), SafeHtmlUtils.fromSafeConstant(constants.changeDisplayNetworkWarning())), // $NON-NLS-1$
    "100px");
    networks.addColumn(new MigrationNetworkIndicatorCheckboxColumn(multiCluster, new MigrationNetworkIndicatorFieldUpdater()), constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
    networks.addColumn(new GlusterNetworkIndicatorCheckboxColumn(multiCluster, new GlusterNetworkIndicatorFieldUpdater()), constants.glusterNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new DefaultRouteNetworkIndicatorCheckboxColumn(new DefaultRouteNetworkIndicatorFieldUpdater()), constants.defaultRouteNetwork(), // $NON-NLS-1$
    "100px");
}
#method_after
private void initEntityModelCellTable() {
    networks.enableColumnResizing();
    boolean multiCluster = networks.asEditor().flush().isMultiCluster();
    // $NON-NLS-1$
    networks.addColumn(new NetworkNameTextColumnWithTooltip(), constants.nameNetwork(), "85px");
    networks.addColumn(new AttachedIndicatorCheckboxColumn(new AttachedIndicatorFieldUpdater()), new AttachedIndicatorCheckboxHeader(), // $NON-NLS-1$
    "90px");
    networks.addColumn(new RequiredIndicatorCheckboxColumn(new RequiredIndicatorFieldUpdater()), new RequiredAllCheckboxHeader(), // $NON-NLS-1$
    "110px");
    networks.addColumn(new VmNetworkImageSafeHtmlWithSafeHtmlTooltipColumn(), constants.vmNetwork(), // $NON-NLS-1$
    "80px");
    networks.addColumn(new ManagementNetworkIndicatorCheckboxColumn(multiCluster, new ManagementNetworkIndicatorFieldUpdater()), constants.managementItemInfo(), // $NON-NLS-1$
    "80px");
    networks.addColumn(new DisplayNetworkIndicatorCheckboxColumn(multiCluster, new DisplayNetworkIndicatorFieldUpdater()), new SafeHtmlHeader(SafeHtmlUtils.fromSafeConstant(constants.displayNetwork()), SafeHtmlUtils.fromSafeConstant(constants.changeDisplayNetworkWarning())), // $NON-NLS-1$
    "100px");
    networks.addColumn(new MigrationNetworkIndicatorCheckboxColumn(multiCluster, new MigrationNetworkIndicatorFieldUpdater()), constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
    networks.addColumn(new GlusterNetworkIndicatorCheckboxColumn(multiCluster, new GlusterNetworkIndicatorFieldUpdater()), constants.glusterNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new DefaultRouteNetworkIndicatorCheckboxColumn(multiCluster, new DefaultRouteNetworkIndicatorFieldUpdater()), constants.defaultRouteNetwork(), // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
private void changeIsAttached(ClusterNetworkModel clusterNetworkModel, Boolean value) {
    clusterNetworkModel.setAttached(value);
    if (!value) {
        if (clusterNetworkModel.isDisplayNetwork()) {
            updateDisplayNetwork(clusterNetworkModel, false);
        }
        if (clusterNetworkModel.isMigrationNetwork()) {
            updateMigrationNetwork(clusterNetworkModel, false);
        }
        if (clusterNetworkModel.isGlusterNetwork()) {
            updateGlusterNetwork(clusterNetworkModel, false);
        }
        if (clusterNetworkModel.isRequired()) {
            clusterNetworkModel.setRequired(false);
        }
        // TODO MMUCHA: no idea what is this for. Verify.
        if (clusterNetworkModel.isDefaultRouteNetwork()) {
            updateDefaultRouteNetwork(clusterNetworkModel, false);
        }
    }
}
#method_after
private void changeIsAttached(ClusterNetworkModel clusterNetworkModel, Boolean value) {
    clusterNetworkModel.setAttached(value);
    if (!value) {
        if (clusterNetworkModel.isDisplayNetwork()) {
            updateDisplayNetwork(clusterNetworkModel, false);
        }
        if (clusterNetworkModel.isMigrationNetwork()) {
            updateMigrationNetwork(clusterNetworkModel, false);
        }
        if (clusterNetworkModel.isGlusterNetwork()) {
            updateGlusterNetwork(clusterNetworkModel, false);
        }
        if (clusterNetworkModel.isRequired()) {
            clusterNetworkModel.setRequired(false);
        }
        if (clusterNetworkModel.isDefaultRouteNetwork()) {
            updateDefaultRouteNetwork(clusterNetworkModel, false);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
}
#method_after
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal() && !isUnsetRoleProhibited(clusterNetworkModel);
}
#end_block

#method_before
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && clusterNetworkModel.isRequired() && !clusterNetworkModel.isExternal() && !(multiCluster && isManagementOriginally(clusterNetworkModel));
}
#method_after
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && clusterNetworkModel.isRequired() && !clusterNetworkModel.isExternal() && !isUnsetRoleProhibited(clusterNetworkModel);
}
#end_block

#method_before
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
}
#method_after
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal() && !isUnsetRoleProhibited(clusterNetworkModel);
}
#end_block

#method_before
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    // TODO MMUCHA: Dear code reviewer! please pay extra attention here, it feels as OK, but I'm not sure if this is correct. Please advise.
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
}
#method_after
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
}
#end_block

#method_before
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
}
#method_after
@Override
protected boolean canEdit(ClusterNetworkModel clusterNetworkModel) {
    return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal() && !isUnsetRoleProhibited(clusterNetworkModel);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<NetworkView> nameColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    boolean virtMode = ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly);
    AbstractTextColumn<NetworkView> dcColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(dcColumn, constants.dcNetwork(), virtMode, "200px");
    AbstractTextColumn<NetworkView> descriptionColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    /* WHERE are the other roles? Probably, here are only listed those roles,
         * which applies for given network in all clusters. Meaning, management network role need not to be set for
         * given network on all clusters, and because of that it's missing here.
         */
    AbstractSafeHtmlColumn<NetworkView> roleColumn = new AbstractSafeHtmlColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<>();
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return MultiImageColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<>();
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return MultiImageColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    AbstractTextColumn<NetworkView> vlanColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(vlanColumn, constants.vlanNetwork(), virtMode, "60px");
    AbstractTextColumn<NetworkView> qosColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getQosName() == null ? "-" : object.getQosName().toString();
        }
    };
    qosColumn.makeSortable(NetworkConditionFieldAutoCompleter.QOS);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(qosColumn, constants.qosName(), virtMode, "60px");
    AbstractTextColumn<NetworkView> labelColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new AbstractLinkColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    providerColumn.makeSortable(NetworkConditionFieldAutoCompleter.PROVIDER_NAME);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(providerColumn, constants.providerNetwork(), virtMode, "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<NetworkView> nameColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(NetworkConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameNetwork(), "200px");
    CommentColumn<NetworkView> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    boolean virtMode = ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly);
    AbstractTextColumn<NetworkView> dcColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDataCenterName();
        }
    };
    dcColumn.makeSortable(NetworkConditionFieldAutoCompleter.DATA_CENTER);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(dcColumn, constants.dcNetwork(), virtMode, "200px");
    AbstractTextColumn<NetworkView> descriptionColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            return object.getDescription();
        }
    };
    descriptionColumn.makeSortable(NetworkConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.descriptionNetwork(), "300px");
    /* Here are only listed those roles,
         * which applies for given network in all clusters. Meaning, management network role need not to be set for
         * given network on all clusters, and because of that it's missing here.
         */
    AbstractSafeHtmlColumn<NetworkView> roleColumn = new AbstractSafeHtmlColumn<NetworkView>() {

        @Override
        public SafeHtml getValue(NetworkView networkView) {
            List<SafeHtml> images = new LinkedList<>();
            if (networkView.isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return MultiImageColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(NetworkView networkView) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<>();
            if (networkView.isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return MultiImageColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(roleColumn, constants.roleNetwork(), "60px");
    AbstractTextColumn<NetworkView> vlanColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getVlanId() == null ? "-" : object.getVlanId().toString();
        }
    };
    vlanColumn.makeSortable(NetworkConditionFieldAutoCompleter.VLAN_ID);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(vlanColumn, constants.vlanNetwork(), virtMode, "60px");
    AbstractTextColumn<NetworkView> qosColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getQosName() == null ? "-" : object.getQosName().toString();
        }
    };
    qosColumn.makeSortable(NetworkConditionFieldAutoCompleter.QOS);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(qosColumn, constants.qosName(), virtMode, "60px");
    AbstractTextColumn<NetworkView> labelColumn = new AbstractTextColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getLabel() == null ? "-" : object.getLabel();
        }
    };
    labelColumn.makeSortable(NetworkConditionFieldAutoCompleter.LABEL);
    // $NON-NLS-1$
    getTable().addColumn(labelColumn, constants.networkLabelNetworksTab(), "200px");
    providerColumn = new AbstractLinkColumn<NetworkView>() {

        @Override
        public String getValue(NetworkView object) {
            // $NON-NLS-1$
            return object.getProvidedBy() == null ? "" : object.getProviderName();
        }
    };
    providerColumn.makeSortable(NetworkConditionFieldAutoCompleter.PROVIDER_NAME);
    // $NON-NLS-1$
    getTable().ensureColumnVisible(providerColumn, constants.providerNetwork(), virtMode, "200px");
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.newNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.importNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getImportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.editNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<NetworkView>(constants.removeNetwork()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
}
#end_block

#method_before
public void setIpv6BootProtocol(Ipv6BootProtocol ipv6BootProtocol) {
    this.ipv6BootProtocol = ipv6BootProtocol;
}
#method_after
public void setIpv6BootProtocol(Ipv6BootProtocol ipv6BootProtocol) {
    this.ipv6BootProtocol = (ipv6BootProtocol == null) ? Ipv6BootProtocol.NONE : ipv6BootProtocol;
}
#end_block

#method_before
private boolean isManagementNetworkChanged(List<HostNetwork> networksToConfigure) {
    Network managementNetwork = getClusterNetworks().stream().filter(e -> e.getCluster().isManagement()).collect(Collectors.collectingAndThen(Collectors.toList(), list -> {
        if (list.size() != 1) {
            throw new IllegalStateException("There isn't management network for cluster " + getClusterId());
        }
        return list.get(0);
    }));
    String managementNetworkName = managementNetwork.getName();
    for (HostNetwork network : networksToConfigure) {
        if (managementNetworkName.equals(network.getNetworkName())) {
            return true;
        }
    }
    for (CreateOrUpdateBond createOrUpdateBond : getParameters().getCreateOrUpdateBonds()) {
        // We are only interested in existing bonds, whose bonding options/slave have changed, so it
        // enough to check existing bonds. New bonds which have the management network
        // are covered by network attachments
        VdsNetworkInterface bondNic = getExistingNicsBusinessEntityMap().get(createOrUpdateBond.getId());
        if (bondNic != null && managementNetworkName.equals(bondNic.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isManagementNetworkChanged(List<HostNetwork> networksToConfigure) {
    Network managementNetwork = managementNetworkUtil.getManagementNetwork(getClusterNetworks(), getClusterId());
    String managementNetworkName = managementNetwork.getName();
    for (HostNetwork network : networksToConfigure) {
        if (managementNetworkName.equals(network.getNetworkName())) {
            return true;
        }
    }
    for (CreateOrUpdateBond createOrUpdateBond : getParameters().getCreateOrUpdateBonds()) {
        // We are only interested in existing bonds, whose bonding options/slave have changed, so it
        // enough to check existing bonds. New bonds which have the management network
        // are covered by network attachments
        VdsNetworkInterface bondNic = getExistingNicsBusinessEntityMap().get(createOrUpdateBond.getId());
        if (bondNic != null && managementNetworkName.equals(bondNic.getNetworkName())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private ValidationResult checkVmNumaCpuAssignment(int cpuCores, List<VmNumaNode> vmNumaNodes) {
    ArrayList<Integer> cpuIds = new ArrayList<>();
    for (VmNumaNode node : vmNumaNodes) {
        cpuIds.addAll(node.getCpuIds());
    }
    if (cpuIds.isEmpty()) {
        return ValidationResult.VALID;
    }
    int minId = Collections.min(cpuIds);
    int maxId = Collections.max(cpuIds);
    if (minId < 0 || maxId >= cpuCores) {
        return new ValidationResult(EngineMessage.VM_NUMA_NODE_INVALID_CPU_ID, String.format("$cpuIndex %d", (minId < 0) ? minId : maxId), String.format("$cpuIndexMax %d", cpuCores - 1));
    }
    // Check duplicates
    Collections.sort(cpuIds);
    for (int i = 0; i < cpuIds.size() - 1; ++i) {
        if (cpuIds.get(i).equals(cpuIds.get(i + 1))) {
            return new ValidationResult(EngineMessage.VM_NUMA_NODE_DUPLICATE_CPU_ID, String.format("$cpuIndex %d", cpuIds.get(i)));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult checkVmNumaCpuAssignment(int cpuCores, List<VmNumaNode> vmNumaNodes) {
    List<Integer> cpuIds = vmNumaNodes.stream().flatMap(node -> node.getCpuIds().stream()).collect(Collectors.toList());
    if (cpuIds.isEmpty()) {
        return ValidationResult.VALID;
    }
    int minId = Collections.min(cpuIds);
    int maxId = Collections.max(cpuIds);
    if (minId < 0 || maxId >= cpuCores) {
        return new ValidationResult(EngineMessage.VM_NUMA_NODE_INVALID_CPU_ID, String.format("$cpuIndex %d", (minId < 0) ? minId : maxId), String.format("$cpuIndexMax %d", cpuCores - 1));
    }
    List<Integer> duplicateIds = cpuIds.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting())).entrySet().stream().filter(a -> a.getValue() > 1).map(Map.Entry::getKey).collect(Collectors.toList());
    if (!duplicateIds.isEmpty()) {
        return new ValidationResult(EngineMessage.VM_NUMA_NODE_DUPLICATE_CPU_IDS, String.format("$cpuIndexes %s", duplicateIds.stream().map(i -> i.toString()).collect(Collectors.joining(", "))));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(vdcReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                break;
            }
        }
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
        logable.setStorageDomainId(storageDomainId);
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(vdcReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            } else {
                log.error("Couldn't find additional ovf store to retrieve the ovf data from in storage domain '{}'", storageDomainId);
                break;
            }
        }
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
        logable.setStorageDomainId(storageDomainId);
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
    }
    return new ArrayList<>();
}
#end_block

#method_before
public void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = vnicProfileDao.get(vmInterface.getVnicProfileId());
    Network network = networkDao.get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, getVnicCustomProperties(vnicProfile));
}
#method_after
public void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName, VM vm) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = vnicProfileDao.get(vmInterface.getVnicProfileId());
    Network network = networkDao.get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, getVnicCustomProperties(vnicProfile));
}
#end_block

#method_before
public void addNetworkFiltersToNic(Map<String, Object> struct, VmNic vmNic) {
    final NetworkFilter networkFilter = fetchVnicProfileNetworkFilter(vmNic);
    if (networkFilter != null) {
        final String networkFilterName = networkFilter.getName();
        struct.put(VdsProperties.NW_FILTER, networkFilterName);
    }
}
#method_after
public void addNetworkFiltersToNic(Map<String, Object> struct, VmNic vmNic) {
    final NetworkFilter networkFilter = fetchVnicProfileNetworkFilter(vmNic);
    if (networkFilter != null) {
        final String networkFilterName = networkFilter.getName();
        struct.put(VdsProperties.NW_FILTER, networkFilterName);
        final List<VmNicFilterParameter> vmNicFilterParameters = vmNicFilterParameterDao.getAllForVmNic(vmNic.getId());
        struct.put(VdsProperties.NETWORK_FILTER_PARAMETERS, mapVmNicFilterParameter(vmNicFilterParameters));
    }
}
#end_block

#method_before
private NetworkFilter fetchVnicProfileNetworkFilter(VmNic vmNic) {
    if (vmNic.getVnicProfileId() != null) {
        VnicProfile vnicProfile = vnicProfileDao.get(vmNic.getVnicProfileId());
        if (vnicProfile != null) {
            final Guid networkFilterId = vnicProfile.getNetworkFilterId();
            return networkFilterId == null ? null : networkFilterDao.getNetworkFilterById(networkFilterId);
        }
    }
    return null;
}
#method_after
protected NetworkFilter fetchVnicProfileNetworkFilter(VmNic vmNic) {
    if (vmNic.getVnicProfileId() != null) {
        VnicProfile vnicProfile = vnicProfileDao.get(vmNic.getVnicProfileId());
        if (vnicProfile != null) {
            final Guid networkFilterId = vnicProfile.getNetworkFilterId();
            return networkFilterId == null ? null : networkFilterDao.getNetworkFilterById(networkFilterId);
        }
    }
    return null;
}
#end_block

#method_before
private Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            String controllerStr = address.get(VdsProperties.Controller);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr) && StringUtils.isNotEmpty(controllerStr)) {
                Integer controllerInt = Integer.valueOf(controllerStr);
                boolean controllerOutOfRange = controllerInt >= vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
                boolean ioThreadsEnabled = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
                if ((ioThreadsEnabled && !controllerOutOfRange) || (!ioThreadsEnabled && controllerInt == getDefaultVirtioScsiIndex(vm))) {
                    if (!vmDeviceUnitMap.containsKey(controllerInt)) {
                        vmDeviceUnitMap.put(controllerInt, new HashMap<>());
                    }
                    vmDeviceUnitMap.get(controllerInt).put(vmDevice, Integer.valueOf(unitStr));
                } else {
                    // controller id not correct, generate the address again again later
                    vmDevice.setAddress(null);
                    vmDeviceDiskMap.put(vmDevice, disk);
                }
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    int increment = 0;
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int controller = getControllerForScsiDisk(entry.getKey(), vm, increment);
        increment++;
        if (!vmDeviceUnitMap.containsKey(controller)) {
            vmDeviceUnitMap.put(controller, new HashMap<>());
        }
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap.get(controller), reserveFirstTwoLuns);
        vmDeviceUnitMap.get(controller).put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
protected Map<Integer, Map<VmDevice, Integer>> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = getSortedDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = new HashMap<>();
    LinkedList<VmDevice> vmDeviceList = new LinkedList<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringMapUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            String controllerStr = address.get(VdsProperties.Controller);
            // Otherwise, adding to 'vmDeviceList' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr) && StringUtils.isNotEmpty(controllerStr)) {
                Integer controllerInt = Integer.valueOf(controllerStr);
                boolean controllerOutOfRange = controllerInt >= vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
                boolean ioThreadsEnabled = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
                if ((ioThreadsEnabled && !controllerOutOfRange) || (controllerInt == getDefaultVirtioScsiIndex(vm))) {
                    if (!vmDeviceUnitMap.containsKey(controllerInt)) {
                        vmDeviceUnitMap.put(controllerInt, new HashMap<>());
                    }
                    vmDeviceUnitMap.get(controllerInt).put(vmDevice, Integer.valueOf(unitStr));
                } else {
                    // controller id not correct, generate the address again later
                    vmDevice.setAddress(null);
                    vmDeviceList.add(vmDevice);
                }
            } else {
                vmDeviceList.add(vmDevice);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address\
    IntStream.range(0, vmDeviceList.size()).forEach(index -> {
        VmDevice vmDevice = vmDeviceList.get(index);
        int controller = getControllerForScsiDisk(vmDevice, vm, index);
        if (!vmDeviceUnitMap.containsKey(controller)) {
            vmDeviceUnitMap.put(controller, new HashMap<>());
        }
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap.get(controller), reserveFirstTwoLuns);
        vmDeviceUnitMap.get(controller).put(vmDevice, unit);
    });
    return vmDeviceUnitMap;
}
#end_block

#method_before
public int getControllerForScsiDisk(VmDevice disk, VM vm, int increment) {
    Map<String, String> address = XmlRpcStringUtils.string2Map(disk.getAddress());
    String controllerStr = address.get(VdsProperties.Controller);
    int defaultIndex = getDefaultVirtioScsiIndex(vm);
    boolean ioThreadsEnabled = FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
    if (!ioThreadsEnabled) {
        // no io threads, only 1 controller allowed and it is the default one
        return defaultIndex;
    }
    if (StringUtils.isNotEmpty(controllerStr)) {
        int controllerInt = Integer.parseInt(controllerStr);
        boolean controllerOutOfRange = controllerInt > vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
        if (!controllerOutOfRange) {
            // io threads enabled and the controller in range, use it
            return controllerInt;
        }
    }
    // In both cases the controller index needs to be generated again.
    if (vm.getNumOfIoThreads() > 0) {
        // the result of this will be a round robin over the controller indexes from the default index
        return increment % vm.getNumOfIoThreads() + defaultIndex;
    }
    return defaultIndex;
}
#method_after
public int getControllerForScsiDisk(VmDevice disk, VM vm, int increment) {
    Map<String, String> address = StringMapUtils.string2Map(disk.getAddress());
    String controllerStr = address.get(VdsProperties.Controller);
    int defaultIndex = getDefaultVirtioScsiIndex(vm);
    boolean ioThreadsEnabled = FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion());
    if (!ioThreadsEnabled) {
        // no io threads, only 1 controller allowed and it is the default one
        return defaultIndex;
    }
    if (StringUtils.isNotEmpty(controllerStr)) {
        int controllerInt = Integer.parseInt(controllerStr);
        boolean controllerOutOfRange = controllerInt > vm.getNumOfIoThreads() + getDefaultVirtioScsiIndex(vm);
        if (!controllerOutOfRange) {
            // io threads enabled and the controller in range, use it
            return controllerInt;
        }
    }
    // In both cases the controller index needs to be generated again.
    if (vm.getNumOfIoThreads() > 0) {
        // the result of this will be a round robin over the controller indexes from the default index
        return increment % vm.getNumOfIoThreads() + defaultIndex;
    }
    return defaultIndex;
}
#end_block

#method_before
void addAddress(VmDevice vmDevice, Map<String, Object> struct) {
    Map<String, String> addressMap = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
    if (!addressMap.isEmpty()) {
        struct.put(VdsProperties.Address, addressMap);
    }
}
#method_after
void addAddress(VmDevice vmDevice, Map<String, Object> struct) {
    Map<String, String> addressMap = StringMapUtils.string2Map(vmDevice.getAddress());
    if (!addressMap.isEmpty()) {
        struct.put(VdsProperties.Address, addressMap);
    }
}
#end_block

#method_before
@Override
public void buildVmVideoCards() {
    List<VmDevice> vmVideoDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.VIDEO);
    for (VmDevice vmVideoDevice : vmVideoDevices) {
        // skip unmanaged devices (handled separately)
        if (!vmVideoDevice.getIsManaged()) {
            continue;
        }
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmVideoDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmVideoDevice.getDevice());
        vmInfoBuildUtils.addAddress(vmVideoDevice, struct);
        struct.put(VdsProperties.SpecParams, vmVideoDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmVideoDevice.getId().getDeviceId()));
        addToManagedDevices(vmVideoDevice);
        devices.add(struct);
    }
}
#method_after
@Override
public void buildVmVideoCards() {
    boolean videoCardOverridden = vm.isRunOnce() && vm.getDefaultDisplayType() != null;
    if (videoCardOverridden) {
        if (vm.getDefaultDisplayType() == DisplayType.none) {
            return;
        }
        buildVmVideoDeviceOverridden();
    } else {
        buildVmVideoDevicesFromDb();
    }
}
#end_block

#method_before
@Override
public void buildVmGraphicsDevices() {
    boolean graphicsOverridden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = null;
    if (infos != null) {
        specParamsFromVm = new HashMap<>();
        addVmGraphicsOptions(infos, specParamsFromVm);
    }
    if (graphicsOverridden) {
        buildVmGraphicsDevicesOverridden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#method_after
@Override
public void buildVmGraphicsDevices() {
    boolean graphicsOverridden = vm.isRunOnce() && vm.getGraphicsInfos() != null && !vm.getGraphicsInfos().isEmpty();
    boolean isHeadlessMode = vm.getDefaultDisplayType() == DisplayType.none;
    if (isHeadlessMode) {
        return;
    }
    Map<GraphicsType, GraphicsInfo> infos = vm.getGraphicsInfos();
    Map<String, Object> specParamsFromVm = null;
    if (infos != null) {
        specParamsFromVm = new HashMap<>();
        addVmGraphicsOptions(infos, specParamsFromVm);
    }
    if (graphicsOverridden) {
        buildVmGraphicsDevicesOverridden(infos, specParamsFromVm);
    } else {
        buildVmGraphicsDevicesFromDb(specParamsFromVm);
    }
}
#end_block

#method_before
@Override
public void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
public void buildVmCD(VmPayload vmPayload) {
    boolean hasPayload = vmPayload != null && vmPayload.getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        Map<String, Object> struct = vmInfoBuildUtils.buildCdDetails(vmPayload, vm);
        addDevice(struct, vmPayload, "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", null, true, true, true, "", null, null, null);
        Map<String, Object> struct = vmInfoBuildUtils.buildCdDetails(vmDevice, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.isManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            String cdPath = vm.getCdPath();
            Map<String, Object> struct = vmInfoBuildUtils.buildCdDetails(vmDevice, vm);
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
@Override
public void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
public void buildVmFloppy(VmPayload vmPayload) {
    // check if we have payload Floppy
    boolean hasPayload = vmPayload != null && vmPayload.getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = vmInfoBuildUtils.buildFloppyDetails(vmPayload);
        addDevice(struct, vmPayload, "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", null, true, true, true, "", null, null, null);
        Map<String, Object> struct = vmInfoBuildUtils.buildFloppyDetails(vmDevice);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.isManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            String file = vm.getFloppyPath();
            Map<String, Object> struct = vmInfoBuildUtils.buildFloppyDetails(vmDevice);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    VmDevice deviceFromMap = vmDevice;
                    int controllerId = virtioScsiIndex;
                    Integer unit = null;
                    for (Map.Entry<Integer, Map<VmDevice, Integer>> controllerToDevices : vmDeviceVirtioScsiUnitMap.entrySet()) {
                        Optional<VmDevice> maybeDeviceFromMap = controllerToDevices.getValue().keySet().stream().filter(d -> d.getId().equals(vmDevice.getId())).findFirst();
                        if (maybeDeviceFromMap.isPresent()) {
                            controllerId = controllerToDevices.getKey();
                            deviceFromMap = maybeDeviceFromMap.get();
                            unit = controllerToDevices.getValue().get(deviceFromMap);
                            break;
                        }
                    }
                    if (StringUtils.isEmpty(deviceFromMap.getAddress())) {
                        // by default use default controller
                        if (unit == null) {
                            // should never get here, but for safety having this fallback and generating a new unit id
                            unit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceVirtioScsiUnitMap.get(controllerId), false);
                        }
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(controllerId, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        unit = vmDeviceSpaprVscsiUnitMap.get(sPaprVscsiIndex).get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = vmInfoBuildUtils.getSortedDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<Integer, Map<VmDevice, Integer>> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.isManaged()) {
            continue;
        }
        if (vmDevice.isPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    setupVirtioScsiDisk(vmDeviceVirtioScsiUnitMap, virtioScsiIndex, disk, struct, vmDevice);
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        Integer unit = vmDeviceSpaprVscsiUnitMap.get(sPaprVscsiIndex).get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion())) {
                struct.put(VdsProperties.DISCARD, dve.isPassDiscard());
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            bootableDevices.add(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
public void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map<String, Object> struct = new HashMap<>();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
public void buildVmNetworkInterfaces(Map<Guid, String> passthroughVnicToVfMap) {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.isManaged() && vmDevice.isPlugged()) {
            Map<String, Object> struct = new HashMap<>();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = passthroughVnicToVfMap.get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            bootableDevices.add(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
public void buildVmBootSequence() {
    // Check if boot sequence in parameters is different from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), managedDevices);
        for (VmDevice vmDevice : managedDevices) {
            for (Map<String, Object> struct : devices) {
                String deviceId = (String) struct.get(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.keySet().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
public void buildVmBootSequence() {
    // recalculate boot order from source devices and set it to target devices
    VmDeviceCommonUtils.updateVmDevicesBootOrder(vm.getBootSequence(), bootableDevices, vm.getInterfaces(), VmDeviceCommonUtils.extractDiskVmElements(vm));
    for (VmDevice vmDevice : bootableDevices) {
        for (Map<String, Object> struct : devices) {
            String deviceId = (String) struct.get(VdsProperties.DeviceId);
            if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                if (vmDevice.getBootOrder() > 0) {
                    struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                }
                break;
            }
        }
    }
}
#end_block

#method_before
@Override
public void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildUtils.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#method_after
@Override
public void buildSysprepVmPayload(String sysPrepContent) {
    // We do not validate the size of the content being passed to the VM payload by VmPayload.isPayloadSizeLegal().
    // The sysprep file size isn't being verified for 3.0 clusters and below, so we maintain the same behavior here.
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.FLOPPY);
    vmPayload.getFiles().put(vmInfoBuildUtils.getOsRepository().getSysprepFileName(vm.getOs(), vm.getCompatibilityVersion()), new String(BASE_64.encode(sysPrepContent.getBytes()), Charset.forName(CharEncoding.UTF_8)));
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = vmInfoBuildUtils.buildFloppyDetails(vmDevice);
    addDevice(struct, vmDevice, vm.getFloppyPath());
}
#end_block

#method_before
@Override
public void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", 0, vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = new HashMap<>();
    vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
    addDevice(struct, vmDevice, "");
}
#method_after
@Override
public void buildCloudInitVmPayload(Map<String, byte[]> cloudInitContent) {
    VmPayload vmPayload = new VmPayload();
    vmPayload.setDeviceType(VmDeviceType.CDROM);
    vmPayload.setVolumeId(CLOUD_INIT_VOL_ID);
    for (Entry<String, byte[]> entry : cloudInitContent.entrySet()) {
        vmPayload.getFiles().put(entry.getKey(), new String(BASE_64.encode(entry.getValue()), Charset.forName(CharEncoding.UTF_8)));
    }
    VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", vmPayload.getSpecParams(), true, true, true, "", null, null, null);
    Map<String, Object> struct = vmInfoBuildUtils.buildCdDetails(vmDevice, vm);
    addDevice(struct, vmDevice, "");
}
#end_block

#method_before
@Override
public void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName(), "", 0, specParams, true, true, true, "", null, null, null);
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#method_after
@Override
public void buildVmMemoryBalloon() {
    // get vm device for this Balloon from DB
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName());
    for (VmDevice vmDevice : vmDevices) {
        // skip unamanged devices (handled separtely)
        if (!vmDevice.isManaged()) {
            continue;
        }
        addMemBalloonDevice(vmDevice);
        // only one memory balloon should exist
        break;
    }
}
#end_block

#method_before
@Override
public void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        createInfo.put(VdsProperties.maxMemSize, VmCommonUtils.maxMemorySizeWithHotplugInMb(vm));
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    addCpuPinning();
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, "true");
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
@Override
public void buildVmProperties(String hibernationVolHandle) {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        // because QEMU fails if memory and maxMemory are the same
        if (vm.getVmMemSizeMb() != vm.getMaxMemorySizeMb()) {
            createInfo.put(VdsProperties.maxMemSize, vm.getMaxMemorySizeMb());
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    addCpuPinning();
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, "true");
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(hibernationVolHandle)) {
        createInfo.put(VdsProperties.hiberVolHandle, hibernationVolHandle);
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
    if (vm.getLeaseStorageDomainId() != null) {
        buildVmLease();
    }
    if (FeatureSupported.isAgentChannelNamingSupported(vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.agentChannelName, "ovirt-guest-agent.0");
    }
}
#end_block

#method_before
@Override
public void buildVmNetworkCluster() {
    // set Display network
    List<NetworkCluster> all = networkClusterDao.getAllForCluster(vm.getClusterId());
    NetworkCluster networkCluster = null;
    for (NetworkCluster tempNetworkCluster : all) {
        if (tempNetworkCluster.isDisplay()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = networkDao.getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getNetworkId())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.put(VdsProperties.DISPLAY_NETWORK, net.getName());
        }
    }
}
#method_after
@Override
public void buildVmNetworkCluster() {
    // set Display network
    Network net = vmInfoBuildUtils.getDisplayNetwork(vm);
    if (net != null) {
        createInfo.put(VdsProperties.DISPLAY_NETWORK, net.getName());
    }
}
#end_block

#method_before
@Override
public void buildVmTimeZone() {
    // get vm timezone
    String timeZone = getTimeZoneForVm(vm);
    final String javaZoneId;
    if (osRepository.isWindows(vm.getOs())) {
        // convert to java & calculate offset
        javaZoneId = WindowsJavaTimezoneMapping.get(timeZone);
    } else {
        javaZoneId = timeZone;
    }
    int offset = 0;
    if (javaZoneId != null) {
        offset = TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000;
    }
    createInfo.put(VdsProperties.utc_diff, "" + offset);
}
#method_after
@Override
public void buildVmTimeZone() {
    // get vm timezone
    createInfo.put(VdsProperties.utc_diff, "" + vmInfoBuildUtils.getVmTimeZone(vm));
}
#end_block

#method_before
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    vmInfoBuildUtils.addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildUtils.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildUtils.addNetworkFiltersToNic(struct, vmInterface);
}
#method_after
private void addNetworkInterfaceProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String nicModel) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.LINK_ACTIVE, String.valueOf(vmInterface.isLinked()));
    vmInfoBuildUtils.addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    struct.put(VdsProperties.NIC_TYPE, nicModel);
    vmInfoBuildUtils.addProfileDataToNic(struct, vm, vmDevice, vmInterface);
    vmInfoBuildUtils.addNetworkFiltersToNic(struct, vmInterface);
}
#end_block

#method_before
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    vmInfoBuildUtils.addBootOrder(vmDevice, struct);
    devices.add(struct);
    addToManagedDevices(vmDevice);
}
#method_after
private void addDevice(Map<String, Object> struct, VmDevice vmDevice, String path) {
    boolean isPayload = VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevice.getDevice().equals(VmDeviceType.CDROM.getName());
    Map<String, Object> specParams = (vmDevice.getSpecParams() == null) ? Collections.emptyMap() : vmDevice.getSpecParams();
    if (path != null) {
        struct.put(VdsProperties.Path, isPayload ? "" : path);
    }
    if (isPayload) {
        String cdInterface = osRepository.getCdInterface(vm.getOs(), vm.getCompatibilityVersion(), ChipsetType.fromMachineType(vm.getEmulatedMachine()));
        int index = VmDeviceCommonUtils.getCdPayloadDeviceIndex(cdInterface);
        struct.put(VdsProperties.Index, Integer.toString(index));
        if ("scsi".equals(cdInterface)) {
            struct.put(VdsProperties.Address, vmInfoBuildUtils.createAddressForScsiDisk(0, index));
        }
    }
    struct.put(VdsProperties.SpecParams, specParams);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    devices.add(struct);
    bootableDevices.add(vmDevice);
}
#end_block

#method_before
private void addNumaSetting() {
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#method_after
private void addNumaSetting() {
    List<VdsNumaNode> totalVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#end_block

#method_before
private void addVmGraphicsOptions(Map<GraphicsType, GraphicsInfo> infos, Map<String, Object> params) {
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        params.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        params.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
        if (Config.getValue(ConfigValues.SSLEnabled)) {
            params.put(VdsProperties.spiceSslCipherSuite, Config.getValue(ConfigValues.CipherSuite));
            params.put(VdsProperties.SpiceSecureChannels, Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString()));
        }
    }
    if (infos != null && infos.containsKey(GraphicsType.VNC)) {
        String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = vm.getDefaultVncKeyboardLayout();
            if (keyboardLayout == null) {
                keyboardLayout = Config.getValue(ConfigValues.VncKeyboardLayout);
            }
        }
        params.put(VdsProperties.KeyboardMap, keyboardLayout);
    }
}
#method_after
private void addVmGraphicsOptions(Map<GraphicsType, GraphicsInfo> infos, Map<String, Object> params) {
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        params.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        params.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
        if (Config.getValue(ConfigValues.SSLEnabled)) {
            params.put(VdsProperties.SpiceSecureChannels, Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString()));
        }
    }
    if (infos != null && infos.containsKey(GraphicsType.VNC)) {
        String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = vm.getDefaultVncKeyboardLayout();
            if (keyboardLayout == null) {
                keyboardLayout = Config.getValue(ConfigValues.VncKeyboardLayout);
            }
        }
        params.put(VdsProperties.KeyboardMap, keyboardLayout);
    }
}
#end_block

#method_before
private Integer calcMaxVCpu() {
    return VmCpuCountHelper.calcMaxVCpu(vm.getStaticData(), vm.getClusterCompatibilityVersion());
}
#method_after
private Integer calcMaxVCpu() {
    return VmCpuCountHelper.calcMaxVCpu(vm, vm.getClusterCompatibilityVersion());
}
#end_block

#method_before
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new EngineException(EngineError.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        getCinderBroker().updateConnectionInfoForDisk(cinderDisk);
    }
    Map<String, String> diskAddressMap = getDiskAddressMap(vmDevice, getDiskVmElement().getDiskInterface());
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice, diskAddressMap, getDiskVmElement().getDiskInterface()));
}
#method_after
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new EngineException(EngineError.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        getCinderBroker().updateConnectionInfoForDisk(cinderDisk);
    }
    Map<String, String> diskAddressMap = getDiskAddressMap(vmDevice, getDiskVmElement().getDiskInterface());
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice, diskAddressMap, getDiskVmElement().getDiskInterface(), getDiskVmElement().isPassDiscard()));
}
#end_block

#method_before
protected void updateDisksFromDb() {
    VmHandler.updateDisksFromDb(getVm());
}
#method_after
protected void updateDisksFromDb() {
    vmHandler.updateDisksFromDb(getVm());
}
#end_block

#method_before
protected boolean isVmNotInPreviewSnapshot() {
    final SnapshotsValidator snapshotsValidator = getSnapshotsValidator();
    return getVmId() != null && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId()));
}
#method_after
protected boolean isVmNotInPreviewSnapshot() {
    return getVmId() != null && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.vmNotInPreview(getVmId()));
}
#end_block

#method_before
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return XmlRpcStringUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMapForController(vmDevice, vmDeviceUnitMap), vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMapForController(vmDevice, vmDeviceUnitMap), vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            lockManager.releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#method_after
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return StringMapUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMapForController(vmDevice, vmDeviceUnitMap), vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMapForController(vmDevice, vmDeviceUnitMap), vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            lockManager.releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#end_block

#method_before
private Map<VmDevice, Integer> vmDeviceUnitMapForController(VmDevice vmDevice, Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap) {
    int numOfDisks = getVm().getDiskMap() != null ? getVm().getDiskMap().values().size() : 0;
    int controllerId = vmInfoBuildUtils.getControllerForScsiDisk(vmDevice, getVm(), numOfDisks);
    if (!vmDeviceUnitMap.containsKey(controllerId)) {
        return new HashMap<>();
    }
    return vmDeviceUnitMap.get(controllerId);
}
#method_after
private Map<VmDevice, Integer> vmDeviceUnitMapForController(VmDevice vmDevice, Map<Integer, Map<VmDevice, Integer>> vmDeviceUnitMap) {
    int numOfDisks = getVm().getDiskMap().values().size();
    int controllerId = vmInfoBuildUtils.getControllerForScsiDisk(vmDevice, getVm(), numOfDisks);
    if (!vmDeviceUnitMap.containsKey(controllerId)) {
        return new HashMap<>();
    }
    return vmDeviceUnitMap.get(controllerId);
}
#end_block

#method_before
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = XmlRpcStringUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#method_after
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = StringMapUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#end_block

#method_before
private VM mockVm() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    command.setCluster(new Cluster());
    // Avoid referencing the unmockable static VmHandler.updateCurrentCd
    doNothing().when(command).updateCurrentCd(anyString());
    when(snapshotDAO.exists(any(Guid.class), any(SnapshotStatus.class))).thenReturn(false);
    return vm;
}
#method_after
private VM mockVm() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    when(vmDao.get(command.getParameters().getVmId())).thenReturn(vm);
    command.setCluster(new Cluster());
    // Avoid referencing the unmockable static VmHandler.updateCurrentCd
    doNothing().when(command).updateCurrentCd(anyString());
    doReturn(null).when(command).getMemoryFromActiveSnapshot();
    when(snapshotDAO.exists(any(Guid.class), any(SnapshotStatus.class))).thenReturn(false);
    return vm;
}
#end_block

#method_before
@Before
public void setUp() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(anyInt(), any(), any())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    vmHandler.init();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doReturn(Collections.emptyMap()).when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
@Before
public void setUp() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(anyInt(), any(), any())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    vmHandler.init();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doReturn(Collections.emptyMap()).when(command).flushPassthroughVnicToVfMap();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
@Override
public void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        // because QEMU fails if memory and maxMemory are the same
        if (vm.getVmMemSizeMb() != vm.getMaxMemorySizeMb()) {
            createInfo.put(VdsProperties.maxMemSize, vm.getMaxMemorySizeMb());
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    addCpuPinning();
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, "true");
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
    if (vm.getLeaseStorageDomainId() != null) {
        buildVmLease();
    }
    if (FeatureSupported.isAgentChannelNamingSupported(vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.agentChannelName, "ovirt-guest-agent.0");
    }
}
#method_after
@Override
public void buildVmProperties(String hibernationVolHandle) {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        // because QEMU fails if memory and maxMemory are the same
        if (vm.getVmMemSizeMb() != vm.getMaxMemorySizeMb()) {
            createInfo.put(VdsProperties.maxMemSize, vm.getMaxMemorySizeMb());
        }
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    addCpuPinning();
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, "true");
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(hibernationVolHandle)) {
        createInfo.put(VdsProperties.hiberVolHandle, hibernationVolHandle);
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
    if (vm.getLeaseStorageDomainId() != null) {
        buildVmLease();
    }
    if (FeatureSupported.isAgentChannelNamingSupported(vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.agentChannelName, "ovirt-guest-agent.0");
    }
}
#end_block

#method_before
private String getMemoryFromActiveSnapshot() {
    // non coherent with the memory, thus we don't want to try to restore the memory again
    if (memoryFromSnapshotUsed) {
        return StringUtils.EMPTY;
    }
    if (getFlow() == RunVmFlow.RESUME_HIBERNATE) {
        return getActiveSnapshot().getMemoryVolume();
    }
    if (!FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) {
        return StringUtils.EMPTY;
    }
    return getActiveSnapshot().getMemoryVolume();
}
#method_after
protected String getMemoryFromActiveSnapshot() {
    // non coherent with the memory, thus we don't want to try to restore the memory again
    if (memoryFromSnapshotUsed) {
        return StringUtils.EMPTY;
    }
    if (getFlow() == RunVmFlow.RESUME_HIBERNATE) {
        return getActiveSnapshot().getMemoryVolume();
    }
    if (!FeatureSupported.isMemorySnapshotSupportedByArchitecture(getVm().getClusterArch(), getVm().getCompatibilityVersion())) {
        return StringUtils.EMPTY;
    }
    return getActiveSnapshot().getMemoryVolume();
}
#end_block

#method_before
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setPassthroughVnicToVfMap(initParametersForPassthroughVnics());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#method_after
protected CreateVDSCommandParameters buildCreateVmParameters() {
    CreateVDSCommandParameters parameters = new CreateVDSCommandParameters(getVdsId(), getVm());
    parameters.setRunInUnknownStatus(getParameters().isRunInUnknownStatus());
    parameters.setVmPayload(vmPayload);
    parameters.setHibernationVolHandle(getMemoryFromActiveSnapshot());
    parameters.setPassthroughVnicToVfMap(flushPassthroughVnicToVfMap());
    if (initializationType == InitializationType.Sysprep && osRepository.isWindows(getVm().getVmOsId()) && (getVm().getFloppyPath() == null || "".equals(getVm().getFloppyPath()))) {
        parameters.setInitializationType(InitializationType.Sysprep);
    }
    if (initializationType == InitializationType.CloudInit && !osRepository.isWindows(getVm().getVmOsId())) {
        parameters.setInitializationType(InitializationType.CloudInit);
    }
    return parameters;
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    updateVmDevicesOnRun();
    updateGraphicsAndDisplayInfos();
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    updateVmInit();
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        vmPayload = null;
    }
    updateVmGuestAgentVersion();
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getEffectiveEmulatedMachine());
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    updateVmDevicesOnRun();
    updateGraphicsAndDisplayInfos();
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    updateVmInit();
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        vmPayload = null;
    }
    updateVmGuestAgentVersion();
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getEffectiveEmulatedMachine());
    }
}
#end_block

#method_before
private void buildVmData() {
    builder.buildVmProperties();
    builder.buildVmVideoCards();
    builder.buildVmGraphicsDevices();
    builder.buildVmCD(getParameters().getVmPayload());
    builder.buildVmFloppy(getParameters().getVmPayload());
    builder.buildVmDrives();
    builder.buildVmNetworkInterfaces(getParameters().getPassthroughVnicToVfMap());
    builder.buildVmNetworkCluster();
    builder.buildVmBootSequence();
    builder.buildVmBootOptions();
    builder.buildVmSoundDevices();
    builder.buildVmConsoleDevice();
    builder.buildVmTimeZone();
    builder.buildVmUsbDevices();
    builder.buildVmMemoryBalloon();
    builder.buildVmWatchdog();
    builder.buildVmVirtioScsi();
    builder.buildVmVirtioSerial();
    builder.buildVmRngDevice();
    builder.buildUnmanagedDevices();
    builder.buildVmSerialNumber();
    builder.buildVmNumaProperties();
    builder.buildVmHostDevices();
    switch(getParameters().getInitializationType()) {
        case Sysprep:
            String sysPrepContent = SysprepHandler.getSysPrep(getParameters().getVm(), getParameters().getSysPrepParams());
            if (!"".equals(sysPrepContent)) {
                builder.buildSysprepVmPayload(sysPrepContent);
            }
            break;
        case CloudInit:
            CloudInitHandler cloudInitHandler = new CloudInitHandler(getParameters().getVm().getVmInit());
            Map<String, byte[]> cloudInitContent;
            try {
                cloudInitContent = cloudInitHandler.getFileData();
            } catch (Exception e) {
                throw new RuntimeException("Failed to build cloud-init data:", e);
            }
            if (cloudInitContent != null && !cloudInitContent.isEmpty()) {
                builder.buildCloudInitVmPayload(cloudInitContent);
            }
            break;
        case None:
    }
}
#method_after
private void buildVmData() {
    builder.buildVmProperties(getParameters().getHibernationVolHandle());
    builder.buildVmVideoCards();
    builder.buildVmGraphicsDevices();
    builder.buildVmCD(getParameters().getVmPayload());
    builder.buildVmFloppy(getParameters().getVmPayload());
    builder.buildVmDrives();
    builder.buildVmNetworkInterfaces(getParameters().getPassthroughVnicToVfMap());
    builder.buildVmNetworkCluster();
    builder.buildVmBootSequence();
    builder.buildVmBootOptions();
    builder.buildVmSoundDevices();
    builder.buildVmConsoleDevice();
    builder.buildVmTimeZone();
    builder.buildVmUsbDevices();
    builder.buildVmMemoryBalloon();
    builder.buildVmWatchdog();
    builder.buildVmVirtioScsi();
    builder.buildVmVirtioSerial();
    builder.buildVmRngDevice();
    builder.buildUnmanagedDevices();
    builder.buildVmSerialNumber();
    builder.buildVmNumaProperties();
    builder.buildVmHostDevices();
    switch(getParameters().getInitializationType()) {
        case Sysprep:
            String sysPrepContent = SysprepHandler.getSysPrep(getParameters().getVm(), getParameters().getSysPrepParams());
            if (!"".equals(sysPrepContent)) {
                builder.buildSysprepVmPayload(sysPrepContent);
            }
            break;
        case CloudInit:
            CloudInitHandler cloudInitHandler = new CloudInitHandler(getParameters().getVm().getVmInit());
            Map<String, byte[]> cloudInitContent;
            try {
                cloudInitContent = cloudInitHandler.getFileData();
            } catch (Exception e) {
                throw new RuntimeException("Failed to build cloud-init data:", e);
            }
            if (cloudInitContent != null && !cloudInitContent.isEmpty()) {
                builder.buildCloudInitVmPayload(cloudInitContent);
            }
            break;
        case None:
    }
}
#end_block

#method_before
private String getDefaultOrigins() {
    List<VDS> allVds = vdsDao.getAll(getUserID(), getParameters().isFiltered());
    StringBuilder sb = new StringBuilder();
    for (VDS vds : allVds) {
        if (sb.length() > 0) {
            sb.append(',');
        }
        sb.append(HTTPS);
        sb.append(vds.getHostName());
    }
    String result = sb.toString();
    log.debug("Default list of origins refreshed to: {}", result);
    return result;
}
#method_after
private Set<String> getDefaultOrigins() {
    List<VDS> allVds = vdsDao.getAll(getUserID(), getParameters().isFiltered());
    Set<String> allowedOrigins = new HashSet<>();
    if (getParameters().getSuffixes().isEmpty()) {
        allVds.stream().forEach(vds -> allowedOrigins.add(String.format("https://%s", vds.getHostName())));
    } else {
        allVds.stream().forEach(vds -> allowedOrigins.addAll(getHostOrigins(vds.getHostName(), getParameters().getSuffixes())));
    }
    if (log.isDebugEnabled()) {
        log.debug("Default list of origins refreshed to: {}", StringUtils.join(allowedOrigins, ','));
    }
    return allowedOrigins;
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    serviceLoader.load(VmMigrationProgressMonitoring.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    parameters.setRefresh(false);
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetDbUserBySession:
        case GetEngineSessionIdForSsoToken:
        case ValidateSession:
        case GetDefaultAllowedOrigins:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            switch(configParameters.getConfigValue()) {
                case VdcVersion:
                case ProductRPMVersion:
                case ApplicationMode:
                case UserSessionTimeOutInterval:
                case CORSSupport:
                case CORSAllowedOrigins:
                    return runQueryImpl(actionType, parameters, false);
                default:
                    break;
            }
        default:
            break;
    }
    return getErrorQueryReturnValue(EngineMessage.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
}
#method_after
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType actionType, VdcQueryParametersBase parameters) {
    parameters.setRefresh(false);
    switch(actionType) {
        case GetAAAProfileList:
        case RegisterVds:
        case CheckDBConnection:
        case GetDbUserBySession:
        case GetEngineSessionIdForSsoToken:
        case ValidateSession:
        case GetDefaultAllowedOrigins:
            return runQueryImpl(actionType, parameters, false);
        case GetConfigurationValue:
            GetConfigurationValueParameters configParameters = (GetConfigurationValueParameters) parameters;
            switch(configParameters.getConfigValue()) {
                case VdcVersion:
                case ProductRPMVersion:
                case ApplicationMode:
                case UserSessionTimeOutInterval:
                case CORSSupport:
                case CORSAllowedOrigins:
                case CORSAllowDefaultOrigins:
                case CORSDefaultOriginSuffixes:
                    return runQueryImpl(actionType, parameters, false);
                default:
                    break;
            }
        default:
            break;
    }
    return getErrorQueryReturnValue(EngineMessage.USER_CANNOT_RUN_QUERY_NOT_PUBLIC);
}
#end_block

#method_before
@Override
public void init(final FilterConfig config) throws ServletException {
    this.config = config;
}
#method_after
@Override
public void init(final FilterConfig config) throws ServletException {
    this.config = config;
    this.enabled = (Boolean) getBackendParameter(ConfigurationValues.CORSSupport);
    this.enabledDefaultOrigins = (Boolean) getBackendParameter(ConfigurationValues.CORSAllowDefaultOrigins);
    String sufficesFromConf = StringUtils.defaultString((String) getBackendParameter(ConfigurationValues.CORSDefaultOriginSuffixes), "");
    this.defaultOriginsSuffixes = new HashSet<>(Arrays.asList(sufficesFromConf.split(",")));
}
#end_block

#method_before
private String mergeOrigins(String fromConfig, String fromDefault) {
    if ("*".equals(fromConfig)) {
        return fromConfig;
    }
    if (StringUtils.isEmpty(fromConfig)) {
        return fromDefault;
    }
    return fromConfig + "," + fromDefault;
}
#method_after
private String mergeOrigins(String fromConfig, Set<String> fromDefault) {
    if ("*".equals(fromConfig)) {
        return fromConfig;
    }
    if (StringUtils.isEmpty(fromConfig)) {
        return StringUtils.join(fromDefault, ',');
    }
    return fromConfig + "," + StringUtils.join(fromDefault, ',');
}
#end_block

#method_before
private Object getBackendParameter(final ConfigurationValues key) throws ServletException {
    final GetConfigurationValueParameters parameters = new GetConfigurationValueParameters();
    parameters.setConfigValue(key);
    parameters.setVersion(ConfigCommon.defaultConfigurationVersion);
    if (backend == null) {
        // TODO: remove when fixed for enginesso.war
        log.error("--- backend is null");
    }
    log.info("VdcQueryType.GetConfigurationValue: " + VdcQueryType.GetConfigurationValue);
    VdcQueryReturnValue value = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, parameters);
    if (!value.getSucceeded()) {
        throw new ServletException("Can't get value of backend parameter \"" + key + "\".");
    }
    return value.getReturnValue();
}
#method_after
private Object getBackendParameter(final ConfigurationValues key) throws ServletException {
    final GetConfigurationValueParameters parameters = new GetConfigurationValueParameters();
    parameters.setConfigValue(key);
    parameters.setVersion(ConfigCommon.defaultConfigurationVersion);
    VdcQueryReturnValue value = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, parameters);
    if (!value.getSucceeded()) {
        throw new ServletException("Can't get value of backend parameter \"" + key + "\".");
    }
    return value.getReturnValue();
}
#end_block

#method_before
private String getDefaultAllowedOrigins() throws ServletException {
    VdcQueryReturnValue value = backend.runPublicQuery(VdcQueryType.GetDefaultAllowedOrigins, new VdcQueryParametersBase());
    if (!value.getSucceeded()) {
        throw new ServletException("Can't get list of default origins");
    }
    return value.getReturnValue();
}
#method_after
private Set<String> getDefaultAllowedOrigins() throws ServletException {
    if (this.enabledDefaultOrigins) {
        GetDefaultAllowedOriginsQueryParameters parameters = new GetDefaultAllowedOriginsQueryParameters();
        parameters.addSuffixes(defaultOriginsSuffixes);
        VdcQueryReturnValue value = backend.runPublicQuery(VdcQueryType.GetDefaultAllowedOrigins, parameters);
        if (!value.getSucceeded()) {
            throw new ServletException("Can't get list of default origins");
        }
        if (log.isDebugEnabled()) {
            log.debug("Origins allowed by default: {}", StringUtils.join((Set<String>) value.getReturnValue(), ','));
        }
        return value.getReturnValue();
    }
    return EMPTY_SET;
}
#end_block

#method_before
public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {
    // reinitialize if needed - new CORSFilter needs to be created with new params
    if (isCORSSupport) {
        synchronized (this) {
            if (initialized) {
                // for performance reasons, check for changes at most once per time period
                long now = System.currentTimeMillis();
                if (lastInitializationTime + delayBeforeReinit < now) {
                    // force reinitialization;
                    initialized = false;
                    lastInitializationTime = now;
                }
            }
        }
    }
    // Perform lazy initialization, if needed:
    if (!initialized) {
        synchronized (this) {
            if (!initialized) {
                lazyInit();
                initialized = true;
            }
        }
    }
    // Do the filtering if needed:
    if (delegate != null) {
        delegate.doFilter(request, response, chain);
    } else {
        chain.doFilter(request, response);
    }
}
#method_after
public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {
    // reinitialize if needed - new CORSFilter needs to be created with new params
    if (delegate != null) {
        // is CORSSupport enabled by engine-config ?
        if (initialized) {
            // for performance reasons, check for changes at most once per time period
            long now = System.currentTimeMillis();
            if (lastInitializationTime + delayBeforeReinit < now) {
                synchronized (this) {
                    // force reinitialization
                    initialized = false;
                }
                lastInitializationTime = now;
            }
        }
    }
    // Perform lazy initialization, if needed:
    if (!initialized) {
        synchronized (this) {
            if (!initialized) {
                createDelegate();
                initialized = true;
            }
        }
    }
    // Do the filtering if needed:
    if (delegate != null) {
        delegate.doFilter(request, response, chain);
    } else {
        chain.doFilter(request, response);
    }
}
#end_block

#method_before
private void generateAddHttpPost(Method method) {
    // Get the parameters:
    Parameter primaryParameter = getFirstParameter(method);
    List<Parameter> secondaryParameters = getSecondaryParameters(method);
    // Begin method:
    Name methodName = method.getName();
    Name primaryParameterName = primaryParameter.getName();
    String primaryArg = pythonNames.getMemberStyleName(primaryParameterName);
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(methodName));
    buffer.startBlock();
    buffer.addLine("self,");
    buffer.addLine("%1$s,", primaryArg);
    secondaryParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    buffer.startBlock();
    generateActionDoc(method, (Parameter p) -> p.isIn() && p.isOut());
    buffer.endBlock();
    // Start body:
    buffer.startBlock();
    // Generate the code to check the type of the parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    generateCheckTypeTuple(primaryParameter);
    secondaryParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL query:
    buffer.addLine("# Build the URL:");
    buffer.addLine("query = query or {}");
    secondaryParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the code to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(method='POST', path=self._path, query=query, headers=headers or {})");
    generateWriteRequestBody(primaryParameter, primaryArg);
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200, 201, 202]:");
    buffer.startBlock();
    generateReturnResponseBody(primaryParameter);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#method_after
private void generateAddHttpPost(Method method) {
    // Get the parameters:
    Parameter primaryParameter = getFirstParameter(method);
    List<Parameter> secondaryParameters = getSecondaryParameters(method);
    // Begin method:
    Name methodName = method.getName();
    Name primaryParameterName = primaryParameter.getName();
    String primaryArg = pythonNames.getMemberStyleName(primaryParameterName);
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(methodName));
    buffer.startBlock();
    buffer.addLine("self,");
    buffer.addLine("%1$s,", primaryArg);
    secondaryParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    buffer.startBlock();
    generateActionDoc(method, (Parameter p) -> p.isIn() && p.isOut());
    buffer.endBlock();
    // Start body:
    buffer.startBlock();
    // Generate the code to check the type of the parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    generateCheckTypeTuple(primaryParameter);
    secondaryParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL query:
    buffer.addLine("# Build the URL:");
    buffer.addLine("query = query or {}");
    secondaryParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the code to build the headers:
    buffer.addLine("# Populate the headers:");
    buffer.addLine("headers = headers or {}");
    buffer.addLine();
    // Generate the code to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(method='POST', path=self._path, query=query, headers=headers)");
    generateWriteRequestBody(primaryParameter, primaryArg);
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200, 201, 202]:");
    buffer.startBlock();
    generateReturnResponseBody(primaryParameter);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#end_block

#method_before
private void generateActionHttpPost(Method method) {
    // Get the input parameters:
    List<Parameter> inParameters = method.parameters().filter(Parameter::isIn).sorted().collect(toList());
    // Begin method:
    Name name = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(name));
    buffer.startBlock();
    buffer.addLine("self,");
    inParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    generateActionDoc(method, Parameter::isIn);
    // Generate the code to check type types of the parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    inParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to populate the action:
    buffer.addLine("# Populate the action:");
    buffer.addLine("action = types.Action(");
    buffer.startBlock();
    inParameters.forEach(this::generateSetActionAttribute);
    buffer.endBlock();
    buffer.addLine(")");
    buffer.addLine();
    // Generate the code to build the request body:
    buffer.addLine("# Build the request body:");
    buffer.addLine("buf = io.BytesIO()");
    buffer.addLine("writer = xml.XmlWriter(buf, indent=True)");
    buffer.addLine("writers.ActionWriter.write_one(action, writer)");
    buffer.addLine("writer.flush()");
    buffer.addLine("body = buf.getvalue()");
    buffer.addLine("writer.close()");
    buffer.addLine("buf.close()");
    buffer.addLine();
    // Generate the code to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(");
    buffer.startBlock();
    buffer.addLine("method='POST',");
    buffer.addLine("path='%%s/%%s' %% (self._path, '%1$s'),", getPath(name));
    buffer.addLine("body=body,");
    buffer.addLine("query=query,");
    buffer.addLine("headers=headers or {},");
    buffer.endBlock();
    buffer.addLine(")");
    buffer.addLine("response = self._connection.send(request)");
    generateActionResponse(method);
    // End method:
    buffer.endBlock();
    buffer.addLine();
}
#method_after
private void generateActionHttpPost(Method method) {
    // Get the input parameters:
    List<Parameter> inParameters = method.parameters().filter(Parameter::isIn).sorted().collect(toList());
    // Begin method:
    Name name = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(name));
    buffer.startBlock();
    buffer.addLine("self,");
    inParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    generateActionDoc(method, Parameter::isIn);
    // Generate the code to check type types of the parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    inParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to populate the action:
    buffer.addLine("# Populate the action:");
    buffer.addLine("action = types.Action(");
    buffer.startBlock();
    inParameters.forEach(this::generateSetActionAttribute);
    buffer.endBlock();
    buffer.addLine(")");
    buffer.addLine();
    // Generate the code to build the request body:
    buffer.addLine("# Build the request body:");
    buffer.addLine("buf = io.BytesIO()");
    buffer.addLine("writer = xml.XmlWriter(buf, indent=True)");
    buffer.addLine("writers.ActionWriter.write_one(action, writer)");
    buffer.addLine("writer.flush()");
    buffer.addLine("body = buf.getvalue()");
    buffer.addLine("writer.close()");
    buffer.addLine("buf.close()");
    buffer.addLine();
    // Generate the code to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(");
    buffer.startBlock();
    buffer.addLine("method='POST',");
    buffer.addLine("path='%%s/%%s' %% (self._path, '%1$s'),", getPath(name));
    buffer.addLine("body=body,");
    buffer.addLine("query=query,");
    buffer.addLine("headers=headers,");
    buffer.endBlock();
    buffer.addLine(")");
    buffer.addLine("response = self._connection.send(request)");
    generateActionResponse(method);
    // End method:
    buffer.endBlock();
    buffer.addLine();
}
#end_block

#method_before
private void generateHttpGet(Method method) {
    // Get the input parameters:
    List<Parameter> inParameters = method.parameters().filter(Parameter::isIn).sorted().collect(toList());
    // Get the output parameter:
    Parameter outParameter = method.parameters().filter(Parameter::isOut).findFirst().orElse(null);
    // Begin method:
    Name methodName = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(methodName));
    buffer.startBlock();
    buffer.addLine("self,");
    inParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    generateActionDoc(method, Parameter::isIn);
    // Generate the code to check the types of the input parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    inParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL:
    buffer.addLine("# Build the URL:");
    buffer.addLine("query = query or {}");
    inParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the code to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(method='GET', path=self._path, query=query, headers=headers or {})");
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200]:");
    buffer.startBlock();
    generateReturnResponseBody(outParameter);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#method_after
private void generateHttpGet(Method method) {
    // Get the input parameters:
    List<Parameter> inParameters = method.parameters().filter(Parameter::isIn).sorted().collect(toList());
    // Get the output parameter:
    Parameter outParameter = method.parameters().filter(Parameter::isOut).findFirst().orElse(null);
    // Begin method:
    Name methodName = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(methodName));
    buffer.startBlock();
    buffer.addLine("self,");
    inParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    generateActionDoc(method, Parameter::isIn);
    // Generate the code to check the types of the input parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    inParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL query:
    buffer.addLine("# Build the URL:");
    buffer.addLine("query = query or {}");
    inParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the code to build the headers:
    buffer.addLine("# Populate the headers:");
    buffer.addLine("headers = headers or {}");
    buffer.addLine();
    // Generate the code to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(method='GET', path=self._path, query=query, headers=headers)");
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200]:");
    buffer.startBlock();
    generateReturnResponseBody(outParameter);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#end_block

#method_before
private void generateHttpPut(Method method) {
    // Classify the parameters:
    Parameter primaryParameter = getFirstParameter(method);
    List<Parameter> secondaryParameters = getSecondaryParameters(method);
    // Begin method:
    Name methodName = method.getName();
    Name primaryParameterName = primaryParameter.getName();
    String primaryArg = pythonNames.getMemberStyleName(primaryParameterName);
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(methodName));
    buffer.startBlock();
    buffer.addLine("self,");
    buffer.addLine("%1$s,", primaryArg);
    getSecondaryParameters(method).forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    generateActionDoc(method, (Parameter p) -> p.isIn() && p.isOut());
    // Generate the code to check the types of the input parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    generateCheckTypeTuple(primaryParameter);
    secondaryParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code the build the query URL from the input parameters:
    buffer.addLine("query = query or {}");
    getSecondaryParameters(method).forEach(this::generateUrlParameter);
    // Body:
    buffer.addLine("request = http.Request(method='PUT', path=self._path, query=query, headers=headers or {})");
    generateWriteRequestBody(primaryParameter, primaryArg);
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200]:");
    buffer.startBlock();
    generateReturnResponseBody(primaryParameter);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#method_after
private void generateHttpPut(Method method) {
    // Classify the parameters:
    Parameter primaryParameter = getFirstParameter(method);
    List<Parameter> secondaryParameters = getSecondaryParameters(method);
    // Begin method:
    Name methodName = method.getName();
    Name primaryParameterName = primaryParameter.getName();
    String primaryArg = pythonNames.getMemberStyleName(primaryParameterName);
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(methodName));
    buffer.startBlock();
    buffer.addLine("self,");
    buffer.addLine("%1$s,", primaryArg);
    getSecondaryParameters(method).forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Start body:
    buffer.startBlock();
    generateActionDoc(method, (Parameter p) -> p.isIn() && p.isOut());
    // Generate the code to check the types of the input parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    generateCheckTypeTuple(primaryParameter);
    secondaryParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL query:
    buffer.addLine("# Build the URL:");
    buffer.addLine("query = query or {}");
    secondaryParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the code to build the headers:
    buffer.addLine("# Populate the headers:");
    buffer.addLine("headers = headers or {}");
    buffer.addLine();
    // Body:
    buffer.addLine("request = http.Request(method='PUT', path=self._path, query=query, headers=headers)");
    generateWriteRequestBody(primaryParameter, primaryArg);
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code in [200]:");
    buffer.startBlock();
    generateReturnResponseBody(primaryParameter);
    buffer.endBlock();
    buffer.addLine("else:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#end_block

#method_before
private void generateHttpDelete(Method method) {
    // Get the parameters:
    List<Parameter> inParameters = method.parameters().filter(Parameter::isIn).collect(toList());
    // Begin method:
    Name name = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(name));
    buffer.startBlock();
    buffer.addLine("self,");
    inParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Begin body:
    buffer.startBlock();
    generateActionDoc(method, Parameter::isIn);
    // Generate the code to check the types of the input parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    inParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL query from the input parameters:
    buffer.addLine("# Build the URL query:");
    buffer.addLine("query = query or {}");
    inParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the method to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(method='DELETE', path=self._path, query=query, headers=headers or {})");
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code not in [200]:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#method_after
private void generateHttpDelete(Method method) {
    // Get the parameters:
    List<Parameter> inParameters = method.parameters().filter(Parameter::isIn).collect(toList());
    // Begin method:
    Name name = method.getName();
    buffer.addLine("def %1$s(", pythonNames.getMemberStyleName(name));
    buffer.startBlock();
    buffer.addLine("self,");
    inParameters.forEach(this::generateFormalParameter);
    buffer.addLine("headers=None,");
    buffer.addLine("query=None,");
    buffer.endBlock();
    buffer.addLine("):");
    // Begin body:
    buffer.startBlock();
    generateActionDoc(method, Parameter::isIn);
    // Generate the code to check the types of the input parameters:
    buffer.addLine("# Check the types of the parameters:");
    buffer.addLine("Service._check_types([");
    buffer.startBlock();
    inParameters.forEach(this::generateCheckTypeTuple);
    buffer.endBlock();
    buffer.addLine("])");
    buffer.addLine();
    // Generate the code to build the URL query:
    buffer.addLine("# Build the URL:");
    buffer.addLine("query = query or {}");
    inParameters.forEach(this::generateUrlParameter);
    buffer.addLine();
    // Generate the code to build the headers:
    buffer.addLine("# Populate the headers:");
    buffer.addLine("headers = headers or {}");
    buffer.addLine();
    // Generate the method to send the request and wait for the response:
    buffer.addLine("# Send the request and wait for the response:");
    buffer.addLine("request = http.Request(method='DELETE', path=self._path, query=query, headers=headers)");
    buffer.addLine("response = self._connection.send(request)");
    buffer.addLine("if response.code not in [200]:");
    buffer.startBlock();
    buffer.addLine("self._check_fault(response)");
    buffer.endBlock();
    // End body:
    buffer.endBlock();
    buffer.addLine();
}
#end_block

#method_before
private String messageFormatter(String msg, String vmid) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(vmid.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(vmid.toString(), vmDetailNode);
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", "|virt|VM_status|" + vmid);
    return node.toString();
}
#method_after
private String messageFormatter(String msg, String vmid) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(vmid.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(vmid.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", "|virt|VM_status|" + vmid);
    return node.toString();
}
#end_block

#method_before
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    ExecutorService executor = Executors.newFixedThreadPool(5);
    Future<Void> future = (Future<Void>) executor.submit(() -> {
        try {
            // simulate real life delays.
            TimeUnit.MILLISECONDS.sleep(delay);
            vm.setStatus(status);
            sendNotification(msg, vm.getId(), removeClient);
            log.info("VM {} set to {}", vm.getId(), msg);
            // update host if required
            if (isUpdateRequired(status)) {
                VdsmManager.getInstance().updateHost(vm.getHost());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    });
    try {
        future.get();
    } catch (ExecutionException e) {
        e.printStackTrace();
    }
}
#method_after
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(() -> {
        try {
            vm.setStatus(status);
            sendNotification(msg, vm.getId(), removeClient);
            log.info("VM {} set to {}", vm.getId(), msg);
            // update host if required
            if (isUpdateRequired(status)) {
                VdsmManager.getInstance().updateHost(vm.getHost());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }, delay, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
public Map create(Map vmParams) {
    try {
        final Host host = getActiveHost();
        final String vmId = (String) vmParams.get("vmId");
        final VM vm = new VM();
        vm.setTimeCreated(System.currentTimeMillis());
        vm.setId(vmId);
        vm.setName((String) vmParams.get("vmName"));
        vm.setCpuType((String) vmParams.get("cpuType"));
        vm.setHost(host);
        vm.setIp(Utils.ipGenerator());
        Integer memSize = 0;
        Object boxedMemSize = vmParams.get("memSize");
        if (boxedMemSize instanceof String) {
            memSize = Integer.parseInt((String) boxedMemSize);
        } else {
            memSize = (Integer) boxedMemSize;
        }
        vm.setMemSize(memSize);
        final Object[] devices = (Object[]) vmParams.get("devices");
        vm.setDeviceList(devices == null ? new ArrayList() : Arrays.asList(devices));
        Map custom = (Map) vmParams.get("custom");
        vm.setCustomMap(custom != null ? custom : map());
        // append address tag when missing by the device
        vm.generateDevicesAddressIfMissing();
        // convert Maps to important Device objects
        vm.parseDevices();
        host.getRunningVMs().put(vm.getId(), vm);
        // persist
        updateHost(host);
        final Map resultMap = getDoneStatus();
        // WaitForLaunch
        vmParams.put("status", vm.getStatus().toString());
        resultMap.put("vmList", vmParams);
        log.debug("VM {} created on host {}", vmId, host.getName());
        addTask(TaskType.START_VM, 2000l, vm);
        addTask(TaskType.START_VM_POWERING_UP, 5000l, vm);
        addTask(TaskType.START_VM_AS_UP, 19000l, vm);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map create(Map vmParams) {
    try {
        final Host host = getActiveHost();
        final String vmId = (String) vmParams.get("vmId");
        final VM vm = new VM();
        vm.setTimeCreated(System.currentTimeMillis());
        vm.setId(vmId);
        vm.setName((String) vmParams.get("vmName"));
        vm.setCpuType((String) vmParams.get("cpuType"));
        vm.setHost(host);
        vm.setIp(Utils.ipGenerator());
        Integer memSize = 0;
        Object boxedMemSize = vmParams.get("memSize");
        if (boxedMemSize instanceof String) {
            memSize = Integer.parseInt((String) boxedMemSize);
        } else {
            memSize = (Integer) boxedMemSize;
        }
        vm.setMemSize(memSize);
        final Object[] devices = (Object[]) vmParams.get("devices");
        vm.setDeviceList(devices == null ? new ArrayList() : Arrays.asList(devices));
        Map custom = (Map) vmParams.get("custom");
        vm.setCustomMap(custom != null ? custom : map());
        // append address tag when missing by the device
        vm.generateDevicesAddressIfMissing();
        // convert Maps to important Device objects
        vm.parseDevices();
        host.getRunningVMs().put(vm.getId(), vm);
        // persist
        updateHost(host);
        final Map resultMap = getDoneStatus();
        // WaitForLaunch
        vmParams.put("status", vm.getStatus().toString());
        resultMap.put("vmList", vmParams);
        log.debug("VM {} created on host {}", vmId, host.getName());
        addTask(TaskType.START_VM, 2000l, vm);
        addTask(TaskType.START_VM_POWERING_UP, 3000l, vm);
        addTask(TaskType.START_VM_AS_UP, 20000l, vm);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
private String messageFormatter(String msg, String vmid, String module, String callType) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(vmid.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(vmid.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", "|" + module + "|" + callType + "|" + vmid);
    return node.toString();
}
#method_after
private String messageFormatter(String msg, String id, String method) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(id.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(id.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", method);
    return node.toString();
}
#end_block

#method_before
private void sendNotification(String message, String vmId, boolean removeClient, String module, String callType) throws ClientConnectionException {
    if (message == null) {
        log.warn("empty message has arrived, ignore empty messages");
    }
    send(messageFormatter(message, vmId, module, callType), vmId, removeClient);
}
#method_after
private void sendNotification(String message, String id, boolean removeClient, String method) throws ClientConnectionException {
    if (message == null) {
        log.warn("empty message has arrived, ignore empty messages");
    }
    send(messageFormatter(message, id, method), id, removeClient);
}
#end_block

#method_before
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        // TODO: Should be changed in the json RPC project.
        ((StompCommonClient) client).send((new Message()).message().withHeader("destination", "jms.queue.events").withContent(message.getBytes()).build());
        log.debug("sending events message {}", message);
    } catch (Exception e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#method_after
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        ((StompCommonClient) client).send((new Message()).message().withHeader("destination", "jms.queue.events").withContent(message.getBytes()).build());
        log.debug("sending events message {}", message);
    } catch (Exception e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#end_block

#method_before
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(new Callable() {

        public Object call() throws Exception {
            try {
                vm.setStatus(status);
                sendNotification(msg, vm.getId(), removeClient, "virt", "VM_status");
                log.info("VM {} set to {}", vm.getId(), msg);
                // update host if required
                if (isUpdateRequired(status)) {
                    VdsmManager.getInstance().updateHost(vm.getHost());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return null;
        }
    }, delay, TimeUnit.MILLISECONDS);
}
#method_after
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(() -> {
        try {
            vm.setStatus(status);
            sendNotification(msg, vm.getId(), removeClient, "|virt|VM_status|" + vm.getId());
            log.info("VM {} set to {}", vm.getId(), msg);
            // update host if required
            if (isUpdateRequired(status)) {
                VdsmManager.getInstance().updateHost(vm.getHost());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }, delay, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
private String messageFormatter(String msg, String vmid, String module, String callType) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(vmid.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(vmid.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", "|" + module + "|" + callType + "|" + vmid);
    return node.toString();
}
#method_after
private String messageFormatter(String msg, String id, String method) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(id.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(id.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", method);
    return node.toString();
}
#end_block

#method_before
private void sendNotification(String message, String vmId, boolean removeClient, String module, String callType) throws ClientConnectionException {
    if (message == null) {
        log.warn("empty message has arrived, ignore empty messages");
    }
    send(messageFormatter(message, vmId, module, callType), vmId, removeClient);
}
#method_after
private void sendNotification(String message, String id, boolean removeClient, String method) throws ClientConnectionException {
    if (message == null) {
        log.warn("empty message has arrived, ignore empty messages");
    }
    send(messageFormatter(message, id, method), id, removeClient);
}
#end_block

#method_before
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        // TODO: Should be changed in the json RPC project.
        ((StompCommonClient) client).send((new Message()).message().withHeader("destination", "jms.queue.events").withContent(message.getBytes()).build());
        log.debug("sending events message {}", message);
    } catch (Exception e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#method_after
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        ((StompCommonClient) client).send((new Message()).message().withHeader("destination", "jms.queue.events").withContent(message.getBytes()).build());
        log.debug("sending events message {}", message);
    } catch (Exception e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#end_block

#method_before
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(new Callable() {

        public Object call() throws Exception {
            try {
                vm.setStatus(status);
                sendNotification(msg, vm.getId(), removeClient, "virt", "VM_status");
                log.info("VM {} set to {}", vm.getId(), msg);
                // update host if required
                if (isUpdateRequired(status)) {
                    VdsmManager.getInstance().updateHost(vm.getHost());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return null;
        }
    }, delay, TimeUnit.MILLISECONDS);
}
#method_after
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(() -> {
        try {
            vm.setStatus(status);
            sendNotification(msg, vm.getId(), removeClient, "|virt|VM_status|" + vm.getId());
            log.info("VM {} set to {}", vm.getId(), msg);
            // update host if required
            if (isUpdateRequired(status)) {
                VdsmManager.getInstance().updateHost(vm.getHost());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }, delay, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
private String messageFormatter(String msg, String id, String module, String callType) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(id.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(id.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", "|" + module + "|" + callType + "|" + id);
    return node.toString();
}
#method_after
private String messageFormatter(String msg, String id, String method) {
    ObjectNode vmDetailNode = new ObjectMapper().createObjectNode();
    vmDetailNode.put("status", msg);
    vmDetailNode.put("hash", Integer.toString(id.hashCode()));
    ObjectNode paramsNode = new ObjectMapper().createObjectNode();
    paramsNode.put(id.toString(), vmDetailNode);
    paramsNode.put("notify_time", System.nanoTime());
    ObjectNode node = new ObjectMapper().createObjectNode();
    node.put("params", paramsNode);
    node.put("jsonrpc", "2.0");
    node.put("method", method);
    return node.toString();
}
#end_block

#method_before
private void sendNotification(String message, String id, boolean removeClient, String module, String callType) throws ClientConnectionException {
    if (message == null) {
        log.warn("empty message has arrived, ignore empty messages");
    }
    send(messageFormatter(message, id, module, callType), id, removeClient);
}
#method_after
private void sendNotification(String message, String id, boolean removeClient, String method) throws ClientConnectionException {
    if (message == null) {
        log.warn("empty message has arrived, ignore empty messages");
    }
    send(messageFormatter(message, id, method), id, removeClient);
}
#end_block

#method_before
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        // TODO: Should be changed in the json RPC project.
        ((StompCommonClient) client).send((new Message()).message().withHeader("destination", "jms.queue.events").withContent(message.getBytes()).build());
        log.debug("sending events message {}", message);
    } catch (Exception e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#method_after
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        ((StompCommonClient) client).send((new Message()).message().withHeader("destination", "jms.queue.events").withContent(message.getBytes()).build());
        log.debug("sending events message {}", message);
    } catch (Exception e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#end_block

#method_before
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(new Callable() {

        public Object call() throws Exception {
            try {
                vm.setStatus(status);
                sendNotification(msg, vm.getId(), removeClient, "virt", "VM_status");
                log.info("VM {} set to {}", vm.getId(), msg);
                // update host if required
                if (isUpdateRequired(status)) {
                    VdsmManager.getInstance().updateHost(vm.getHost());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            return null;
        }
    }, delay, TimeUnit.MILLISECONDS);
}
#method_after
// TODO: enlarge this method to support cross entities objects such as storage, hosts (currently BaseObject not
private void vmUpdateStatus(final VM vm, final VM.VMStatus status, final long delay, final String msg, final boolean removeClient) throws InterruptedException {
    scheduledExecutorService.schedule(() -> {
        try {
            vm.setStatus(status);
            sendNotification(msg, vm.getId(), removeClient, "|virt|VM_status|" + vm.getId());
            log.info("VM {} set to {}", vm.getId(), msg);
            // update host if required
            if (isUpdateRequired(status)) {
                VdsmManager.getInstance().updateHost(vm.getHost());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }, delay, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
private boolean isUpdateRequired(VM.VMStatus status) {
    // list of statuses which required vdsm update {up, poweringdown, paused}
    if (status == VM.VMStatus.Up || status == VM.VMStatus.PoweringDown || status == VM.VMStatus.Paused) {
        return true;
    }
    return false;
}
#method_after
private boolean isUpdateRequired(VM.VMStatus status) {
    // list of statuses which required vdsm update {up, poweringdown, paused}
    switch(status) {
        case Up:
        case PoweringDown:
        case Paused:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
@Test
public void testLinkHrefAttributeAndElement() {
    V4Vm vm = objectFromXml("<vm><link rel=\"permissions\" href=\"123\"/><permissions><permission id=\"456\"/></permissions></vm>");
    assertNotNull(vm);
    assertNotNull(vm.permissions());
    assertTrue(vm.permissions() instanceof ListWithHref);
    assertTrue(vm.permissions().size() > 0);
    assertEquals("123", ((ListWithHref) vm.permissions()).href());
    assertEquals("456", vm.permissions().get(0).id());
}
#method_after
@Test
public void testLinkHrefAttributeAndElement() {
    V4Vm vm = objectFromXml("<vm><permissions><permission id=\"456\"/></permissions><link rel=\"permissions\" href=\"123\"/></vm>");
    assertNotNull(vm);
    assertNotNull(vm.permissions());
    assertTrue(vm.permissions() instanceof ListWithHref);
    assertTrue(vm.permissions().size() > 0);
    assertEquals("123", ((ListWithHref) vm.permissions()).href());
    assertEquals("456", vm.permissions().get(0).id());
}
#end_block

#method_before
private void generateProcessLink(StructType type) {
    // Get the type and container name:
    JavaClassName containerName = javaTypes.getContainerName(type);
    javaBuffer.addImport(ArrayListWithHref.class);
    javaBuffer.addImport(ListWithHref.class);
    javaBuffer.addLine("private static void processLink(%1$s object, Map.Entry<String, String> link) {", containerName.getSimpleName());
    List<Link> links = type.links().sorted().filter(link -> link.getType() instanceof ListType).collect(toList());
    if (!links.isEmpty()) {
        javaBuffer.addLine("// Process the attributes:");
        javaBuffer.addLine("String rel = link.getKey();");
        javaBuffer.addLine("String href = link.getValue();");
        javaBuffer.addLine("if (href != null) {");
        javaBuffer.addLine("switch (rel) {");
        links.forEach(link -> {
            String field = javaNames.getJavaMemberStyleName(link.getName());
            String rel = link.getName().words().map(String::toLowerCase).collect(joining());
            javaBuffer.addLine("case \"%1$s\":", rel);
            javaBuffer.addLine("ListWithHref list = new ArrayListWithHref(object.%1$s());", field);
            javaBuffer.addLine("list.href(href);");
            javaBuffer.addLine("object.%1$s(list);", field);
            javaBuffer.addLine("break;");
        });
        javaBuffer.addLine("default:");
        javaBuffer.addLine("break;");
        // End switch
        javaBuffer.addLine("}");
        // End if
        javaBuffer.addLine("}");
    }
    // End method
    javaBuffer.addLine("}");
}
#method_after
private void generateProcessLink(StructType type) {
    // Get the type and container name:
    JavaClassName containerName = javaTypes.getContainerName(type);
    javaBuffer.addImport(ArrayListWithHref.class);
    javaBuffer.addImport(ListWithHref.class);
    javaBuffer.addLine("private static void processLink(%1$s object, String[] link) {", containerName.getSimpleName());
    List<Link> links = type.links().sorted().filter(link -> link.getType() instanceof ListType).collect(toList());
    if (!links.isEmpty()) {
        javaBuffer.addLine("// Process the attributes:");
        javaBuffer.addLine("String rel = link[0];");
        javaBuffer.addLine("String href = link[1];");
        javaBuffer.addLine("if (href != null) {");
        javaBuffer.addLine("switch (rel) {");
        links.forEach(link -> {
            String field = javaNames.getJavaMemberStyleName(link.getName());
            String rel = link.getName().words().map(String::toLowerCase).collect(joining());
            javaBuffer.addLine("case \"%1$s\":", rel);
            javaBuffer.addLine("ListWithHref list = new ArrayListWithHref(object.%1$s());", field);
            javaBuffer.addLine("list.href(href);");
            javaBuffer.addLine("object.%1$s(list);", field);
            javaBuffer.addLine("break;");
        });
        javaBuffer.addLine("default:");
        javaBuffer.addLine("break;");
        // End switch
        javaBuffer.addLine("}");
        // End if
        javaBuffer.addLine("}");
    }
    // End method
    javaBuffer.addLine("}");
}
#end_block

#method_before
private void generateStructReadOne(StructType type) {
    // Get the type and container name:
    JavaClassName typeName = javaTypes.getInterfaceName(type);
    JavaClassName containerName = javaTypes.getContainerName(type);
    // Add the required imports:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(containerName);
    javaBuffer.addImport(XmlReader.class);
    javaBuffer.addImport(Map.class);
    javaBuffer.addImport(HashMap.class);
    // Generate the method:
    List<StructMember> allMembers = new ArrayList<>();
    allMembers.addAll(type.getAttributes());
    allMembers.addAll(type.getLinks());
    List<StructMember> asAttributes = allMembers.stream().filter(x -> schemaNames.isRepresentedAsAttribute(x.getName())).collect(toList());
    List<StructMember> asElements = allMembers.stream().filter(x -> !schemaNames.isRepresentedAsAttribute(x.getName())).collect(toList());
    javaBuffer.addLine("public static %1$s readOne(XmlReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("// Do nothing if there aren't more tags:");
    javaBuffer.addLine("if (!reader.forward()) {");
    javaBuffer.addLine("return null;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("// Create the object:");
    javaBuffer.addLine("%1$s object = new %1$s();", containerName.getSimpleName());
    javaBuffer.addLine();
    if (!asAttributes.isEmpty()) {
        javaBuffer.addLine("// Process the attributes:");
        javaBuffer.addLine("for (int i = 0; i < reader.getAttributeCount(); i++) {");
        javaBuffer.addLine("String name = reader.getAttributeLocalName(i);");
        javaBuffer.addLine("String image = reader.getAttributeValue(i);");
        javaBuffer.addLine("switch (name) {");
        asAttributes.stream().sorted().forEach(this::generateStructReadMemberFromAttribute);
        javaBuffer.addLine("default:");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("}");
        javaBuffer.addLine("}");
        javaBuffer.addLine();
    }
    javaBuffer.addLine("// Process the inner elements:");
    javaBuffer.addLine("Map<String, String> links = new HashMap<>();");
    javaBuffer.addLine("reader.next();");
    javaBuffer.addLine("while (reader.forward()) {");
    if (!asElements.isEmpty()) {
        javaBuffer.addLine("String name = reader.getLocalName();");
        javaBuffer.addLine("switch (name) {");
        asElements.stream().sorted().forEach(this::generateStructReadMemberFromElement);
        javaBuffer.addLine("case \"link\":");
        javaBuffer.addLine("// Process the attributes:");
        javaBuffer.addLine("String rel = null;");
        javaBuffer.addLine("String href = null;");
        javaBuffer.addLine("for (int i = 0; i < reader.getAttributeCount(); i++) {");
        javaBuffer.addLine("String attrName = reader.getAttributeLocalName(i);");
        javaBuffer.addLine("String attrVal = reader.getAttributeValue(i);");
        javaBuffer.addLine("switch (attrName) {");
        javaBuffer.addLine("case \"href\":");
        javaBuffer.addLine("href = attrVal;");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("case \"rel\":");
        javaBuffer.addLine("rel = attrVal;");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("default:");
        javaBuffer.addLine("reader.skip();");
        javaBuffer.addLine("break;");
        // End switch
        javaBuffer.addLine("}");
        // End for cycle
        javaBuffer.addLine("}");
        javaBuffer.addLine("reader.skip();");
        javaBuffer.addLine("links.put(rel, href);");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("default:");
        javaBuffer.addLine("reader.skip();");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("}");
    } else {
        javaBuffer.addLine("reader.skip();");
    }
    javaBuffer.addLine("}");
    // Process the links:
    javaBuffer.addLine("for (Map.Entry<String, String> link : links.entrySet()) {");
    javaBuffer.addLine("processLink(object, link);");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("// Discard the end tag:");
    javaBuffer.addLine("reader.next();");
    javaBuffer.addLine();
    javaBuffer.addLine("return object;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#method_after
private void generateStructReadOne(StructType type) {
    // Get the type and container name:
    JavaClassName typeName = javaTypes.getInterfaceName(type);
    JavaClassName containerName = javaTypes.getContainerName(type);
    // Add the required imports:
    javaBuffer.addImport(typeName);
    javaBuffer.addImport(containerName);
    javaBuffer.addImport(XmlReader.class);
    // Generate the method:
    List<StructMember> allMembers = new ArrayList<>();
    allMembers.addAll(type.getAttributes());
    allMembers.addAll(type.getLinks());
    List<StructMember> asAttributes = allMembers.stream().filter(x -> schemaNames.isRepresentedAsAttribute(x.getName())).collect(toList());
    List<StructMember> asElements = allMembers.stream().filter(x -> !schemaNames.isRepresentedAsAttribute(x.getName())).collect(toList());
    javaBuffer.addLine("public static %1$s readOne(XmlReader reader) {", typeName.getSimpleName());
    javaBuffer.addLine("// Do nothing if there aren't more tags:");
    javaBuffer.addLine("if (!reader.forward()) {");
    javaBuffer.addLine("return null;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("// Create the object:");
    javaBuffer.addLine("%1$s object = new %1$s();", containerName.getSimpleName());
    javaBuffer.addLine();
    if (!asAttributes.isEmpty()) {
        javaBuffer.addLine("// Process the attributes:");
        javaBuffer.addLine("for (int i = 0; i < reader.getAttributeCount(); i++) {");
        javaBuffer.addLine("String name = reader.getAttributeLocalName(i);");
        javaBuffer.addLine("String image = reader.getAttributeValue(i);");
        javaBuffer.addLine("switch (name) {");
        asAttributes.stream().sorted().forEach(this::generateStructReadMemberFromAttribute);
        javaBuffer.addLine("default:");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("}");
        javaBuffer.addLine("}");
        javaBuffer.addLine();
    }
    javaBuffer.addLine("// Process the inner elements:");
    javaBuffer.addLine("List<String[]> links = new ArrayList<>();");
    javaBuffer.addLine("reader.next();");
    javaBuffer.addLine("while (reader.forward()) {");
    if (!asElements.isEmpty()) {
        javaBuffer.addLine("String name = reader.getLocalName();");
        javaBuffer.addLine("switch (name) {");
        asElements.stream().sorted().forEach(this::generateStructReadMemberFromElement);
        javaBuffer.addLine("case \"link\":");
        javaBuffer.addLine("// Process the attributes:");
        javaBuffer.addLine("String rel = reader.getAttributeValue(\"rel\");");
        javaBuffer.addLine("String href = reader.getAttributeValue(\"href\");");
        javaBuffer.addLine("if (rel != null && href != null) {");
        javaBuffer.addLine("links.add(new String[]{rel, href});");
        javaBuffer.addLine("}");
        javaBuffer.addLine("reader.next();");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("default:");
        javaBuffer.addLine("reader.skip();");
        javaBuffer.addLine("break;");
        javaBuffer.addLine("}");
    } else {
        javaBuffer.addLine("reader.skip();");
    }
    javaBuffer.addLine("}");
    // Process the links:
    javaBuffer.addLine("if (links != null) {");
    javaBuffer.addLine("for (String[] link : links) {");
    javaBuffer.addLine("processLink(object, link);");
    javaBuffer.addLine("}");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
    javaBuffer.addLine("// Discard the end tag:");
    javaBuffer.addLine("reader.next();");
    javaBuffer.addLine();
    javaBuffer.addLine("return object;");
    javaBuffer.addLine("}");
    javaBuffer.addLine();
}
#end_block

#method_before
private static StoragePool cloneStoragePool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setMasterDomainVersion(instance.getMasterDomainVersion());
    obj.setLVER(instance.getLVER());
    obj.setRecoveryMode(instance.getRecoveryMode());
    obj.setSpmVdsId(instance.getSpmVdsId());
    obj.setClusterCompatibilityLevelUpgradeNeeded(instance.isClusterCompatibilityLevelUpgradeNeeded());
    obj.setCompatibilityVersion(instance.getCompatibilityVersion());
    return obj;
}
#method_after
private static StoragePool cloneStoragePool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setIsLocal(instance.isLocal());
    obj.setStatus(instance.getStatus());
    obj.setMasterDomainVersion(instance.getMasterDomainVersion());
    obj.setLVER(instance.getLVER());
    obj.setRecoveryMode(instance.getRecoveryMode());
    obj.setSpmVdsId(instance.getSpmVdsId());
    obj.setStoragePoolCompatibilityLevelUpgradeNeeded(instance.isStoragePoolCompatibilityLevelUpgradeNeeded());
    obj.setCompatibilityVersion(instance.getCompatibilityVersion());
    return obj;
}
#end_block

#method_before
@Override
public SafeHtml getEntityValue(Cluster object) {
    List<SafeHtml> imagesHtml = new ArrayList(getSafeHtmlStringMap(object).keySet());
    if (!imagesHtml.isEmpty()) {
        return MultiImageColumnHelper.getValue(imagesHtml);
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityValue(Cluster object) {
    if (object.isClusterCompatibilityLevelUpgradeNeeded()) {
        return getImageSafeHtml(IconType.EXCLAMATION);
    }
    return null;
}
#end_block

#method_before
@Override
public SafeHtml getEntityTooltip(Cluster object) {
    Map<SafeHtml, String> imagesToText = getSafeHtmlStringMap(object);
    if (!imagesToText.isEmpty()) {
        return MultiImageColumnHelper.getDataCenterTooltip(imagesToText);
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityTooltip(Cluster object) {
    if (object.isClusterCompatibilityLevelUpgradeNeeded()) {
        return SafeHtmlUtils.fromTrustedString(constants.clusterLevelUpgradeNeeded());
    }
    return null;
}
#end_block

#method_before
private List<StoragePool> searchStoragePool() {
    Optional<Version> retVal = Config.<HashSet<Version>>getValue(ConfigValues.SupportedClusterLevels).stream().max((v1, v2) -> v1.compareTo(v2));
    List<StoragePool> dataCenters = genericSearch(storagePoolDao, true);
    if (retVal.isPresent()) {
        dataCenters.stream().forEach(dataCenter -> dataCenter.setClusterCompatibilityLevelUpgradeNeeded(retVal.get().compareTo(dataCenter.getCompatibilityVersion()) > 0));
    }
    return dataCenters;
}
#method_after
private List<StoragePool> searchStoragePool() {
    Optional<Version> retVal = Config.<HashSet<Version>>getValue(ConfigValues.SupportedClusterLevels).stream().max((v1, v2) -> v1.compareTo(v2));
    List<StoragePool> dataCenters = genericSearch(storagePoolDao, true);
    if (retVal.isPresent()) {
        dataCenters.stream().forEach(dataCenter -> dataCenter.setStoragePoolCompatibilityLevelUpgradeNeeded(retVal.get().compareTo(dataCenter.getCompatibilityVersion()) > 0));
    }
    return dataCenters;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    DcStatusColumn statusIconColumn = new DcStatusColumn();
    statusIconColumn.setContextMenuTitle(constants.statusIconDc());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    DcAdditionalStatusColumn additionalStatusColumn = new DcAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusHost());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<StoragePool> nameColumn = new AbstractTextColumn<StoragePool>() {

        @Override
        public String getValue(StoragePool object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(StoragePoolFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameDc(), "150px");
    CommentColumn<StoragePool> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StoragePool> storageTypeColumn = new AbstractBooleanColumn<StoragePool>(constants.storageTypeLocal(), constants.storageTypeShared()) {

        @Override
        protected Boolean getRawValue(StoragePool object) {
            return object.isLocal();
        }
    };
    storageTypeColumn.makeSortable(StoragePoolFieldAutoCompleter.LOCAL);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storgeTypeDc(), "150px");
    AbstractTextColumn<StoragePool> statusColumn = new AbstractEnumColumn<StoragePool, StoragePoolStatus>() {

        @Override
        public StoragePoolStatus getRawValue(StoragePool object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable(StoragePoolFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusDc(), "150px");
    AbstractTextColumn<StoragePool> versionColumn = new AbstractTextColumn<StoragePool>() {

        @Override
        public String getValue(StoragePool object) {
            return object.getCompatibilityVersion().getValue();
        }
    };
    versionColumn.makeSortable(StoragePoolFieldAutoCompleter.COMPATIBILITY_VERSION);
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersDc(), "150px");
    AbstractTextColumn<StoragePool> descColumn = new AbstractTextColumn<StoragePool>() {

        @Override
        public String getValue(StoragePool object) {
            return object.getdescription();
        }
    };
    descColumn.makeSortable(StoragePoolFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionDc(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.newDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.editDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.removeDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.forceRemoveDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getForceRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<StoragePool>(constants.guideMeDc(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.reinitializeDC(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRecoveryStorageCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    DcStatusColumn statusIconColumn = new DcStatusColumn();
    statusIconColumn.setContextMenuTitle(constants.statusIconDc());
    // $NON-NLS-1$
    getTable().addColumn(statusIconColumn, constants.empty(), "30px");
    DcAdditionalStatusColumn additionalStatusColumn = new DcAdditionalStatusColumn();
    additionalStatusColumn.setContextMenuTitle(constants.additionalStatusDataCenter());
    // $NON-NLS-1$
    getTable().addColumn(additionalStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<StoragePool> nameColumn = new AbstractTextColumn<StoragePool>() {

        @Override
        public String getValue(StoragePool object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(StoragePoolFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameDc(), "150px");
    CommentColumn<StoragePool> commentColumn = new CommentColumn<>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    AbstractTextColumn<StoragePool> storageTypeColumn = new AbstractBooleanColumn<StoragePool>(constants.storageTypeLocal(), constants.storageTypeShared()) {

        @Override
        protected Boolean getRawValue(StoragePool object) {
            return object.isLocal();
        }
    };
    storageTypeColumn.makeSortable(StoragePoolFieldAutoCompleter.LOCAL);
    // $NON-NLS-1$
    getTable().addColumn(storageTypeColumn, constants.storgeTypeDc(), "150px");
    AbstractTextColumn<StoragePool> statusColumn = new AbstractEnumColumn<StoragePool, StoragePoolStatus>() {

        @Override
        public StoragePoolStatus getRawValue(StoragePool object) {
            return object.getStatus();
        }
    };
    statusColumn.makeSortable(StoragePoolFieldAutoCompleter.STATUS);
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusDc(), "150px");
    AbstractTextColumn<StoragePool> versionColumn = new AbstractTextColumn<StoragePool>() {

        @Override
        public String getValue(StoragePool object) {
            return object.getCompatibilityVersion().getValue();
        }
    };
    versionColumn.makeSortable(StoragePoolFieldAutoCompleter.COMPATIBILITY_VERSION);
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersDc(), "150px");
    AbstractTextColumn<StoragePool> descColumn = new AbstractTextColumn<StoragePool>() {

        @Override
        public String getValue(StoragePool object) {
            return object.getdescription();
        }
    };
    descColumn.makeSortable(StoragePoolFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionDc(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.newDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.editDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.removeDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.forceRemoveDC()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getForceRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<StoragePool>(constants.guideMeDc(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StoragePool>(constants.reinitializeDC(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRecoveryStorageCommand();
        }
    });
}
#end_block

#method_before
protected SafeHtml getImageSafeHtml(IconType iconType) {
    return SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    "<i class='fa " + iconType.getCssName() + // $NON-NLS-1$
    "' style='font-size:16px;color:orange'></i>");
}
#method_after
protected SafeHtml getImageSafeHtml(IconType iconType) {
    return AssetProvider.getTemplates().iconTypeAlertTemplate(iconType.getCssName());
}
#end_block

#method_before
private List<StoragePool> searchStoragePool() {
    Optional<Version> retVal = Config.<HashSet<Version>>getValue(ConfigValues.SupportedClusterLevels).stream().max((v1, v2) -> v1.compareTo(v2));
    List<StoragePool> dataCenters = genericSearch(storagePoolDao, true);
    if (retVal.isPresent()) {
        Version version = retVal.get();
        dataCenters.stream().forEach(dataCenter -> dataCenter.setClusterCompatibilityLevelUpgradeNeeded(version.compareTo(dataCenter.getCompatibilityVersion()) > 0));
    }
    return dataCenters;
}
#method_after
private List<StoragePool> searchStoragePool() {
    Optional<Version> retVal = Config.<HashSet<Version>>getValue(ConfigValues.SupportedClusterLevels).stream().max((v1, v2) -> v1.compareTo(v2));
    List<StoragePool> dataCenters = genericSearch(storagePoolDao, true);
    if (retVal.isPresent()) {
        dataCenters.stream().forEach(dataCenter -> dataCenter.setStoragePoolCompatibilityLevelUpgradeNeeded(retVal.get().compareTo(dataCenter.getCompatibilityVersion()) > 0));
    }
    return dataCenters;
}
#end_block

#method_before
@Override
public SafeHtml getEntityValue(StoragePool object) {
    List<SafeHtml> imagesHtml = new ArrayList(getSafeHtmlStringMap(object).keySet());
    if (!imagesHtml.isEmpty()) {
        return MultiImageColumnHelper.getValue(imagesHtml);
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityValue(StoragePool object) {
    if (object.isStoragePoolCompatibilityLevelUpgradeNeeded()) {
        return getImageSafeHtml(IconType.EXCLAMATION);
    }
    return null;
}
#end_block

#method_before
@Override
public SafeHtml getEntityTooltip(StoragePool object) {
    Map<SafeHtml, String> imagesToText = getSafeHtmlStringMap(object);
    if (!imagesToText.isEmpty()) {
        return MultiImageColumnHelper.getDataCenterTooltip(imagesToText);
    }
    return null;
}
#method_after
@Override
public SafeHtml getEntityTooltip(StoragePool object) {
    if (object.isStoragePoolCompatibilityLevelUpgradeNeeded()) {
        return SafeHtmlUtils.fromTrustedString(constants.clusterLevelUpgradeNeeded());
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters() == null || getParameters().getAgent() == null || getParameters().getAgent().getIp() == null || getParameters().getAgent().getHostId() == null || getParameters().getAgent().getPassword() == null || getParameters().getAgent().getType() == null || getParameters().getAgent().getUser() == null) {
        return failValidation(EngineMessage.VDS_ADD_FENCE_AGENT_MANDATORY_PARAMETERS_MISSING);
    }
    Guid vdsId = getParameters().getAgent().getHostId();
    VDS vds = vdsDao.get(vdsId);
    Guid vdsClusterId = vds.getClusterId();
    Cluster cluster = clusterDao.get(vdsClusterId);
    String clusterCompatibilityVersion = cluster.getCompatibilityVersion().toString();
    if (!Regex.isMatch(FenceConfigHelper.getFenceConfigurationValue(ConfigValues.VdsFenceType.name(), clusterCompatibilityVersion), String.format("(,|^)%1$s(,|$)", getParameters().getAgent().getType()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AGENT_NOT_SUPPORTED);
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (getParameters() == null || getParameters().getAgent() == null || getParameters().getAgent().getIp() == null || getParameters().getAgent().getHostId() == null || getParameters().getAgent().getPassword() == null || getParameters().getAgent().getType() == null || getParameters().getAgent().getUser() == null) {
        return failValidation(EngineMessage.VDS_ADD_FENCE_AGENT_MANDATORY_PARAMETERS_MISSING);
    }
    Guid vdsId = getParameters().getAgent().getHostId();
    VDS vds = vdsDao.get(vdsId);
    Guid vdsClusterId = vds.getClusterId();
    Cluster cluster = clusterDao.get(vdsClusterId);
    String clusterCompatibilityVersion = cluster.getCompatibilityVersion().toString();
    if (!FenceConfigHelper.getValidFenceAgentTypes(clusterCompatibilityVersion).contains(getParameters().getAgent().getType())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AGENT_NOT_SUPPORTED);
    }
    return super.validate();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    handleRandomUrandomMigration();
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                OvfDataUpdater.getInstance().triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                OvfDataUpdater.getInstance().triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateRngDevice() {
    if (getParameters().isUpdateRngDevice()) {
        return changeRngDevice();
    }
    return true;
}
#method_after
private void updateRngDevice() {
    if (!getParameters().isUpdateRngDevice()) {
        return;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        log.error("Updating RNG device of VM {} ({}) failed. Old RNG device = {}. New RNG device = {}.", getVm().getName(), getVm().getId(), rngDevs.isEmpty() ? null : rngDevs.get(0), getParameters().getRngDevice());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!getParameters().getVmStaticData().isAutoStartup()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED_WITH_HA_OFF);
        }
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        AllVmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.exportVm(vm, AllVmImages, ClusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
private boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<>();
    ArrayList<DiskImage> AllVmImages = new ArrayList<>();
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(vmNetworkInterfaceDao.getAllForVm(vm.getId()));
    }
    List<Guid> imageGroupIds = new ArrayList<>();
    for (Disk disk : getDisksBasedOnImage()) {
        DiskImage diskImage = (DiskImage) disk;
        diskImage.setParentId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setImageTemplateId(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
        diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
        DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
        diskImage.setVolumeFormat(diskForVolumeInfo.getVolumeFormat());
        diskImage.setVolumeType(diskForVolumeInfo.getVolumeType());
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
        if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
            DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
            diskImage.setActualSizeInBytes(fromVdsm.getActualSizeInBytes());
        }
        AllVmImages.add(diskImage);
        imageGroupIds.add(disk.getId());
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = vmTemplateDao.get(vm.getVmtGuid());
        vm.setVmtName(t.getName());
    }
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    String vmMeta = ovfManager.exportVm(vm, AllVmImages, ClusterUtils.getCompatibilityVersion(vm));
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return runVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
private Optional<VM> chooseNextVmToMigrateFromVMsToHostsAffinity(Cluster cluster, List<AffinityGroup> allAffinityGroups) {
    List<AffinityGroup> allVmToHostsAffinityGroups = getAllAffinityGroupsForVMsToHostsAffinity(allAffinityGroups);
    if (allVmToHostsAffinityGroups.isEmpty()) {
        return Optional.empty();
    }
    Map<Guid, VM> vmsMap = getVMsMap(allVmToHostsAffinityGroups);
    List<Guid> candidateVMs = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, true);
    if (candidateVMs.isEmpty()) {
        log.debug("No vm to hosts hard-affinity group violation detected");
    } else {
        AffinityRulesUtils.AffinityGroupHostsConflict hostsResult = AffinityRulesUtils.checkForAffinityGroupHostsConflict(allVmToHostsAffinityGroups);
        if (!hostsResult.getPositiveHosts().isEmpty()) {
            log.warn("The following hosts were found in a positive enforcing affinity group and do not exist in " + " at least one other affinity group (positive enforcing) for a VM : {}", hostsResult.getPositiveHosts().toString());
        }
    }
    for (Guid id : candidateVMs) {
        VM candidateVM = vmsMap.get(id);
        if (isVmMigrationValid(cluster, candidateVM)) {
            return Optional.of(candidateVM);
        }
    }
    candidateVMs = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, false);
    if (candidateVMs.isEmpty()) {
        log.debug("No vm to hosts soft-affinity group violation detected");
    }
    for (Guid id : candidateVMs) {
        VM candidateVM = vmsMap.get(id);
        if (isVmMigrationValid(cluster, candidateVM)) {
            return Optional.of(candidateVM);
        }
    }
    return Optional.empty();
}
#method_after
private Optional<VM> chooseNextVmToMigrateFromVMsToHostsAffinity(Cluster cluster, List<AffinityGroup> allAffinityGroups) {
    List<AffinityGroup> allVmToHostsAffinityGroups = getAllAffinityGroupsForVMsToHostsAffinity(allAffinityGroups);
    if (allVmToHostsAffinityGroups.isEmpty()) {
        return Optional.empty();
    }
    Map<Guid, VM> vmsMap = getVMsMap(allVmToHostsAffinityGroups);
    List<Guid> candidateVMs = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, true);
    if (candidateVMs.isEmpty()) {
        log.debug("No vm to hosts hard-affinity group violation detected");
    } else {
        List<AffinityRulesUtils.AffinityGroupConflicts> conflicts = AffinityRulesUtils.checkForAffinityGroupHostsConflict(allVmToHostsAffinityGroups);
        for (AffinityRulesUtils.AffinityGroupConflicts conflict : conflicts) {
            if (conflict.isVmToVmAffinity()) {
                log.warn(conflict.getType().getMessage(), conflict.getVms().stream().map(id -> id.toString()).collect(Collectors.joining(",")), AffinityRulesUtils.getAffinityGroupsNames(conflict.getAffinityGroups()), conflict.getNegativeVms().stream().map(id -> id.toString()).collect(Collectors.joining(",")));
            } else {
                log.warn(conflict.getType().getMessage(), AffinityRulesUtils.getAffinityGroupsNames(conflict.getAffinityGroups()), conflict.getHosts().stream().map(id -> id.toString()).collect(Collectors.joining(",")), conflict.getVms().stream().map(id -> id.toString()).collect(Collectors.joining(",")));
            }
        }
    }
    for (Guid id : candidateVMs) {
        VM candidateVM = vmsMap.get(id);
        if (isVmMigrationValid(cluster, candidateVM)) {
            return Optional.of(candidateVM);
        }
    }
    candidateVMs = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, false);
    if (candidateVMs.isEmpty()) {
        log.debug("No vm to hosts soft-affinity group violation detected");
    }
    for (Guid id : candidateVMs) {
        VM candidateVM = vmsMap.get(id);
        if (isVmMigrationValid(cluster, candidateVM)) {
            return Optional.of(candidateVM);
        }
    }
    return Optional.empty();
}
#end_block

#method_before
public static AffinityGroupConflict checkForAffinityGroupConflict(Iterable<AffinityGroup> affinityGroups, Set<Set<Guid>> unifiedPositiveGroups) {
    for (AffinityGroup ag : affinityGroups) {
        if (ag.isVmNegative()) {
            for (Set<Guid> positiveGroup : unifiedPositiveGroups) {
                Set<Guid> intersection = new HashSet<>(ag.getVmIds());
                intersection.retainAll(positiveGroup);
                if (intersection.size() > 1) {
                    return new AffinityGroupConflict(positiveGroup, ag.getVmIds());
                }
            }
        }
    }
    return null;
}
#method_after
public static void checkForAffinityGroupConflict(List<AffinityGroup> affinityGroups, List<AffinityGroupConflicts> conflicts) {
    Set<Set<Guid>> unifiedPositiveGroups = getUnifiedPositiveAffinityGroups(affinityGroups.stream().filter(AffinityGroup::isVmAffinityEnabled).collect(Collectors.toList()));
    affinityGroups.stream().filter(AffinityGroup::isVmAffinityEnabled).filter(AffinityGroup::isVmNegative).forEach(ag -> {
        for (Set<Guid> positiveGroup : unifiedPositiveGroups) {
            Set<Guid> intersection = new HashSet<>(ag.getVmIds());
            intersection.retainAll(positiveGroup);
            if (intersection.size() > 1) {
                conflicts.add(new AffinityGroupConflicts(new HashSet<>(Arrays.asList(ag)), AffinityRulesConflicts.VM_TO_VM_AFFINITY_CONFLICTS, AuditLogType.VM_TO_VM_AFFINITY_CONFLICTS, positiveGroup, intersection));
            }
        }
    });
}
#end_block

#method_before
public static AffinityGroupHostsConflict checkForAffinityGroupHostsConflict(List<AffinityGroup> affinityGroups) {
    Set<Guid> conflictingPositiveHosts = new HashSet<>();
    Set<Guid> conflictingNegativeHosts = new HashSet<>();
    Map<Guid, List<Set<Guid>>> positiveEnforcingVmToHostsMap = getPositiveEnforcingVmToHostsMap(affinityGroups);
    affinityGroups.forEach(affinityGroup -> {
        if (affinityGroup.isVdsAffinityEnabled() && affinityGroup.isVdsEnforcing() && !affinityGroup.getVdsIds().isEmpty()) {
            List<Guid> affinityGroupHostIds = affinityGroup.getVdsIds();
            affinityGroup.getVmIds().forEach(vm_id -> {
                if (positiveEnforcingVmToHostsMap.containsKey(vm_id)) {
                    positiveEnforcingVmToHostsMap.get(vm_id).forEach(vds_list -> {
                        Set<Guid> vds_ids = new HashSet<>(vds_list);
                        if (affinityGroup.isVdsPositive()) {
                            vds_ids.removeAll(affinityGroupHostIds);
                            conflictingPositiveHosts.addAll(vds_ids);
                        } else {
                            vds_ids.retainAll(affinityGroupHostIds);
                            conflictingNegativeHosts.addAll(vds_ids);
                        }
                    });
                }
            });
        }
    });
    return new AffinityGroupHostsConflict(conflictingPositiveHosts, conflictingNegativeHosts);
}
#method_after
public static List<AffinityGroupConflicts> checkForAffinityGroupHostsConflict(List<AffinityGroup> affinityGroups) {
    List<AffinityGroupConflicts> conflicts = new ArrayList<>();
    checkHostsInPositiveAndNegativeAffinity(affinityGroups.stream().filter(AffinityGroup::isVdsEnforcing).collect(Collectors.toList()), true, conflicts);
    checkHostsInPositiveAndNegativeAffinity(affinityGroups, false, conflicts);
    checkVmToHostWithPositiveVmToVmConflict(affinityGroups, conflicts);
    checkVmToHostWithNegativeVmToVmConflicts(affinityGroups, conflicts);
    checkNonIntersectingPositiveHosts(affinityGroups, conflicts);
    checkForAffinityGroupConflict(affinityGroups, conflicts);
    return conflicts;
}
#end_block

#method_before
private boolean affinityGroupsWithoutConflict(AffinityGroup affinityGroup) {
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByClusterId(affinityGroup.getClusterId());
    // Replace the existing affinity group by the updated copy
    for (Iterator<AffinityGroup> it = affinityGroups.iterator(); it.hasNext(); ) {
        AffinityGroup g = it.next();
        if (g.getId().equals(affinityGroup.getId())) {
            it.remove();
        }
    }
    affinityGroups.add(affinityGroup);
    AffinityRulesUtils.AffinityGroupHostsConflict hostsResult = AffinityRulesUtils.checkForAffinityGroupHostsConflict(affinityGroups);
    if (!hostsResult.getNegativeHosts().isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_HOSTS_RULES_COLLISION, String.format("$negativeHosts %s", hostsResult.getNegativeHosts().toString()));
    }
    Set<Set<Guid>> unifiedPositive = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(affinityGroups);
    AffinityRulesUtils.AffinityGroupConflict result = AffinityRulesUtils.checkForAffinityGroupConflict(affinityGroups, unifiedPositive);
    if (result == null) {
        return true;
    } else {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_RULES_COLLISION, String.format("$UnifiedAffinityGroups %s", result.getPositiveVms().toString()), String.format("$negativeAR %s", result.getNegativeVms().toString()));
    }
}
#method_after
private boolean affinityGroupsWithoutConflict(AffinityGroup affinityGroup) {
    List<AffinityGroup> affinityGroups = affinityGroupDao.getAllAffinityGroupsByClusterId(affinityGroup.getClusterId());
    // Replace the existing affinity group by the updated copy
    for (Iterator<AffinityGroup> it = affinityGroups.iterator(); it.hasNext(); ) {
        AffinityGroup g = it.next();
        if (g.getId().equals(affinityGroup.getId())) {
            it.remove();
        }
    }
    affinityGroups.add(affinityGroup);
    List<AffinityRulesUtils.AffinityGroupConflicts> conflicts = AffinityRulesUtils.checkForAffinityGroupHostsConflict(affinityGroups);
    for (AffinityRulesUtils.AffinityGroupConflicts conflict : conflicts) {
        String affinityGroupsNames = AffinityRulesUtils.getAffinityGroupsNames(conflict.getAffinityGroups());
        String hosts = conflict.getHosts().stream().map(id -> id.toString()).collect(Collectors.joining(","));
        String vms = conflict.getVms().stream().map(id -> id.toString()).collect(Collectors.joining(","));
        if (conflict.getType().canBeSaved()) {
            addCustomValue("AffinityGroups", affinityGroupsNames);
            addCustomValue("Hosts", hosts);
            addCustomValue("Vms", vms);
            auditLogDirector.log(this, conflict.getAuditLogType());
        } else {
            if (conflict.isVmToVmAffinity()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_RULES_COLLISION, String.format("$UnifiedAffinityGroups %1$s", vms), String.format("$negativeAR %1$s", affinityGroupsNames), String.format("$Vms %1$s", conflict.getNegativeVms().stream().map(id -> id.toString()).collect(Collectors.joining(","))));
            } else {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_AFFINITY_HOSTS_RULES_COLLISION, String.format("AffinityGroups: %1$s", affinityGroupsNames), String.format("Hosts: %1$s", hosts), String.format("Vms: %1$s", vms));
            }
        }
    }
    return true;
}
#end_block

#method_before
@Mapping(from = AffinityGroup.class, to = org.ovirt.engine.core.common.scheduling.AffinityGroup.class)
public static org.ovirt.engine.core.common.scheduling.AffinityGroup map(AffinityGroup model, org.ovirt.engine.core.common.scheduling.AffinityGroup template) {
    org.ovirt.engine.core.common.scheduling.AffinityGroup entity = template != null ? template : new org.ovirt.engine.core.common.scheduling.AffinityGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    AffinityRule hostsRule = model.getHostsRule();
    if (hostsRule != null) {
        if (hostsRule.isSetEnforcing()) {
            entity.setVdsEnforcing(hostsRule.isEnforcing());
        }
        if (hostsRule.isSetPositive()) {
            entity.setVdsAffinityRule(hostsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        }
    }
    AffinityRule vmsRule = model.getVmsRule();
    if (vmsRule != null) {
        if (vmsRule.isSetEnabled()) {
            if (!vmsRule.isEnabled()) {
                entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
            } else if (vmsRule.isSetPositive()) {
                entity.setVmAffinityRule(vmsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
            }
        }
        if (vmsRule.isSetEnforcing()) {
            entity.setVmEnforcing(vmsRule.isEnforcing());
        }
    } else {
        if (model.isSetPositive()) {
            entity.setVmAffinityRule(model.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        } else if (entity.getVmAffinityRule() == null) {
            entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
        }
        if (model.isSetEnforcing()) {
            entity.setVmEnforcing(model.isEnforcing());
        }
    }
    if (model.isSetHosts()) {
        List<Guid> hostIds = entity.getVdsIds();
        if (hostIds == null) {
            hostIds = new ArrayList<>();
            entity.setVdsIds(hostIds);
        }
        // Replace the existing list with the provided one
        hostIds.clear();
        model.getHosts().getHosts().stream().filter(Host::isSetId).map(Host::getId).map(Guid::createGuidFromString).forEach(hostIds::add);
    }
    if (model.isSetVms()) {
        List<Guid> vmIds = entity.getVmIds();
        if (vmIds == null) {
            vmIds = new ArrayList<>();
            entity.setVmIds(vmIds);
        }
        // Replace the existing list with the provided one
        vmIds.clear();
        model.getVms().getVms().stream().filter(Vm::isSetId).map(Vm::getId).map(Guid::createGuidFromString).forEach(vmIds::add);
    }
    return entity;
}
#method_after
@Mapping(from = AffinityGroup.class, to = org.ovirt.engine.core.common.scheduling.AffinityGroup.class)
public static org.ovirt.engine.core.common.scheduling.AffinityGroup map(AffinityGroup model, org.ovirt.engine.core.common.scheduling.AffinityGroup template) {
    org.ovirt.engine.core.common.scheduling.AffinityGroup entity = template != null ? template : new org.ovirt.engine.core.common.scheduling.AffinityGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    AffinityRule hostsRule = model.getHostsRule();
    if (hostsRule != null) {
        if (hostsRule.isSetEnforcing()) {
            entity.setVdsEnforcing(hostsRule.isEnforcing());
        }
        if (hostsRule.isSetPositive()) {
            entity.setVdsAffinityRule(hostsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        }
    }
    AffinityRule vmsRule = model.getVmsRule();
    if (vmsRule != null) {
        if (vmsRule.isSetEnabled()) {
            if (!vmsRule.isEnabled()) {
                entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
            } else if (vmsRule.isSetPositive()) {
                entity.setVmAffinityRule(vmsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
            }
        }
        if (vmsRule.isSetEnforcing()) {
            entity.setVmEnforcing(vmsRule.isEnforcing());
        }
    } else {
        if (model.isSetPositive()) {
            entity.setVmAffinityRule(model.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        // Default to DISABLED for new entities,
        // but do not touch existing values when no change is requested
        } else if (entity.getVmAffinityRule() == null) {
            entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
        }
        if (model.isSetEnforcing()) {
            entity.setVmEnforcing(model.isEnforcing());
        }
    }
    if (model.isSetHosts()) {
        List<Guid> hostIds = entity.getVdsIds();
        if (hostIds == null) {
            hostIds = new ArrayList<>();
            entity.setVdsIds(hostIds);
        }
        // Replace the existing list with the provided one
        hostIds.clear();
        model.getHosts().getHosts().stream().filter(Host::isSetId).map(Host::getId).map(Guid::createGuidFromString).forEach(hostIds::add);
    }
    if (model.isSetVms()) {
        List<Guid> vmIds = entity.getVmIds();
        if (vmIds == null) {
            vmIds = new ArrayList<>();
            entity.setVmIds(vmIds);
        }
        // Replace the existing list with the provided one
        vmIds.clear();
        model.getVms().getVms().stream().filter(Vm::isSetId).map(Vm::getId).map(Guid::createGuidFromString).forEach(vmIds::add);
    }
    return entity;
}
#end_block

#method_before
public void updateSuggestedLabels() {
    suggestedLabels = new TreeSet<>(suggestedLabelsCache);
    suggestedLabels.removeAll(computeSelecetedLabels());
    for (ListModel<String> labelModel : getItems()) {
        labelModel.setItems(suggestedLabels, labelModel.getSelectedItem());
    }
}
#method_after
public void updateSuggestedLabels() {
    suggestedLabels = new TreeSet<>(suggestedLabelsCache);
    suggestedLabels.removeAll(computeSelectedLabels());
    for (ListModel<String> labelModel : getItems()) {
        labelModel.setItems(suggestedLabels, labelModel.getSelectedItem());
    }
}
#end_block

#method_before
@Override
protected ListModel<String> createGhostValue() {
    ListModel<String> value = new ListModel<>();
    value.setItems(model.getSuggestedLabels());
    // $NON-NLS-1$
    value.setSelectedItem("");
    return value;
}
#method_after
@Override
protected ListModel<String> createGhostValue() {
    ListModel<String> value = new ListModel<>();
    // $NON-NLS-1$
    value.setSelectedItem("");
    return value;
}
#end_block

#method_before
@Override
protected void init(final VfsNicLabelModel model) {
    super.init(model);
    for (ListModel<String> labelModel : model.getItems()) {
        labelModel.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                ValueChangeEvent.fire(VfsNicLabelWidget.this, null);
                model.updateSuggestedLabels();
            }
        });
    }
}
#method_after
@Override
protected void init(final VfsNicLabelModel model) {
    super.init(model);
    getModel().updateSuggestedLabels();
    for (ListModel<String> labelModel : model.getItems()) {
        labelModel.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                selectedLabelsChanged();
            }
        });
    }
}
#end_block

#method_before
@Override
protected void onAdd(ListModel<String> value, NicLabelEditor widget) {
    super.onAdd(value, widget);
    value.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ValueChangeEvent.fire(VfsNicLabelWidget.this, null);
            model.updateSuggestedLabels();
        }
    });
}
#method_after
@Override
protected void onAdd(ListModel<String> value, NicLabelEditor widget) {
    super.onAdd(value, widget);
    getModel().updateSuggestedLabels();
    value.getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            selectedLabelsChanged();
        }
    });
}
#end_block

#method_before
@Override
protected void onRemove(ListModel<String> value, NicLabelEditor widget) {
    super.onRemove(value, widget);
    ValueChangeEvent.fire(this, null);
    model.updateSuggestedLabels();
}
#method_after
@Override
protected void onRemove(ListModel<String> value, NicLabelEditor widget) {
    super.onRemove(value, widget);
    getModel().updateSuggestedLabels();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    T parameters = getParameters();
    addCustomValue("ApiVersion", parameters.getApiVersion());
    addCustomValue("ClientAddress", parameters.getClientAddress());
    addCustomValue("DeprecatingVersion", parameters.getDeprecatingVersion());
    addCustomValue("RemovingVersion", parameters.getRemovingVersion());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    T parameters = getParameters();
    // Use the client address as the custom id of the audit log message. That way the flood prevention mechanism
    // will automatically discard duplicated messages.
    setCustomId(parameters.getClientAddress());
    // Populate the audit log message with the details:
    addCustomValue("ApiVersion", parameters.getApiVersion());
    addCustomValue("ClientAddress", parameters.getClientAddress());
    addCustomValue("DeprecatingVersion", parameters.getDeprecatingVersion());
    addCustomValue("RemovingVersion", parameters.getRemovingVersion());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) throws ServletException {
    LocalConfig localConfig = LocalConfig.getInstance();
    // Get the supported and default versions:
    supportedVersions = localConfig.getSupportedVersions();
    defaultVersion = localConfig.getDefaultVersion();
    // Get the information about deprecated versions and store them in a set and a map for easy/fast access:
    Set<DeprecatedVersionInfo> deprecatedVersionInfos = localConfig.getDeprecatedVersions();
    deprecatedVersionsSet = deprecatedVersionInfos.stream().map(DeprecatedVersionInfo::getVersion).collect(toSet());
    deprecatedVersionsMap = deprecatedVersionInfos.stream().collect(toMap(DeprecatedVersionInfo::getVersion, identity()));
    // Get the integer that indicates how often to send deprecation messages to the audit log. Note that simplify
    // comparisons this is converted to from seconds to millisenconds.
    deprecatedMessagesTime = localConfig.getDeprecatedMessagesFrequency() * 1000L;
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    LocalConfig localConfig = LocalConfig.getInstance();
    // Get the supported and default versions:
    supportedVersions = localConfig.getSupportedVersions();
    defaultVersion = localConfig.getDefaultVersion();
    // Get the information about deprecated versions and store them in a set and a map for easy/fast access:
    Set<DeprecatedVersionInfo> deprecatedVersionInfos = localConfig.getDeprecatedVersions();
    deprecatedVersionsSet = deprecatedVersionInfos.stream().map(DeprecatedVersionInfo::getVersion).collect(toSet());
    deprecatedVersionsMap = deprecatedVersionInfos.stream().collect(toMap(DeprecatedVersionInfo::getVersion, identity()));
}
#end_block

#method_before
private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
    // Get a reference to the object that stores the information of the current request:
    Current current = CurrentManager.get();
    // Get the remote address, as we need it for several things:
    String remoteAddress = request.getRemoteAddr();
    // First try to extract the version from the request path:
    String version = null;
    VersionSource source = null;
    String path = current.getPath();
    Matcher matcher = VERSION_PATTERN.matcher(path);
    if (matcher.matches()) {
        version = matcher.group(VERSION_GROUP);
        path = matcher.group(PATH_GROUP);
        source = VersionSource.URL;
    }
    // If the version hasn't been determined yet, then try to extract it from the headers:
    if (version == null || version.isEmpty()) {
        version = request.getHeader(VERSION_HEADER);
        if (version != null && !version.isEmpty()) {
            source = VersionSource.HEADER;
        }
    }
    // Finally, if the version hasn't been determined, then use the default:
    if (version == null || version.isEmpty()) {
        version = defaultVersion;
        source = VersionSource.DEFAULT;
    }
    // Check that the version is supported, and return an HTTP error response if it isn't:
    if (!supportedVersions.contains(version)) {
        log.error("Client \"{}\" is requesting unsupported version \"{}\", will send a 400 error code.", remoteAddress, version);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST);
        return;
    }
    // Check if the version is deprecated, if it is then send a message to the audit log:
    if (deprecatedVersionsSet.contains(version)) {
        Long nowTime = System.currentTimeMillis();
        Long lastTime = deprecatedMessagesTimes.get(remoteAddress);
        if (lastTime == null || nowTime - lastTime > deprecatedMessagesTime) {
            DeprecatedVersionInfo versionInfo = deprecatedVersionsMap.get(version);
            AddDeprecatedApiEventParameters parameters = new AddDeprecatedApiEventParameters(version, remoteAddress, versionInfo.getDeprecating(), versionInfo.getRemoving());
            backend.runInternalAction(VdcActionType.AddDeprecatedApiEvent, parameters);
            deprecatedMessagesTimes.put(remoteAddress, nowTime);
        }
    }
    // Copy the version, the source and the path to the object that stores information to the current request:
    current.setVersion(version);
    current.setVersionSource(source);
    current.setPath(path);
    // modified request.
    if (source == VersionSource.URL) {
        chain.doFilter(request, response);
    } else {
        String prefix = current.getPrefix();
        String uri = request.getRequestURI();
        StringBuilder buffer = new StringBuilder(2 + version.length() + (uri.length() - prefix.length()));
        buffer.append("/v");
        buffer.append(version);
        buffer.append(uri, prefix.length(), uri.length());
        path = buffer.toString();
        RequestDispatcher dispatcher = request.getRequestDispatcher(path);
        if (dispatcher == null) {
            log.error("Can't find dispatcher for path \"{}\", as requested by client \"{}\", will send a 404 error code.", path, remoteAddress);
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
        } else {
            dispatcher.forward(request, response);
        }
    }
}
#method_after
private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
    // Get a reference to the object that stores the information of the current request:
    Current current = CurrentManager.get();
    // Get the remote address, as we need it for several things:
    String remoteAddress = request.getRemoteAddr();
    // First try to extract the version from the request path:
    String version = null;
    VersionSource source = null;
    String path = current.getPath();
    Matcher matcher = VERSION_PATTERN.matcher(path);
    if (matcher.matches()) {
        version = matcher.group(VERSION_GROUP);
        path = matcher.group(PATH_GROUP);
        source = VersionSource.URL;
    }
    // If the version hasn't been determined yet, then try to extract it from the headers:
    if (version == null || version.isEmpty()) {
        version = request.getHeader(VERSION_HEADER);
        if (version != null && !version.isEmpty()) {
            source = VersionSource.HEADER;
        }
    }
    // Finally, if the version hasn't been determined, then use the default:
    if (version == null || version.isEmpty()) {
        version = defaultVersion;
        source = VersionSource.DEFAULT;
    }
    // Check that the version is supported, and return an HTTP error response if it isn't:
    if (!supportedVersions.contains(version)) {
        log.error("Client \"{}\" is requesting unsupported version \"{}\", will send a 400 error code.", remoteAddress, version);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST);
        return;
    }
    // Check if the version is deprecated, if it is then send a message to the audit log:
    if (deprecatedVersionsSet.contains(version)) {
        DeprecatedVersionInfo versionInfo = deprecatedVersionsMap.get(version);
        AddDeprecatedApiEventParameters parameters = new AddDeprecatedApiEventParameters(version, remoteAddress, versionInfo.getDeprecating(), versionInfo.getRemoving());
        backend.runAction(VdcActionType.AddDeprecatedApiEvent, parameters);
    }
    // Copy the version, the source and the path to the object that stores information to the current request:
    current.setVersion(version);
    current.setVersionSource(source);
    current.setPath(path);
    // modified request.
    if (source == VersionSource.URL) {
        chain.doFilter(request, response);
    } else {
        String prefix = current.getPrefix();
        String uri = request.getRequestURI();
        StringBuilder buffer = new StringBuilder(2 + version.length() + (uri.length() - prefix.length()));
        buffer.append("/v");
        buffer.append(version);
        buffer.append(uri, prefix.length(), uri.length());
        path = buffer.toString();
        RequestDispatcher dispatcher = request.getRequestDispatcher(path);
        if (dispatcher == null) {
            log.error("Can't find dispatcher for path \"{}\", as requested by client \"{}\", will send a 404 error code.", path, remoteAddress);
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
        } else {
            dispatcher.forward(request, response);
        }
    }
}
#end_block

#method_before
private void commitVfsConfigChanges(final HostNicVfsConfig hostNicVfsConfig, final VfsConfigModel vfsConfigModel) {
    if (hostNicVfsConfig != null) {
        // Num of vfs
        hostNicVfsConfig.setNumOfVfs(vfsConfigModel.getNumOfVfs().getEntity());
        // Networks
        hostNicVfsConfig.setAllNetworksAllowed(vfsConfigModel.getAllNetworksAllowed().getSelectedItem() == AllNetworksSelector.allNetworkAllowed);
        Set<Guid> networks = new HashSet<>();
        for (VfsConfigNetwork vfsConfigNetwork : vfsConfigModel.getNetworks().getItems()) {
            if (vfsConfigNetwork.isAttached() && vfsConfigNetwork.getLabelViaAttached() == null) {
                networks.add(vfsConfigNetwork.getEntity().getId());
            }
        }
        hostNicVfsConfig.setNetworks(networks);
        // Labels
        hostNicVfsConfig.setNetworkLabels(vfsConfigModel.getLabelsModel().computeSelecetedLabels());
    }
}
#method_after
private void commitVfsConfigChanges(final HostNicVfsConfig hostNicVfsConfig, final VfsConfigModel vfsConfigModel) {
    if (hostNicVfsConfig != null) {
        // Num of vfs
        hostNicVfsConfig.setNumOfVfs(vfsConfigModel.getNumOfVfs().getEntity());
        // Networks
        hostNicVfsConfig.setAllNetworksAllowed(vfsConfigModel.getAllNetworksAllowed().getSelectedItem() == AllNetworksSelector.allNetworkAllowed);
        Set<Guid> networks = new HashSet<>();
        for (VfsConfigNetwork vfsConfigNetwork : vfsConfigModel.getNetworks().getItems()) {
            if (vfsConfigNetwork.isAttached() && vfsConfigNetwork.getLabelViaAttached() == null) {
                networks.add(vfsConfigNetwork.getEntity().getId());
            }
        }
        hostNicVfsConfig.setNetworks(networks);
        // Labels
        hostNicVfsConfig.setNetworkLabels(vfsConfigModel.getLabelsModel().computeSelectedLabels());
    }
}
#end_block

#method_before
private void initCreateOrUpdateBondParameters() {
    NetworkCommonUtils.fillBondSlaves(allExistingNics);
    for (VdsNetworkInterface nic : allExistingNics) {
        if (nic.isBond()) {
            getHostSetupNetworksParametersData().getBonds().add(CreateOrUpdateBond.fromBond((Bond) nic));
        }
    }
    initBondNameToIdMap();
}
#method_after
private void initCreateOrUpdateBondParameters() {
    NetworkCommonUtils.fillBondSlaves(allExistingNics);
    for (VdsNetworkInterface nic : allExistingNics) {
        if (nic.isBond()) {
            getHostSetupNetworksParametersData().getBonds().add(CreateOrUpdateBond.fromBond((Bond) nic));
        }
    }
    hostSetupNetworksParametersData.setOriginalBondsByName(Entities.entitiesByName(hostSetupNetworksParametersData.getBonds()));
}
#end_block

#method_before
private void initOrginalBondNameToIdMap(CreateOrUpdateBond... bonds) {
    Map<String, Guid> originalBondNameToId = new HashMap<>();
    for (CreateOrUpdateBond bond : bonds) {
        originalBondNameToId.put(bond.getName(), bond.getId());
    }
    dataFromHostSetupNetworksModel.setOriginalBondNameToId(originalBondNameToId);
}
#method_after
private void initOrginalBondNameToIdMap(CreateOrUpdateBond... bonds) {
    dataFromHostSetupNetworksModel.setOriginalBondsByName(Entities.entitiesByName(Arrays.asList(bonds)));
}
#end_block

#method_before
public void addBondToParameters(CreateOrUpdateBond bond) {
    // $NON-NLS-1$
    assert bond.getId() == null : "When adding a bond to the parameters its id should be null";
    Guid originalIdOfBondWithTheSameName = originalBondNameToId.get(bond.getName());
    bond.setId(originalIdOfBondWithTheSameName);
    if (originalIdOfBondWithTheSameName != null) {
        removedBonds.remove(originalIdOfBondWithTheSameName);
    }
    bonds.add(bond);
}
#method_after
public void addBondToParameters(CreateOrUpdateBond bond) {
    if (bond.getId() != null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("When adding a bond to the parameters its id should be null");
    }
    CreateOrUpdateBond originalBondWithTheSameName = originalBondsByName.get(bond.getName());
    if (originalBondWithTheSameName != null) {
        bond.setId(originalBondWithTheSameName.getId());
        removedBonds.remove(originalBondWithTheSameName.getId());
    }
    bonds.add(bond);
}
#end_block

#method_before
private void generateMethods(StructType type) {
    PythonClassName typeName = pythonNames.getTypeName(type);
    PythonClassName readerName = pythonNames.getReaderName(type);
    // Generate the method that reads one instance:
    buffer.addLine("@staticmethod");
    buffer.addLine("def read_one(reader):");
    buffer.startBlock();
    buffer.addLine("# Do nothing if there aren't more tags:");
    buffer.addLine("if not reader.forward():");
    buffer.startBlock();
    buffer.addLine("return None");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Create the object:");
    buffer.addLine("obj = types.%1$s()", typeName.getClassName());
    buffer.addLine();
    buffer.addLine("# Process the attributes:");
    buffer.addLine("obj.href = reader.get_attribute('href')");
    generateAttributesRead(type);
    buffer.addLine();
    buffer.addLine("# Discard the start tag:");
    buffer.addLine("empty = reader.empty_element()");
    buffer.addLine("reader.read()");
    buffer.addLine("if empty:");
    buffer.startBlock();
    buffer.addLine("return obj");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Process the inner elements:");
    generateElementsRead(type);
    buffer.addLine();
    buffer.addLine("# Discard the end tag:");
    buffer.addLine("reader.read()");
    buffer.addLine();
    buffer.addLine("return obj");
    buffer.endBlock();
    buffer.addLine();
    // Generate the method that reads many instances:
    buffer.addLine("@staticmethod");
    buffer.addLine("def read_many(reader):");
    buffer.startBlock();
    buffer.addLine("# Do nothing if there aren't more tags:");
    buffer.addLine("objs = List()");
    buffer.addLine("if not reader.forward():");
    buffer.startBlock();
    buffer.addLine("return objs");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Process the attributes:");
    buffer.addLine("objs.href = reader.get_attribute('href')");
    buffer.addLine();
    buffer.addLine("# Discard the start tag:");
    buffer.addLine("empty = reader.empty_element()");
    buffer.addLine("reader.read()");
    buffer.addLine("if empty:");
    buffer.startBlock();
    buffer.addLine("return objs");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Process the inner elements:");
    buffer.addLine("while reader.forward():");
    buffer.startBlock();
    buffer.addLine("objs.append(%1$s.read_one(reader))", readerName.getClassName());
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Discard the end tag:");
    buffer.addLine("reader.read()");
    buffer.addLine();
    buffer.addLine("return objs");
    buffer.endBlock();
    buffer.addLine();
    // Generate the method that reads links to lists:
    List<Link> links = type.links().filter(link -> link.getType() instanceof ListType).sorted().collect(toList());
    if (!links.isEmpty()) {
        buffer.addLine("@staticmethod");
        buffer.addLine("def _process_link(link, obj):");
        buffer.startBlock();
        buffer.addLine("# Process the attributes:");
        buffer.addLine("rel = link[0]");
        buffer.addLine("href = link[1]");
        buffer.addLine("if href and rel:");
        buffer.startBlock();
        buffer.addLine("list = List(href)");
        boolean firstLink = true;
        for (Link link : links) {
            String keyword = firstLink ? "if" : "elif";
            String field = pythonNames.getMemberStyleName(link.getName());
            String rel = link.getName().words().map(String::toLowerCase).collect(joining());
            buffer.addLine("%1$s rel == \"%2$s\":", keyword, rel);
            buffer.startBlock();
            buffer.addLine("if isinstance(obj.%1$s, List):", field);
            buffer.startBlock();
            buffer.addLine("obj.%1$s.href = href", field, readerName.getClassName());
            buffer.endBlock();
            buffer.addLine("else:");
            buffer.startBlock();
            buffer.addLine("obj.%1$s = list", field);
            buffer.endBlock();
            buffer.endBlock();
            firstLink = false;
        }
        // End if
        buffer.endBlock();
        // End method
        buffer.endBlock();
        buffer.addLine();
    }
}
#method_after
private void generateMethods(StructType type) {
    PythonClassName typeName = pythonNames.getTypeName(type);
    PythonClassName readerName = pythonNames.getReaderName(type);
    // Generate the method that reads one instance:
    buffer.addLine("@staticmethod");
    buffer.addLine("def read_one(reader):");
    buffer.startBlock();
    buffer.addLine("# Do nothing if there aren't more tags:");
    buffer.addLine("if not reader.forward():");
    buffer.startBlock();
    buffer.addLine("return None");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Create the object:");
    buffer.addLine("obj = types.%1$s()", typeName.getClassName());
    buffer.addLine();
    buffer.addLine("# Process the attributes:");
    buffer.addLine("obj.href = reader.get_attribute('href')");
    generateAttributesRead(type);
    buffer.addLine();
    buffer.addLine("# Discard the start tag:");
    buffer.addLine("empty = reader.empty_element()");
    buffer.addLine("reader.read()");
    buffer.addLine("if empty:");
    buffer.startBlock();
    buffer.addLine("return obj");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Process the inner elements:");
    generateElementsRead(type);
    buffer.addLine();
    buffer.addLine("# Discard the end tag:");
    buffer.addLine("reader.read()");
    buffer.addLine();
    buffer.addLine("return obj");
    buffer.endBlock();
    buffer.addLine();
    // Generate the method that reads many instances:
    buffer.addLine("@staticmethod");
    buffer.addLine("def read_many(reader):");
    buffer.startBlock();
    buffer.addLine("# Do nothing if there aren't more tags:");
    buffer.addLine("objs = List()");
    buffer.addLine("if not reader.forward():");
    buffer.startBlock();
    buffer.addLine("return objs");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Process the attributes:");
    buffer.addLine("objs.href = reader.get_attribute('href')");
    buffer.addLine();
    buffer.addLine("# Discard the start tag:");
    buffer.addLine("empty = reader.empty_element()");
    buffer.addLine("reader.read()");
    buffer.addLine("if empty:");
    buffer.startBlock();
    buffer.addLine("return objs");
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Process the inner elements:");
    buffer.addLine("while reader.forward():");
    buffer.startBlock();
    buffer.addLine("objs.append(%1$s.read_one(reader))", readerName.getClassName());
    buffer.endBlock();
    buffer.addLine();
    buffer.addLine("# Discard the end tag:");
    buffer.addLine("reader.read()");
    buffer.addLine();
    buffer.addLine("return objs");
    buffer.endBlock();
    buffer.addLine();
    // Generate the method that reads links to lists:
    List<Link> links = type.links().filter(link -> link.getType() instanceof ListType).sorted().collect(toList());
    if (!links.isEmpty()) {
        buffer.addLine("@staticmethod");
        buffer.addLine("def _process_link(link, obj):");
        buffer.startBlock();
        buffer.addLine("# Process the attributes:");
        buffer.addLine("rel = link[0]");
        buffer.addLine("href = link[1]");
        buffer.addLine("if href and rel:");
        buffer.startBlock();
        boolean firstLink = true;
        for (Link link : links) {
            String keyword = firstLink ? "if" : "elif";
            String field = pythonNames.getMemberStyleName(link.getName());
            String rel = link.getName().words().map(String::toLowerCase).collect(joining());
            buffer.addLine("%1$s rel == \"%2$s\":", keyword, rel);
            buffer.startBlock();
            buffer.addLine("if obj.%1$s is not None:", field);
            buffer.startBlock();
            buffer.addLine("obj.%1$s.href = href", field);
            buffer.endBlock();
            buffer.addLine("else:");
            buffer.startBlock();
            buffer.addLine("obj.%1$s = List(href)", field);
            buffer.endBlock();
            buffer.endBlock();
            firstLink = false;
        }
        // End if
        buffer.endBlock();
        // End method
        buffer.endBlock();
        buffer.addLine();
    }
}
#end_block

#method_before
public MacPool createDecoratedPool(MacPool macPool, List<MacPoolDecorator> decorators) {
    log.debug("Creating decorated MacPool for {}", macPool);
    MacPool decoratedPool = decoratePool(macPool, decorators);
    log.debug("MacPool {} decorated as {}.", macPool, decoratedPool);
    return lockedObjectFactory.createLockingInstance(decoratedPool, MacPool.class, lockForMacPool(macPool.getId()));
}
#method_after
public MacPool createDecoratedPool(MacPool macPool, List<MacPoolDecorator> decorators) {
    MacPool lockedPool = lockedObjectFactory.createLockingInstance(macPool, MacPool.class, lockForMacPool(macPool.getId()));
    MacPool decoratedPool = decoratePool(lockedPool, decorators);
    log.debug("MacPool {} decorated as {}.", macPool, decoratedPool);
    return decoratedPool;
}
#end_block

#method_before
private MacPool decoratePool(MacPool macPool, List<MacPoolDecorator> decorators) {
    if (decorators == null || decorators.isEmpty()) {
        log.debug("No MacPoolDecorators passed to decorate pool {}. ", macPool);
        return macPool;
    }
    MacPool result = macPool;
    log.debug("Decorating MacPool {} with decorators: {}.", Arrays.toString(decorators.toArray()));
    for (MacPoolDecorator decorator : decorators) {
        decorator.setMacPool(result);
        result = decorator;
    }
    return result;
}
#method_after
private MacPool decoratePool(MacPool macPool, List<MacPoolDecorator> decorators) {
    if (CollectionUtils.isEmpty(decorators)) {
        log.debug("No MacPoolDecorators were passed to decorate pool {}. ", macPool);
        return macPool;
    }
    MacPool result = macPool;
    log.debug("Decorating MacPool {} with decorators: {}.", Arrays.toString(decorators.toArray()));
    for (MacPoolDecorator decorator : decorators) {
        decorator.setMacPool(result);
        result = decorator;
    }
    return result;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("allowDuplicateMacAddresses", allowDuplicateMacAddresses).append("defaultPool", defaultPool).append("description", description).append("id", id).append("name", name).append("ranges", ranges).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", id).append("name", name).append("description", description).append("ranges", ranges).append("allowDuplicateMacAddresses", allowDuplicateMacAddresses).append("defaultPool", defaultPool).build();
}
#end_block

#method_before
private void initializeMacPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    List<String> macsForMacPool = macPoolDao.getAllMacsForMacPool(macPool.getId());
    final MacPool pool = createPoolInternal(macPool);
    log.debug("Initializing {} with macs: {}", pool, Arrays.toString(macsForMacPool.toArray()));
    for (String mac : macsForMacPool) {
        pool.forceAddMac(mac);
    }
}
#method_after
private void initializeMacPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    List<String> macsForMacPool = macPoolDao.getAllMacsForMacPool(macPool.getId());
    final MacPool pool = createPoolInternal(macPool);
    log.debug("Initializing {} with macs: {}", pool, macsForMacPool);
    for (String mac : macsForMacPool) {
        pool.forceAddMac(mac);
    }
}
#end_block

#method_before
public MacPool getMacPoolForCluster(Guid clusterId, CommandContext commandContext) {
    return getMacPoolById(getMacPoolId(clusterId), commandContext);
}
#method_after
public ReadMacPool getMacPoolForCluster(Guid clusterId) {
    return getMacPoolById(getMacPoolId(clusterId));
}
#end_block

#method_before
public MacPool getMacPoolForCluster(Guid clusterId, CommandContext commandContext) {
    return getMacPoolById(getMacPoolId(clusterId), commandContext);
}
#method_after
public MacPool getMacPoolForCluster(Guid clusterId, CommandContext commandContext) {
    Objects.requireNonNull(commandContext);
    return getMacPoolById(getMacPoolId(clusterId), commandContext);
}
#end_block

#method_before
public MacPool getMacPoolById(Guid macPoolId) {
    MacPool result = getMacPoolById(macPoolId, Collections.emptyList());
    log.debug("Returning {} for use in compensation mechanism", result);
    return result;
}
#method_after
public MacPool getMacPoolById(Guid macPoolId) {
    return getMacPoolById(macPoolId, Collections.emptyList());
}
#end_block

#method_before
private MacPool getMacPoolById(Guid macPoolId, List<MacPoolDecorator> decorators) {
    try (AutoCloseableLock lock = readLockResource()) {
        return getMacPoolWithoutLocking(macPoolId, decorators);
    }
}
#method_after
private MacPool getMacPoolById(Guid macPoolId, List<MacPoolDecorator> decorators) {
    try (AutoCloseableLock lock = readLockResource()) {
        MacPool result = getMacPoolWithoutLocking(macPoolId, decorators);
        log.debug("Returning {} for requested id={}", result, macPoolId);
        return result;
    }
}
#end_block

#method_before
private MacPool getMacPoolWithoutLocking(Guid macPoolId, List<MacPoolDecorator> decorators) {
    final MacPool poolById = macPools.get(macPoolId);
    if (poolById == null) {
        throw new IllegalStateException(INEXISTENT_POOL_EXCEPTION_MESSAGE);
    }
    return decoratedMacPoolFactory.createDecoratedPool(poolById, decorators);
}
#method_after
private MacPool getMacPoolWithoutLocking(Guid macPoolId, List<MacPoolDecorator> decorators) {
    final MacPool poolById = macPools.get(macPoolId);
    if (poolById == null) {
        throw new IllegalStateException(createExceptionMessageMacPoolHavingIdDoesNotExist(macPoolId));
    }
    return decoratedMacPoolFactory.createDecoratedPool(poolById, decorators);
}
#end_block

#method_before
public void modifyPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        if (!macPools.containsKey(macPool.getId())) {
            throw new IllegalStateException(INEXISTENT_POOL_EXCEPTION_MESSAGE);
        }
        log.debug("Updating pool {}. (old will be deleted and new initialized from db entity)", macPool);
        removeWithoutLocking(macPool.getId());
        initializeMacPool(macPool);
    }
}
#method_after
public void modifyPool(org.ovirt.engine.core.common.businessentities.MacPool macPool) {
    try (AutoCloseableLock lock = writeLockResource()) {
        Guid macPoolId = macPool.getId();
        if (!macPools.containsKey(macPoolId)) {
            throw new IllegalStateException(createExceptionMessageMacPoolHavingIdDoesNotExist(macPoolId));
        }
        log.debug("Updating pool {}. (old will be deleted and new initialized from db entity)", macPool);
        removeWithoutLocking(macPoolId);
        initializeMacPool(macPool);
    }
}
#end_block

#method_before
private List<TransactionalStrategyState> getStrategyForMacAllocation() {
    List<TransactionalStrategyState> states = new ArrayList<>();
    if (usingCompensationState.shouldUseCompensation()) {
        states.add(usingCompensationState);
    }
    boolean shouldUseTxDecorator = TransactionSupport.current() != null;
    if (shouldUseTxDecorator) {
        states.add(usingTxDecoratorState);
    }
    if (states.isEmpty()) {
        states.add(nontransactionalState);
    }
    log.debug("Using {} as allocation strategies", Arrays.toString(states.toArray()));
    return states;
}
#method_after
private List<TransactionalStrategyState> getStrategyForMacAllocation() {
    List<TransactionalStrategyState> states = new ArrayList<>();
    if (usingCompensationState.shouldUseCompensation()) {
        states.add(usingCompensationState);
    }
    boolean shouldUseTxDecorator = TransactionSupport.current() != null;
    if (shouldUseTxDecorator) {
        states.add(usingTxDecoratorState);
    }
    if (states.isEmpty()) {
        states.add(nontransactionalState);
    }
    log.debug("Using {} as allocation strategies", states);
    return states;
}
#end_block

#method_before
@Override
public final void freeMacs(List<String> macs) {
    List<String> macsToRelease = filterOutUnusedMacs(macs);
    if (macsToRelease.isEmpty()) {
        log.warn("Call to release with empty collection as parameter.");
    } else {
        // we need to recalculate this on every call, since command context might change in between calls
        TransactionalStrategyState strategyForMacRelease = getStrategyForMacRelease();
        log.debug("Using {} as release strategy", strategyForMacRelease);
        strategyForMacRelease.releaseMacsOnCommit(macsToRelease);
    }
}
#method_after
@Override
public final void freeMacs(List<String> macs) {
    List<String> macsToRelease = filterOutUnusedMacs(macs);
    if (macsToRelease.isEmpty()) {
        log.warn("Trying to release MACs using empty collection as parameter.");
    } else {
        // we need to recalculate this on every call, since command context might change in between calls
        TransactionalStrategyState strategyForMacRelease = getStrategyForMacRelease();
        log.debug("Using {} as release strategy", strategyForMacRelease);
        strategyForMacRelease.releaseMacsOnCommit(macsToRelease);
    }
}
#end_block

#method_before
@Override
public void releaseMacsOnCommit(List<String> macs) {
    CompensationContext compensationContext = this.commandContext.getCompensationContext();
    ReleaseMacsCompensationListener compensationListener = this.compensationListener;
    log.debug("Registering macs: {} to be released in case of successful execution", Arrays.toString(macs.toArray()));
    compensationListener.macsToReleaseOnCommit.addAll(macs);
    log.debug("Registering compensation listener {}" + compensationListener);
    compensationContext.addListener(compensationListener);
}
#method_after
@Override
public void releaseMacsOnCommit(List<String> macs) {
    CompensationContext compensationContext = this.commandContext.getCompensationContext();
    ReleaseMacsCompensationListener compensationListener = this.compensationListener;
    log.debug("Registering macs: {} to be released in case of successful execution", macs);
    compensationListener.macsToReleaseOnCommit.addAll(macs);
    log.debug("Registering compensation listener {}" + compensationListener);
    compensationContext.addListener(compensationListener);
}
#end_block

#method_before
@Override
public void cleaningCompensationDataAfterSuccess() {
    log.debug("Command successfully executed, releasing macs: {}" + macsToReleaseOnCommit);
    macsToReleaseOnCommit.forEach(macPool::freeMac);
    /* This is probably not needed, since commands are not recycled and so it's not decorators / listeners.
                 * But why not to do it just to be super-sure.
                 */
    this.macsToReleaseOnCommit.clear();
}
#method_after
@Override
public void cleaningCompensationDataAfterSuccess() {
    log.debug("Command successfully executed, releasing macs: {}" + macsToReleaseOnCommit);
    macsToReleaseOnCommit.forEach(macPool::freeMac);
}
#end_block

#method_before
@Override
public void onSuccess() {
    log.debug("Command succeeded, releasing macs {}.", Arrays.toString(super.macs.toArray()));
    releaseMacs();
}
#method_after
@Override
public void onSuccess() {
    log.debug("Command succeeded, releasing macs {}.", super.macs);
    releaseMacs();
}
#end_block

#method_before
@Override
public void onRollback() {
    log.debug("Rollback occured, releasing macs {}.", Arrays.toString(super.macs.toArray()));
    releaseMacs();
}
#method_after
@Override
public void onRollback() {
    log.debug("Rollback occurred, releasing macs {}.", super.macs);
    releaseMacs();
}
#end_block

#method_before
@Override
public void releaseMacsOnCommit(List<String> macs) {
    log.debug("Non-tx, non-compensation state, immediately releasing macs {}.", Arrays.toString(macs.toArray()));
    macs.forEach(macPool::freeMac);
}
#method_after
@Override
public void releaseMacsOnCommit(List<String> macs) {
    log.debug("Non-tx, non-compensation state, immediately releasing macs {}.", macs);
    macs.forEach(macPool::freeMac);
}
#end_block

#method_before
@Override
public void freeMacs(List<String> macs) {
    log.debug("Releasing mac addresses {} back to {}", Arrays.toString(macs.toArray()), this);
    for (String mac : macs) {
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    }
}
#method_after
@Override
public void freeMacs(List<String> macs) {
    log.debug("Releasing mac addresses {} back to {}", macs, this);
    for (String mac : macs) {
        macsStorage.freeMac(MacAddressRangeUtils.macToLong(mac));
    }
}
#end_block

#method_before
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    log.debug("Allocating {} mac addresses from {}.", numberOfAddresses, this);
    List<Long> macs = macsStorage.allocateAvailableMacs(numberOfAddresses);
    List<String> result = MacAddressRangeUtils.macAddressesToStrings(macs);
    log.debug("Allocated mac addresses: {} from {}.", Arrays.toString(result.toArray()), this);
    // TODO MMUCHA: Dear code reviewer! i believe we can remove this operation... Please advise.
    Collections.sort(result);
    logWhenMacPoolIsEmpty();
    return result;
}
#method_after
@Override
public List<String> allocateMacAddresses(int numberOfAddresses) {
    log.debug("Allocating {} mac addresses from {}.", numberOfAddresses, this);
    List<Long> macs = macsStorage.allocateAvailableMacs(numberOfAddresses);
    List<String> result = MacAddressRangeUtils.macAddressesToStrings(macs);
    log.debug("Allocated mac addresses: {} from {}.", result, this);
    Collections.sort(result);
    logWhenMacPoolIsEmpty();
    return result;
}
#end_block

#method_before
public MacPool getMacPoolForCluster(Guid clusterId, CommandContext commandContext) {
    return getMacPoolById(getMacPoolId(clusterId), commandContext);
}
#method_after
public ReadMacPool getMacPoolForCluster(Guid clusterId) {
    return getMacPoolById(getMacPoolId(clusterId));
}
#end_block

#method_before
public MacPool getMacPoolForCluster(Guid clusterId, CommandContext commandContext) {
    return getMacPoolById(getMacPoolId(clusterId), commandContext);
}
#method_after
public MacPool getMacPoolForCluster(Guid clusterId, CommandContext commandContext) {
    Objects.requireNonNull(commandContext);
    return getMacPoolById(getMacPoolId(clusterId), commandContext);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    when(DbFacade.getInstance().getAuditLogDao()).thenReturn(auditLogDao);
    macPool = createMacPool(MAC_FROM, MAC_TO);
    cluster = createCluster(macPool);
    vmNic = createVmNic();
    when(decoratedMacPoolFactory.createDecoratedPool(any(org.ovirt.engine.core.bll.network.macpool.MacPool.class), anyListOf(MacPoolDecorator.class))).thenAnswer(invocation -> invocation.getArguments()[0]);
    macPoolPerCluster = new MacPoolPerCluster(macPoolDao, clusterDao, new MacPoolFactory(), decoratedMacPoolFactory);
}
#method_after
@Before
public void setUp() throws Exception {
    when(DbFacade.getInstance().getAuditLogDao()).thenReturn(auditLogDao);
    commandContext = CommandContext.createContext(SESSION_ID);
    macPool = createMacPool(MAC_FROM, MAC_TO);
    cluster = createCluster(macPool);
    vmNic = createVmNic();
    when(decoratedMacPoolFactory.createDecoratedPool(any(org.ovirt.engine.core.bll.network.macpool.MacPool.class), anyList())).thenAnswer(invocation -> invocation.getArguments()[0]);
    macPoolPerCluster = new MacPoolPerCluster(macPoolDao, clusterDao, new MacPoolFactory(), decoratedMacPoolFactory);
}
#end_block

#method_before
@Test()
public void testPoolDoesNotExistForGivenCluster() throws Exception {
    macPoolPerCluster.initialize();
    expectedException.expect(IllegalStateException.class);
    expectedException.expectMessage(MacPoolPerCluster.INEXISTENT_POOL_EXCEPTION_MESSAGE);
    macPoolPerCluster.getMacPoolForCluster(Guid.newGuid(), null);
}
#method_after
@Test()
public void testPoolDoesNotExistForGivenCluster() throws Exception {
    macPoolPerCluster.initialize();
    expectedException.expect(IllegalStateException.class);
    expectedException.expectMessage(MacPoolPerCluster.INEXISTENT_POOL_EXCEPTION_MESSAGE);
    getMacPool(Guid.newGuid());
}
#end_block

#method_before
@Test
public void testPoolOfGivenGuidExist() {
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    macPoolPerCluster.initialize();
    assertThat(macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null), is(notNullValue()));
}
#method_after
@Test
public void testPoolOfGivenGuidExist() {
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    macPoolPerCluster.initialize();
    assertThat(getMacPool(cluster.getId()), is(notNullValue()));
}
#end_block

#method_before
@Test
public void testNicIsCorrectlyAllocatedInScopedPool() throws Exception {
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    mockAllMacsForCluster(cluster, vmNic.getMacAddress());
    macPoolPerCluster.initialize();
    assertThat("scoped pool for this nic should exist", macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null), is(notNullValue()));
    assertThat("provided mac should be used in returned pool", macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null).isMacInUse(vmNic.getMacAddress()), is(true));
}
#method_after
@Test
public void testNicIsCorrectlyAllocatedInScopedPool() throws Exception {
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    mockAllMacsForCluster(cluster, vmNic.getMacAddress());
    macPoolPerCluster.initialize();
    assertThat("scoped pool for this nic should exist", getMacPool(cluster.getId()), is(notNullValue()));
    assertThat("provided mac should be used in returned pool", getMacPool(cluster.getId()).isMacInUse(vmNic.getMacAddress()), is(true));
}
#end_block

#method_before
@Test
public void testCreatePool() throws Exception {
    macPoolPerCluster.initialize();
    mockCluster(cluster);
    macPoolPerCluster.createPool(macPool);
    assertThat("scoped pool for this data center should exist", macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null), is(notNullValue()));
}
#method_after
@Test
public void testCreatePool() throws Exception {
    macPoolPerCluster.initialize();
    mockCluster(cluster);
    macPoolPerCluster.createPool(macPool);
    assertThat("scoped pool for this data center should exist", getMacPool(cluster.getId()), is(notNullValue()));
}
#end_block

#method_before
@Test
public void testModifyOfExistingMacPool() throws Exception {
    final String macAddress1 = "00:00:00:00:00:01";
    final String macAddress2 = "00:00:00:00:00:02";
    MacPool macPool = createMacPool(macAddress1, macAddress1);
    Cluster cluster = createCluster(macPool);
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    macPoolPerCluster.initialize();
    assertThat(macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null).addMac(MAC_FROM), is(true));
    assertThat(macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null).addMac(MAC_FROM), is(false));
    final String allocatedMac = allocateMac(cluster);
    /*needed due to implementation of modifyPool;
        modify assumes, that all allocated macs is used for vmNics. If allocatedMac succeeded it's expected that all
        vmNics were also successfully persisted to db or all allocated macs were returned to the pool. So after
        allocation we need to mock db, otherwise re-init in modifyPool would return improper results.*/
    mockAllMacsForCluster(cluster, allocatedMac);
    assertThat(allocatedMac, is(macAddress1));
    try {
        allocateMac(cluster);
        fail("this allocation should not succeed.");
    } catch (EngineException e) {
    // ok, this exception should occur.
    }
    macPool.setAllowDuplicateMacAddresses(true);
    final MacRange macRange = new MacRange();
    macRange.setMacFrom(macAddress1);
    macRange.setMacTo(macAddress2);
    macPool.setRanges(Collections.singletonList(macRange));
    macPoolPerCluster.modifyPool(macPool);
    assertThat(macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null).addMac(MAC_FROM), is(true));
    assertThat(allocateMac(cluster), is(macAddress2));
}
#method_after
@Test
public void testModifyOfExistingMacPool() throws Exception {
    final String macAddress1 = "00:00:00:00:00:01";
    final String macAddress2 = "00:00:00:00:00:02";
    MacPool macPool = createMacPool(macAddress1, macAddress1);
    Cluster cluster = createCluster(macPool);
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    macPoolPerCluster.initialize();
    assertThat(getMacPool(cluster.getId()).addMac(MAC_FROM), is(true));
    assertThat(getMacPool(cluster.getId()).addMac(MAC_FROM), is(false));
    final String allocatedMac = allocateMac(cluster);
    /*needed due to implementation of modifyPool;
        modify assumes, that all allocated macs is used for vmNics. If allocatedMac succeeded it's expected that all
        vmNics were also successfully persisted to db or all allocated macs were returned to the pool. So after
        allocation we need to mock db, otherwise re-init in modifyPool would return improper results.*/
    mockAllMacsForCluster(cluster, allocatedMac);
    assertThat(allocatedMac, is(macAddress1));
    try {
        allocateMac(cluster);
        fail("this allocation should not succeed.");
    } catch (EngineException e) {
    // ok, this exception should occur.
    }
    macPool.setAllowDuplicateMacAddresses(true);
    final MacRange macRange = new MacRange();
    macRange.setMacFrom(macAddress1);
    macRange.setMacTo(macAddress2);
    macPool.setRanges(Collections.singletonList(macRange));
    macPoolPerCluster.modifyPool(macPool);
    assertThat(getMacPool(cluster.getId()).addMac(MAC_FROM), is(true));
    assertThat(allocateMac(cluster), is(macAddress2));
}
#end_block

#method_before
protected String allocateMac(Cluster cluster) {
    return macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null).allocateNewMac();
}
#method_after
protected String allocateMac(Cluster cluster) {
    final Guid clusterId = cluster.getId();
    return getMacPool(clusterId).allocateNewMac();
}
#end_block

#method_before
@Test
public void testRemoveOfMacPool() throws Exception {
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    macPoolPerCluster.initialize();
    assertThat(macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null), is(notNullValue()));
    macPoolPerCluster.removePool(macPool.getId());
    expectedException.expect(IllegalStateException.class);
    expectedException.expectMessage(MacPoolPerCluster.INEXISTENT_POOL_EXCEPTION_MESSAGE);
    macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null);
}
#method_after
@Test
public void testRemoveOfMacPool() throws Exception {
    mockCluster(cluster);
    mockGettingAllMacPools(macPool);
    macPoolPerCluster.initialize();
    assertThat(getMacPool(cluster.getId()), is(notNullValue()));
    macPoolPerCluster.removePool(macPool.getId());
    expectedException.expect(IllegalStateException.class);
    expectedException.expectMessage(MacPoolPerCluster.INEXISTENT_POOL_EXCEPTION_MESSAGE);
    getMacPool(cluster.getId());
}
#end_block

#method_before
@Test
public void testRemoveOfInexistentMacPool() throws Exception {
    macPoolPerCluster.initialize();
    try {
        macPoolPerCluster.getMacPoolForCluster(cluster.getId(), null);
        fail("pool for given data center should not exist");
    } catch (IllegalStateException e) {
    // ignore this exception.
    }
    macPoolPerCluster.removePool(macPool.getId());
// nothing to test, should not fail.
}
#method_after
@Test
public void testRemoveOfInexistentMacPool() throws Exception {
    macPoolPerCluster.initialize();
    try {
        getMacPool(cluster.getId());
        fail("pool for given data center should not exist");
    } catch (IllegalStateException e) {
    // ignore this exception.
    }
    macPoolPerCluster.removePool(macPool.getId());
// nothing to test, should not fail.
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    stringEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nextTabIndex = stringEditor.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    nextTabIndex++;
    nameEditor.setTabIndex(nextTabIndex++);
    cidrEditor.setTabIndex(nextTabIndex++);
    ipVersionEditor.setTabIndex(nextTabIndex++);
    gatewayEditor.setTabIndex(nextTabIndex++);
    return dnsServersEditor.setTabIndexes(nextTabIndex);
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    nextTabIndex = nameEditor.setTabIndexes(nextTabIndex);
    nextTabIndex = cidrEditor.setTabIndexes(nextTabIndex);
    nextTabIndex = ipVersionEditor.setTabIndexes(nextTabIndex);
    nextTabIndex = gatewayEditor.setTabIndexes(nextTabIndex);
    nextTabIndex = dnsServersEditor.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected DnsServerEditor createWidget(EntityModel<String> value) {
    dnsServerEditor = new DnsServerEditor();
    if (usePatternFly) {
        dnsServerEditor.setUsePatternFly(true);
        dnsServerEditor.hideLabel();
        dnsServerEditor.getElement().getStyle().setWidth(width, Unit.PX);
    }
    dnsServerEditor.edit(value);
    return dnsServerEditor;
}
#method_after
@Override
protected DnsServerEditor createWidget(EntityModel<String> value) {
    DnsServerEditor widget = new DnsServerEditor();
    if (usePatternFly) {
        widget.setUsePatternFly(true);
        widget.hideLabel();
        widget.getElement().getStyle().setWidth(width, Unit.PX);
    }
    widget.edit(value);
    return widget;
}
#end_block

#method_before
@Override
protected EntityModel<String> createGhostValue() {
    EntityModel<String> value = new EntityModel<>();
    // $NON-NLS-1$
    value.setEntity("");
    return value;
}
#method_after
@Override
protected EntityModel<String> createGhostValue() {
    EntityModel<String> value = new EntityModel<>();
    value.setEntity("");
    return value;
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    try {
        super.proceedProxyReturnValue();
    } catch (VDSNetworkException e) {
        handleException(e, "exception was caught and ignored");
    } catch (VDSRecoveringException e) {
        handleException(e, "it's in recovery mode");
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    try {
        super.proceedProxyReturnValue();
    } catch (VDSNetworkException e) {
        handleException(e, "VDSNetworkException was caught");
    } catch (VDSRecoveringException e) {
        handleException(e, "it's in recovery mode");
    }
}
#end_block

#method_before
private void handleException(VDSExceptionBase e, String reason) {
    final VDSReturnValue vdsReturnValue = getVDSReturnValue();
    vdsReturnValue.setSucceeded(false);
    vdsReturnValue.setExceptionString(e.toString());
    vdsReturnValue.setExceptionObject(e);
    vdsReturnValue.setVdsError(e.getVdsError());
    final String msg = MessageFormatter.format("Failed to poll host {} - {}.", getParameters().getVdsId(), reason).getMessage();
    log.debug(msg, e);
}
#method_after
private void handleException(VDSExceptionBase e, String reason) {
    setVdsRuntimeError(e);
    final String msg = String.format("Failed to poll host %s - %s.", getParameters().getVdsId(), reason);
    log.debug(msg, e);
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItemsWithStatusForExclusiveLock() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.VmWithStatusForExclusive.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.VmWithStatusForExclusive.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItemsWithStatusForExclusiveLock() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VmWithStatusForExclusiveLock.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VmWithStatusForExclusiveLock.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
private List<VM.VmWithStatusForExclusive> getSelectedItemsWithStatusForExclusiveLock() {
    List<VM.VmWithStatusForExclusive> vmsWithStatusForExclusive = new ArrayList<>();
    for (VM vm : getSelectedItems()) {
        vmsWithStatusForExclusive.add(new VM.VmWithStatusForExclusive(vm));
    }
    return vmsWithStatusForExclusive;
}
#method_after
private List<VmWithStatusForExclusiveLock> getSelectedItemsWithStatusForExclusiveLock() {
    List<VmWithStatusForExclusiveLock> vmsWithStatusForExclusive = new ArrayList<>();
    for (VM vm : getSelectedItems()) {
        vmsWithStatusForExclusive.add(new VmWithStatusForExclusiveLock(vm));
    }
    return vmsWithStatusForExclusive;
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VM.VmWithStatusForExclusive.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(guestAgentPresent || acpiEnabled)) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecutePartially(vms, VmWithStatusForExclusiveLock.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(guestAgentPresent || acpiEnabled)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Fetch all the Iso files of a given type for storage pool with active storage domain of this domain Id.
    try {
        getQueryReturnValue().setReturnValue(getUserRequestForStorageDomainRepoFileList());
    } catch (Exception e) {
        log.error("Failed to retrieve image list: {}", e.getCause().getMessage());
        getQueryReturnValue().setExceptionString(e.getCause().getMessage());
        getQueryReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    // Fetch all the Iso files of a given type for storage pool with active storage domain of this domain Id.
    try {
        getQueryReturnValue().setReturnValue(getUserRequestForStorageDomainRepoFileList());
    } catch (Exception e) {
        String message = Optional.of(e.getCause()).map(Throwable::getMessage).orElse("");
        log.error("Failed to retrieve image list: {}", message);
        getQueryReturnValue().setExceptionString(message);
        getQueryReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
public static void updateMaxMemorySize(VmBase vmBase, Version effectiveCompatibilityVersion) {
    final int maxOfMaxMemorySize = VmCommonUtils.maxMemorySizeWithHotplugInMb(vmBase.getOsId(), effectiveCompatibilityVersion);
    if (vmBase.getMaxMemorySizeMb() > maxOfMaxMemorySize) {
        vmBase.setMaxMemorySizeMb(maxOfMaxMemorySize);
        return;
    }
    if (vmBase.getMaxMemorySizeMb() == 0) {
        vmBase.setMaxMemorySizeMb(VmCommonUtils.getMaxMemorySizeDefault(vmBase.getMemSizeMb()));
    }
}
#method_after
public static void updateMaxMemorySize(VmBase vmBase, Version effectiveCompatibilityVersion) {
    if (vmBase == null) {
        return;
    }
    final int maxOfMaxMemorySize = VmCommonUtils.maxMemorySizeWithHotplugInMb(vmBase.getOsId(), effectiveCompatibilityVersion);
    if (vmBase.getMaxMemorySizeMb() > maxOfMaxMemorySize) {
        vmBase.setMaxMemorySizeMb(maxOfMaxMemorySize);
        return;
    }
    if (vmBase.getMaxMemorySizeMb() == 0) {
        final int maxMemorySize = Math.min(VmCommonUtils.getMaxMemorySizeDefault(vmBase.getMemSizeMb()), maxOfMaxMemorySize);
        vmBase.setMaxMemorySizeMb(maxMemorySize);
    }
}
#end_block

#method_before
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!getBehavior().isBlankTemplateBehavior()) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.INITIAL_RUN_TAB, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    fireValidationCompleteEvent();
    return isValid;
}
#method_after
public boolean validate(boolean templateWithVersionRequired) {
    resetTabsValidity();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        validateNaming();
        getVmId().setIsValid(true);
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getVmId().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), createEachDiskAHasStorageDomainValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!getBehavior().isBlankTemplateBehavior()) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.INITIAL_RUN_TAB, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean hwPartValid = validateHwPart();
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    fireValidationCompleteEvent();
    return isValid;
}
#end_block

#method_before
@Override
public boolean test(StorageDomain storageDomain) {
    updateDisksStorage(storageDomain, memoryDisks);
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
    return storageDomainValidator.isDomainWithinThresholds().isValid() && storageDomainValidator.hasSpaceForClonedDisks(memoryDisks).isValid();
}
#method_after
@Override
public boolean test(StorageDomain storageDomain) {
    memoryStorageHandler.updateDisksStorage(storageDomain, memoryDisks);
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
    return storageDomainValidator.isDomainWithinThresholds().isValid() && storageDomainValidator.hasSpaceForClonedDisks(memoryDisks).isValid();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, device, type, address, specParams, isManaged, isPlugged, getIsReadOnly(), alias, customProperties, snapshotId, logicalName, hostDevice);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, device, type, address, specParams, managed, plugged, getReadOnly(), alias, customProperties, snapshotId, logicalName, hostDevice);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return Objects.equals(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && Objects.equals(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged() == other.getIsPlugged() && getIsReadOnly().equals(other.getIsReadOnly()) && alias.equals(other.alias) && Objects.equals(customProperties, other.customProperties) && Objects.equals(snapshotId, other.snapshotId) && Objects.equals(logicalName, other.logicalName) && Objects.equals(hostDevice, other.hostDevice);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return Objects.equals(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && Objects.equals(specParams, other.specParams) && managed == other.managed && isPlugged() == other.isPlugged() && getReadOnly().equals(other.getReadOnly()) && alias.equals(other.alias) && Objects.equals(customProperties, other.customProperties) && Objects.equals(snapshotId, other.snapshotId) && Objects.equals(logicalName, other.logicalName) && Objects.equals(hostDevice, other.hostDevice);
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", id).append("device", getDevice()).append("type", getType()).append("specParams", getSpecParams()).append("address", getAddress()).append("managed", getIsManaged()).append("plugged", getIsPlugged()).append("readOnly", getIsReadOnly()).append("deviceAlias", getAlias()).append("customProperties", getCustomProperties()).append("snapshotId", getSnapshotId()).append("logicalName", getLogicalName()).append("hostDevice", getHostDevice()).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", id).append("device", getDevice()).append("type", getType()).append("specParams", getSpecParams()).append("address", getAddress()).append("managed", isManaged()).append("plugged", isPlugged()).append("readOnly", getReadOnly()).append("deviceAlias", getAlias()).append("customProperties", getCustomProperties()).append("snapshotId", getSnapshotId()).append("logicalName", getLogicalName()).append("hostDevice", getHostDevice()).build();
}
#end_block

#method_before
protected boolean validateCanUpdateReadOnly() {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
        return validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#method_after
protected boolean validateCanUpdateReadOnly() {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.isPlugged()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
        return validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = diskDao.get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = diskVmElementDao.get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            baseDiskDao.update(diskForUpdate);
            diskVmElementDao.update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    // No specific update for LUN disk
                    break;
            }
            reloadDisks();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                vmDeviceDao.update(vmDeviceForVm);
            }
            if ((getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) || ((getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) && (getDiskVmElement().getDiskInterface() == DiskInterface.IDE))) {
                vmDeviceForVm.setAddress("");
                vmDeviceDao.clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = diskDao.get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = diskVmElementDao.get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            baseDiskDao.update(diskForUpdate);
            diskVmElementDao.update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    // No specific update for LUN disk
                    break;
            }
            reloadDisks();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setReadOnly(getNewDisk().getReadOnly());
                vmDeviceDao.update(vmDeviceForVm);
            }
            if ((getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) || ((getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) && (getDiskVmElement().getDiskInterface() == DiskInterface.IDE))) {
                vmDeviceForVm.setAddress("");
                vmDeviceDao.clearDeviceAddress(getOldDisk().getId());
            }
        }
    });
}
#end_block

#method_before
protected boolean updateReadOnlyRequested() {
    Boolean readOnlyNewValue = getNewDisk().getReadOnly();
    return readOnlyNewValue != null && !getVmDeviceForVm().getIsReadOnly().equals(readOnlyNewValue);
}
#method_after
protected boolean updateReadOnlyRequested() {
    Boolean readOnlyNewValue = getNewDisk().getReadOnly();
    return readOnlyNewValue != null && !getVmDeviceForVm().getReadOnly().equals(readOnlyNewValue);
}
#end_block

#method_before
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#method_after
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().isPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias())) {
            return false;
        }
    }
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failValidation(EngineMessage.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failValidation(EngineMessage.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias())) {
            return false;
        }
    }
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.isPlugged()) {
        return failValidation(EngineMessage.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.isPlugged()) {
        return failValidation(EngineMessage.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#end_block

#method_before
protected void updateDeviceProperties() {
    VmDevice device = vmDeviceDao.get(oldVmDevice.getId());
    device.setIsPlugged(true);
    vmDeviceDao.updateHotPlugDisk(device);
}
#method_after
protected void updateDeviceProperties() {
    VmDevice device = vmDeviceDao.get(oldVmDevice.getId());
    device.setPlugged(true);
    vmDeviceDao.updateHotPlugDisk(device);
}
#end_block

#method_before
@Override
public void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#method_after
@Override
public void buildVmCD() {
    Map<String, Object> struct;
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    // check if we have payload CD
    if (hasPayload) {
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vm.getVmPayload(), struct, vm);
        addDevice(struct, vm.getVmPayload(), "");
    }
    // check first if CD was given as a RunOnce parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getCdPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName(), "", null, true, true, true, "", null, null, null);
        struct = new HashMap<>();
        vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
        addDevice(struct, vmDevice, vm.getCdPath());
    } else {
        // get vm device for this CD from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.isManaged()) {
                continue;
            }
            // the method, so no need to add the device again,
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            struct = new HashMap<>();
            String cdPath = vm.getCdPath();
            vmInfoBuildUtils.addCdDetails(vmDevice, struct, vm);
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            addDevice(struct, vmDevice, cdPath == null ? "" : cdPath);
        }
    }
    numOfReservedScsiIndexes++;
}
#end_block

#method_before
@Override
public void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#method_after
@Override
public void buildVmFloppy() {
    // check if we have payload Floppy
    boolean hasPayload = vm.getVmPayload() != null && vm.getVmPayload().getDeviceType() == VmDeviceType.FLOPPY;
    if (hasPayload) {
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vm.getVmPayload(), struct);
        addDevice(struct, vm.getVmPayload(), "");
    } else // check first if Floppy was given as a parameter
    if (vm.isRunOnce() && !StringUtils.isEmpty(vm.getFloppyPath())) {
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName(), "", null, true, true, true, "", null, null, null);
        Map<String, Object> struct = new HashMap<>();
        vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
        addDevice(struct, vmDevice, vm.getFloppyPath());
    } else {
        // get vm device for this Floppy from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.DISK, VmDeviceType.FLOPPY.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.isManaged()) {
                continue;
            }
            // instead of the blank cd
            if (!VmPayload.isPayload(vmDevice.getSpecParams()) && vmDevices.size() > 1) {
                continue;
            }
            // need to add the device again
            if (VmPayload.isPayload(vmDevice.getSpecParams())) {
                continue;
            }
            Map<String, Object> struct = new HashMap<>();
            String file = vm.getFloppyPath();
            vmInfoBuildUtils.addFloppyDetails(vmDevice, struct);
            addDevice(struct, vmDevice, file);
        }
    }
}
#end_block

#method_before
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = vmInfoBuildUtils.getSortedDisks(vm);
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion())) {
                struct.put(VdsProperties.DISCARD, dve.isPassDiscard());
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            bootableDevices.add(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = vmInfoBuildUtils.getSortedDisks(vm);
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.isManaged()) {
            continue;
        }
        if (vmDevice.isPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion())) {
                struct.put(VdsProperties.DISCARD, dve.isPassDiscard());
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            bootableDevices.add(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
public void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            Map<String, Object> struct = new HashMap<>();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            bootableDevices.add(vmDevice);
        }
    }
}
#method_after
@Override
public void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE.getName()));
    devicesByDeviceId.putAll(Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.INTERFACE, VmDeviceType.HOST_DEVICE.getName())));
    for (VmNic vmInterface : vm.getInterfaces()) {
        // get vm device for this nic from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId()));
        if (vmDevice != null && vmDevice.isManaged() && vmDevice.isPlugged()) {
            Map<String, Object> struct = new HashMap<>();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (vmInterface.isPassthrough()) {
                String vfDeviceName = vm.getPassthroughVnicToVfMap().get(vmInterface.getId());
                vmInfoBuildUtils.addNetworkVirtualFunctionProperties(struct, vmInterface, vmDevice, vfDeviceName, vm);
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, vmInfoBuildUtils.evaluateInterfaceType(ifaceType, vm.getHasAgent()));
            }
            devices.add(struct);
            bootableDevices.add(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
public void buildVmBootSequence() {
    // recalculate boot order from source devices and set it to target devices
    VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), bootableDevices);
    for (VmDevice vmDevice : bootableDevices) {
        for (Map<String, Object> struct : devices) {
            String deviceId = (String) struct.get(VdsProperties.DeviceId);
            if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                if (vmDevice.getBootOrder() > 0) {
                    struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                }
                break;
            }
        }
    }
}
#method_after
@Override
public void buildVmBootSequence() {
    // recalculate boot order from source devices and set it to target devices
    VmDeviceCommonUtils.updateVmDevicesBootOrder(vm.isRunOnce() ? vm.getBootSequence() : vm.getDefaultBootSequence(), bootableDevices, vm.getInterfaces(), VmDeviceCommonUtils.extractDiskVmElements(vm));
    for (VmDevice vmDevice : bootableDevices) {
        for (Map<String, Object> struct : devices) {
            String deviceId = (String) struct.get(VdsProperties.DeviceId);
            if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                if (vmDevice.getBootOrder() > 0) {
                    struct.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                }
                break;
            }
        }
    }
}
#end_block

#method_before
@Override
public void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName(), "", specParams, true, true, true, "", null, null, null);
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#method_after
@Override
public void buildVmMemoryBalloon() {
    if (vm.isRunOnce() && vm.isBalloonEnabled()) {
        Map<String, Object> specParams = new HashMap<>();
        specParams.put(VdsProperties.Model, VdsProperties.Virtio);
        VmDevice vmDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName(), "", specParams, true, true, true, "", null, null, null);
        addMemBalloonDevice(vmDevice);
    } else {
        // get vm device for this Balloon from DB
        List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unamanged devices (handled separtely)
            if (!vmDevice.isManaged()) {
                continue;
            }
            addMemBalloonDevice(vmDevice);
            // only one memory balloon should exist
            break;
        }
    }
}
#end_block

#method_before
private void buildVmVideoDevicesFromDb() {
    List<VmDevice> vmVideoDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.VIDEO);
    for (VmDevice vmVideoDevice : vmVideoDevices) {
        // skip unmanaged devices (handled separately)
        if (!vmVideoDevice.getIsManaged()) {
            continue;
        }
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmVideoDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmVideoDevice.getDevice());
        vmInfoBuildUtils.addAddress(vmVideoDevice, struct);
        struct.put(VdsProperties.SpecParams, vmVideoDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmVideoDevice.getId().getDeviceId()));
        devices.add(struct);
    }
}
#method_after
private void buildVmVideoDevicesFromDb() {
    List<VmDevice> vmVideoDevices = vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), VmDeviceGeneralType.VIDEO);
    for (VmDevice vmVideoDevice : vmVideoDevices) {
        // skip unmanaged devices (handled separately)
        if (!vmVideoDevice.isManaged()) {
            continue;
        }
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, vmVideoDevice.getType().getValue());
        struct.put(VdsProperties.Device, vmVideoDevice.getDevice());
        vmInfoBuildUtils.addAddress(vmVideoDevice, struct);
        struct.put(VdsProperties.SpecParams, vmVideoDevice.getSpecParams());
        struct.put(VdsProperties.DeviceId, String.valueOf(vmVideoDevice.getId().getDeviceId()));
        devices.add(struct);
    }
}
#end_block

#method_before
private void updateDevice() {
    vmDevice.setIsPlugged(getParameters().getAction() == PlugAction.PLUG);
    vmDeviceDao.update(vmDevice);
}
#method_after
private void updateDevice() {
    vmDevice.setPlugged(getParameters().getAction() == PlugAction.PLUG);
    vmDeviceDao.update(vmDevice);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVmNetworkInterfaceDao();
    existingVmInterface = dao.get(FixturesTool.VM_NETWORK_INTERFACE);
    existingTemplateInterface = dao.get(FixturesTool.TEMPLATE_NETWORK_INTERFACE);
    newVmInterface = new VmNetworkInterface();
    newVmInterface.setStatistics(new VmNetworkStatistics());
    newVmInterface.setId(Guid.newGuid());
    newVmInterface.setVnicProfileId(FixturesTool.VM_NETWORK_INTERFACE_PROFILE);
    newVmInterface.setName("eth77");
    newVmInterface.setNetworkName("enginet");
    newVmInterface.setLinked(true);
    newVmInterface.setSpeed(1000);
    newVmInterface.setType(3);
    newVmInterface.setMacAddress("01:C0:81:21:71:17");
    newVmDevice.setType(VmDeviceGeneralType.INTERFACE);
    newVmDevice.setDevice("bridge");
    newVmDevice.setAddress("sample");
    newVmDevice.setIsManaged(true);
    newVmDevice.setIsPlugged(true);
    newVmDevice.setIsReadOnly(false);
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "val1");
    newVmDevice.setCustomProperties(customProp);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVmNetworkInterfaceDao();
    existingVmInterface = dao.get(FixturesTool.VM_NETWORK_INTERFACE);
    existingTemplateInterface = dao.get(FixturesTool.TEMPLATE_NETWORK_INTERFACE);
    newVmInterface = new VmNetworkInterface();
    newVmInterface.setStatistics(new VmNetworkStatistics());
    newVmInterface.setId(Guid.newGuid());
    newVmInterface.setVnicProfileId(FixturesTool.VM_NETWORK_INTERFACE_PROFILE);
    newVmInterface.setName("eth77");
    newVmInterface.setNetworkName("enginet");
    newVmInterface.setLinked(true);
    newVmInterface.setSpeed(1000);
    newVmInterface.setType(3);
    newVmInterface.setMacAddress("01:C0:81:21:71:17");
    newVmDevice.setType(VmDeviceGeneralType.INTERFACE);
    newVmDevice.setDevice("bridge");
    newVmDevice.setAddress("sample");
    newVmDevice.setManaged(true);
    newVmDevice.setPlugged(true);
    newVmDevice.setReadOnly(false);
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "val1");
    newVmDevice.setCustomProperties(customProp);
}
#end_block

#method_before
@Test
public void testUpdateHotPlugDisk() {
    VmDevice vmDevice = dao.get(getExistingEntityId());
    boolean newPluggedValue = !vmDevice.getIsPlugged();
    assertTrue(StringUtils.isNotBlank(vmDevice.getAddress()));
    vmDevice.setIsPlugged(newPluggedValue);
    dao.updateHotPlugDisk(vmDevice);
    dao.get(getExistingEntityId());
    assertEquals(vmDevice.getIsPlugged(), newPluggedValue);
}
#method_after
@Test
public void testUpdateHotPlugDisk() {
    VmDevice vmDevice = dao.get(getExistingEntityId());
    boolean newPluggedValue = !vmDevice.isPlugged();
    assertTrue(StringUtils.isNotBlank(vmDevice.getAddress()));
    vmDevice.setPlugged(newPluggedValue);
    dao.updateHotPlugDisk(vmDevice);
    dao.get(getExistingEntityId());
    assertEquals(vmDevice.isPlugged(), newPluggedValue);
}
#end_block

#method_before
@Test
public void validateFailedROVmAttachedToPool() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    command.getParameters().getDiskInfo().setReadOnly(true);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(vm);
    // Default RO is false
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    vmDevice.setIsReadOnly(true);
    command.getParameters().getDiskInfo().setReadOnly(false);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#method_after
@Test
public void validateFailedROVmAttachedToPool() {
    when(diskDao.get(diskImageGuid)).thenReturn(createDiskImage());
    command.getParameters().getDiskInfo().setReadOnly(true);
    VM vm = createVm(VMStatus.Down);
    vm.setVmPoolId(Guid.newGuid());
    initializeCommand(vm);
    // Default RO is false
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    vmDevice.setReadOnly(true);
    command.getParameters().getDiskInfo().setReadOnly(false);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
}
#end_block

#method_before
@Test
public void testFailedRoDiskResize() {
    ((DiskImage) command.getParameters().getDiskInfo()).setSize(command.getParameters().getDiskInfo().getSize() * 2L);
    initializeCommand();
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    vmDevice.setIsReadOnly(true);
    assertFalse(command.validateCanResizeDisk());
    ValidateTestUtils.assertValidationMessages("wrong failure", command, EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#method_after
@Test
public void testFailedRoDiskResize() {
    ((DiskImage) command.getParameters().getDiskInfo()).setSize(command.getParameters().getDiskInfo().getSize() * 2L);
    initializeCommand();
    DiskImage oldDisk = createDiskImage();
    doReturn(oldDisk).when(command).getOldDisk();
    VmDevice vmDevice = stubVmDevice(diskImageGuid, vmId);
    vmDevice.setReadOnly(true);
    assertFalse(command.validateCanResizeDisk());
    ValidateTestUtils.assertValidationMessages("wrong failure", command, EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
}
#end_block

#method_before
private void addReadOnlyColumn() {
    final AbstractCheckboxColumn<VmDevice> readonlyColumn = new AbstractCheckboxColumn<VmDevice>() {

        @Override
        public Boolean getValue(VmDevice object) {
            return object.getIsReadOnly();
        }

        @Override
        protected boolean canEdit(VmDevice object) {
            return false;
        }
    };
    readonlyColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(readonlyColumn, constants.deviceReadOnlyAlias(), "70px");
}
#method_after
private void addReadOnlyColumn() {
    final AbstractCheckboxColumn<VmDevice> readonlyColumn = new AbstractCheckboxColumn<VmDevice>() {

        @Override
        public Boolean getValue(VmDevice object) {
            return object.getReadOnly();
        }

        @Override
        protected boolean canEdit(VmDevice object) {
            return false;
        }
    };
    readonlyColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(readonlyColumn, constants.deviceReadOnlyAlias(), "70px");
}
#end_block

#method_before
private void addPluggedColumn() {
    final AbstractCheckboxColumn<VmDevice> pluggedColumn = new AbstractCheckboxColumn<VmDevice>() {

        @Override
        public Boolean getValue(VmDevice object) {
            return object.getIsPlugged();
        }

        @Override
        protected boolean canEdit(VmDevice object) {
            return false;
        }
    };
    pluggedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(pluggedColumn, constants.devicePluggedAlias(), "70px");
}
#method_after
private void addPluggedColumn() {
    final AbstractCheckboxColumn<VmDevice> pluggedColumn = new AbstractCheckboxColumn<VmDevice>() {

        @Override
        public Boolean getValue(VmDevice object) {
            return object.isPlugged();
        }

        @Override
        protected boolean canEdit(VmDevice object) {
            return false;
        }
    };
    pluggedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(pluggedColumn, constants.devicePluggedAlias(), "70px");
}
#end_block

#method_before
private void addManagedColumn() {
    final AbstractCheckboxColumn<VmDevice> managedColumn = new AbstractCheckboxColumn<VmDevice>() {

        @Override
        public Boolean getValue(VmDevice object) {
            return object.getIsManaged();
        }

        @Override
        protected boolean canEdit(VmDevice object) {
            return false;
        }
    };
    managedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(managedColumn, constants.deviceManagedAlias(), "70px");
}
#method_after
private void addManagedColumn() {
    final AbstractCheckboxColumn<VmDevice> managedColumn = new AbstractCheckboxColumn<VmDevice>() {

        @Override
        public Boolean getValue(VmDevice object) {
            return object.isManaged();
        }

        @Override
        protected boolean canEdit(VmDevice object) {
            return false;
        }
    };
    managedColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(managedColumn, constants.deviceManagedAlias(), "70px");
}
#end_block

#method_before
private VmDevice addManagedVmDevice(VmDevice vmDevice) {
    vmDevice.setIsManaged(true);
    vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    return vmDevice;
}
#method_after
private VmDevice addManagedVmDevice(VmDevice vmDevice) {
    vmDevice.setManaged(true);
    vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
    return vmDevice;
}
#end_block

#method_before
private VmDevice readVmDevice(XmlNode node, Guid deviceId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS).innerText)) {
        vmDevice.setAddress(String.valueOf(selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS).innerText));
    } else {
        vmDevice.setAddress("");
    }
    if (selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS).innerText)) {
        vmDevice.setAlias(String.valueOf(selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS).innerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = selectSingleNode(node, OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.innerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText)) {
        vmDevice.setDevice(String.valueOf(selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText)) {
        vmDevice.setIsPlugged(Boolean.valueOf(selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText));
    } else {
        vmDevice.setIsPlugged(Boolean.TRUE);
    }
    if (selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS).innerText)) {
        vmDevice.setIsReadOnly(Boolean.valueOf(selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS).innerText));
    } else {
        vmDevice.setIsReadOnly(Boolean.FALSE);
    }
    if (selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (selectSingleNode(node, OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).innerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    }
    return vmDevice;
}
#method_after
private VmDevice readVmDevice(XmlNode node, Guid deviceId) {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(deviceId, vmBase.getId()));
    if (selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS).innerText)) {
        vmDevice.setAddress(String.valueOf(selectSingleNode(node, OvfProperties.VMD_ADDRESS, _xmlNS).innerText));
    } else {
        vmDevice.setAddress("");
    }
    if (selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS).innerText)) {
        vmDevice.setAlias(String.valueOf(selectSingleNode(node, OvfProperties.VMD_ALIAS, _xmlNS).innerText));
    } else {
        vmDevice.setAlias("");
    }
    XmlNode specParamsNode = selectSingleNode(node, OvfProperties.VMD_SPEC_PARAMS, _xmlNS);
    if (specParamsNode != null && !StringUtils.isEmpty(specParamsNode.innerText)) {
        vmDevice.setSpecParams(getMapNode(specParamsNode));
    } else {
        // Empty map
        vmDevice.setSpecParams(Collections.<String, Object>emptyMap());
    }
    if (selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)) {
        vmDevice.setType(VmDeviceGeneralType.forValue(String.valueOf(selectSingleNode(node, OvfProperties.VMD_TYPE, _xmlNS).innerText)));
    } else {
        int resourceType = getResourceType(node, OvfProperties.VMD_RESOURCE_TYPE);
        vmDevice.setType(VmDeviceGeneralType.forValue(VmDeviceType.getoVirtDevice(resourceType)));
    }
    if (selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText)) {
        vmDevice.setDevice(String.valueOf(selectSingleNode(node, OvfProperties.VMD_DEVICE, _xmlNS).innerText));
    } else {
        setDeviceByResource(node, vmDevice);
    }
    if (selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText)) {
        vmDevice.setPlugged(Boolean.valueOf(selectSingleNode(node, OvfProperties.VMD_IS_PLUGGED, _xmlNS).innerText));
    } else {
        vmDevice.setPlugged(Boolean.TRUE);
    }
    if (selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS) != null && !StringUtils.isEmpty(selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS).innerText)) {
        vmDevice.setReadOnly(Boolean.valueOf(selectSingleNode(node, OvfProperties.VMD_IS_READONLY, _xmlNS).innerText));
    } else {
        vmDevice.setReadOnly(Boolean.FALSE);
    }
    if (selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)) {
        vmDevice.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(String.valueOf(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    } else {
        vmDevice.setCustomProperties(null);
    }
    if (selectSingleNode(node, OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS) != null && StringUtils.isNotEmpty(selectSingleNode(node, OvfProperties.VMD_SNAPSHOT_PROP, _xmlNS).innerText)) {
        vmDevice.setSnapshotId(new Guid(String.valueOf(selectSingleNode(node, OvfProperties.VMD_CUSTOM_PROP, _xmlNS).innerText)));
    }
    return vmDevice;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.Down) {
        return failVmStatusIllegal();
    }
    disk = diskHandler.loadDiskFromSnapshot(getDiskVmElement().getDiskId(), getParameters().getSnapshotId());
    if (!isDiskExistAndAttachedToVm(disk)) {
        return false;
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), getVmId()));
    if (vmDevice == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_DETACHED);
    }
    if (vmDevice.getSnapshotId() != null) {
        disk = diskHandler.loadDiskFromSnapshot(disk.getId(), vmDevice.getSnapshotId());
    }
    if (vmDevice.getIsPlugged() && getVm().getStatus() != VMStatus.Down) {
        if (!isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias())) {
            return false;
        }
    }
    // Check if disk has no snapshots before detaching it.
    if (disk.getDiskStorageType().isInternal()) {
        // therefore for attached disk snapshot it shouldn't be checked whether it has snapshots or not.
        if (vmDevice.getSnapshotId() == null && diskImageDao.getAllSnapshotsForImageGroup(disk.getId()).size() > 1) {
            return failValidation(EngineMessage.ERROR_CANNOT_DETACH_DISK_WITH_SNAPSHOT);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.Down) {
        return failVmStatusIllegal();
    }
    disk = diskHandler.loadDiskFromSnapshot(getDiskVmElement().getDiskId(), getParameters().getSnapshotId());
    if (!isDiskExistAndAttachedToVm(disk)) {
        return false;
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(disk.getId(), getVmId()));
    if (vmDevice == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_ALREADY_DETACHED);
    }
    if (vmDevice.getSnapshotId() != null) {
        disk = diskHandler.loadDiskFromSnapshot(disk.getId(), vmDevice.getSnapshotId());
    }
    if (vmDevice.isPlugged() && getVm().getStatus() != VMStatus.Down) {
        if (!isDiskSupportedForPlugUnPlug(getDiskVmElement(), disk.getDiskAlias())) {
            return false;
        }
    }
    // Check if disk has no snapshots before detaching it.
    if (disk.getDiskStorageType().isInternal()) {
        // therefore for attached disk snapshot it shouldn't be checked whether it has snapshots or not.
        if (vmDevice.getSnapshotId() == null && diskImageDao.getAllSnapshotsForImageGroup(disk.getId()).size() > 1) {
            return failValidation(EngineMessage.ERROR_CANNOT_DETACH_DISK_WITH_SNAPSHOT);
        }
    }
    return true;
}
#end_block

#method_before
private boolean diskShouldBeUnPlugged() {
    return Boolean.TRUE.equals(getParameters().isPlugUnPlug() && vmDevice.getIsPlugged() && getVm().getStatus() != VMStatus.Down);
}
#method_after
private boolean diskShouldBeUnPlugged() {
    return Boolean.TRUE.equals(getParameters().isPlugUnPlug() && vmDevice.isPlugged() && getVm().getStatus() != VMStatus.Down);
}
#end_block

#method_before
public void setVmDevices(VmBase vmBase) {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vmBase.getId());
    vmBase.setUnmanagedDeviceList(vmDeviceDao.getUnmanagedDevicesByVmId(vmBase.getId()));
    Map<Guid, VmDevice> vmManagedDeviceMap = new HashMap<>();
    for (VmDevice device : devices) {
        if (device.getIsManaged()) {
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vmBase.setManagedDeviceMap(vmManagedDeviceMap);
}
#method_after
public void setVmDevices(VmBase vmBase) {
    List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vmBase.getId());
    vmBase.setUnmanagedDeviceList(vmDeviceDao.getUnmanagedDevicesByVmId(vmBase.getId()));
    Map<Guid, VmDevice> vmManagedDeviceMap = new HashMap<>();
    for (VmDevice device : devices) {
        if (device.isManaged()) {
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vmBase.setManagedDeviceMap(vmManagedDeviceMap);
}
#end_block

#method_before
private void addImportedInterfaces(VmBase vmBase, List<VmDevice> vmDevicesToUpdate) {
    for (VmNic iface : vmBase.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addInterface(vmBase.getId(), deviceId, true, iface.isPassthrough(), getVmDeviceAddress(vmBase, deviceId));
        VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            vmBase.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface, vmBase));
        updateImportedVmDevice(vmBase, vmDevice, deviceId, vmDevicesToUpdate);
    }
}
#method_after
private void addImportedInterfaces(VmBase vmBase, List<VmDevice> vmDevicesToUpdate) {
    for (VmNic iface : vmBase.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addInterface(vmBase.getId(), deviceId, true, iface.isPassthrough(), getVmDeviceAddress(vmBase, deviceId));
        VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            vmBase.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setPlugged(exportedDevice.isPlugged() && canPlugInterface(iface, vmBase));
        updateImportedVmDevice(vmBase, vmDevice, deviceId, vmDevicesToUpdate);
    }
}
#end_block

#method_before
private void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd) {
    boolean hasCd = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setIsManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add unmanaged devices
    vmDeviceToAdd.addAll(vmBase.getUnmanagedDeviceList());
}
#method_after
private void addImportedOtherDevices(VmBase vmBase, List<VmDevice> vmDeviceToAdd) {
    boolean hasCd = false;
    for (VmDevice vmDevice : vmBase.getManagedDeviceMap().values()) {
        switch(vmDevice.getType()) {
            case DISK:
                if (VmDeviceType.CDROM.getName().equals(vmDevice.getDevice())) {
                    hasCd = true;
                } else {
                    // disks are added separately
                    continue;
                }
                break;
            case INTERFACE:
                // network interfaces are added separately
                continue;
            case VIDEO:
                vmDevice.setSpecParams(getVideoDeviceSpecParams(vmBase));
                break;
            case HOSTDEV:
                // it is currently unsafe to import host devices, due to possibility of invalid dedicatedVmForVds
                continue;
        }
        vmDevice.setManaged(true);
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCd) {
        // add an empty CD
        addCdDevice(vmBase.getId());
    }
    // add unmanaged devices
    vmDeviceToAdd.addAll(vmBase.getUnmanagedDeviceList());
}
#end_block

#method_before
private void updateImportedVmDevice(VmBase vmBase, VmDevice vmDevice, Guid deviceId, List<VmDevice> vmDevicesToUpdate) {
    VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
    if (exportedDevice != null) {
        vmDevice.setAddress(exportedDevice.getAddress());
        vmDevice.setIsPlugged(exportedDevice.getIsPlugged());
        vmDevice.setIsReadOnly(exportedDevice.getIsReadOnly());
        vmDevicesToUpdate.add(vmDevice);
    }
}
#method_after
private void updateImportedVmDevice(VmBase vmBase, VmDevice vmDevice, Guid deviceId, List<VmDevice> vmDevicesToUpdate) {
    VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
    if (exportedDevice != null) {
        vmDevice.setAddress(exportedDevice.getAddress());
        vmDevice.setPlugged(exportedDevice.isPlugged());
        vmDevice.setReadOnly(exportedDevice.getReadOnly());
        vmDevicesToUpdate.add(vmDevice);
    }
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("host_device", entity.getHostDevice());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.isManaged()).addValue("is_plugged", entity.isPlugged()).addValue("is_readonly", entity.getReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("host_device", entity.getHostDevice());
}
#end_block

#method_before
@Override
public void updateHotPlugDisk(VmDevice vmDevice) {
    MapSqlParameterSource paramsForUpdate = createParameterSourceForUpdate(vmDevice).addValue("is_plugged", vmDevice.getIsPlugged());
    getCallsHandler().executeModification("UpdateVmDeviceForHotPlugDisk", paramsForUpdate);
}
#method_after
@Override
public void updateHotPlugDisk(VmDevice vmDevice) {
    MapSqlParameterSource paramsForUpdate = createParameterSourceForUpdate(vmDevice).addValue("is_plugged", vmDevice.isPlugged());
    getCallsHandler().executeModification("UpdateVmDeviceForHotPlugDisk", paramsForUpdate);
}
#end_block

#method_before
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        if (dbDevice == null) {
            dbDevice = getByDeviceType((String) vdsmDevice.get(VdsProperties.Device), dbDeviceMap);
            deviceId = dbDevice != null ? dbDevice.getDeviceId() : deviceId;
        }
        String logicalName = getDeviceLogicalName(vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            if (newDevice != null) {
                change.addDeviceToAdd(newDevice);
                processedDeviceIds.add(newDevice.getDeviceId());
            }
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
            processedDeviceIds.add(deviceId);
        }
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#method_after
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        if (dbDevice == null) {
            dbDevice = getByDeviceType((String) vdsmDevice.get(VdsProperties.Device), dbDeviceMap);
            deviceId = dbDevice != null ? dbDevice.getDeviceId() : deviceId;
        }
        String logicalName = getDeviceLogicalName(vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            if (newDevice != null) {
                change.addDeviceToAdd(newDevice);
                processedDeviceIds.add(newDevice.getDeviceId());
            }
        } else {
            dbDevice.setPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
            processedDeviceIds.add(deviceId);
        }
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#end_block

#method_before
private void handleRemovedDevices(Change change, Guid vmId, Set<Guid> libvirtDevices, List<VmDevice> dbDevices) {
    for (VmDevice device : dbDevices) {
        if (libvirtDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (deviceWithoutAddress(device)) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setIsPlugged(Boolean.FALSE);
                device.setAddress("");
                change.addDeviceToUpdate(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            change.addDeviceIdToRemove(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Change change, Guid vmId, Set<Guid> libvirtDevices, List<VmDevice> dbDevices) {
    for (VmDevice device : dbDevices) {
        if (libvirtDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (deviceWithoutAddress(device)) {
            continue;
        }
        if (device.isManaged()) {
            if (device.isPlugged()) {
                device.setPlugged(Boolean.FALSE);
                device.setAddress("");
                change.addDeviceToUpdate(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            change.addDeviceIdToRemove(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#end_block

#method_before
public static void updateVmDevicesBootOrder(VM vm, BootSequence bootSequence, List<VmDevice> devices) {
    int bootOrder = 0;
    // reset current boot order of all relevant devices before recomputing it.
    for (VmDevice device : devices) {
        device.setBootOrder(0);
    }
    switch(bootSequence) {
        case C:
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            break;
        case CD:
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            break;
        case CN:
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            break;
        case CND:
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            break;
        case N:
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(vm, devices, bootOrder);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(vm, devices, bootOrder);
            break;
    }
}
#method_after
public static void updateVmDevicesBootOrder(BootSequence bootSequence, Collection<VmDevice> devices, List<VmNetworkInterface> interfaces, Map<VmDeviceId, DiskVmElement> deviceIdToDiskVmElement) {
    int bootOrder = 0;
    // reset current boot order of all relevant devices before recomputing it.
    for (VmDevice device : devices) {
        device.setBootOrder(0);
    }
    switch(bootSequence) {
        case C:
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            break;
        case CD:
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case CDN:
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            break;
        case CN:
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            break;
        case CND:
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case D:
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case DC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            break;
        case DCN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            break;
        case DN:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            break;
        case DNC:
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            break;
        case N:
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            break;
        case NC:
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            break;
        case NCD:
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case ND:
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            bootOrder = setCDBootOrder(devices, bootOrder);
            break;
        case NDC:
            bootOrder = setNetworkBootOrder(devices, bootOrder, interfaces);
            bootOrder = setCDBootOrder(devices, bootOrder);
            bootOrder = setDiskBootOrder(devices, bootOrder, deviceIdToDiskVmElement);
            break;
    }
}
#end_block

#method_before
private static int setNetworkBootOrder(VM vm, List<VmDevice> devices, int bootOrder) {
    for (VmDevice pluggedInterface : sortInterfacesByName(vm, getPluggedManagedInterfaces(devices))) {
        pluggedInterface.setBootOrder(++bootOrder);
    }
    return bootOrder;
}
#method_after
private static int setNetworkBootOrder(Collection<VmDevice> devices, int bootOrder, List<VmNetworkInterface> interfaces) {
    for (VmDevice pluggedInterface : sortInterfacesByName(getPluggedManagedInterfaces(devices), interfaces)) {
        pluggedInterface.setBootOrder(++bootOrder);
    }
    return bootOrder;
}
#end_block

#method_before
private static List<VmDevice> getPluggedManagedInterfaces(List<VmDevice> devices) {
    List<VmDevice> result = new ArrayList<>();
    for (VmDevice device : devices) {
        if ((isHostDevInterface(device) || isBridge(device)) && device.getIsPlugged() && device.getIsManaged()) {
            result.add(device);
        }
    }
    return result;
}
#method_after
private static List<VmDevice> getPluggedManagedInterfaces(Collection<VmDevice> devices) {
    List<VmDevice> result = new ArrayList<>();
    for (VmDevice device : devices) {
        if ((isHostDevInterface(device) || isBridge(device)) && device.isPlugged() && device.isManaged()) {
            result.add(device);
        }
    }
    return result;
}
#end_block

#method_before
private static List<VmDevice> sortInterfacesByName(VM vm, List<VmDevice> pluggedInterfaces) {
    if (pluggedInterfaces.size() < 2) {
        return pluggedInterfaces;
    }
    final Map<Guid, String> deviceIdToIfaceName = new HashMap<>();
    for (VmNetworkInterface iface : vm.getInterfaces()) {
        deviceIdToIfaceName.put(iface.getId(), iface.getName());
    }
    Collections.sort(pluggedInterfaces, new Comparator<VmDevice>() {

        @Override
        public int compare(VmDevice first, VmDevice second) {
            Guid firstDeviceId = first.getId().getDeviceId();
            Guid secondDeviceId = second.getId().getDeviceId();
            String firstIfaceName = deviceIdToIfaceName.get(firstDeviceId);
            String secondIfaceName = deviceIdToIfaceName.get(secondDeviceId);
            return firstIfaceName.compareTo(secondIfaceName);
        }
    });
    return pluggedInterfaces;
}
#method_after
private static List<VmDevice> sortInterfacesByName(List<VmDevice> pluggedInterfaces, List<VmNetworkInterface> interfaces) {
    if (pluggedInterfaces.size() < 2) {
        return pluggedInterfaces;
    }
    final Map<Guid, String> deviceIdToIfaceName = new HashMap<>();
    for (VmNetworkInterface iface : interfaces) {
        deviceIdToIfaceName.put(iface.getId(), iface.getName());
    }
    Collections.sort(pluggedInterfaces, new Comparator<VmDevice>() {

        @Override
        public int compare(VmDevice first, VmDevice second) {
            Guid firstDeviceId = first.getId().getDeviceId();
            Guid secondDeviceId = second.getId().getDeviceId();
            String firstIfaceName = deviceIdToIfaceName.get(firstDeviceId);
            String secondIfaceName = deviceIdToIfaceName.get(secondDeviceId);
            return firstIfaceName.compareTo(secondIfaceName);
        }
    });
    return pluggedInterfaces;
}
#end_block

#method_before
private static int setCDBootOrder(List<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (isCD(device) && device.getIsPlugged()) {
            device.setBootOrder(++bootOrder);
        }
    }
    return bootOrder;
}
#method_after
private static int setCDBootOrder(Collection<VmDevice> devices, int bootOrder) {
    for (VmDevice device : devices) {
        if (isCD(device) && device.isPlugged()) {
            device.setBootOrder(++bootOrder);
        }
    }
    return bootOrder;
}
#end_block

#method_before
private static int setDiskBootOrder(VM vm, List<VmDevice> devices, int bootOrder) {
    LinkedList<VmDevice> diskDevices = new LinkedList<>();
    for (VmDevice device : devices) {
        if (isDisk(device)) {
            Guid id = device.getDeviceId();
            if (id != null && !id.equals(Guid.Empty)) {
                if (device.getSnapshotId() == null) {
                    diskDevices.addFirst(device);
                } else {
                    diskDevices.addLast(device);
                }
            }
        }
    }
    for (VmDevice device : diskDevices) {
        DiskVmElement dve = getDiskVmElement(vm, device.getDeviceId());
        if (dve != null && dve.isBoot()) {
            device.setBootOrder(++bootOrder);
        }
    }
    return bootOrder;
}
#method_after
private static int setDiskBootOrder(Collection<VmDevice> devices, int bootOrder, Map<VmDeviceId, DiskVmElement> deviceIdTodiskVmElement) {
    LinkedList<VmDevice> diskDevices = new LinkedList<>();
    for (VmDevice device : devices) {
        if (isDisk(device)) {
            Guid id = device.getDeviceId();
            if (id != null && !id.equals(Guid.Empty)) {
                if (device.getSnapshotId() == null) {
                    diskDevices.addFirst(device);
                } else {
                    diskDevices.addLast(device);
                }
            }
        }
    }
    for (VmDevice device : diskDevices) {
        DiskVmElement dve = deviceIdTodiskVmElement.get(device.getId());
        if (dve != null && dve.isBoot()) {
            device.setBootOrder(++bootOrder);
        }
    }
    return bootOrder;
}
#end_block

#method_before
public static void addVideoDevice(VmBase vmBase) {
    if (vmBase.getDefaultDisplayType().getDefaultVmDeviceType() == null) {
        return;
    }
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(Guid.newGuid(), vmBase.getId()));
    vmDevice.setType(VmDeviceGeneralType.VIDEO);
    vmDevice.setDevice(vmBase.getDefaultDisplayType().getDefaultVmDeviceType().getName());
    vmDevice.setIsManaged(true);
    vmDevice.setIsPlugged(true);
    vmDevice.setIsReadOnly(false);
    vmDevice.setAddress("");
    vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
}
#method_after
public static void addVideoDevice(VmBase vmBase) {
    if (vmBase.getDefaultDisplayType().getDefaultVmDeviceType() == null) {
        return;
    }
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(Guid.newGuid(), vmBase.getId()));
    vmDevice.setType(VmDeviceGeneralType.VIDEO);
    vmDevice.setDevice(vmBase.getDefaultDisplayType().getDefaultVmDeviceType().getName());
    vmDevice.setManaged(true);
    vmDevice.setPlugged(true);
    vmDevice.setReadOnly(false);
    vmDevice.setAddress("");
    vmBase.getManagedDeviceMap().put(vmDevice.getDeviceId(), vmDevice);
}
#end_block

#method_before
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (isMonitoringNeeded(vdsManager.getCopyVds().getStatus())) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(vdsManager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring().perform(fetcher.getChangedVms(), fetchTime, vdsManager, true);
            processDevices(fetcher.getVdsmVms().stream(), fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("poll")
public void poll() {
    if (isMonitoringNeeded(vdsManager.getStatus())) {
        VmsListFetcher fetcher = new VmsStatisticsFetcher(vdsManager);
        long fetchTime = System.nanoTime();
        if (fetcher.fetch()) {
            getVmsMonitoring().perform(fetcher.getChangedVms(), fetchTime, vdsManager, true);
            processDevices(fetcher.getVdsmVms().stream(), fetchTime);
        } else {
            log.info("Failed to fetch vms info for host '{}' - skipping VMs monitoring.", vdsManager.getVdsName());
        }
    }
}
#end_block

#method_before
boolean isMonitoringNeeded(VDSStatus status) {
    switch(status) {
        case Up:
        case NonResponsive:
        case Error:
        case NonOperational:
        case PreparingForMaintenance:
        case Initializing:
        case Connecting:
            return true;
        default:
            return false;
    }
}
#method_after
boolean isMonitoringNeeded(VDSStatus status) {
    switch(status) {
        default:
            return false;
        case Up:
        case Error:
        case NonOperational:
        case PreparingForMaintenance:
        // for monitoring but it's currently not final.
        case NonResponsive:
        case Initializing:
        case Connecting:
            return true;
    }
}
#end_block

#method_before
@Override
public HostJobInfo.HostJobStatus poll() {
    SubchainInfo info = getParameters().getSubchainInfo();
    return poller.pollImage(getStoragePoolId(), info.getStorageDomainId(), info.getImageGroupId(), info.getBaseImageId(), info.getGeneration(), getCommandId(), getActionType());
}
#method_after
@Override
public HostJobInfo.HostJobStatus poll() {
    SubchainInfo info = getParameters().getSubchainInfo();
    return poller.pollImage(getParameters().getStoragePoolId(), info.getStorageDomainId(), info.getImageGroupId(), info.getBaseImageId(), info.getBaseImageGeneration(), getCommandId(), getActionType());
}
#end_block

#method_before
@Override
public void attemptToFenceJob() {
    SubchainInfo info = getParameters().getSubchainInfo();
    VdsmImageLocationInfo locationInfo = new VdsmImageLocationInfo(info.getStorageDomainId(), info.getImageGroupId(), info.getBaseImageId(), info.getGeneration());
    FenceVolumeJobCommandParameters parameters = new FenceVolumeJobCommandParameters(locationInfo);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setStoragePoolId(getParameters().getStoragePoolId());
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    runInternalActionWithTasksContext(VdcActionType.FenceVolumeJob, parameters);
}
#method_after
@Override
public void attemptToFenceJob() {
    SubchainInfo info = getParameters().getSubchainInfo();
    VdsmImageLocationInfo locationInfo = new VdsmImageLocationInfo(info.getStorageDomainId(), info.getImageGroupId(), info.getBaseImageId(), info.getBaseImageGeneration());
    FenceVolumeJobCommandParameters parameters = new FenceVolumeJobCommandParameters(locationInfo);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setStoragePoolId(getParameters().getStoragePoolId());
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    runInternalActionWithTasksContext(VdcActionType.FenceVolumeJob, parameters);
}
#end_block

#method_before
private void completeGenerationInfo() {
    SubchainInfo info = getParameters().getSubchainInfo();
    DiskImage image = ImagesHandler.getVolumeInfoFromVdsm(getParameters().getStoragePoolId(), info.getStorageDomainId(), info.getImageGroupId(), info.getBaseImageId());
    info.setGeneration(image.getImage().getGeneration());
    persistCommandIfNeeded();
}
#method_after
private void completeGenerationInfo() {
    SubchainInfo info = getParameters().getSubchainInfo();
    DiskImage image = ImagesHandler.getVolumeInfoFromVdsm(getParameters().getStoragePoolId(), info.getStorageDomainId(), info.getImageGroupId(), info.getBaseImageId());
    info.setBaseImageGeneration(image.getImage().getGeneration());
    persistCommandIfNeeded();
}
#end_block

#method_before
public static Map<String, Object> prepareSubchainInfoForVdsCommand(SubchainInfo subchainInfo) {
    Map<String, Object> map = new HashMap<>();
    map.put("sd_id", subchainInfo.getStorageDomainId().toString());
    map.put("img_id", subchainInfo.getImageGroupId().toString());
    map.put("base_id", subchainInfo.getBaseImageId().toString());
    map.put("top_id", subchainInfo.getTopImageId().toString());
    if (subchainInfo.getGeneration() != null) {
        map.put("base_generation", subchainInfo.getGeneration());
    }
    return map;
}
#method_after
public static Map<String, Object> prepareSubchainInfoForVdsCommand(SubchainInfo subchainInfo) {
    Map<String, Object> map = new HashMap<>();
    map.put("sd_id", subchainInfo.getStorageDomainId().toString());
    map.put("img_id", subchainInfo.getImageGroupId().toString());
    map.put("base_id", subchainInfo.getBaseImageId().toString());
    map.put("top_id", subchainInfo.getTopImageId().toString());
    if (subchainInfo.getBaseImageGeneration() != null) {
        map.put("base_generation", subchainInfo.getBaseImageGeneration());
    }
    return map;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("storageDomainId", storageDomainId).append("imageGroupId", imageGroupId).append("baseImageId", baseImageId).append("topImageId", topImageId).append("generation", generation).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("storageDomainId", storageDomainId).append("imageGroupId", imageGroupId).append("baseImageId", baseImageId).append("topImageId", topImageId).append("generation", baseImageGeneration).build();
}
#end_block

#method_before
@Test
public void testValidateThereIsEnoughOfFreeMacsNoAllocations() {
    final ValidationResult actual = underTest.validateThereIsEnoughOfFreeMacs(singletonList(vmNetworkInterfaceMock), macPoolMock, ALWAYS_FALSE);
    Assert.assertThat(actual, ValidationResultMatchers.isValid());
}
#method_after
@Test
public void testValidateThereIsEnoughOfFreeMacsNoAllocations() {
    final ValidationResult actual = underTest.validateThereIsEnoughOfFreeMacs(singletonList(vmNetworkInterfaceMock), macPoolMock, ALWAYS_FALSE);
    assertThat(actual, isValid());
}
#end_block

#method_before
@Test
public void testValidateThereIsEnoughOfFreeMacsPositive() {
    when(macPoolMock.getAvailableMacsCount()).thenReturn(1);
    final ValidationResult actual = underTest.validateThereIsEnoughOfFreeMacs(singletonList(vmNetworkInterfaceMock), macPoolMock, ALWAYS_TRUE);
    Assert.assertThat(actual, ValidationResultMatchers.isValid());
}
#method_after
@Test
public void testValidateThereIsEnoughOfFreeMacsPositive() {
    when(macPoolMock.getAvailableMacsCount()).thenReturn(1);
    final ValidationResult actual = underTest.validateThereIsEnoughOfFreeMacs(singletonList(vmNetworkInterfaceMock), macPoolMock, ALWAYS_TRUE);
    assertThat(actual, isValid());
}
#end_block

#method_before
@Test
public void testValidateThereIsEnoughOfFreeMacsNegative() {
    when(macPoolMock.getAvailableMacsCount()).thenReturn(0);
    final ValidationResult actual = underTest.validateThereIsEnoughOfFreeMacs(singletonList(vmNetworkInterfaceMock), macPoolMock, ALWAYS_TRUE);
    Assert.assertThat(actual, ValidationResultMatchers.failsWith(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES));
}
#method_after
@Test
public void testValidateThereIsEnoughOfFreeMacsNegative() {
    when(macPoolMock.getAvailableMacsCount()).thenReturn(0);
    final ValidationResult actual = underTest.validateThereIsEnoughOfFreeMacs(singletonList(vmNetworkInterfaceMock), macPoolMock, ALWAYS_TRUE);
    assertThat(actual, failsWith(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES));
}
#end_block

#method_before
private void updateQcowCompat() {
    if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) {
        getImage().setQcowCompat(QcowCompat.QCOW2_V2);
        if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
            QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), false);
            if (qemuImageInfo != null) {
                getImage().setQcowCompat(qemuImageInfo.getQcowCompat());
            }
            imageDao.update(getImage().getImage());
        }
    }
}
#method_after
private void updateQcowCompat() {
    if (getImage().getVolumeFormat().equals(VolumeFormat.COW)) {
        getImage().setQcowCompat(QcowCompat.QCOW2_V2);
        if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
            QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(getStoragePool().getId(), getStorageDomainId(), getImage().getImage().getDiskId(), getImage().getImageId(), false);
            if (qemuImageInfo != null) {
                getImage().setQcowCompat(qemuImageInfo.getQcowCompat());
            }
        }
        imageDao.update(getImage().getImage());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VmDevice graphicsDev = getParameters().getDev();
    vmDeviceDao.remove(graphicsDev.getId());
    if (noGraphicsDevicesLeft()) {
        getVmDeviceUtils().removeVideoDevices(getParameters().getDev().getVmId());
        // Since getParameters().isVm() isn't set by REST api, try to set both
        setVmToHeadlessMode();
        setTemplateToHeadlessMode();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VmDevice graphicsDev = getParameters().getDev();
    vmDeviceDao.remove(graphicsDev.getId());
    if (noGraphicsDevicesLeft()) {
        vmDeviceUtils.removeVideoDevices(getVmBaseId());
        // Since getParameters().isVm() isn't set by REST api, try to set VM and if failed then try to set Template
        if (!setVmToHeadlessMode()) {
            setTemplateToHeadlessMode();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean noGraphicsDevicesLeft() {
    List<GraphicsDevice> devices = runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getParameters().getDev().getVmId())).getReturnValue();
    return devices.isEmpty();
}
#method_after
private boolean noGraphicsDevicesLeft() {
    List<GraphicsDevice> devices = runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getVmBaseId())).getReturnValue();
    return devices.isEmpty();
}
#end_block

#method_before
private void setVmToHeadlessMode() {
    VmStatic vmStatic = vmStaticDao.get(getParameters().getDev().getVmId());
    if (vmStatic != null && vmStatic.getDefaultDisplayType() != DisplayType.none) {
        vmStatic.setDefaultDisplayType(DisplayType.none);
        vmStatic.setSingleQxlPci(false);
        vmStaticDao.update(vmStatic);
    }
}
#method_after
private boolean setVmToHeadlessMode() {
    VmStatic vmStatic = vmStaticDao.get(getVmBaseId());
    if (vmStatic != null && vmStatic.getDefaultDisplayType() != DisplayType.none) {
        vmStatic.setDefaultDisplayType(DisplayType.none);
        vmStatic.setSingleQxlPci(false);
        resourceManager.getVmManager(getVmBaseId()).update(vmStatic);
        return true;
    }
    return false;
}
#end_block

#method_before
private void setTemplateToHeadlessMode() {
    VmTemplate vmTemplate = vmTemplateDao.get(getParameters().getDev().getVmId());
    if (vmTemplate != null && vmTemplate.getDefaultDisplayType() != DisplayType.none) {
        vmTemplate.setDefaultDisplayType(DisplayType.none);
        vmTemplate.setSingleQxlPci(false);
        vmTemplateDao.update(vmTemplate);
    }
}
#method_after
private void setTemplateToHeadlessMode() {
    VmTemplate vmTemplate = vmTemplateDao.get(getVmBaseId());
    if (vmTemplate != null && vmTemplate.getDefaultDisplayType() != DisplayType.none) {
        vmTemplate.setDefaultDisplayType(DisplayType.none);
        vmTemplate.setSingleQxlPci(false);
        vmTemplateDao.update(vmTemplate);
    }
}
#end_block

#method_before
private void setVmToNonHeadlessMode() {
    VmStatic vmStatic = vmStaticDao.get(getParameters().getDev().getVmId());
    if (vmStatic != null && vmStatic.getDefaultDisplayType() == DisplayType.none) {
        vmStatic.setDefaultDisplayType(DisplayType.qxl);
        vmStaticDao.update(vmStatic);
    }
    if (getVmDeviceUtils().getVideoDevices(getParameters().getDev().getVmId()).isEmpty()) {
        getVmDeviceUtils().addVideoDevices(vmStatic, getVmDeviceUtils().getNeededNumberOfVideoDevices(vmStatic));
    }
}
#method_after
private void setVmToNonHeadlessMode() {
    VmStatic vmStatic = vmStaticDao.get(getVmBaseId());
    if (vmStatic == null) {
        return;
    }
    if (vmStatic.getDefaultDisplayType() == DisplayType.none) {
        vmStatic.setDefaultDisplayType(DisplayType.qxl);
        resourceManager.getVmManager(getVmBaseId()).update(vmStatic);
    }
    vmDeviceUtils.addVideoDevicesOnlyIfNoVideoDeviceExists(vmStatic);
}
#end_block

#method_before
private void setTemplateToNonHeadlessMode() {
    VmTemplate vmTemplate = vmTemplateDao.get(getParameters().getDev().getVmId());
    if (vmTemplate != null && vmTemplate.getDefaultDisplayType() == DisplayType.none) {
        vmTemplate.setDefaultDisplayType(DisplayType.qxl);
        vmTemplateDao.update(vmTemplate);
    }
    if (getVmDeviceUtils().getVideoDevices(getParameters().getDev().getVmId()).isEmpty()) {
        getVmDeviceUtils().addVideoDevices(vmTemplate, getVmDeviceUtils().getNeededNumberOfVideoDevices(vmTemplate));
    }
}
#method_after
private void setTemplateToNonHeadlessMode() {
    VmTemplate vmTemplate = vmTemplateDao.get(getVmBaseId());
    if (vmTemplate == null) {
        return;
    }
    if (vmTemplate.getDefaultDisplayType() == DisplayType.none) {
        vmTemplate.setDefaultDisplayType(DisplayType.qxl);
        vmTemplateDao.update(vmTemplate);
    }
    vmDeviceUtils.addVideoDevicesOnlyIfNoVideoDeviceExists(vmTemplate);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getParameters().getDev().getVmId(), getParameters().isVm() ? VdcObjectType.VM : VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    permissionList.add(new PermissionSubject(getVmBaseId(), getParameters().isVm() ? VdcObjectType.VM : VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VdcQueryReturnValue res = runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getParameters().getDev().getVmId()));
    if (res.getSucceeded()) {
        prevDevices = res.getReturnValue();
        for (GraphicsDevice device : prevDevices) {
            if (device.getGraphicsType().equals(getParameters().getDev().getGraphicsType())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_ONLY_ONE_DEVICE_WITH_THIS_GRAPHICS_ALLOWED);
            }
        }
        return true;
    }
    return false;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VdcQueryReturnValue res = runInternalQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(getVmBaseId()));
    if (res.getSucceeded()) {
        prevDevices = res.getReturnValue();
        for (GraphicsDevice device : prevDevices) {
            if (device.getGraphicsType().equals(getParameters().getDev().getGraphicsType())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_ONLY_ONE_DEVICE_WITH_THIS_GRAPHICS_ALLOWED);
            }
        }
        return true;
    }
    return false;
}
#end_block

#method_before
public List<GraphicsDevice> getPrevDevices() {
    return prevDevices;
}
#method_after
protected List<GraphicsDevice> getPrevDevices() {
    return prevDevices;
}
#end_block

#method_before
public int getNeededNumberOfVideoDevices(VmBase vmBase) {
    int maxMonitorsSpice = vmBase.getSingleQxlPci() ? SINGLE_QXL_MONITORS : vmBase.getNumOfMonitors();
    int maxMonitorsVnc = Math.max(VNC_MIN_MONITORS, vmBase.getNumOfMonitors());
    return Math.min(maxMonitorsSpice, maxMonitorsVnc);
}
#method_after
private int getNeededNumberOfVideoDevices(VmBase vmBase) {
    int maxMonitorsSpice = vmBase.getSingleQxlPci() ? SINGLE_QXL_MONITORS : vmBase.getNumOfMonitors();
    int maxMonitorsVnc = Math.max(VNC_MIN_MONITORS, vmBase.getNumOfMonitors());
    return Math.min(maxMonitorsSpice, maxMonitorsVnc);
}
#end_block

#method_before
protected void createDefaultDiskProfile() {
    executeInNewTransaction(() -> {
        final DiskProfile diskProfile = diskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        DiskProfileParameters diskProfileParameters = new DiskProfileParameters(diskProfile, true);
        runInternalAction(VdcActionType.AddDiskProfile, diskProfileParameters, cloneContextAndDetachFromParent());
        getCompensationContext().snapshotNewEntity(diskProfile);
        getCompensationContext().stateChanged();
        return null;
    });
}
#method_after
protected void createDefaultDiskProfile() {
    executeInNewTransaction(() -> {
        final DiskProfile diskProfile = diskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        DiskProfileParameters diskProfileParameters = new DiskProfileParameters(diskProfile, true);
        runInternalActionWithTasksContext(VdcActionType.AddDiskProfile, diskProfileParameters);
        getCompensationContext().snapshotNewEntity(diskProfile);
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getEngineSessionId());
    return getBackend().runQuery(search, searchParameters);
}
#method_after
@Override
public VdcQueryReturnValue runQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getEngineSessionId());
    if (searchParameters.getCorrelationId() == null) {
        searchParameters.setCorrelationId(CorrelationIdTracker.getCorrelationId());
    }
    return getBackend().runQuery(search, searchParameters);
}
#end_block

#method_before
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: runPublicQuery invoked! '{}'", queryType);
    debugQuery(queryType, params);
    return getBackend().runPublicQuery(queryType, params);
}
#method_after
@Override
public VdcQueryReturnValue runPublicQuery(VdcQueryType queryType, VdcQueryParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: runPublicQuery invoked! '{}'", queryType);
    if (params.getCorrelationId() == null) {
        params.setCorrelationId(CorrelationIdTracker.getCorrelationId());
    }
    debugQuery(queryType, params);
    return getBackend().runPublicQuery(queryType, params);
}
#end_block

#method_before
@Override
public ArrayList<VdcQueryReturnValue> runMultipleQueries(ArrayList<VdcQueryType> queryTypeList, ArrayList<VdcQueryParametersBase> queryParamsList) {
    int size = queryTypeList == null ? 0 : queryTypeList.size();
    // $NON-NLS-1$
    log.debug("Server: RunMultipleQuery invoked! [amount of queries: {}]", size);
    ArrayList<VdcQueryReturnValue> ret = new ArrayList<>();
    if (queryTypeList != null && queryParamsList != null && queryTypeList.size() == queryParamsList.size()) {
        for (int i = 0; i < queryTypeList.size(); i++) {
            debugQuery(queryTypeList.get(i), queryParamsList.get(i));
            ret.add(runQuery(queryTypeList.get(i), queryParamsList.get(i)));
        }
    } else {
        log.error(// $NON-NLS-1$
        "Wrong multi query usage: the query types and parameters" + // $NON-NLS-1$
        " must not be null or be equally long. Types '{}' Params '{}'", queryTypeList, queryParamsList);
    }
    for (VdcQueryReturnValue vqrv : ret) {
        // $NON-NLS-1$
        log.debug("VdcQueryReturnValue '{}'", vqrv);
    }
    // $NON-NLS-1$
    log.debug("Server: RunMultipleQuery result [amount of queries: {}]", ret.size());
    return ret;
}
#method_after
@Override
public ArrayList<VdcQueryReturnValue> runMultipleQueries(ArrayList<VdcQueryType> queryTypeList, ArrayList<VdcQueryParametersBase> queryParamsList) {
    int size = queryTypeList == null ? 0 : queryTypeList.size();
    // $NON-NLS-1$
    log.debug("Server: RunMultipleQuery invoked! [amount of queries: {}]", size);
    ArrayList<VdcQueryReturnValue> ret = new ArrayList<>();
    if (queryTypeList != null && queryParamsList != null && queryTypeList.size() == queryParamsList.size()) {
        String correlationId = CorrelationIdTracker.getCorrelationId();
        for (int i = 0; i < queryTypeList.size(); i++) {
            if (queryParamsList.get(i).getCorrelationId() == null) {
                queryParamsList.get(i).setCorrelationId(correlationId);
            }
            debugQuery(queryTypeList.get(i), queryParamsList.get(i));
            ret.add(runQuery(queryTypeList.get(i), queryParamsList.get(i)));
        }
    } else {
        log.error(// $NON-NLS-1$
        "Wrong multi query usage: the query types and parameters must not be null " + // $NON-NLS-1$
        "or be equally long. Types length '{}' vs params length '{}'", queryTypeList == null ? 0 : queryTypeList.size(), queryParamsList == null ? 0 : queryParamsList.size());
    }
    for (VdcQueryReturnValue vqrv : ret) {
        // $NON-NLS-1$
        log.debug("VdcQueryReturnValue '{}'", vqrv);
    }
    // $NON-NLS-1$
    log.debug("Server: RunMultipleQuery result [amount of queries: {}]", ret.size());
    return ret;
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllValidationPass, boolean isWaitForResult) {
    // $NON-NLS-1$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: {}]", multipleParams.size());
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getEngineSessionId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllValidationPass, isWaitForResult);
    return returnValues;
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> runMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllValidationPass, boolean isWaitForResult) {
    // $NON-NLS-1$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: {}]", multipleParams.size());
    String correlationId = CorrelationIdTracker.getCorrelationId();
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getEngineSessionId());
        if (params.getCorrelationId() == null) {
            params.setCorrelationId(correlationId);
        }
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllValidationPass, isWaitForResult);
    return returnValues;
}
#end_block

#method_before
@Override
public VdcReturnValueBase runAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getEngineSessionId());
    return getBackend().runAction(actionType, params);
}
#method_after
@Override
public VdcReturnValueBase runAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getEngineSessionId());
    if (params.getCorrelationId() == null) {
        params.setCorrelationId(CorrelationIdTracker.getCorrelationId());
    }
    return getBackend().runAction(actionType, params);
}
#end_block

#method_before
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "Host.hostDevListByCaps":
            return new HostDevListByCaps();
        case "Host.setMOMPolicyParameters":
            return new HostSetMomPolicyParamters();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "StorageDomain.attach":
            return new StorageDomainAttachCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        case "Volume.getInfo":
            return new VolumeGetInfoCommand();
        default:
            // TODO: Support StorageDomain.getImages
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#method_after
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "Host.hostDevListByCaps":
            return new HostDevListByCaps();
        case "Host.setMOMPolicyParameters":
            return new HostSetMomPolicyParameters();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "StorageDomain.attach":
            return new StorageDomainAttachCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        case "Volume.getInfo":
            return new VolumeGetInfoCommand();
        default:
            // TODO: Support StorageDomain.getImages
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#end_block

#method_before
public RuntimeException error(Throwable t) {
    log.error(ERROR, t);
    return new RuntimeException(ERROR, t);
}
#method_after
public RuntimeException error(Throwable t) {
    String message = t.getMessage() == null ? t.getClass().getName() : t.getMessage();
    log.error(message, t);
    return new RuntimeException(message, t);
}
#end_block

#method_before
public void syncTask(Host host, Task task) {
    if (host == null) {
        host = getActiveHost();
        log.debug("host is null, task {} will be sync by any active host {}", task.getName(), host.getName());
    }
    try {
        host.getRunningTasks().put(task.getId(), task);
        log.debug("sync task:{} to host:{}", task.getName(), host.getName());
        TaskProcessor.getInstance().setTasksMap(host.getName(), task.getId());
    } catch (Exception e) {
        log.error("something went wrong durring task sync {}", e);
    }
}
#method_after
public void syncTask(Host host, Task task) {
    if (host == null) {
        host = getActiveHost();
        log.debug("host is null, task {} will be sync by any active host {}", task.getName(), host.getName());
    }
    host.getRunningTasks().put(task.getId(), task);
    log.debug("sync task:{} to host:{}", task.getName(), host.getName());
    TaskProcessor.getInstance().setTasksMap(host.getName(), task.getId());
}
#end_block

#method_before
public List getClusterLevelsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    resultList.add("4.1");
    return resultList;
}
#method_after
public List getClusterLevelsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    resultList.add("4.1");
    resultList.add("4.2");
    return resultList;
}
#end_block

#method_before
public List getSupportedENGINEsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    resultList.add("4.1");
    return resultList;
}
#method_after
public List getSupportedENGINEsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    resultList.add("4.1");
    resultList.add("4.2");
    return resultList;
}
#end_block

#method_before
public Map<String, Map> hostDevListByCaps() {
    // TODO: still not fully supported - WIP
    Map resultMap = getDoneStatus();
    Map<String, Map> infoMap = map();
    try {
        infoMap.put("computer", getCapability());
        infoMap.put("pci_0000_00_1b_0", getHardware(0));
        infoMap.put("pci_0000_00_1b_1", getHardware(1));
        infoMap.put("pci_0000_00_1b_2", getHardware(2));
        infoMap.put("pci_0000_00_1b_3", getHardware(3));
        infoMap.put("pci_0000_00_1b_4", getHardware(4));
        infoMap.put("pci_0000_00_1b_5", getHardware(5));
        infoMap.put("pci_0000_00_1b_6", getHardware(6));
        infoMap.put("pci_0000_00_1b_7", getHardware(7));
        infoMap.put("pci_0000_00_1b_8", getHardware(8));
        infoMap.put("pci_0000_00_1b_9", getHardware(9));
        infoMap.put("pci_0000_00_1b_10", getHardware(10));
        infoMap.put("pci_0000_00_1b_11", getHardware(11));
        infoMap.put("pci_0000_00_1f_12", getHardware(12));
        resultMap.put("info", infoMap);
    } catch (NullPointerException e) {
        log.error("getHostDevListByCaps failed due to {}", e);
        throw error(e);
    } finally {
        return resultMap;
    }
}
#method_after
public Map<String, Map> hostDevListByCaps() {
    Map resultMap = getDoneStatus();
    Map<String, Map> infoMap = map();
    infoMap.put("computer", getCapability());
    IntStream.range(0, 12).forEach(i -> {
        infoMap.put("pci_0000_00_1b_" + i, getHardware(i));
    });
    resultMap.put("info", infoMap);
    return resultMap;
}
#end_block

#method_before
public ResponseBuilder run(JsonNode params, ResponseBuilder builder) {
    Object result = null;
    try {
        Map apiResult = activateApi(params);
        if (fieldName() != null) {
            result = apiResult.get(fieldName());
        } else {
            result = apiResult;
        }
    } catch (Exception e) {
        log.error("Can't run api call", e);
        return builder.withError((Map<String, Object>) Collections.EMPTY_MAP);
    }
    if (result instanceof Map) {
        builder = builder.withResult((Map) result);
    } else if (result instanceof List) {
        builder = builder.withResult((List) result);
    } else if (result instanceof String) {
        builder = builder.withResult((String) result);
    } else if (result != null && result.getClass().isArray()) {
        List tempList = new ArrayList();
        Collections.addAll(tempList, (Object[]) result);
        builder = builder.withResult(tempList);
    } else {
        log.error("Unknown response data --> " + result, new Exception());
    }
    return builder;
}
#method_after
public ResponseBuilder run(JsonNode params, ResponseBuilder builder) {
    Object result = null;
    try {
        Map apiResult = activateApi(params);
        if (fieldName() != null) {
            result = apiResult.get(fieldName());
        } else {
            result = apiResult;
        }
    } catch (Exception e) {
        log.error("Can't run api call", e);
        Map<String, Object> error = new HashMap<>();
        // General exception
        error.put("code", 100);
        error.put("message", e.getMessage());
        return builder.withError(error);
    }
    if (result instanceof Map) {
        builder = builder.withResult((Map) result);
    } else if (result instanceof List) {
        builder = builder.withResult((List) result);
    } else if (result instanceof String) {
        builder = builder.withResult((String) result);
    } else if (result != null && result.getClass().isArray()) {
        List tempList = new ArrayList();
        Collections.addAll(tempList, (Object[]) result);
        builder = builder.withResult(tempList);
    } else {
        log.error("Unknown response data --> " + result, new Exception());
        Map<String, Object> error = new HashMap<>();
        // General exception
        error.put("code", 100);
        error.put("message", "Unknown response data");
        builder.withError(error);
    }
    return builder;
}
#end_block

#method_before
public static Api getInstance() {
    return singleton;
}
#method_after
public static Api getInstance() {
    if (instance == null) {
        synchronized (Api.class) {
            if (instance == null) {
                instance = new Api();
            }
        }
    }
    return instance;
}
#end_block

#method_before
protected UriInfo setUpActionExpectations(VdcActionType task, Class<? extends VdcActionParametersBase> clz, String[] names, Object[] values, boolean valid, boolean success, Object taskReturn, ArrayList<Guid> asyncTasks, ArrayList<AsyncTaskStatus> asyncStatuses, Guid jobId, JobExecutionStatus jobStatus, String baseUri, boolean replay, String errorMessage) {
    VdcReturnValueBase result = mock(VdcReturnValueBase.class);
    when(result.isValid()).thenReturn(valid);
    if (valid) {
        when(result.getSucceeded()).thenReturn(success);
        if (success) {
            if (taskReturn != null) {
                when(result.getActionReturnValue()).thenReturn(taskReturn);
            }
        } else {
            when(result.getExecuteFailedMessages()).thenReturn(asList(FAILURE));
            setUpL10nExpectations(asList(FAILURE));
        }
    } else {
        when(result.getValidationMessages()).thenReturn(asList(errorMessage));
        setUpL10nExpectations(asList(errorMessage));
    }
    when(backend.runAction(eq(task), eqActionParams(clz, addSession(names), addSession(values)))).thenReturn(result);
    enqueueInteraction(() -> verify(backend, atLeastOnce()).runAction(eq(task), eqActionParams(clz, addSession(names), addSession(values))));
    VdcQueryReturnValue monitorResult = mock(VdcQueryReturnValue.class);
    when(monitorResult.getSucceeded()).thenReturn(success);
    when(result.getHasAsyncTasks()).thenReturn(asyncTasks != null || jobId != null);
    // simulate polling on async task's statuses, and/or job status.
    setAsyncTaskStatusExpectations(asyncTasks, asyncStatuses, monitorResult, result);
    setJobStatusExpectations(jobId, jobStatus, monitorResult, result);
    UriInfo uriInfo = setUpBasicUriExpectations();
    if (baseUri != null) {
        when(uriInfo.getPath()).thenReturn(baseUri);
    }
    return uriInfo;
}
#method_after
protected UriInfo setUpActionExpectations(VdcActionType task, Class<? extends VdcActionParametersBase> clz, String[] names, Object[] values, boolean valid, boolean success, Object taskReturn, ArrayList<Guid> asyncTasks, ArrayList<AsyncTaskStatus> asyncStatuses, Guid jobId, JobExecutionStatus jobStatus, String baseUri, boolean replay, String errorMessage) {
    VdcReturnValueBase result = mock(VdcReturnValueBase.class);
    when(result.isValid()).thenReturn(valid);
    if (valid) {
        when(result.getSucceeded()).thenReturn(success);
        if (success) {
            if (taskReturn != null) {
                when(result.getActionReturnValue()).thenReturn(taskReturn);
            }
        } else {
            when(result.getExecuteFailedMessages()).thenReturn(asList(FAILURE));
            setUpL10nExpectations(asList(FAILURE));
        }
    } else {
        when(result.getValidationMessages()).thenReturn(asList(errorMessage));
        setUpL10nExpectations(asList(errorMessage));
    }
    when(backend.runAction(eq(task), eqActionParams(clz, addSession(names), addSession(values)))).thenReturn(result);
    enqueueInteraction(() -> verify(backend, atLeastOnce()).runAction(eq(task), eqActionParams(clz, addSession(names), addSession(values))));
    VdcQueryReturnValue monitorResult = mock(VdcQueryReturnValue.class);
    when(monitorResult.getSucceeded()).thenReturn(success);
    when(result.getHasAsyncTasks()).thenReturn(asyncTasks != null || jobId != null);
    // simulate polling on async task's statuses, and/or job status.
    setAsyncTaskStatusExpectations(asyncTasks, asyncStatuses, monitorResult, result);
    setJobStatusExpectations(jobId, jobStatus, monitorResult, result);
    UriInfo uriInfo = setUpBasicUriExpectations();
    if (baseUri != null) {
        CurrentManager.get().setPath(baseUri);
        when(uriInfo.getPath()).thenReturn(baseUri);
    }
    return uriInfo;
}
#end_block

#method_before
private void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user, VmInterfaceManager vmInterfaceManager) {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getClusterId(), vm.getStoragePoolId(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, vm.getOs(), vm.getCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#method_after
private void synchronizeNics(VM vm, CompensationContext compensationContext, DbUser user, VmInterfaceManager vmInterfaceManager) {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getClusterId(), vm.getStoragePoolId(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, user);
        vmInterfaceManager.add(vmInterface, compensationContext, true, false, vm.getOs(), vm.getCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#end_block

#method_before
public static void updateMaxMemorySize(VmBase vmBase, Version effectiveCompatibilityVersion) {
    if (vmBase.getMaxMemorySizeMb() == 0) {
        final int maxMemorySize = VmCommonUtils.maxMemorySizeWithHotplugInMb(vmBase.getOsId(), effectiveCompatibilityVersion);
        vmBase.setMaxMemorySizeMb(maxMemorySize);
    }
}
#method_after
public static void updateMaxMemorySize(VmBase vmBase, Version effectiveCompatibilityVersion) {
    final int maxOfMaxMemorySize = VmCommonUtils.maxMemorySizeWithHotplugInMb(vmBase.getOsId(), effectiveCompatibilityVersion);
    if (vmBase.getMaxMemorySizeMb() == 0 || vmBase.getMaxMemorySizeMb() > maxOfMaxMemorySize) {
        vmBase.setMaxMemorySizeMb(maxOfMaxMemorySize);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    if (!validate(vmNicMacsUtils.validateMacAddress(getVmTemplate().getInterfaces()))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getVmTemplate(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    discardHelper.logIfDisksWithIllegalPassDiscardExist(getVmTemplateId());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    macPool = getMacPool();
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (!validateBeforeCloneVm(domainsMap)) {
        return false;
    }
    // Since methods #validateBeforeCloneVm > #validateAndSetVmFromExportDomain > #setVmFromExportDomain may
    // change this.vm instance, following code can't be in #init() method and has to follow call of
    // #validateBeforeCloneVm.
    VmHandler.updateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion());
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > macPool.getAvailableMacsCount()) {
            return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return validateAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    macPool = getMacPool();
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (!validateBeforeCloneVm(domainsMap)) {
        return false;
    }
    // Since methods #validateBeforeCloneVm > #validateAndSetVmFromExportDomain > #setVmFromExportDomain may
    // change this.vm instance, following code can't be in #init() method and has to follow call of
    // #validateBeforeCloneVm.
    VmHandler.updateMaxMemorySize(getVm().getStaticData(), getEffectiveCompatibilityVersion());
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > macPool.getAvailableMacsCount()) {
            return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    return validateAfterCloneVm(domainsMap);
}
#end_block

#method_before
protected boolean validateBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && isCopyCollapseDisabledWithSnapshotsOrWithTemplate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED, String.format("$VmName %1$s", getVmName()));
    }
    // Register can never happen with copyCollapse = true since there's no copy operation involved.
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#method_after
protected boolean validateBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && isCopyCollapseDisabledWithSnapshotsOrWithTemplate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED, String.format("$VmName %1$s", getVmName()));
    }
    // Register can never happen with copyCollapse = true since there's no copy operation involved.
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) {
        getVm().setLeaseStorageDomainId(null);
    }
    super.executeVmCommand();
}
#method_after
@Override
protected void executeVmCommand() {
    if (shouldAddLease(getVm().getStaticData())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                getVm().setLeaseStorageDomainId(null);
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    }
    super.executeVmCommand();
}
#end_block

#method_before
void initComboBox() {
    keyListBoxEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<GlusterVolumeOptionInfo>() {

        @Override
        public String getReplacementStringNullSafe(GlusterVolumeOptionInfo option) {
            return option.getKey();
        }

        @Override
        public String getDisplayStringNullSafe(GlusterVolumeOptionInfo data) {
            return templates.typeAheadNameDescription(data == null ? constants.empty() : data.getKey(), constants.empty()).asString();
        }
    });
}
#method_after
void initComboBox() {
    keyListBoxEditor = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            return typeAheadNameTemplateNullSafe(data);
        }
    });
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getVm())) {
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean shouldAddLease(VM vm) {
    return vm.getLeaseStorageDomainId() != null;
}
#method_after
protected boolean shouldAddLease(VmStatic vm) {
    return vm.getLeaseStorageDomainId() != null;
}
#end_block

#method_before
protected boolean validateLeaseStorageDomain(Guid leaseStorageDomainId) {
    StorageDomain domain = storageDomainDao.get(leaseStorageDomainId);
    StorageDomainValidator validator = new StorageDomainValidator(domain);
    if (!validate(validator.isDomainExistAndActive())) {
        return false;
    }
    if (getStoragePoolId().equals(domain.getStoragePoolId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_LEASE_STORAGE_IS_NOT_A_PART_OF_POOL);
    }
    return true;
}
#method_after
protected boolean validateLeaseStorageDomain(Guid leaseStorageDomainId) {
    StorageDomain domain = storageDomainDao.getForStoragePool(leaseStorageDomainId, getStoragePoolId());
    StorageDomainValidator validator = new StorageDomainValidator(domain);
    return validate(validator.isDomainExistAndActive()) && validate(validator.isDataDomain());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (shouldAddLease(getVm())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN_ERROR);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    }
    super.executeVmCommand();
}
#method_after
@Override
protected void executeVmCommand() {
    if (shouldAddLease(getVm().getStaticData())) {
        if (FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            if (validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
                if (!addVmLease(getVm().getLeaseStorageDomainId(), getVm().getId())) {
                    getVm().setLeaseStorageDomainId(null);
                }
            } else {
                getVm().setLeaseStorageDomainId(null);
                auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_STORAGE_DOMAIN);
            }
        } else {
            getVm().setLeaseStorageDomainId(null);
            auditLogDirector.log(this, AuditLogType.CANNOT_IMPORT_VM_WITH_LEASE_COMPAT_VERSION);
        }
    }
    super.executeVmCommand();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getVm())) {
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getVm().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!FeatureSupported.isVmLeasesSupported(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_LEASES_ARE_NOT_SUPPORTED);
        }
        if (!validateLeaseStorageDomain(getParameters().getVmStaticData().getLeaseStorageDomainId())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void convertVm(int defaultOsId, DisplayType defaultDisplayType, long fetchTime, Map<String, Object> vmInfo) {
    Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
    String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
    if (isHostedEngineVm(vmId, vmNameOnHost)) {
        // its a hosted engine VM -> import it
        importHostedEngineVm(vmInfo);
        return;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(vmId);
    vmStatic.setCreationDate(new Date());
    vmStatic.setClusterId(getClusterId());
    vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
    vmStatic.setOrigin(OriginType.EXTERNAL);
    vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
    vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
    vmStatic.setMaxMemorySizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.maxMemSize)));
    vmStatic.setSingleQxlPci(false);
    setOsId(vmStatic, (String) vmInfo.get(VdsProperties.guest_os), defaultOsId);
    setDisplayType(vmStatic, (String) vmInfo.get(VdsProperties.displayType), defaultDisplayType);
    addExternallyManagedVm(vmStatic);
    addDevices(vmInfo, fetchTime);
    log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
}
#method_after
protected void convertVm(int defaultOsId, DisplayType defaultDisplayType, long fetchTime, Map<String, Object> vmInfo) {
    Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
    String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
    if (isHostedEngineVm(vmId, vmNameOnHost)) {
        // its a hosted engine VM -> import it
        importHostedEngineVm(vmInfo);
        return;
    }
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(vmId);
    vmStatic.setCreationDate(new Date());
    vmStatic.setClusterId(getClusterId());
    vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
    vmStatic.setOrigin(OriginType.EXTERNAL);
    vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
    vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
    // VMs started before engine 3.6 may not have 'maxMemory' set
    final int maxMemorySize = vmInfo.get(VdsProperties.maxMemSize) != null ? VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.maxMemSize)) : vmStatic.getMemSizeMb();
    vmStatic.setMaxMemorySizeMb(maxMemorySize);
    vmStatic.setSingleQxlPci(false);
    setOsId(vmStatic, (String) vmInfo.get(VdsProperties.guest_os), defaultOsId);
    setDisplayType(vmStatic, (String) vmInfo.get(VdsProperties.displayType), defaultDisplayType);
    addExternallyManagedVm(vmStatic);
    addDevices(vmInfo, fetchTime);
    log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!manageActionDetailsMap.keySet().contains(getParameters().getActionType())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_ACTION_TYPE);
    }
    if (Guid.isNullOrEmpty(getClusterId()) && Guid.isNullOrEmpty(getParameters().getServerId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTERID_AND_SERVERID_BOTH_NULL);
    }
    /*
         * only check for upserver if this is a cluster wide service change.
         * On a server level change, this validation leads to chicken-egg if glusterd is not running
         */
    if (!Guid.isNullOrEmpty(getClusterId()) && !Guid.isNullOrEmpty(getParameters().getServerId()) && getGlusterUtils().getAllUpServers(getClusterId()).size() == 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SERVERS_FOR_CLUSTER);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!manageActionDetailsMap.keySet().contains(getParameters().getActionType())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_ACTION_TYPE);
    }
    if (Guid.isNullOrEmpty(getClusterId()) && Guid.isNullOrEmpty(getParameters().getServerId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTERID_AND_SERVERID_BOTH_NULL);
    }
    /*
         * only check for upserver if this is a cluster wide service change.
         * On a server level change, this validation leads to chicken-egg if glusterd is not running
         */
    if (!Guid.isNullOrEmpty(getClusterId()) && Guid.isNullOrEmpty(getParameters().getServerId()) && getGlusterUtils().getAllUpServers(getClusterId()).size() == 0) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_SERVERS_FOR_CLUSTER);
    }
    return true;
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist() && isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !VmPropertiesUtils.getInstance().getSupportedClusterLevels().contains(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED);
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean isDedicatedVmForVdsChanged() {
    List<Guid> paramList = getParameters().getVmStaticData().getDedicatedVmForVdsList();
    List<Guid> vmList = getVm().getDedicatedVmForVdsList();
    if (vmList == null && paramList == null) {
        return false;
    }
    if (vmList == null || paramList == null) {
        return true;
    }
    // vmList.equals(paramList) not good enough, the lists order could change
    if (vmList.size() != paramList.size()) {
        return true;
    }
    for (Guid origGuid : vmList) {
        if (paramList.contains(origGuid) == false) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isDedicatedVmForVdsChanged() {
    List<Guid> paramList = getParameters().getVmStaticData().getDedicatedVmForVdsList();
    List<Guid> vmList = getVm().getDedicatedVmForVdsList();
    if (vmList == null && paramList == null) {
        return false;
    }
    if (vmList == null || paramList == null) {
        return true;
    }
    // vmList.equals(paramList) not good enough, the lists order could change
    if (vmList.size() != paramList.size()) {
        return true;
    }
    return !paramList.containsAll(vmList);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !parameters.isConsoleEnabled()) {
        parameters.getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    if (isCompatibilityVersionSupportedByCluster(getEffectiveCompatibilityVersion())) {
        updateVmObject();
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !parameters.isConsoleEnabled()) {
        parameters.getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !VmPropertiesUtils.getInstance().getSupportedClusterLevels().contains(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    Version customCompatibilityVersionFromParams = getParameters().getVmStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void initEffectiveCompatibilityVersion() {
    Version effectiveCompatibilityVersion = VmPropertiesUtils.getInstance().getSupportedClusterLevels().contains(getParameters().getVmStaticData().getCustomCompatibilityVersion()) ? CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster) : // The effective Compatibility Version will be taken from Cluster
    CompatibilityVersionUtils.getEffective(this::getCluster);
    setEffectiveCompatibilityVersion(effectiveCompatibilityVersion);
}
#method_after
protected void initEffectiveCompatibilityVersion() {
    setEffectiveCompatibilityVersion(CompatibilityVersionUtils.getEffective(getParameters().getVmStaticData(), this::getCluster));
}
#end_block

#method_before
@Override
public StatusOnlyReturn updateVolume(String jobId, Map<?, ?> volumeInfo, Map<?, ?> volumeAttributes) {
    JsonRpcRequest request = new RequestBuilder("SDM.updateVolume").withParameter("job_id", jobId).withParameter("vol_info", volumeInfo).withParameter("vol_attr", volumeAttributes).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#method_after
@Override
public StatusOnlyReturn updateVolume(String jobId, Map<?, ?> volumeInfo, Map<?, ?> volumeAttributes) {
    JsonRpcRequest request = new RequestBuilder("SDM.update_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeInfo).withParameter("vol_attr", volumeAttributes).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturn amendVolume(String jobId, Map<String, Object> volInfo, Map<String, Object> volAttr) {
    JsonRpcRequest request = new RequestBuilder("SDM.amend_volume").withParameter("job_id", jobId).withParameter("vol_info", volInfo).withParameter("vol_attr", volAttr).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#method_after
@Override
public StatusOnlyReturn amendVolume(String jobId, Map<String, Object> volInfo, Map<String, Object> qcow2_attr) {
    JsonRpcRequest request = new RequestBuilder("SDM.amend_volume").withParameter("job_id", jobId).withParameter("vol_info", volInfo).withParameter("qcow2_attr", qcow2_attr).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> normalizationParameters() {
    return Arrays.asList(new Object[][] { { null, null, null, null }, { null, "", null, "" }, { "", "", "", "" }, { "", "123", "000", "123" }, { "123", "", "123", "000" }, { "123", "123", "123", "123" }, { "123", "1", "123", "001" }, { "1", "123", "001", "123" }, { "01", "0123", "0001", "0123" }, { "abc123", "123", "abc123", "123" }, { "abc123", "1", "abc123", "001" }, { "abc1", "123", "abc001", "123" }, { "abc01", "0123", "abc0001", "0123" }, { "123", "abc123", "123", "abc123" }, { "123", "abc1", "123", "abc001" }, { "1", "abc123", "001", "abc123" }, { "01", "abc0123", "0001", "abc0123" }, { "abc123", "abc123", "abc123", "abc123" }, { "abc123", "abc1", "abc123", "abc001" }, { "abc1", "abc123", "abc001", "abc123" }, { "abc01", "abc0123", "abc0001", "abc0123" }, { "abc", "abc123", "abc000", "abc123" }, { "abc123", "abc", "abc123", "abc000" } });
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> normalizationParameters() {
    return Arrays.asList(new Object[][] { { null, null, null, null }, { null, "", null, "" }, { "", "", "", "" }, { "", "123", "", "123" }, { "123", "", "123", "" }, { "123", "123", "123", "123" }, { "123", "1", "123", "001" }, { "1", "123", "001", "123" }, { "01", "0123", "0001", "0123" }, { "abc123", "123", "abc123", "123" }, { "abc123", "1", "abc123", "001" }, { "abc1", "123", "abc001", "123" }, { "abc01", "0123", "abc0001", "0123" }, { "123", "abc123", "123", "abc123" }, { "123", "abc1", "123", "abc001" }, { "1", "abc123", "001", "abc123" }, { "01", "abc0123", "0001", "abc0123" }, { "abc123", "abc123", "abc123", "abc123" }, { "abc123", "abc1", "abc123", "abc001" }, { "abc1", "abc123", "abc001", "abc123" }, { "abc01", "abc0123", "abc0001", "abc0123" }, { "abc", "abc123", "abc", "abc123" }, { "abc123", "abc", "abc123", "abc" } });
}
#end_block

#method_before
public List<String> normalize(String... strings) {
    final Map<String, Pair<String, String>> stringParts = Arrays.stream(strings).filter(Objects::nonNull).collect(Collectors.toMap(Function.identity(), this::decompose, (value, ignore) -> value));
    final int maxNumericSuffixLength = stringParts.values().stream().filter(Objects::nonNull).collect(Collectors.summarizingInt(pair -> pair.getSecond().length())).getMax();
    return Arrays.stream(strings).map(str -> compose(str, stringParts, maxNumericSuffixLength)).collect(Collectors.toList());
}
#method_after
public List<String> normalize(String... strings) {
    final List<TextWithNumericSuffix> inputAsTextWithNumericSuffix = Arrays.stream(strings).map(this::decompose).collect(Collectors.toList());
    final int maxNumericSuffixLength = findMaxNumericSuffixLength(inputAsTextWithNumericSuffix);
    return inputAsTextWithNumericSuffix.stream().map(e -> e.compose(maxNumericSuffixLength)).collect(Collectors.toList());
}
#end_block

#method_before
private Pair<String, String> decompose(String str) {
    if (str == null) {
        return null;
    } else {
        final Matcher matcher = NUMERIC_SUFFIX_PATTERN.matcher(str);
        if (matcher.matches()) {
            final String prefix = matcher.group(1);
            final String numericSuffix = matcher.group(2);
            return new Pair<>(prefix, numericSuffix);
        } else {
            return null;
        }
    }
}
#method_after
private TextWithNumericSuffix decompose(String str) {
    if (str == null) {
        return new TextWithNumericSuffix(null);
    } else {
        final Matcher matcher = NUMERIC_SUFFIX_PATTERN.matcher(str);
        if (matcher.matches()) {
            final String prefix = matcher.group(1);
            final String numericSuffix = matcher.group(2);
            return new TextWithNumericSuffix(prefix, numericSuffix);
        } else {
            return new TextWithNumericSuffix(str);
        }
    }
}
#end_block

#method_before
public static Map<String, Object> prepareLocationInfoForVdsCommand(LocationInfo locationInfo) {
    if (locationInfo instanceof ExternalLocationInfo) {
        ExternalLocationInfo info = (ExternalLocationInfo) locationInfo;
        if (ConnectionMethod.HTTP.equals(info.getConnectionMethod())) {
            HttpLocationInfo httpInfo = (HttpLocationInfo) info;
            Map<String, Object> infoMap = new HashMap<>();
            infoMap.put("method", "http");
            infoMap.put("url", httpInfo.getUrl());
            infoMap.put("headers", httpInfo.getHeaders());
            return infoMap;
        }
    }
    if (locationInfo instanceof VdsmImageLocationInfo) {
        VdsmImageLocationInfo info = (VdsmImageLocationInfo) locationInfo;
        Map<String, Object> infoMap = new HashMap<>();
        infoMap.put("endpoint_type", "div");
        infoMap.put("sd_id", info.getStorageDomainId().toString());
        infoMap.put("img_id", info.getImageGroupId().toString());
        infoMap.put("vol_id", info.getImageId().toString());
        infoMap.put("generation", info.getGeneration());
        return infoMap;
    }
    throw new RuntimeException("Unsupported location info");
}
#method_after
public static Map<String, Object> prepareLocationInfoForVdsCommand(LocationInfo locationInfo) {
    if (locationInfo instanceof ExternalLocationInfo) {
        ExternalLocationInfo info = (ExternalLocationInfo) locationInfo;
        if (ConnectionMethod.HTTP.equals(info.getConnectionMethod())) {
            HttpLocationInfo httpInfo = (HttpLocationInfo) info;
            Map<String, Object> infoMap = new HashMap<>();
            infoMap.put("method", "http");
            infoMap.put("url", httpInfo.getUrl());
            infoMap.put("headers", httpInfo.getHeaders());
            return infoMap;
        }
    }
    if (locationInfo instanceof VdsmImageLocationInfo) {
        VdsmImageLocationInfo info = (VdsmImageLocationInfo) locationInfo;
        Map<String, Object> infoMap = new HashMap<>();
        infoMap.put("endpoint_type", "div");
        infoMap.put("sd_id", info.getStorageDomainId().toString());
        infoMap.put("img_id", info.getImageGroupId().toString());
        infoMap.put("vol_id", info.getImageId().toString());
        if (info.getGeneration() != null) {
            infoMap.put("generation", info.getGeneration());
        }
        return infoMap;
    }
    throw new RuntimeException("Unsupported location info");
}
#end_block

#method_before
private String getEffectiveEmulatedMachine() {
    if (getVm().getCustomEmulatedMachine() != null) {
        return getVm().getCustomEmulatedMachine();
    }
    // The 'default' to be set
    String recentDefault = getCluster().getEmulatedMachine();
    if (removeThisDebugSwitch && getVm().getCustomCompatibilityVersion() != null) {
        // previous cluster version default is expected
        // example: recentDefault: pc-i440fx-rhel7.3.0  ; oldSupported: [pc-i440fx-rhel7.2.0, pc-i440fx-2.1, pseries-rhel7.2.0]
        List<String> oldSupported = Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getVm().getCustomCompatibilityVersion().getValue());
        Optional<String> best = oldSupported.stream().max((s1, s2) -> StringUtils.indexOfDifference(recentDefault, s1) - StringUtils.indexOfDifference(recentDefault, s2));
        log.info("Emulated machine '{}' selected since Custom Compatibility Version is set for the '{}' VM", best.orElse(recentDefault), getVm().getName());
        return best.orElse(recentDefault);
    }
    return recentDefault;
}
#method_after
protected String getEffectiveEmulatedMachine() {
    if (getVm().getCustomEmulatedMachine() != null) {
        return getVm().getCustomEmulatedMachine();
    }
    // The 'default' to be set
    String recentClusterDefault = getCluster().getEmulatedMachine();
    if (getVm().getCustomCompatibilityVersion() == null) {
        return recentClusterDefault;
    }
    // previous cluster version default is expected
    // example: recentDefault: pc-i440fx-rhel7.3.0  ; oldSupported: [pc-i440fx-rhel7.2.0, pc-i440fx-2.1, pseries-rhel7.2.0]
    List<String> oldSupported = Config.getValue(ConfigValues.ClusterEmulatedMachines, getVm().getCustomCompatibilityVersion().getValue());
    Optional<String> best = oldSupported.stream().max((s1, s2) -> StringUtils.indexOfDifference(recentClusterDefault, s1) - StringUtils.indexOfDifference(recentClusterDefault, s2));
    log.info("Emulated machine '{}' selected since Custom Compatibility Version is set for '{}'", best.orElse(recentClusterDefault), getVm());
    return best.orElse(recentClusterDefault);
}
#end_block

#method_before
protected RunVmValidator getRunVmValidator() {
    return new RunVmValidator(getVm(), getParameters(), isInternalExecution(), getActiveIsoDomainId());
}
#method_after
protected RunVmValidator getRunVmValidator() {
    return Injector.injectMembers(new RunVmValidator(getVm(), getParameters(), isInternalExecution(), getActiveIsoDomainId()));
}
#end_block

#method_before
private boolean validateMasterDeactivationAllowed() {
    List<StorageDomain> domains = storageDomainDao.getAllForStoragePool(getStorageDomain().getStoragePoolId());
    List<StorageDomain> activeDomains = filterNonActiveDomains(domains);
    List<StorageDomain> dataDomains = activeDomains.stream().filter(d -> d.getStorageDomainType() == StorageDomainType.Data).collect(Collectors.toList());
    if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
    }
    List<StorageDomain> busyDomains = domains.stream().filter(d -> d.getStatus().isStorageDomainInProcess()).collect(Collectors.toList());
    if (!busyDomains.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
    }
    return true;
}
#method_after
private boolean validateMasterDeactivationAllowed() {
    List<StorageDomain> domains = storageDomainDao.getAllForStoragePool(getStorageDomain().getStoragePoolId());
    List<StorageDomain> activeDomains = filterActiveDomains(domains);
    List<StorageDomain> dataDomains = activeDomains.stream().filter(d -> d.getStorageDomainType() == StorageDomainType.Data).collect(Collectors.toList());
    if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
    }
    List<StorageDomain> busyDomains = domains.stream().filter(d -> d.getStatus().isStorageDomainInProcess()).collect(Collectors.toList());
    if (!busyDomains.isEmpty()) {
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
    }
    return true;
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
    StorageJobCommandParameters cmdParams = (StorageJobCommandParameters) commandEntity.getCommandParameters();
    Guid job = cmdParams.getStorageJobId();
    Guid vdsId = cmdParams.getVdsRunningOn();
    HostJobStatus jobStatus = null;
    VDS vds = getVdsDao().get(vdsId);
    boolean jobsReportedByHost = false;
    if (vds.getStatus() == VDSStatus.Up) {
        HostJobInfo jobInfo;
        try {
            jobInfo = pollStorageJob(job, vdsId);
        } catch (Exception e) {
            // We shouldn't get an error when polling the host job (as it access the local storage only).
            // If we got an error, it will usually be a network error - so the host will either move
            // to Non Responsive or the polling will succeed on the next attempt.
            log.warn("Command {} id: '{}': Failed to poll the job '{}' on host '{}' (id: '{}'), will retry soon", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
            return;
        }
        if (jobInfo != null) {
            jobStatus = jobInfo.getStatus();
            updateStepProgress(commandEntity.getCommandContext().getStepId(), jobInfo.getProgress());
        }
        jobsReportedByHost = true;
    } else {
        log.warn("Command {} id: '{}': can't poll the job '{}' as host '{}' (id: '{}') isn't in status UP", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
    }
    // If we couldn't determine job status by polling the host, we can try to determine it using different methods.
    if (jobStatus == null) {
        jobStatus = handleUndeterminedJobStatus(getCommand(cmdId), jobsReportedByHost);
    }
    if (jobStatus == null) {
        log.info("Command {} id: '{}': couldn't get the status of job '{}' on host '{}' (id: '{}'), assuming it's " + "still running", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
        return;
    }
    if (jobStatus.isAlive()) {
        log.info("Command {} id: '{}': waiting for job '{}' on host '{}' (id: '{}') to complete", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
        return;
    }
    log.info("Command {} id: '{}': job '{}' execution was completed with VDSM job status '{}'", commandEntity.getCommandType(), cmdId, job, jobStatus);
    CommandBase<?> command = getCommand(cmdId);
    if (command.shouldUpdateStepProgress() && jobStatus == HostJobStatus.done) {
        updateStepProgress(commandEntity.getCommandContext().getStepId(), MAX_PROGRESS);
    }
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    command.getParameters().setTaskGroupSuccess(status == CommandExecutionStatus.EXECUTED && jobStatus == HostJobStatus.done);
    command.setCommandStatus(command.getParameters().getTaskGroupSuccess() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    log.info("Command {} id: '{}': execution was completed, the command status is '{}'", command.getActionType(), command.getCommandId(), command.getCommandStatus());
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
    StorageJobCommandParameters cmdParams = (StorageJobCommandParameters) commandEntity.getCommandParameters();
    Guid job = cmdParams.getStorageJobId();
    Guid vdsId = cmdParams.getVdsRunningOn();
    HostJobStatus jobStatus = null;
    VDS vds = getVdsDao().get(vdsId);
    boolean jobsReportedByHost = false;
    if (vds.getStatus() == VDSStatus.Up) {
        HostJobInfo jobInfo;
        try {
            jobInfo = pollStorageJob(job, vdsId);
        } catch (Exception e) {
            // We shouldn't get an error when polling the host job (as it access the local storage only).
            // If we got an error, it will usually be a network error - so the host will either move
            // to Non Responsive or the polling will succeed on the next attempt.
            log.warn("Command {} id: '{}': Failed to poll the job '{}' on host '{}' (id: '{}'), will retry soon", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
            return;
        }
        if (jobInfo != null) {
            handlePolledJobStatus((StorageJobCommand) getCommand(cmdId), jobInfo);
            jobStatus = jobInfo.getStatus();
            updateStepProgress(commandEntity.getCommandContext().getStepId(), jobInfo.getProgress());
        }
        jobsReportedByHost = true;
    } else {
        log.warn("Command {} id: '{}': can't poll the job '{}' as host '{}' (id: '{}') isn't in status UP", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
    }
    // If we couldn't determine job status by polling the host, we can try to determine it using different methods.
    if (jobStatus == null) {
        jobStatus = handleUndeterminedJobStatus(getCommand(cmdId), jobsReportedByHost);
    }
    if (jobStatus == null) {
        log.info("Command {} id: '{}': couldn't get the status of job '{}' on host '{}' (id: '{}'), assuming it's " + "still running", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
        return;
    }
    if (jobStatus.isAlive()) {
        log.info("Command {} id: '{}': waiting for job '{}' on host '{}' (id: '{}') to complete", commandEntity.getCommandType(), cmdId, job, vds.getName(), vdsId);
        return;
    }
    log.info("Command {} id: '{}': job '{}' execution was completed with VDSM job status '{}'", commandEntity.getCommandType(), cmdId, job, jobStatus);
    CommandBase<?> command = getCommand(cmdId);
    if (command.shouldUpdateStepProgress() && jobStatus == HostJobStatus.done) {
        updateStepProgress(commandEntity.getCommandContext().getStepId(), MAX_PROGRESS);
    }
    CommandExecutionStatus status = CommandCoordinatorUtil.getCommandExecutionStatus(cmdId);
    command.getParameters().setTaskGroupSuccess(status == CommandExecutionStatus.EXECUTED && jobStatus == HostJobStatus.done);
    command.setCommandStatus(command.getParameters().getTaskGroupSuccess() ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
    log.info("Command {} id: '{}': execution was completed, the command status is '{}'", command.getActionType(), command.getCommandId(), command.getCommandStatus());
}
#end_block

#method_before
public static CommandEntity buildCommandEntity(Guid userId, long engineSessionSeqId, Guid commandId, Guid parentCommandId, Guid rootCommandId, PersistedCommandContext commandContext, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean callbackEnabled, VdcReturnValueBase returnValue, Map<String, Serializable> data) {
    CommandEntity entity = new CommandEntity();
    entity.setEngineSessionSeqId(engineSessionSeqId);
    entity.setUserId(userId);
    entity.setId(commandId);
    entity.setParentCommandId(parentCommandId);
    entity.setRootCommandId(rootCommandId);
    entity.setCommandContext(commandContext);
    entity.setCommandType(actionType);
    entity.setCommandParameters(params);
    entity.setCommandStatus(status);
    entity.setCallbackEnabled(callbackEnabled);
    entity.setReturnValue(returnValue);
    entity.setData(data);
    return entity;
}
#method_after
public static CommandEntity buildCommandEntity(Guid userId, long engineSessionSeqId, Guid commandId, Guid parentCommandId, Guid rootCommandId, PersistedCommandContext commandContext, VdcActionType actionType, VdcActionParametersBase params, CommandStatus status, boolean callbackEnabled, VdcReturnValueBase returnValue, Map<String, Serializable> data) {
    CommandEntity entity = new CommandEntity();
    entity.setEngineSessionSeqId(engineSessionSeqId);
    entity.setUserId(userId);
    entity.setId(commandId);
    entity.setParentCommandId(parentCommandId);
    entity.setRootCommandId(rootCommandId);
    if (commandContext != null) {
        entity.setCommandContext(commandContext);
    }
    entity.setCommandType(actionType);
    entity.setCommandParameters(params);
    entity.setCommandStatus(status);
    entity.setCallbackEnabled(callbackEnabled);
    entity.setReturnValue(returnValue);
    entity.setData(data);
    return entity;
}
#end_block

#method_before
private CommandContext buildCommandContext(CommandEntity cmdEntity) {
    ExecutionContext executionContext = new ExecutionContext();
    PersistedCommandContext persistedCommandContext = cmdEntity.getCommandContext();
    if (!Guid.isNullOrEmpty(persistedCommandContext.getJobId())) {
        executionContext.setJob(jobRepository.getJobWithSteps(persistedCommandContext.getJobId()));
    } else if (!Guid.isNullOrEmpty(persistedCommandContext.getStepId())) {
        executionContext.setStep(jobRepository.getStep(persistedCommandContext.getStepId()));
    }
    if (StringUtils.isNotEmpty(persistedCommandContext.getExecutionMethod())) {
        executionContext.setExecutionMethod(ExecutionContext.ExecutionMethod.valueOf(persistedCommandContext.getExecutionMethod()));
    }
    executionContext.setCompleted(persistedCommandContext.isCompleted());
    executionContext.setJobRequired(persistedCommandContext.isJobRequired());
    executionContext.setMonitored(persistedCommandContext.isMonitored());
    executionContext.setShouldEndJob(persistedCommandContext.shouldEndJob());
    executionContext.setTasksMonitored(persistedCommandContext.isTasksMonitored());
    return new CommandContext(new EngineContext()).withExecutionContext(executionContext);
}
#method_after
private CommandContext buildCommandContext(CommandEntity cmdEntity) {
    ExecutionContext executionContext = new ExecutionContext();
    PersistedCommandContext persistedCommandContext = cmdEntity.getCommandContext();
    if (!Guid.isNullOrEmpty(persistedCommandContext.getJobId())) {
        executionContext.setJob(jobRepository.getJobWithSteps(persistedCommandContext.getJobId()));
    } else if (!Guid.isNullOrEmpty(persistedCommandContext.getStepId())) {
        executionContext.setStep(jobRepository.getStep(persistedCommandContext.getStepId()));
    }
    executionContext.setExecutionMethod(persistedCommandContext.getExecutionMethod());
    executionContext.setCompleted(persistedCommandContext.isCompleted());
    executionContext.setJobRequired(persistedCommandContext.isJobRequired());
    executionContext.setMonitored(persistedCommandContext.isMonitored());
    executionContext.setShouldEndJob(persistedCommandContext.shouldEndJob());
    executionContext.setTasksMonitored(persistedCommandContext.isTasksMonitored());
    return new CommandContext(new EngineContext()).withExecutionContext(executionContext);
}
#end_block

#method_before
public String getExecutionMethod() {
    return executionMethod;
}
#method_after
public ExecutionMethod getExecutionMethod() {
    return executionMethod;
}
#end_block

#method_before
public void setExecutionMethod(String executionMethod) {
    this.executionMethod = executionMethod;
}
#method_after
public void setExecutionMethod(ExecutionMethod executionMethod) {
    this.executionMethod = executionMethod;
}
#end_block

#method_before
public boolean isMonitored() {
    return isMonitored;
}
#method_after
public boolean isMonitored() {
    return monitored;
}
#end_block

#method_before
public void setMonitored(boolean monitored) {
    isMonitored = monitored;
}
#method_after
public void setMonitored(boolean monitored) {
    this.monitored = monitored;
}
#end_block

#method_before
public boolean isTasksMonitored() {
    return isTasksMonitored;
}
#method_after
public boolean isTasksMonitored() {
    return tasksMonitored;
}
#end_block

#method_before
public void setTasksMonitored(boolean tasksMonitored) {
    isTasksMonitored = tasksMonitored;
}
#method_after
public void setTasksMonitored(boolean tasksMonitored) {
    this.tasksMonitored = tasksMonitored;
}
#end_block

#method_before
public boolean isCompleted() {
    return isCompleted;
}
#method_after
public boolean isCompleted() {
    return completed;
}
#end_block

#method_before
public void setCompleted(boolean completed) {
    isCompleted = completed;
}
#method_after
public void setCompleted(boolean completed) {
    this.completed = completed;
}
#end_block

#method_before
public boolean isJobRequired() {
    return isJobRequired;
}
#method_after
public boolean isJobRequired() {
    return jobRequired;
}
#end_block

#method_before
public void setJobRequired(boolean jobRequired) {
    isJobRequired = jobRequired;
}
#method_after
public void setJobRequired(boolean jobRequired) {
    this.jobRequired = jobRequired;
}
#end_block

#method_before
@PostConstruct
protected final void postConstruct() {
    if (!isCompensationContext()) {
        initCommandBase();
        init();
    }
}
#method_after
@PostConstruct
protected final void postConstruct() {
    if (!isCompensationContext()) {
        initCommandBase();
        init();
    } else {
        this.context.withCompensationContext(createDefaultCompensationContext());
    }
}
#end_block

#method_before
private void handleCommandStepAndEntities() {
    if (getCommandStep() != null) {
        Step taskStep = executionHandler.addTaskStep(getExecutionContext(), getCommandStep(), null, getCommandStepSubjectEntities());
        if (taskStep != null) {
            if (shouldUpdateStepProgress()) {
                stepDao.updateStepProgress(taskStep.getId(), 0);
            }
            getExecutionContext().setStep(taskStep);
            persistCommandIfNeeded();
        }
    }
}
#method_after
private void handleCommandStepAndEntities() {
    if (getCommandStep() != null) {
        Step taskStep = executionHandler.addTaskStep(getExecutionContext(), getCommandStep(), ExecutionMessageDirector.resolveStepMessage(getCommandStep(), getJobMessageProperties()), getCommandStepSubjectEntities());
        if (taskStep != null) {
            if (shouldUpdateStepProgress()) {
                stepDao.updateStepProgress(taskStep.getId(), 0);
            }
            getExecutionContext().setStep(taskStep);
            persistCommandIfNeeded();
        }
    }
}
#end_block

#method_before
private PersistedCommandContext buildPersistedCommandContext() {
    PersistedCommandContext persistedCommandContext = new PersistedCommandContext();
    persistedCommandContext.setJobId(getExecutionContext() == null || getExecutionContext().getJob() == null ? Guid.Empty : getExecutionContext().getJob().getId());
    persistedCommandContext.setStepId(getExecutionContext() == null || getExecutionContext().getStep() == null ? Guid.Empty : getExecutionContext().getStep().getId());
    persistedCommandContext.setExecutionMethod(getExecutionContext() == null ? ExecutionContext.ExecutionMethod.AsStep.toString() : getExecutionContext().getExecutionMethod().toString());
    if (getExecutionContext() != null) {
        persistedCommandContext.setCompleted(getExecutionContext().isCompleted());
        persistedCommandContext.setJobRequired(getExecutionContext().isJobRequired());
        persistedCommandContext.setMonitored(getExecutionContext().isMonitored());
        persistedCommandContext.setShouldEndJob(getExecutionContext().shouldEndJob());
        persistedCommandContext.setTasksMonitored(getExecutionContext().isTasksMonitored());
    }
    return persistedCommandContext;
}
#method_after
private PersistedCommandContext buildPersistedCommandContext() {
    PersistedCommandContext persistedCommandContext = new PersistedCommandContext();
    persistedCommandContext.setJobId(getExecutionContext() == null || getExecutionContext().getJob() == null ? null : getExecutionContext().getJob().getId());
    persistedCommandContext.setStepId(getExecutionContext() == null || getExecutionContext().getStep() == null ? null : getExecutionContext().getStep().getId());
    persistedCommandContext.setExecutionMethod(getExecutionContext() == null ? ExecutionMethod.AsStep : getExecutionContext().getExecutionMethod());
    if (getExecutionContext() != null) {
        persistedCommandContext.setCompleted(getExecutionContext().isCompleted());
        persistedCommandContext.setJobRequired(getExecutionContext().isJobRequired());
        persistedCommandContext.setMonitored(getExecutionContext().isMonitored());
        persistedCommandContext.setShouldEndJob(getExecutionContext().shouldEndJob());
        persistedCommandContext.setTasksMonitored(getExecutionContext().isTasksMonitored());
    }
    return persistedCommandContext;
}
#end_block

#method_before
public static TagObject from(TagModel model) {
    if (model != null) {
        TagObject result = JavaScriptObject.createObject().cast();
        JsArray<TagObject> children = JavaScriptObject.createArray().cast();
        // $NON-NLS-1$
        result.setValueAsString("description", model.getDescription().getEntity());
        // $NON-NLS-1$
        result.setValueAsString("name", model.getName().getEntity());
        // $NON-NLS-1$
        result.setValueAsBoolean("selected", model.getSelection());
        // Only calculate total for root node.
        if (model.getParent() == null) {
            // $NON-NLS-1$
            result.setValueAsDouble("selectedTagCount", calculateSelectedTagCount(model));
        }
        for (TagModel child : model.getChildren()) {
            children.push(TagObject.from(child));
        }
        // $NON-NLS-1$
        result.setValueAsJavaScriptObject("children", children);
        return result;
    } else {
        return null;
    }
}
#method_after
public static TagObject from(TagModel model) {
    return from(model, true);
}
#end_block

#method_before
public static TagObject from(TagModel model) {
    if (model != null) {
        TagObject result = JavaScriptObject.createObject().cast();
        JsArray<TagObject> children = JavaScriptObject.createArray().cast();
        // $NON-NLS-1$
        result.setValueAsString("description", model.getDescription().getEntity());
        // $NON-NLS-1$
        result.setValueAsString("name", model.getName().getEntity());
        // $NON-NLS-1$
        result.setValueAsBoolean("selected", model.getSelection());
        // Only calculate total for root node.
        if (model.getParent() == null) {
            // $NON-NLS-1$
            result.setValueAsDouble("selectedTagCount", calculateSelectedTagCount(model));
        }
        for (TagModel child : model.getChildren()) {
            children.push(TagObject.from(child));
        }
        // $NON-NLS-1$
        result.setValueAsJavaScriptObject("children", children);
        return result;
    } else {
        return null;
    }
}
#method_after
private static TagObject from(TagModel model, boolean includeChildren) {
    TagObject result = JavaScriptObject.createObject().cast();
    // $NON-NLS-1$
    result.setValueAsString("description", model.getDescription().getEntity());
    // $NON-NLS-1$
    result.setValueAsString("name", model.getName().getEntity());
    // $NON-NLS-1$
    result.setValueAsBoolean("selected", model.getSelection());
    if (includeChildren) {
        JsArray<TagObject> children = JavaScriptObject.createArray().cast();
        for (TagModel child : model.getChildren()) {
            children.push(TagObject.from(child, true));
        }
        // $NON-NLS-1$
        result.setValueAsJavaScriptObject("children", children);
    }
    return result;
}
#end_block

#method_before
@Override
protected void initializeModelHandlers(final TagListModel model) {
    super.initializeModelHandlers(model);
    // Add model reset handler
    model.getResetRequestedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (model.getItems() == null) {
                return;
            }
            Iterator<TagModel> iterator = model.getItems().iterator();
            if (iterator.hasNext()) {
                TagModel root = model.cloneTagModel(iterator.next());
                updateDataProvider(Arrays.asList(root));
            }
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItems".equals(args.propertyName)) {
                // mean nothing has been selected and we don't want to inform people about it.
                if (getSelectionModel().getSelectedObject() != null) {
                    TagActivatedEvent.fire(TagModelProvider.this, findRootNode(getSelectionModel().getSelectedObject()));
                }
            }
        }

        private TagModel findRootNode(TagModel tagModel) {
            if (tagModel.getParent() != null) {
                return findRootNode(tagModel.getParent());
            }
            return tagModel;
        }
    });
}
#method_after
@Override
protected void initializeModelHandlers(final TagListModel model) {
    super.initializeModelHandlers(model);
    // Add model reset handler
    model.getResetRequestedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (model.getItems() == null) {
                return;
            }
            Iterator<TagModel> iterator = model.getItems().iterator();
            if (iterator.hasNext()) {
                TagModel root = model.cloneTagModel(iterator.next());
                updateDataProvider(Arrays.asList(root));
            }
        }
    });
    model.getSelectedItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // The selectedItemsChangedEvent only gets fired when activating/deactiving a tag. Changing
            // the selection in the tag tree does not fire this event.
            TagActivationChangeEvent.fire(TagModelProvider.this, activeTagList(model.getRootNode()));
        }

        private List<TagModel> activeTagList(TagModel model) {
            List<TagModel> result = new ArrayList<>();
            if (model.getSelection()) {
                result.add(model);
            }
            for (TagModel child : model.getChildren()) {
                result.addAll(activeTagList(child));
            }
            return result;
        }
    });
}
#end_block

#method_before
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        getHostList().setIsAvailable(true);
        getVmList().setIsAvailable(true);
        getUserList().setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
        // When a tag is unselected, clear out any stored search string for the model.
        // $NON-NLS-1$
        getHostList().setSearchString("Host:");
        // $NON-NLS-1$
        getVmList().setSearchString("Vms:");
        // $NON-NLS-1$
        getUserList().setSearchString("Users:");
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != getHostList() && oldSelectedItem != getVolumeList() && oldSelectedItem != getVmList() && oldSelectedItem != getUserList()) {
        setSelectedItem(getVmList());
    } else if (getHasSelectedTags() || hadSelectedTags) {
        // Update search string only when selecting or de-selecting tags
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<>(prefix);
        RefObject<String> tempRef_search = new RefObject<>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#method_after
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        getHostList().setIsAvailable(true);
        getVmList().setIsAvailable(true);
        getUserList().setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
        // When a tag is unselected, clear out any stored search string for the model.
        getHostList().setSearchString(getHostList().getDefaultSearchString());
        getVmList().setSearchString(getVmList().getDefaultSearchString());
        getUserList().setSearchString(getUserList().getDefaultSearchString());
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != getHostList() && oldSelectedItem != getVolumeList() && oldSelectedItem != getVmList() && oldSelectedItem != getUserList()) {
        setSelectedItem(getVmList());
    } else if (getHasSelectedTags() || hadSelectedTags) {
        // Update search string only when selecting or de-selecting tags
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<>(prefix);
        RefObject<String> tempRef_search = new RefObject<>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#end_block

#method_before
private void setAllListModelsUnavailable() {
    for (ListModel m : getItems()) {
        // Don't mark plugin models as unavailable, the plug-ins themselves will hide/show the tabs.
        if (!(m instanceof PluginModel)) {
            m.setIsAvailable(false);
        }
    }
}
#method_after
private void setAllListModelsUnavailable() {
    for (ListModel m : getItems()) {
        m.setIsAvailable(false);
    }
}
#end_block

#method_before
protected List<Pair<Guid, Boolean>> connectHostsInUpToDomainStorageServer() {
    return disconnectOrConnectHostsInUpToDomainStorageServer(ActionType.CONNECT);
}
#method_after
protected List<Pair<Guid, Boolean>> connectHostsInUpToDomainStorageServer() {
    return performConnectionOpOnAllUpHosts(vds -> StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).connectStorageToDomainByVdsId(getStorageDomain(), vds.getId()));
}
#end_block

#method_before
protected List<Pair<Guid, Boolean>> disconnectHostsInUpToDomainStorageServer() {
    return disconnectOrConnectHostsInUpToDomainStorageServer(ActionType.DISCONNECT);
}
#method_after
protected List<Pair<Guid, Boolean>> disconnectHostsInUpToDomainStorageServer() {
    return performConnectionOpOnAllUpHosts(vds -> StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId()));
}
#end_block

#method_before
@Before
public void initializeMocks() {
    doNothing().when(command).updateDisksFromDb();
    doReturn(true).when(command).checkImageConfiguration();
    doReturn(false).when(command).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(false).when(command).hasWatchdog(any(Guid.class));
    doReturn(false).when(command).isBalloonEnabled(any(Guid.class));
    doReturn(false).when(command).isSoundDeviceEnabled(any(Guid.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(new ArrayList<>()).when(diskVmElementDao).getAllForVm(vmId);
    doReturn(true).when(command).validateQuota();
    mockSnapshotValidator();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isPassDiscardSupported(any(Guid.class));
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
}
#method_after
@Before
public void initializeMocks() {
    doNothing().when(command).updateDisksFromDb();
    doReturn(true).when(command).checkImageConfiguration();
    doReturn(false).when(command).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(false).when(command).hasWatchdog(any(Guid.class));
    doReturn(false).when(command).isBalloonEnabled(any(Guid.class));
    doReturn(false).when(command).isSoundDeviceEnabled(any(Guid.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(new ArrayList<>()).when(diskVmElementDao).getAllForVm(vmId);
    doReturn(true).when(command).validateQuota();
    mockSnapshotsValidator();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isPassDiscardSupported(any(Guid.class));
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    injectorRule.bind(VmDeviceUtils.class, vmDeviceUtils);
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    hostDao.getAll().stream().filter(h -> h.getStatus().isQualifyForCheckUpdates()).forEach(this::submitCheckUpdatesForHost);
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    hostDao.getAll().stream().filter(h -> h.getStatus().isEligibleForCheckUpdates()).forEach(this::submitCheckUpdatesForHost);
}
#end_block

#method_before
public HostUpgradeManagerResult checkForUpdates(VDS host) {
    if (!vdsDynamicDao.get(host.getId()).getStatus().isQualifyForOnDemandCheckUpdates()) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", host.getName(), host.getStatus());
        return null;
    }
    HostUpgradeManagerResult updatesResult = null;
    AuditLogableBase auditLog = Injector.injectMembers(new AuditLogableBase());
    auditLog.setVds(host);
    try {
        updatesResult = availableUpdatesFinder.checkForUpdates(host);
        if (updatesResult.isUpdatesAvailable()) {
            String message = updatesResult.getAvailablePackages() == null ? "found updates." : String.format("found updates for packages %s", StringUtils.join(updatesResult.getAvailablePackages(), ", "));
            auditLog.addCustomValue("Message", message);
        } else {
            auditLog.addCustomValue("Message", "no updates found.");
        }
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FINISHED);
    } catch (IllegalStateException e) {
        log.warn(e.getMessage());
        auditLog.addCustomValue("Message", "Another refresh process is already running");
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}' with error message '{}'", host.getName(), e.getMessage());
        log.debug("Exception", e);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause() == null ? null : e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
    }
    if (updatesResult != null && updatesResult.isUpdatesAvailable() != host.isUpdateAvailable()) {
        VdsManager hostManager = resourceManager.getVdsManager(host.getId());
        synchronized (hostManager) {
            hostManager.updateUpdateAvailable(updatesResult.isUpdatesAvailable());
        }
    }
    return updatesResult;
}
#method_after
public HostUpgradeManagerResult checkForUpdates(VDS host) {
    if (!vdsDynamicDao.get(host.getId()).getStatus().isEligibleForOnDemandCheckUpdates()) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", host.getName(), host.getStatus());
        return null;
    }
    HostUpgradeManagerResult updatesResult = null;
    AuditLogableBase auditLog = Injector.injectMembers(new AuditLogableBase());
    auditLog.setVds(host);
    try {
        updatesResult = availableUpdatesFinder.checkForUpdates(host);
        if (updatesResult.isUpdatesAvailable()) {
            String message = updatesResult.getAvailablePackages() == null ? "found updates." : String.format("found updates for packages %s", StringUtils.join(updatesResult.getAvailablePackages(), ", "));
            auditLog.addCustomValue("Message", message);
        } else {
            auditLog.addCustomValue("Message", "no updates found.");
        }
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FINISHED);
    } catch (IllegalStateException e) {
        log.warn(e.getMessage());
        auditLog.addCustomValue("Message", "Another refresh process is already running");
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}' with error message '{}'", host.getName(), e.getMessage());
        log.debug("Exception", e);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause() == null ? null : e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
    }
    if (updatesResult != null && updatesResult.isUpdatesAvailable() != host.isUpdateAvailable()) {
        VdsManager hostManager = resourceManager.getVdsManager(host.getId());
        synchronized (hostManager) {
            hostManager.updateUpdateAvailable(updatesResult.isUpdatesAvailable());
        }
    }
    return updatesResult;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<StorageDomainDR> sessionColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            GlusterGeoRepSession session = getDetailModel().getGeoRepSessionsMap().get(storageDomainDR.getGeoRepSessionId());
            if (session == null) {
                return storageDomainDR.getGeoRepSessionId().toString();
            } else {
                // $NON-NLS-1$
                return session.getSlaveHostName() + "::" + session.getSlaveVolumeName();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionColumn, constants.geoRepSlaveVolume(), "300px");
    AbstractTextColumn<StorageDomainDR> scheduleColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            StorageSyncSchedule schedule = new StorageSyncSchedule(storageDomainDR.getScheduleCronExpression());
            return schedule.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(scheduleColumn, constants.scheduleLabel(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomainDR>(constants.newDRSetup()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomainDR>(constants.editDRSetup()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<StorageDomainDR> sessionColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            GlusterGeoRepSession session = getDetailModel().getGeoRepSessionsMap().get(storageDomainDR.getGeoRepSessionId());
            if (session == null) {
                return storageDomainDR.getGeoRepSessionId().toString();
            } else {
                return messages.geoRepRemoteSessionName(session.getSlaveHostName(), session.getSlaveVolumeName());
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionColumn, constants.geoRepSlaveVolume(), "300px");
    AbstractTextColumn<StorageDomainDR> scheduleColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            StorageSyncSchedule schedule = new StorageSyncSchedule(storageDomainDR.getScheduleCronExpression());
            return schedule.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(scheduleColumn, constants.scheduleLabel(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomainDR>(constants.newDRSetup()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomainDR>(constants.editDRSetup()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
}
#end_block

#method_before
private void populateSessionsMap(List<StorageDomainDR> storageDRs) {
    for (final StorageDomainDR storageDR : storageDRs) {
        if (!geoRepSessionsMap.containsKey(storageDR.getGeoRepSessionId())) {
            Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeGeoRepSessionById, new IdQueryParameters(storageDR.getGeoRepSessionId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    if (returnValue.getReturnValue() != null) {
                        geoRepSessionsMap.put(storageDR.getGeoRepSessionId(), (GlusterGeoRepSession) returnValue.getReturnValue());
                    }
                }
            }));
        }
    }
}
#method_after
private void populateSessionsMap(List<StorageDomainDR> storageDRs) {
    for (final StorageDomainDR storageDR : storageDRs) {
        if (!geoRepSessionsMap.containsKey(storageDR.getGeoRepSessionId())) {
            AsyncDataProvider.getInstance().getGlusterVolumeGeoRepSessionById(new AsyncQuery<>(new AsyncCallback<GlusterGeoRepSession>() {

                @Override
                public void onSuccess(GlusterGeoRepSession geoRepSession) {
                    if (geoRepSession != null) {
                        geoRepSessionsMap.put(storageDR.getGeoRepSessionId(), geoRepSession);
                    }
                }
            }), storageDR.getGeoRepSessionId());
        }
    }
}
#end_block

#method_before
private void newDR() {
    if (getWindow() != null) {
        return;
    }
    final StorageDomain storageDomain = getEntity();
    if (storageDomain == null) {
        return;
    }
    final StorageDRModel model = new StorageDRModel();
    model.setHelpTag(HelpTag.new_storage_dr);
    // $NON-NLS-1$
    model.setHashName("new_storage_dr");
    model.setTitle(ConstantsManager.getInstance().getConstants().newDRSetup());
    setWindow(model);
    model.startProgress();
    model.getStorageDomain().setEntity(storageDomain);
    // TBD if glusterVolumeId is null - show error
    AsyncDataProvider.getInstance().getGlusterGeoRepSessionsForStorageDomain(new AsyncQuery<>(new AsyncCallback<List<GlusterGeoRepSession>>() {

        @Override
        public void onSuccess(List<GlusterGeoRepSession> geoRepSessions) {
            model.getGeoRepSession().setItems(geoRepSessions);
            model.stopProgress();
        }
    }), storageDomain.getId());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void newDR() {
    if (getWindow() != null) {
        return;
    }
    final StorageDomain storageDomain = getEntity();
    if (storageDomain == null) {
        return;
    }
    final StorageDRModel model = new StorageDRModel();
    model.setHelpTag(HelpTag.new_storage_dr);
    // $NON-NLS-1$
    model.setHashName("new_storage_dr");
    model.setTitle(ConstantsManager.getInstance().getConstants().newDRSetup());
    setWindow(model);
    model.getStorageDomain().setEntity(storageDomain);
    // TBD if glusterVolumeId is null - show error
    model.startProgress();
    AsyncDataProvider.getInstance().getGlusterGeoRepSessionsForStorageDomain(new AsyncQuery<>(new AsyncCallback<List<GlusterGeoRepSession>>() {

        @Override
        public void onSuccess(List<GlusterGeoRepSession> geoRepSessions) {
            model.getGeoRepSession().setItems(geoRepSessions);
            model.stopProgress();
        }
    }), storageDomain.getId());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OnSave", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
}
#method_after
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setDiscardAfterDelete(model.getDiscardAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
}
#end_block

#method_before
private void initEditors() {
    daysEditor = new ListModelCheckBoxGroupEditor<>(new AbstractRenderer<StorageSyncSchedule.Day>() {

        @Override
        public String render(StorageSyncSchedule.Day object) {
            return object.toString().substring(0, 3);
        }
    });
    frequencyEditor = new ListModelListBoxEditor<>(new AbstractRenderer<StorageSyncSchedule.Frequency>() {

        @Override
        public String render(StorageSyncSchedule.Frequency object) {
            return EnumTranslator.getInstance().translate(object);
        }
    });
    geoRepSessionEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<GlusterGeoRepSession>() {

        @Override
        protected String renderNullSafe(GlusterGeoRepSession geoRepSession) {
            if (geoRepSession == null) {
                // $NON-NLS-1$
                return "";
            } else {
                // $NON-NLS-1$
                return geoRepSession.getSlaveHostName() + "::" + geoRepSession.getSlaveVolumeName();
            }
        }
    });
    hoursEditor = new IntegerEntityModelTextBoxEditor();
    minsEditor = new IntegerEntityModelTextBoxEditor();
}
#method_after
private void initEditors() {
    daysEditor = new ListModelCheckBoxGroupEditor<>(new AbstractRenderer<StorageSyncSchedule.Day>() {

        @Override
        public String render(StorageSyncSchedule.Day object) {
            return object.toString().substring(0, 3);
        }
    });
    frequencyEditor = new ListModelListBoxEditor<>(new AbstractRenderer<StorageSyncSchedule.Frequency>() {

        @Override
        public String render(StorageSyncSchedule.Frequency object) {
            return EnumTranslator.getInstance().translate(object);
        }
    });
    geoRepSessionEditor = new ListModelListBoxEditor<>(new NullSafeRenderer<GlusterGeoRepSession>() {

        @Override
        protected String renderNullSafe(GlusterGeoRepSession geoRepSession) {
            if (geoRepSession == null) {
                return StringUtils.EMPTY;
            } else {
                return messages.geoRepRemoteSessionName(geoRepSession.getSlaveHostName(), geoRepSession.getSlaveVolumeName());
            }
        }
    });
    hoursEditor = new ListModelListBoxEditor<>();
    minsEditor = new ListModelListBoxEditor<>();
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDRPresenter.class, SubTabStorageDRPresenter.ViewDef.class, SubTabStorageDRView.class, SubTabStorageDRPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(VnicProfileMappingPopupPresenterWidget.class, VnicProfileMappingPopupPresenterWidget.ViewDef.class, VnicProfileMappingPopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    bindPresenterWidget(StorageDRPopupPresenterWidget.class, StorageDRPopupPresenterWidget.ViewDef.class, StorageDRPopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch();
    IdQueryParameters parameters = new IdQueryParameters(getEntity().getId());
    parameters.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainDR, parameters, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<StorageDomainDR> resultList = returnValue.getReturnValue();
            setItems(resultList);
        }
    }));
}
#method_after
@Override
protected void syncSearch() {
    if (getEntity() == null) {
        return;
    }
    super.syncSearch();
    IdQueryParameters parameters = new IdQueryParameters(getEntity().getId());
    parameters.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainDR, parameters, new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<StorageDomainDR> resultList = returnValue.getReturnValue();
            setItems(resultList);
            populateSessionsMap(resultList);
        }
    }));
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomainDR> domainDRs = getSelectedItems() != null ? Linq.<StorageDomainDR>cast(getSelectedItems()) : new ArrayList<StorageDomainDR>();
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(domainDRs.size() == 1);
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomainDR> domainDRs = getSelectedItems() != null ? Linq.<StorageDomainDR>cast(getSelectedItems()) : new ArrayList<StorageDomainDR>();
    getEditCommand().setIsExecutionAllowed(domainDRs.size() == 1);
}
#end_block

#method_before
private void newDR() {
    if (getWindow() != null) {
        return;
    }
    final StorageDomain storageDomain = getEntity();
    if (storageDomain == null) {
        return;
    }
    final StorageDRModel model = new StorageDRModel();
    model.setHelpTag(HelpTag.new_storage_dr);
    // $NON-NLS-1$
    model.setHashName("new_storage_dr");
    model.setTitle(ConstantsManager.getInstance().getConstants().newDRSetup());
    setWindow(model);
    model.startProgress();
    model.getStorageDomain().setEntity(storageDomain);
    // TBD if glusterVolumeId is null - show error
    AsyncDataProvider.getInstance().getStorageConnectionById(new AsyncQuery<>(new AsyncCallback<StorageServerConnections>() {

        @Override
        public void onSuccess(StorageServerConnections connection) {
            storageDomain.getStorageStaticData().setConnection(connection);
            if (storageDomain.getStorageStaticData().getConnection() == null || storageDomain.getStorageStaticData().getConnection().getGlusterVolumeId() == null) {
                model.setMessage(ConstantsManager.getInstance().getConstants().confirmVolumeSnapshotRestoreWithStopMessage());
                model.stopProgress();
            } else {
                AsyncDataProvider.getInstance().getGlusterGeoRepSessionsForVolume(new AsyncQuery<>(new AsyncCallback<List<GlusterGeoRepSession>>() {

                    @Override
                    public void onSuccess(List<GlusterGeoRepSession> geoRepSessions) {
                        model.getGeoRepSession().setItems(geoRepSessions);
                    }
                }), storageDomain.getStorageStaticData().getConnection().getGlusterVolumeId());
                model.stopProgress();
            }
        }
    }), storageDomain.getStorage(), true);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onNewDR", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void newDR() {
    if (getWindow() != null) {
        return;
    }
    final StorageDomain storageDomain = getEntity();
    if (storageDomain == null) {
        return;
    }
    final StorageDRModel model = new StorageDRModel();
    model.setHelpTag(HelpTag.new_storage_dr);
    // $NON-NLS-1$
    model.setHashName("new_storage_dr");
    model.setTitle(ConstantsManager.getInstance().getConstants().newDRSetup());
    setWindow(model);
    model.getStorageDomain().setEntity(storageDomain);
    // TBD if glusterVolumeId is null - show error
    model.startProgress();
    AsyncDataProvider.getInstance().getGlusterGeoRepSessionsForStorageDomain(new AsyncQuery<>(new AsyncCallback<List<GlusterGeoRepSession>>() {

        @Override
        public void onSuccess(List<GlusterGeoRepSession> geoRepSessions) {
            model.getGeoRepSession().setItems(geoRepSessions);
            model.stopProgress();
        }
    }), storageDomain.getId());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onNewDR", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onNewDR() {
    final StorageDRModel model = (StorageDRModel) getWindow();
    if (!model.validate()) {
        return;
    }
    StorageDomain storageDomain = getEntity();
    final StorageSyncSchedule syncSchedule = new StorageSyncSchedule();
    syncSchedule.setFrequency(model.getFrequency().getSelectedItem());
    syncSchedule.setHour(model.getHour().getEntity());
    syncSchedule.setMins(model.getMins().getEntity());
    StorageSyncScheduleParameters parameter = new StorageSyncScheduleParameters(syncSchedule, storageDomain.getId(), model.getGeoRepSession().getSelectedItem().getId());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.ScheduleGlusterStorageSync, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageDRListModel localModel = (StorageDRListModel) result.getState();
            model.stopProgress();
            localModel.postSaveAction(result.getReturnValue());
        }
    }, this);
}
#method_after
private void onNewDR() {
    final StorageDRModel model = (StorageDRModel) getWindow();
    if (!model.validate()) {
        return;
    }
    StorageDomain storageDomain = getEntity();
    final StorageSyncSchedule syncSchedule = new StorageSyncSchedule();
    syncSchedule.setFrequency(model.getFrequency().getSelectedItem());
    syncSchedule.setHour(model.getHour().getSelectedItem());
    syncSchedule.setMins(model.getMins().getSelectedItem());
    Guid georepId = model.getGeoRepSession().getSelectedItem() != null ? model.getGeoRepSession().getSelectedItem().getId() : null;
    StorageSyncScheduleParameters parameter = new StorageSyncScheduleParameters(syncSchedule, storageDomain.getId(), georepId);
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.ScheduleGlusterStorageSync, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageDRListModel localModel = (StorageDRListModel) result.getState();
            model.stopProgress();
            localModel.postSaveAction(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<StorageDomainDR> sessionColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            return storageDomainDR.getGeoRepSessionId().toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionColumn, constants.geoRepSlaveVolume(), "300px");
    AbstractTextColumn<StorageDomainDR> scheduleColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            return storageDomainDR.getSyncSchedule();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(scheduleColumn, constants.scheduleLabel(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomainDR>(constants.newDRSetup()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<StorageDomainDR> sessionColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            GlusterGeoRepSession session = getDetailModel().getGeoRepSessionsMap().get(storageDomainDR.getGeoRepSessionId());
            if (session == null) {
                return storageDomainDR.getGeoRepSessionId().toString();
            } else {
                return messages.geoRepRemoteSessionName(session.getSlaveHostName(), session.getSlaveVolumeName());
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sessionColumn, constants.geoRepSlaveVolume(), "300px");
    AbstractTextColumn<StorageDomainDR> scheduleColumn = new AbstractTextColumn<StorageDomainDR>() {

        @Override
        public String getValue(StorageDomainDR storageDomainDR) {
            StorageSyncSchedule schedule = new StorageSyncSchedule(storageDomainDR.getScheduleCronExpression());
            return schedule.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(scheduleColumn, constants.scheduleLabel(), "300px");
    getTable().addActionButton(new WebAdminButtonDefinition<StorageDomainDR>(constants.newDRSetup()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getNewCommand();
        }
    });
}
#end_block

#method_before
private void getDefaultConfigurationVersion(final LoginModel loginModel) {
    AsyncQuery callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = returnValue.getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(final LoginModel loginModel) {
    AsyncQuery callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public void initCache(final LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery<>(new AsyncCallback<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public void onSuccess(Map<KeyValuePairCompat<ConfigurationValues, String>, Object> returnValue) {
            getDefaultConfigurationVersion(loginModel);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#method_after
public void initCache(final LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery<>(new AsyncCallback<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public void onSuccess(Map<KeyValuePairCompat<ConfigurationValues, String>, Object> returnValue) {
            getDefaultConfigurationVersion(loginModel);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initGet64BitOss();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#end_block

#method_before
private void initMigrationPolicies() {
    AsyncQuery<List<MigrationPolicy>> aQuery = new AsyncQuery<>(new AsyncCallback<List<MigrationPolicy>>() {

        @Override
        public void onSuccess(List<MigrationPolicy> returnValue) {
            migrationPolicies = returnValue;
        }
    });
    aQuery.converterCallback = new Converter<List<MigrationPolicy>>() {

        @Override
        public List<MigrationPolicy> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<MigrationPolicy> policies = (List<MigrationPolicy>) returnValue;
            Collections.sort(policies, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return policies;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void initMigrationPolicies() {
    AsyncQuery<Map<Version, List<MigrationPolicy>>> aQuery = new AsyncQuery<>(new AsyncCallback<Map<Version, List<MigrationPolicy>>>() {

        @Override
        public void onSuccess(Map<Version, List<MigrationPolicy>> returnValue) {
            migrationPoliciesByVersion = returnValue;
        }
    });
    aQuery.converterCallback = new Converter<Map<Version, List<MigrationPolicy>>>() {

        @Override
        public Map<Version, List<MigrationPolicy>> convert(Object returnValue) {
            if (returnValue == null) {
                return new HashMap<>();
            }
            Map<Version, List<MigrationPolicy>> policiesByVersion = (Map<Version, List<MigrationPolicy>>) returnValue;
            for (List<MigrationPolicy> policies : policiesByVersion.values()) {
                Collections.sort(policies, new Comparator<MigrationPolicy>() {

                    @Override
                    public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                        // the empty one is always the first
                        if (NoMigrationPolicy.ID.equals(m1.getId())) {
                            return -1;
                        }
                        return m1.getName().compareTo(m2.getName());
                    }
                });
            }
            return policiesByVersion;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public List<MigrationPolicy> getMigrationPolicies() {
    return migrationPolicies;
}
#method_after
public List<MigrationPolicy> getMigrationPolicies(Version compatibilityVersion) {
    List<MigrationPolicy> migrationPolicies = migrationPoliciesByVersion.get(compatibilityVersion);
    return migrationPolicies != null ? migrationPolicies : Collections.singletonList((MigrationPolicy) new NoMigrationPolicy());
}
#end_block

#method_before
public EntityModel<Integer> getHour() {
    return hour;
}
#method_after
public ListModel<Integer> getHour() {
    return hour;
}
#end_block

#method_before
public void setHour(EntityModel<Integer> hour) {
    this.hour = hour;
}
#method_after
public void setHour(ListModel<Integer> hour) {
    this.hour = hour;
}
#end_block

#method_before
public EntityModel<Integer> getMins() {
    return mins;
}
#method_after
public ListModel<Integer> getMins() {
    return mins;
}
#end_block

#method_before
public void setMins(EntityModel<Integer> mins) {
    this.mins = mins;
}
#method_after
public void setMins(ListModel<Integer> mins) {
    this.mins = mins;
}
#end_block

#method_before
public boolean validate() {
    return true;
}
#method_after
public boolean validate() {
    getGeoRepSession().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getFrequency().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getHour().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, MAX_HOUR) });
    getMins().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, MAX_MINUTE) });
    boolean ret = getGeoRepSession().getIsValid() && getFrequency().getIsValid();
    if (!getFrequency().getSelectedItem().equals(Frequency.NONE)) {
        return ret && getHour().getIsValid() && getMins().getIsValid();
    }
    return ret;
}
#end_block

#method_before
private void setVmLeasesAvailability() {
    TModel model = getModel();
    Version compVer = model.getSelectedCluster().getCompatibilityVersion();
    if (model.getCustomCompatibilityVersion().getSelectedItem() != null) {
        compVer = model.getCustomCompatibilityVersion().getSelectedItem();
    }
    model.getLease().setIsAvailable(AsyncDataProvider.getInstance().isVmLeasesFeatureSupported(compVer));
}
#method_after
private void setVmLeasesAvailability() {
    TModel model = getModel();
    Version compVer = model.getSelectedCluster().getCompatibilityVersion();
    if (model.getCustomCompatibilityVersion().getSelectedItem() != null) {
        compVer = model.getCustomCompatibilityVersion().getSelectedItem();
    }
    model.getLease().setIsChangeable(AsyncDataProvider.getInstance().isVmLeasesFeatureSupported(compVer), constants.vmLeasesSupported());
}
#end_block

#method_before
protected void updateLeaseStorageDomains(final Guid selectedStorageDomainId) {
    setVmLeasesAvailability();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> returnValue) {
            List<StorageDomain> domains = new ArrayList<>();
            domains.add(null);
            for (StorageDomain domain : returnValue) {
                if (domain.getStorageDomainType().isDataDomain() && domain.getStatus() == StorageDomainStatus.Active) {
                    domains.add(domain);
                }
            }
            getModel().getLease().setItems(domains);
            if (!getModel().getLease().getIsAvailable() || selectedStorageDomainId == null) {
                getModel().getLease().setSelectedItem(null);
            } else {
                for (StorageDomain domain : domains) {
                    if (domain != null && selectedStorageDomainId.equals(domain.getId())) {
                        getModel().getLease().setSelectedItem(domain);
                        break;
                    }
                }
            }
        }
    }), getModel().getSelectedDataCenter().getId());
}
#method_after
protected void updateLeaseStorageDomains(final Guid selectedStorageDomainId) {
    setVmLeasesAvailability();
    AsyncDataProvider.getInstance().getStorageDomainList(new AsyncQuery<>(new AsyncCallback<List<StorageDomain>>() {

        @Override
        public void onSuccess(List<StorageDomain> returnValue) {
            List<StorageDomain> domains = new ArrayList<>();
            domains.add(null);
            for (StorageDomain domain : returnValue) {
                if (domain.getStorageDomainType().isDataDomain() && domain.getStatus() == StorageDomainStatus.Active) {
                    domains.add(domain);
                }
            }
            getModel().getLease().setItems(domains);
            if (!getModel().getLease().getIsChangable() || selectedStorageDomainId == null) {
                getModel().getLease().setSelectedItem(null);
            } else {
                for (StorageDomain domain : domains) {
                    if (domain != null && selectedStorageDomainId.equals(domain.getId())) {
                        getModel().getLease().setSelectedItem(domain);
                        break;
                    }
                }
            }
        }
    }), getModel().getSelectedDataCenter().getId());
}
#end_block

#method_before
@Override
protected boolean acquireLock() {
    if (getLock() == null) {
        if (!super.acquireLock()) {
            return false;
        }
        if (!Guid.Empty.equals(getVmId()) && isVmPrestarted()) {
            EngineLock runLock = vmPoolHandler.createLock(getVmId());
            Map<String, Pair<String, String>> exclusiveLocks = new HashMap<>();
            Map<String, Pair<String, String>> sharedLocks = new HashMap<>();
            exclusiveLocks.putAll(getContext().getLock().getExclusiveLocks());
            exclusiveLocks.putAll(runLock.getExclusiveLocks());
            if (getContext().getLock().getSharedLocks() != null) {
                sharedLocks.putAll(getContext().getLock().getSharedLocks());
            }
            if (runLock.getSharedLocks() != null) {
                sharedLocks.putAll(runLock.getSharedLocks());
            }
            setLock(new EngineLock(exclusiveLocks, sharedLocks));
        }
    }
    return true;
}
#method_after
@Override
protected boolean acquireLock() {
    if (getLock() == null) {
        if (!super.acquireLock()) {
            return false;
        }
        if (!Guid.Empty.equals(getVmId()) && isVmPrestarted()) {
            EngineLock runLock = vmPoolHandler.createLock(getVmId());
            Map<String, Pair<String, String>> exclusiveLocks = new HashMap<>();
            Map<String, Pair<String, String>> sharedLocks = new HashMap<>();
            if (getContext().getLock().getExclusiveLocks() != null) {
                exclusiveLocks.putAll(getContext().getLock().getExclusiveLocks());
            }
            exclusiveLocks.putAll(runLock.getExclusiveLocks());
            if (getContext().getLock().getSharedLocks() != null) {
                sharedLocks.putAll(getContext().getLock().getSharedLocks());
            }
            if (runLock.getSharedLocks() != null) {
                sharedLocks.putAll(runLock.getSharedLocks());
            }
            setLock(new EngineLock(exclusiveLocks, sharedLocks));
        }
    }
    return true;
}
#end_block

#method_before
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields, DisplayType vmVideoDeviceTypeforNextRun) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = vmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    // as all other devices will be done
    if (vmVideoDeviceTypeforNextRun == DisplayType.none) {
        VmDevice device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, VmDeviceGeneralType.VIDEO);
        while (device != null) {
            vmManagedDeviceMap.remove(device.getDeviceId());
            device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, VmDeviceGeneralType.VIDEO);
        }
    } else if (vm.getDefaultDisplayType() == DisplayType.none) {
        VmDevice videoDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vmVideoDeviceTypeforNextRun.toString(), "", 0, Collections.emptyMap(), true, true, false, "", null, null, null);
        vmManagedDeviceMap.put(videoDevice.getDeviceId(), videoDevice);
    }
    return vmManagedDeviceMap;
}
#method_after
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields, DisplayType vmVideoDeviceTypeforNextRun) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = vmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    // as all other devices will be done
    if (vmVideoDeviceTypeforNextRun == DisplayType.none) {
        vmManagedDeviceMap = vmManagedDeviceMap.entrySet().stream().filter(entry -> !entry.getValue().getType().equals(VmDeviceGeneralType.VIDEO)).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    } else if (vm.getDefaultDisplayType() == DisplayType.none) {
        VmDevice videoDevice = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vmVideoDeviceTypeforNextRun.toString(), "", 0, Collections.emptyMap(), true, true, false, "", null, null, null);
        vmManagedDeviceMap.put(videoDevice.getDeviceId(), videoDevice);
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<>();
    ArrayList<String> list = new ArrayList<>();
    boolean runningHe = false;
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getClusterId());
        if (item.isHostedEngineDeployed()) {
            runningHe = true;
        }
    }
    model.setItems(list);
    if (runningHe) {
        model.setNote(ConstantsManager.getInstance().getConstants().noteRemoveHaHost());
    }
    // - the cluster should have  gluster service enabled
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null && cluster.supportsGlusterService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    model.setHelpTag(HelpTag.remove_host);
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<>();
    ArrayList<String> list = new ArrayList<>();
    boolean heOnHosts = false;
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        clusters.add(item.getClusterId());
        String name = item.getName();
        if (item.isHostedEngineDeployed()) {
            // $NON-NLS-1$
            name = name + " *";
            heOnHosts = true;
        }
        list.add(name);
    }
    model.setItems(list);
    if (heOnHosts) {
        model.setNote(ConstantsManager.getInstance().getConstants().heHostRemovalWarning());
    }
    // - the cluster should have  gluster service enabled
    if (clusters.size() == 1) {
        model.startProgress();
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery<>(new AsyncCallback<Cluster>() {

            @Override
            public void onSuccess(Cluster cluster) {
                if (cluster != null && cluster.supportsGlusterService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void connect() throws ClientConnectionException {
    if (isOpen()) {
        return;
    }
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (isOpen() && isInInit()) {
            getPostConnectCallback().await(policy.getRetryTimeOut(), policy.getTimeUnit());
        }
        if (isOpen()) {
            return;
        }
        final FutureTask<SocketChannel> task = scheduleTask(new Retryable<>(() -> {
            InetAddress address = InetAddress.getByName(hostname);
            log.info("Connecting to " + address);
            final InetSocketAddress addr = new InetSocketAddress(address, port);
            final SocketChannel socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
            socketChannel.connect(addr);
            return socketChannel;
        }, this.policy));
        this.channel = task.get();
        final long timeout = getTimeout(policy.getRetryTimeOut(), policy.getTimeUnit());
        while (!this.channel.finishConnect()) {
            final FutureTask<SocketChannel> connectTask = scheduleTask(new Retryable<>(() -> {
                if (System.currentTimeMillis() >= timeout) {
                    throw new ConnectException("Connection timeout");
                }
                return null;
            }, this.policy));
            connectTask.get();
        }
        updateLastIncomingHeartbeat();
        updateLastOutgoingHeartbeat();
        if (!isOpen()) {
            throw new ClientConnectionException("Connection failed");
        }
        this.closing.set(false);
        postConnect(getPostConnectCallback());
    } catch (InterruptedException | ExecutionException e) {
        logException(log, "Exception during connection", e);
        final String message = "Connection issue " + e.getMessage();
        scheduleClose(message);
        throw new ClientConnectionException(e);
    } catch (IOException e) {
        closeChannel();
        throw new ClientConnectionException("Connection failed");
    }
}
#method_after
public void connect() throws ClientConnectionException {
    if (isOpen()) {
        return;
    }
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (isOpen() && isInInit()) {
            getPostConnectCallback().await(policy.getRetryTimeOut(), policy.getTimeUnit());
        }
        if (isOpen()) {
            return;
        }
        final FutureTask<SocketChannel> task = scheduleTask(new Retryable<>(() -> {
            InetAddress address = InetAddress.getByName(hostname);
            log.info("Connecting to " + address);
            final InetSocketAddress addr = new InetSocketAddress(address, port);
            final SocketChannel socketChannel = SocketChannel.open();
            socketChannel.configureBlocking(false);
            socketChannel.connect(addr);
            return socketChannel;
        }, this.policy));
        this.channel = task.get();
        final long timeout = getTimeout(policy.getRetryTimeOut(), policy.getTimeUnit());
        while (!this.channel.finishConnect()) {
            final FutureTask<SocketChannel> connectTask = scheduleTask(new Retryable<>(() -> {
                if (System.currentTimeMillis() >= timeout) {
                    throw new ConnectException("Connection timeout");
                }
                return null;
            }, this.policy));
            connectTask.get();
        }
        updateLastIncomingHeartbeat();
        updateLastOutgoingHeartbeat();
        if (!isOpen()) {
            throw new ClientConnectionException("Connection failed");
        }
        this.closing.set(false);
        postConnect(getPostConnectCallback());
    } catch (InterruptedException | ExecutionException e) {
        logException(log, "Exception during connection", e);
        final String message = "Connection issue " + e.getMessage();
        scheduleClose(message);
        throw new ClientConnectionException(e);
    } catch (IOException e) {
        closeChannel();
        throw new ClientConnectionException("Connection failed", e);
    }
}
#end_block

#method_before
public int read(ByteBuffer buff) throws IOException {
    int read = 0;
    if (this.appPeerBuffer.position() == 0) {
        this.channel.read(this.packatPeerBuffer);
        if (this.packatPeerBuffer.position() == 0) {
            return read;
        }
        this.packatPeerBuffer.flip();
        boolean retry = true;
        while (retry) {
            SSLEngineResult result = this.engine.unwrap(this.packatPeerBuffer, this.appPeerBuffer);
            switch(result.getStatus()) {
                case BUFFER_OVERFLOW:
                    putBuffer(buff);
                    read += result.bytesProduced();
                    retry = false;
                    break;
                case BUFFER_UNDERFLOW:
                    read += result.bytesProduced();
                    retry = false;
                    break;
                default:
                    if (HandshakeStatus.NEED_TASK.equals(result.getHandshakeStatus()) || !this.appPeerBuffer.hasRemaining()) {
                        retry = false;
                    }
                    read += result.bytesProduced();
            }
        }
        this.packatPeerBuffer.compact();
    }
    putBuffer(buff);
    return read;
}
#method_after
public int read(ByteBuffer buff) throws IOException {
    int read = 0;
    if (this.appPeerBuffer.position() == 0) {
        this.channel.read(this.packatPeerBuffer);
        if (this.packatPeerBuffer.position() == 0) {
            return read;
        }
        this.packatPeerBuffer.flip();
        boolean retry = true;
        while (retry) {
            SSLEngineResult result = this.engine.unwrap(this.packatPeerBuffer, this.appPeerBuffer);
            switch(result.getStatus()) {
                case BUFFER_OVERFLOW:
                    putBuffer(buff);
                case BUFFER_UNDERFLOW:
                    read += result.bytesProduced();
                    retry = false;
                    break;
                default:
                    if (HandshakeStatus.NEED_TASK.equals(result.getHandshakeStatus()) || !this.appPeerBuffer.hasRemaining()) {
                        retry = false;
                    }
                    read += result.bytesProduced();
            }
        }
        this.packatPeerBuffer.compact();
    }
    putBuffer(buff);
    return read;
}
#end_block

#method_before
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Optional<Guid> vdsToRunOn = getVdsToRunOn();
    setDestinationVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    vmHandler.updateVmGuestAgentVersion(getVm());
    if (!vdsToRunOn.isPresent()) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#method_after
protected boolean initVdss() {
    try {
        setVdsIdRef(getVm().getRunOnVds());
        Optional<Guid> vdsToRunOn = getVdsToRunOn();
        setDestinationVdsId(vdsToRunOn.orElse(null));
        if (vdsToRunOn.isPresent()) {
            getRunVdssList().add(vdsToRunOn.get());
        }
        vmHandler.updateVmGuestAgentVersion(getVm());
        if (!vdsToRunOn.isPresent()) {
            return false;
        }
        if (getDestinationVds() == null || getVds() == null) {
            return false;
        }
        return true;
    } catch (Exception e) {
        cleanupPassthroughVnics(getDestinationVdsId());
        throw e;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    try {
        resourceManager.getVmManager(getVmId()).getStatistics().setMigrationProgressPercent(0);
        setSucceeded(initVdss() && perform());
    } catch (Exception e) {
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        cleanupPassthroughVnics(getDestinationVdsId());
    }
}
#method_after
@Override
protected void executeVmCommand() {
    getVmManager().getStatistics().setMigrationProgressPercent(0);
    setSucceeded(initVdss() && perform());
}
#end_block

#method_before
private List<VmNetworkInterface> getAllVmPassthroughNics() {
    List<VmNetworkInterface> allForVm = vmNetworkInterfaceDao.getAllForVm(getVmId());
    return allForVm.stream().filter(vnic -> vnic.isPassthrough() && vnic.isPlugged()).collect(Collectors.toList());
}
#method_after
private List<VmNetworkInterface> getAllVmPassthroughNics() {
    if (cachedVmPassthroughNics == null) {
        cachedVmPassthroughNics = vmNetworkInterfaceDao.getAllForVm(getVmId()).stream().filter(vnic -> vnic.isPassthrough() && vnic.isPlugged()).collect(Collectors.toList());
        log.debug("Performing migration with following passthrough nics: {}", cachedVmPassthroughNics);
    }
    return cachedVmPassthroughNics;
}
#end_block

#method_before
private boolean perform() {
    try {
        getParameters().setStartTime(new Date());
        allVmPassthroughNics = getAllVmPassthroughNics();
        log.debug("Performing migration with following passthrough nics: {}", allVmPassthroughNics);
        if (!unplugNics(allVmPassthroughNics)) {
            return false;
        }
        if (connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
    } catch (Exception e) {
        log.debug("Migration failed.", e);
        // this will clean all VF reservations made in {@link #initVdss}.
        cleanupPassthroughVnics(getDestinationVdsId());
    }
    runningFailed();
    return false;
}
#method_after
private boolean perform() {
    try {
        getParameters().setStartTime(new Date());
        if (unplugPassthroughNics() && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
        // otherwise
        runningFailed();
        return false;
    } catch (Exception e) {
        runningFailed();
        throw e;
    }
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId(), getCluster().getCompatibilityVersion());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getLiteralMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    Integer maxIncomingMigrations = null;
    Integer maxOutgoingMigrations = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId(), getCluster().getCompatibilityVersion());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
        maxIncomingMigrations = maxOutgoingMigrations = effectiveMigrationPolicy.getMaxMigrations();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getLiteralMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents, maxIncomingMigrations, maxOutgoingMigrations);
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
        try {
            plugNics(allVmPassthroughNics);
        } catch (Exception e) {
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_PLUGGING_VM_NICS_FAILED);
            log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
            log.debug("Exception: ", e);
        }
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
        plugPassthroughNics();
    } finally {
        super.runningSucceded();
    }
}
#end_block

#method_before
private String getLiteralMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = networkDao.getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return String.format("[%s]", migrationDestinationIpv6Address);
        }
    }
    return null;
}
#method_after
private String getLiteralMigrationNetworkIp() {
    Network migrationNetwork = null;
    // Find migrationNetworkCluster
    List<Network> allNetworksInCluster = networkDao.getAllForCluster(getVm().getClusterId());
    for (Network tempNetwork : allNetworksInCluster) {
        if (tempNetwork.getCluster().isMigration()) {
            migrationNetwork = tempNetwork;
            break;
        }
    }
    if (migrationNetwork != null) {
        final String migrationDestinationIpv4Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv4Address);
        if (migrationDestinationIpv4Address != null) {
            return migrationDestinationIpv4Address;
        }
        final String migrationDestinationIpv6Address = findValidMigrationIpAddress(migrationNetwork, VdsNetworkInterface::getIpv6Address);
        if (migrationDestinationIpv6Address != null) {
            return formatIpv6AddressForUri(migrationDestinationIpv6Address);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void rerun() {
    // make Vm property to null in order to refresh it from db
    setVm(null);
    determineMigrationFailureForAuditLog();
    // if vm is up and rerun is called then it got up on the source, try to rerun
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        super.rerun();
    } else {
        // vm went down on the destination and source, migration failed.
        runningFailed();
        // signal the caller that a rerun was made so that it won't log
        // the failure message again
        _isRerun = true;
    }
}
#method_after
@Override
public void rerun() {
    // make Vm property to null in order to refresh it from db
    setVm(null);
    determineMigrationFailureForAuditLog();
    // if vm is up and rerun is called then it got up on the source, try to rerun
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        // this will clean all VF reservations made in {@link #initVdss}.
        cleanupPassthroughVnics(getDestinationVdsId());
        super.rerun();
    } else {
        // vm went down on the destination and source, migration failed.
        runningFailed();
        // signal the caller that a rerun was made so that it won't log
        // the failure message again
        _isRerun = true;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    macPool = getMacPool();
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (!validateBeforeCloneVm(domainsMap)) {
        return false;
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > macPool.getAvailableMacsCount()) {
            return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    return validateAfterCloneVm(domainsMap);
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    macPool = getMacPool();
    Map<Guid, StorageDomain> domainsMap = new HashMap<>();
    if (!validateBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
        if (getVm().getInterfaces().size() > macPool.getAvailableMacsCount()) {
            return failValidation(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        }
    }
    if (!validateBallonDevice()) {
        return false;
    }
    if (!validateSoundDevice()) {
        return false;
    }
    return validateAfterCloneVm(domainsMap);
}
#end_block

#method_before
protected boolean validateBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && isCopyCollapseDisabledWithSnapshotsOrWithTemplate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED, String.format("$VmName %1$s", getVmName()));
    }
    // Register can never happen with copyCollapse = true since there's no copy operation involved.
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#method_after
protected boolean validateBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && isCopyCollapseDisabledWithSnapshotsOrWithTemplate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED, String.format("$VmName %1$s", getVmName()));
    }
    // Register can never happen with copyCollapse = true since there's no copy operation involved.
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        if (!validateAndSetVmFromExportDomain()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    return true;
}
#end_block

#method_before
protected boolean validateAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !validateUniqueVmName()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getValidationMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDao().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateGraphicsAndDisplay()) {
        return false;
    }
    if (!getParameters().isImportAsNewEntity()) {
        List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
        if (!validate(vmNicMacsUtils.validateThereIsEnoughOfFreeMacs(vmNetworkInterfaces, getMacPool()))) {
            return false;
        }
        if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
protected boolean validateAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vmFromParams = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !validateUniqueVmName()) {
        return false;
    }
    if (!VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vmFromParams.getDiskMap() != null) {
        for (Disk disk : vmFromParams.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getValidationMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", storageDomainStaticDao.get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVmArchitecture()) {
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    if (!isImagesAlreadyOnTarget()) {
        if (!handleDestStorageDomains()) {
            return false;
        }
    }
    if (!validateGraphicsAndDisplay()) {
        return false;
    }
    if (!getParameters().isImportAsNewEntity()) {
        List<VmNetworkInterface> vmNetworkInterfaces = getVm().getInterfaces();
        if (!validate(vmNicMacsUtils.validateThereIsEnoughOfFreeMacs(vmNetworkInterfaces, getMacPool()))) {
            return false;
        }
        if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private StorageDomain updateStorageDomainInMemoryVolumes(List<DiskImage> disksList) {
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(VmUtils.getSnapshotMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
    StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getParameters().getStoragePoolId(), memoryDisksList, getVmDisksDummies(), getVm());
    disksList.addAll(memoryDisksList);
    return storageDomain;
}
#method_after
private StorageDomain updateStorageDomainInMemoryVolumes(List<DiskImage> disksList) {
    List<DiskImage> memoryDisksList = MemoryUtils.createDiskDummies(vmOverheadCalculator.getSnapshotMemorySizeInBytes(getVm()), MemoryUtils.METADATA_SIZE_IN_BYTES);
    StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getParameters().getStoragePoolId(), memoryDisksList, getVmDisksDummies(), getVm());
    disksList.addAll(memoryDisksList);
    return storageDomain;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = validate(getImportValidator().verifyDisks(imageList, imageToDestinationDomainMap));
    if (retValue && !VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        Set<Guid> domainsId = domains.stream().map(StorageDomain::getId).collect(Collectors.toSet());
        if (!domainsId.isEmpty() && Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (!retValue.getSucceeded()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : new ArrayList<>(getImages())) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getSourceDomainId(image);
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = runVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (!retValue.getSucceeded()) {
            if (!getParameters().isAllowPartialImport()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
            }
            log.warn("Disk image '{}/{}' doesn't exist on storage domain '{}'. Ignoring since force flag in on", imageGroupId, imageGUID, storageDomainId);
            getVm().getImages().remove(image);
            failedDisksToImportForAuditLog.putIfAbsent(image.getId(), image.getDiskAlias());
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void processImages() {
    processImages(!isImagesAlreadyOnTarget());
    // if there are no tasks, we can just unlock the VM
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        VmHandler.unLockVm(getVm());
    }
}
#method_after
@Override
protected void processImages() {
    processImages(!isImagesAlreadyOnTarget());
    // if there are no tasks, we can just unlock the VM
    if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
        vmHandler.unLockVm(getVm());
    }
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForMemoryDumpImage(Guid containerID, Guid storageId, Guid imageId, Guid volumeId) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, imageId, volumeId, imageId, volumeId, storageId, ImageOperation.Copy);
    params.setParentCommand(getActionType());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setParentParameters(getParameters());
    StorageDomainStatic storageDomain = getStorageDomainStaticDao().get(storageId);
    if (storageDomain.getStorageType().isBlockDomain()) {
        params.setUseCopyCollapse(true);
        params.setVolumeType(VolumeType.Preallocated);
        params.setVolumeFormat(VolumeFormat.RAW);
    }
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForMemoryDumpImage(Guid containerID, Guid storageId, Guid imageId, Guid volumeId) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, imageId, volumeId, imageId, volumeId, storageId, ImageOperation.Copy);
    params.setParentCommand(getActionType());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setParentParameters(getParameters());
    StorageDomainStatic storageDomain = storageDomainStaticDao.get(storageId);
    if (storageDomain.getStorageType().isBlockDomain()) {
        params.setUseCopyCollapse(true);
        params.setVolumeType(VolumeType.Preallocated);
        params.setVolumeFormat(VolumeFormat.RAW);
    }
    return params;
}
#end_block

#method_before
protected void saveBaseDisk(DiskImage disk) {
    getBaseDiskDao().save(disk);
}
#method_after
protected void saveBaseDisk(DiskImage disk) {
    baseDiskDao.save(disk);
}
#end_block

#method_before
protected void saveDiskVmElement(Guid diskId, Guid vmId, DiskVmElement diskVmElement) {
    DiskVmElement dve = DiskVmElement.copyOf(diskVmElement, diskId, vmId);
    getDiskVmElementDao().save(dve);
}
#method_after
protected void saveDiskVmElement(Guid diskId, Guid vmId, DiskVmElement diskVmElement) {
    DiskVmElement dve = DiskVmElement.copyOf(diskVmElement, diskId, vmId);
    updatePassDiscardForDiskVmElement(dve);
    diskVmElementDao.save(dve);
}
#end_block

#method_before
protected void saveImage(DiskImage disk) {
    BaseImagesCommand.saveImage(disk);
}
#method_after
protected void saveImage(DiskImage disk) {
    ImagesHandler.saveImage(disk);
}
#end_block

#method_before
protected void updateImage(DiskImage disk) {
    getImageDao().update(disk.getImage());
}
#method_after
protected void updateImage(DiskImage disk) {
    imageDao.update(disk.getImage());
}
#end_block

#method_before
protected void saveDiskImageDynamic(DiskImage disk) {
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(disk.getImageId());
    diskDynamic.setActualSize(disk.getActualSizeInBytes());
    getDiskImageDynamicDao().save(diskDynamic);
}
#method_after
protected void saveDiskImageDynamic(DiskImage disk) {
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(disk.getImageId());
    diskDynamic.setActualSize(disk.getActualSizeInBytes());
    diskImageDynamicDao.save(diskDynamic);
}
#end_block

#method_before
private void updateSnapshotsFromExport() {
    if (getVm().getSnapshots() == null) {
        return;
    }
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (!StringUtils.isEmpty(snapshot.getMemoryVolume())) {
            updateMemoryDisks(snapshot);
        }
        if (getSnapshotDao().exists(getVm().getId(), snapshot.getId())) {
            getSnapshotDao().update(snapshot);
        } else {
            getSnapshotDao().save(snapshot);
        }
    }
}
#method_after
private void updateSnapshotsFromExport() {
    if (getVm().getSnapshots() == null) {
        return;
    }
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (!StringUtils.isEmpty(snapshot.getMemoryVolume())) {
            updateMemoryDisks(snapshot);
        }
        if (snapshotDao.exists(getVm().getId(), snapshot.getId())) {
            snapshotDao.update(snapshot);
        } else {
            snapshotDao.save(snapshot);
        }
    }
}
#end_block

#method_before
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, getStorageDomainStaticDao().get(guids.get(0)).getStorageType());
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#method_after
private DiskImage createMemoryDisk(Snapshot snapshot) {
    List<Guid> guids = GuidUtils.getGuidListFromString(snapshot.getMemoryVolume());
    VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
    DiskImage memoryDisk = MemoryUtils.createMemoryDisk(vm, storageDomainStaticDao.get(guids.get(0)).getStorageType(), vmOverheadCalculator);
    memoryDisk.setId(guids.get(2));
    memoryDisk.setImageId(guids.get(3));
    memoryDisk.setStorageIds(new ArrayList<>(Collections.singletonList(guids.get(0))));
    memoryDisk.setStoragePoolId(guids.get(1));
    memoryDisk.setCreationDate(snapshot.getCreationDate());
    return memoryDisk;
}
#end_block

#method_before
protected void saveSnapshotIfNotExists(Guid snapshotId, DiskImage disk) {
    if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
        getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getDescription(), disk.getLastModifiedDate(), disk.getAppList()));
    }
}
#method_after
protected void saveSnapshotIfNotExists(Guid snapshotId, DiskImage disk) {
    if (!snapshotDao.exists(getVm().getId(), snapshotId)) {
        snapshotDao.save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getDescription(), disk.getLastModifiedDate(), disk.getAppList()));
    }
}
#end_block

#method_before
protected void updateActiveSnapshot(Guid snapshotId) {
    getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
}
#method_after
protected void updateActiveSnapshot(Guid snapshotId) {
    snapshotDao.update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    checkTrustedService();
    endActionOnAllImageGroups();
    VmHandler.unLockVm(getVm());
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    checkTrustedService();
    endActionOnAllImageGroups();
    vmHandler.unLockVm(getVm());
    setSucceeded(true);
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getVm().isTrustedService() && !getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (getVm().isTrustedService() && !getCluster().supportsTrustedService()) {
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getCluster().supportsTrustedService()) {
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading it form DB
    setVm(null);
    if (getVm() != null) {
        removeVmSnapshots();
        endActionOnAllImageGroups();
        removeVmNetworkInterfaces();
        getVmDynamicDao().remove(getVmId());
        getVmStatisticsDao().remove(getVmId());
        getVmStaticDao().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(getParameters().getVm());
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading it form DB
    setVm(null);
    if (getVm() != null) {
        removeVmSnapshots();
        endActionOnAllImageGroups();
        removeVmNetworkInterfaces();
        vmDynamicDao.remove(getVmId());
        vmStatisticsDao.remove(getVmId());
        vmStaticDao.remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(getParameters().getVm());
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getParameters().getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (getParameters().getVm().getDiskMap() != null) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (Disk disk : getDisksForDiskProfileValidation()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                map.put(diskImage, imageToDestinationDomainMap.get(diskImage.getId()));
            }
        }
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = getVmTemplateDao().get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = getVmTemplateDao().get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVmTemplate() == null) {
        return false;
    }
    setDescription(getVmTemplateName());
    // check that the storage pool is valid
    if (!checkStoragePool() || !validateTemplateArchitecture() || !isClusterCompatible()) {
        return false;
    }
    // set the source domain and check that it is ImportExport type and active
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
    if (!validate(sourceDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    if ((getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) && !getParameters().isImagesExistOnTargetStorageDomain()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    if (!getParameters().isImagesExistOnTargetStorageDomain()) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (!qretVal.getSucceeded()) {
            return false;
        }
        Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
        ArrayList<DiskImage> images = new ArrayList<>();
        for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
            if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                images = new ArrayList<>(entry.getValue());
                getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                break;
            }
        }
        getParameters().setImages(images);
        getVmTemplate().setImages(images);
        ensureDomainMap(getImages(), getParameters().getDestDomainId());
        HashMap<Guid, DiskImage> imageMap = new HashMap<>();
        for (DiskImage image : images) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
                return false;
            }
            StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
            changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
            if (!ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getValidationMessages())) {
                return false;
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            image.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomain.getId())));
            imageMap.put(image.getImageId(), image);
        }
        getVmTemplate().setDiskImageMap(imageMap);
    }
    sourceTemplateId = getVmTemplateId();
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    VmTemplate duplicateTemplate = vmTemplateDao.get(getParameters().getVmTemplate().getId());
    // check that the template does not exists in the target domain
    if (duplicateTemplate != null) {
        return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS, String.format("$TemplateName %1$s", duplicateTemplate.getName()));
    }
    if (getVmTemplate().isBaseTemplate() && isVmTemplateWithSameNameExist()) {
        return failValidation(EngineMessage.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
    }
    if (!validateNoDuplicateDiskImages(getImages())) {
        return false;
    }
    if (getImages() != null && !getImages().isEmpty() && !getParameters().isImagesExistOnTargetStorageDomain()) {
        if (!validateSpaceRequirements(getImages())) {
            return false;
        }
    }
    List<VmNetworkInterface> vmNetworkInterfaces = getVmTemplate().getInterfaces();
    vmNicMacsUtils.replaceInvalidEmptyStringMacAddressesWithNull(vmNetworkInterfaces);
    if (!validate(vmNicMacsUtils.validateMacAddress(vmNetworkInterfaces))) {
        return false;
    }
    // if this is a template version, check base template exist
    if (!getVmTemplate().isBaseTemplate()) {
        VmTemplate baseTemplate = vmTemplateDao.get(getVmTemplate().getBaseTemplateId());
        if (baseTemplate == null) {
            return failValidation(EngineMessage.VMT_CANNOT_IMPORT_TEMPLATE_VERSION_MISSING_BASE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected StorageDomain getSourceDomain() {
    if (sourceDomain == null && !Guid.Empty.equals(sourceDomainId)) {
        sourceDomain = getStorageDomainDao().getForStoragePool(sourceDomainId, getStoragePool().getId());
    }
    return sourceDomain;
}
#method_after
protected StorageDomain getSourceDomain() {
    if (sourceDomain == null && !Guid.Empty.equals(sourceDomainId)) {
        sourceDomain = storageDomainDao.getForStoragePool(sourceDomainId, getStoragePool().getId());
    }
    return sourceDomain;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        VmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        initImportClonedTemplateDisks();
        addVmTemplateToDb();
        updateOriginalTemplateNameOnDerivedVms();
        addVmInterfaces();
        getCompensationContext().stateChanged();
        vmHandler.addVmInitToDB(getVmTemplate());
        return null;
    });
    boolean doesVmTemplateContainImages = !getImages().isEmpty();
    if (doesVmTemplateContainImages && !getParameters().isImagesExistOnTargetStorageDomain()) {
        moveOrCopyAllImageGroups(getVmTemplateId(), getImages());
    }
    getVmDeviceUtils().addImportedDevices(getVmTemplate(), getParameters().isImportAsNewEntity());
    if (!doesVmTemplateContainImages || getParameters().isImagesExistOnTargetStorageDomain()) {
        endMoveOrCopyCommand();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void updateOriginalTemplateNameOnDerivedVms() {
    if (!getParameters().isImportAsNewEntity()) {
        // in case it has been renamed
        getVmDao().updateOriginalTemplateName(getVmTemplate().getId(), getVmTemplate().getName());
    }
}
#method_after
private void updateOriginalTemplateNameOnDerivedVms() {
    if (!getParameters().isImportAsNewEntity()) {
        // in case it has been renamed
        vmDao.updateOriginalTemplateName(getVmTemplate().getId(), getVmTemplate().getName());
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (getVmTemplate().isTrustedService() && !getCluster().supportsTrustedService()) {
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getCluster().supportsTrustedService()) {
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    getVmTemplate().setClusterId(getParameters().getClusterId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate(), null)) {
        getVmTemplate().setDedicatedVmForVdsList(Collections.emptyList());
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    VmHandler.updateImportedVmUsbPolicy(getVmTemplate());
    getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = BaseImagesCommand.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!getBaseDiskDao().exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            getBaseDiskDao().save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setActualSize(image.getActualSizeInBytes());
        getDiskImageDynamicDao().save(diskDynamic);
        DiskVmElement dve = DiskVmElement.copyOf(image.getDiskVmElementForVm(sourceTemplateId), image.getId(), getVmTemplateId());
        getDiskVmElementDao().save(dve);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#method_after
protected void addVmTemplateToDb() {
    getVmTemplate().setClusterId(getParameters().getClusterId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!vmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate(), null)) {
        getVmTemplate().setDedicatedVmForVdsList(Collections.emptyList());
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = ImagesHandler.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!baseDiskDao.exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            baseDiskDao.save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setActualSize(image.getActualSizeInBytes());
        diskImageDynamicDao.save(diskDynamic);
        DiskVmElement dve = DiskVmElement.copyOf(image.getDiskVmElementForVm(sourceTemplateId), image.getId(), getVmTemplateId());
        diskVmElementDao.save(dve);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#end_block

#method_before
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName());
}
#method_after
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        nic.setVnicProfileId(iface.getVnicProfileId());
        vmNicDao.save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        vmNetworkStatisticsDao.save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName());
}
#end_block

#method_before
@Override
protected void endMoveOrCopyCommand() {
    VmTemplateHandler.unlockVmTemplate(getVmTemplateId());
    endActionOnAllImageGroups();
    setSucceeded(true);
}
#method_after
@Override
protected void endMoveOrCopyCommand() {
    vmTemplateHandler.unlockVmTemplate(getVmTemplateId());
    endActionOnAllImageGroups();
    setSucceeded(true);
}
#end_block

#method_before
protected void removeNetwork() {
    List<VmNic> list = getVmNicDao().getAllForTemplate(getVmTemplateId());
    for (VmNic iface : list) {
        getVmNicDao().remove(iface.getId());
    }
}
#method_after
protected void removeNetwork() {
    List<VmNic> list = vmNicDao.getAllForTemplate(getVmTemplateId());
    for (VmNic iface : list) {
        vmNicDao.remove(iface.getId());
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    removeNetwork();
    endActionOnAllImageGroups();
    getVmTemplateDao().remove(getVmTemplateId());
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    removeNetwork();
    endActionOnAllImageGroups();
    vmTemplateDao.remove(getVmTemplateId());
    setSucceeded(true);
}
#end_block

#method_before
public ValidationResult validateMacAddress(List<? extends VmNic> vmNics) {
    for (VmNic iface : vmNics) {
        String str = iface.getMacAddress();
        if (str != null) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID, String.format("$IfaceName %1$s", iface.getName()), String.format("$MacAddress %1$s", iface.getMacAddress()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateMacAddress(List<? extends VmNic> vmNics) {
    for (VmNic iface : vmNics) {
        if (iface.getMacAddress() != null) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID, String.format("$IfaceName %1$s", iface.getName()), String.format("$MacAddress %1$s", iface.getMacAddress()));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult validateThereIsEnoughOfFreeMacs(List<? extends VmNic> vmNics, MacPool macPool) {
    long requiredMacs = streamOfFilteredNics(vmNics, false).count();
    boolean notEnoughOfMacs = requiredMacs > 0 && macPool.getAvailableMacsCount() < requiredMacs;
    return ValidationResult.failWith(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES).when(notEnoughOfMacs);
}
#method_after
public ValidationResult validateThereIsEnoughOfFreeMacs(List<? extends VmNic> vmNics, MacPool macPool) {
    Stream<? extends VmNic> nicsWithoutMacAddress = vmNics.stream().filter(this::nicWithoutMacAddress);
    long requiredMacs = nicsWithoutMacAddress.count();
    boolean notEnoughOfMacs = requiredMacs > 0 && macPool.getAvailableMacsCount() < requiredMacs;
    return ValidationResult.failWith(EngineMessage.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES).when(notEnoughOfMacs);
}
#end_block

#method_before
public void replaceInvalidEmptyStringMacAddressesWithNull(List<VmNetworkInterface> vmNetworkInterfaces) {
    for (VmNetworkInterface vmNetworkInterface : vmNetworkInterfaces) {
        String macAddress = vmNetworkInterface.getMacAddress();
        if (macAddress != null && macAddress.isEmpty()) {
            vmNetworkInterface.setMacAddress(null);
        }
    }
}
#method_after
public void replaceInvalidEmptyStringMacAddressesWithNull(List<VmNetworkInterface> vmNetworkInterfaces) {
    vmNetworkInterfaces.stream().filter((vmNetworkInterface) -> StringUtils.isEmpty(vmNetworkInterface.getMacAddress())).forEach(e -> e.setMacAddress(null));
}
#end_block

#method_before
private MapSqlParameterSource createFullParametersSource(StorageDomainDR storageDomainDR) {
    return getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainDR.getStorageDomainId()).addValue("georep_session_id", storageDomainDR.getGeoRepSessionId()).addValue("sync_schedule", storageDomainDR.getSyncSchedule()).addValue("qrtz_job_id", storageDomainDR.getJobId());
}
#method_after
private MapSqlParameterSource createFullParametersSource(StorageDomainDR storageDomainDR) {
    return getCustomMapSqlParameterSource().addValue("storage_domain_id", storageDomainDR.getStorageDomainId()).addValue("georep_session_id", storageDomainDR.getGeoRepSessionId()).addValue("sync_schedule", storageDomainDR.getScheduleCronExpression()).addValue("qrtz_job_id", storageDomainDR.getJobId());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageSyncSchedule)) {
        return false;
    }
    StorageSyncSchedule other = (StorageSyncSchedule) obj;
    return Objects.equals(frequency, other.frequency) && Objects.equals(days, other.days) && Objects.equals(hour, other.hour) && Objects.equals(mins, other.mins);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageSyncSchedule)) {
        return false;
    }
    StorageSyncSchedule other = (StorageSyncSchedule) obj;
    return Objects.equals(frequency, other.frequency) && Arrays.equals(days, other.days) && Objects.equals(hour, other.hour) && Objects.equals(mins, other.mins);
}
#end_block

#method_before
@Override
public void edit(GlusterStorageModel object) {
    driver.edit(object);
    pathExampleLabel.setVisible(object.getPath().getIsAvailable() && object.getPath().getIsChangable());
}
#method_after
@Override
public void edit(GlusterStorageModel object) {
    final GlusterStorageModel glusterStorageModel = object;
    driver.edit(object);
    glusterVolumesEditor.asEditor().setValue(object.getGlusterVolumes().getSelectedItem());
    pathExampleLabel.setVisible(object.getPath().getIsAvailable() && object.getPath().getIsChangable());
    glusterStorageModel.getLinkGlusterVolume().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            // Editor, needs the example
            boolean showEditor = !glusterStorageModel.getLinkGlusterVolume().getEntity();
            pathEditorRow.setVisible(showEditor);
            pathExampleLabel.setVisible(showEditor);
            // List box, shouldn't have an example since you can only select one.
            glusterVolumesRow.setVisible(!showEditor);
        }
    });
}
#end_block

#method_before
private void addAttachVmNamesCustomValue() {
    addCustomValue("VmNames", listVms.stream().map(vm -> vm.getName()).collect(Collectors.joining(", ")));
}
#method_after
private void addAttachVmNamesCustomValue() {
    addCustomValue("VmNames", listVms.stream().map(VM::getName).collect(Collectors.joining(", ")));
}
#end_block

#method_before
private GlusterGeoRepSession getSession() {
    return geoRepDao.getById(getParameters().getGeoRepSessionId());
}
#method_after
private GlusterGeoRepSession getSession() {
    if (geoRepSession == null) {
        geoRepSession = geoRepDao.getById(getParameters().getGeoRepSessionId());
    }
    return geoRepSession;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Get list of running VMs that have disks on storage domain
    List<VM> vms = runInternalQuery(VdcQueryType.GetVmsByStorageDomain, new IdQueryParameters(getStorageDomain().getId())).getReturnValue();
    // Snapshot the VMs
    // TBD - run as child command?
    Map<Guid, Guid> createdSnapshotVMMap = new HashMap<>();
    for (VM vm : vms) {
        CreateAllSnapshotsFromVmParameters param = new CreateAllSnapshotsFromVmParameters(vm.getId(), vm.getName() + "-TMPDR", false, vm.getDiskList());
        Guid createdSnapshotId = runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, param).getActionReturnValue();
        createdSnapshotVMMap.put(createdSnapshotId, vm.getId());
    }
    getParameters().setSnapshotIdVmIds(createdSnapshotVMMap);
    persistCommand(getParameters().getParentCommand(), true);
    if (getSession().getStatus() != GeoRepSessionStatus.ACTIVE) {
        // Start geo-replication
        Future<VdcReturnValueBase> geoRepCmd = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.StartGlusterVolumeGeoRep, new GlusterVolumeGeoRepSessionParameters(getSession().getMasterVolumeId(), getSession().getId()), cloneContext());
        VdcReturnValueBase result;
        try {
            result = geoRepCmd.get();
            if (!result.getSucceeded()) {
                propagateFailure(result);
                return;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Exception", e);
            return;
        }
    }
    // checkpoint the replication session
    GlusterVolumeGeoRepSessionConfigParameters configParams = new GlusterVolumeGeoRepSessionConfigParameters(getSession().getMasterVolumeId(), getSession().getId(), "checkpoint", "now");
    runInternalAction(VdcActionType.SetGeoRepConfig, configParams);
}
#method_after
@Override
protected void executeCommand() {
    // Get list of running VMs that have disks on storage domain
    List<VM> vms = runInternalQuery(VdcQueryType.GetVmsByStorageDomain, new IdQueryParameters(getStorageDomain().getId())).getReturnValue();
    // Snapshot the VMs
    Map<Guid, Guid> vmIdSnapshotIdMap = new HashMap<>();
    for (VM vm : vms) {
        try {
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CreateAllSnapshotsFromVm, getCreateSnapshotParameters(vm), cloneContextAndDetachFromParent());
            vmIdSnapshotIdMap.put(vm.getId(), future.get().getActionReturnValue());
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error creating VM snapshot for VM with id '{}', name '{}' for DR sync", vm.getId(), vm.getName(), e.getMessage());
            log.debug("Exception", e);
            endWithFailure();
            getParameters().setTaskGroupSuccess(false);
        }
    }
    getParameters().setVmIdSnapshotIds(vmIdSnapshotIdMap);
    getParameters().setNextStep(DRStep.GEO_REP);
    persistCommandIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new GlusterStorageSyncCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
@OnTimerMethodAnnotation("syncData")
public void syncData(String storageDomainId, String geoRepSessionId) {
    try {
        // Get storage domain and georep session
        StorageDomain storageDomain = storageDomainDao.get(new Guid(storageDomainId));
        if (storageDomain == null) {
            log.error("No storage domain found");
            return;
        }
        GlusterGeoRepSession session = geoRepDao.getById(new Guid(geoRepSessionId));
        if (session == null) {
            log.error("No geo-replication session found");
        }
        backend.runInternalAction(VdcActionType.GlusterStorageSync, new GlusterStorageSyncCommandParameters(storageDomain.getId(), session.getId()), ExecutionHandler.createInternalJobContext());
    } catch (Exception e) {
        log.error("Error running dr sync", e);
    }
}
#method_after
@OnTimerMethodAnnotation("syncData")
public void syncData(String storageDomainId, String geoRepSessionId) {
    try {
        // Get storage domain and georep session
        StorageDomain storageDomain = storageDomainDao.get(new Guid(storageDomainId));
        if (storageDomain == null) {
            log.error("No storage domain found for id '{}'", storageDomainId);
            return;
        }
        GlusterGeoRepSession session = geoRepDao.getById(new Guid(geoRepSessionId));
        if (session == null) {
            log.error("No geo-replication session found for id '{}'", geoRepSessionId);
            return;
        }
        backend.runInternalAction(VdcActionType.GlusterStorageSync, new GlusterStorageSyncCommandParameters(storageDomain.getId(), session.getId()), ExecutionHandler.createInternalJobContext());
    } catch (Exception e) {
        log.error("Error running dr sync", e);
    }
}
#end_block

#method_before
private boolean handlePositiveEnforcingAffinityGroup(Guid vdsId, List<VM> runningVms) {
    List<AffinityGroup> affinityGroups = affinityGroupDao.getPositiveEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
    if (!affinityGroups.isEmpty()) {
        List<Object> items = new ArrayList<>();
        affinityGroups.stream().filter(ag -> (!ag.getVdsIds().isEmpty()) || // check vm to vm affinity groups with 2 or more running vms
        (ag.getVdsIds().isEmpty() && ag.isVmAffinityEnabled() && runningVms.size() > 1 && ag.getVmIds().size() > 1 && runningVms.stream().filter(vm -> ag.getVmIds().contains(vm.getId())).collect(Collectors.toList()).size() > 1)).collect(Collectors.toList()).forEach(affinityGroup -> {
            items.add(String.format("%1$s (%2$s)", affinityGroup.getName(), StringUtils.join(affinityGroup.getVmEntityNames(), " ,")));
        });
        if (!items.isEmpty()) {
            addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_HAS_AFFINITY_VMS);
            getReturnValue().getValidationMessages().addAll(ReplacementUtils.replaceWith("AFFINITY_GROUPS_VMS", items));
            return false;
        }
    }
    return true;
}
#method_after
private boolean handlePositiveEnforcingAffinityGroup(Guid vdsId, List<VM> runningVms) {
    List<AffinityGroup> affinityGroups = affinityGroupDao.getPositiveEnforcingAffinityGroupsByRunningVmsOnVdsId(vdsId);
    if (!affinityGroups.isEmpty()) {
        List<Object> items = new ArrayList<>();
        affinityGroups.stream().filter(ag -> !ag.getVdsIds().isEmpty() || affinityGroupContainsRunningVMs(ag, runningVms)).forEach(affinityGroup -> {
            items.add(String.format("%1$s (%2$s)", affinityGroup.getName(), StringUtils.join(affinityGroup.getVmEntityNames(), " ,")));
        });
        if (!items.isEmpty()) {
            addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_HAS_AFFINITY_VMS);
            getReturnValue().getValidationMessages().addAll(ReplacementUtils.replaceWith("AFFINITY_GROUPS_VMS", items));
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    return isNoLeasesOnStorageDomain() && canDetachStorageDomainWithVmsAndDisks(getStorageDomain()) && canDetachDomain(getParameters().getDestroyingPool(), getParameters().getRemoveLast());
}
#method_after
@Override
protected boolean validate() {
    return canDetachStorageDomainWithVmsAndDisks(getStorageDomain()) && canDetachDomain(getParameters().getDestroyingPool(), getParameters().getRemoveLast()) && isNoLeasesOnStorageDomain();
}
#end_block

#method_before
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Optional<Guid> vdsToRunOn = getVdsToRunOn();
    setDestinationVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    vmHandler.updateVmGuestAgentVersion(getVm());
    if (!vdsToRunOn.isPresent()) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#method_after
protected boolean initVdss() {
    try {
        setVdsIdRef(getVm().getRunOnVds());
        Optional<Guid> vdsToRunOn = getVdsToRunOn();
        setDestinationVdsId(vdsToRunOn.orElse(null));
        if (vdsToRunOn.isPresent()) {
            getRunVdssList().add(vdsToRunOn.get());
        }
        vmHandler.updateVmGuestAgentVersion(getVm());
        if (!vdsToRunOn.isPresent()) {
            return false;
        }
        if (getDestinationVds() == null || getVds() == null) {
            return false;
        }
        return true;
    } catch (Exception e) {
        cleanupPassthroughVnics(getDestinationVdsId());
        throw e;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    resourceManager.getVmManager(getVmId()).getStatistics().setMigrationProgressPercent(0);
    setSucceeded(initVdss() && perform());
}
#method_after
@Override
protected void executeVmCommand() {
    getVmManager().getStatistics().setMigrationProgressPercent(0);
    setSucceeded(initVdss() && perform());
}
#end_block

#method_before
private boolean perform() {
    getParameters().setStartTime(new Date());
    try {
        if (unplugPassthroughNics() && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
    } catch (EngineException e) {
    }
    runningFailed();
    return false;
}
#method_after
private boolean perform() {
    try {
        getParameters().setStartTime(new Date());
        allVmPassthroughNics = getAllVmPassthroughNics();
        log.debug("Performing migration with following passthrough nics: {}", allVmPassthroughNics);
        if (unplugPassthroughNics(allVmPassthroughNics) && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
        // otherwise
        runningFailed();
        return false;
    } catch (Exception e) {
        runningFailed();
        throw e;
    }
}
#end_block

#method_before
private boolean unplugPassthroughNics() {
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getVmPassthroughNics(), PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    return true;
}
#method_after
private boolean unplugPassthroughNics(List<VmNetworkInterface> vmNics) {
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(vmNics, PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean plugPassthroughNics() {
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getVmPassthroughNics(), PlugAction.PLUG);
    boolean plugOfAllMacsSucceeded = true;
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    Map<Guid, String> vnicToVfMap = getVnicToVfMap(getDestinationVdsId());
    List<VmNic> notRepluggedNics = new ArrayList<>();
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        boolean nicPlugSucceeded = returnValue.getSucceeded();
        plugOfAllMacsSucceeded &= nicPlugSucceeded;
        if (!nicPlugSucceeded) {
            notRepluggedNics.add(parameter.getNic());
        }
    }
    if (!plugOfAllMacsSucceeded) {
        Set<String> vfsToUnregister = notRepluggedNics.stream().map(VmNic::getId).map(vnicToVfMap::get).collect(Collectors.toSet());
        networkDeviceHelper.setVmIdOnVfs(getDestinationVdsId(), null, vfsToUnregister);
        addCustomValue("NamesOfNotRepluggedNics", notRepluggedNics.stream().map(VmNic::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NOT_ALL_VM_NICS_WERE_PLUGGED_BACK);
    }
    return plugOfAllMacsSucceeded;
}
#method_after
private void plugPassthroughNics(List<VmNetworkInterface> vmNics) {
    try {
        List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(vmNics, PlugAction.PLUG);
        boolean plugOfAllMacsSucceeded = true;
        log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
        Map<Guid, String> vnicToVfMap = getVnicToVfMap(getDestinationVdsId());
        List<VmNic> notRepluggedNics = new ArrayList<>();
        for (ActivateDeactivateVmNicParameters parameter : parametersList) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
            boolean nicPlugSucceeded = returnValue.getSucceeded();
            plugOfAllMacsSucceeded &= nicPlugSucceeded;
            if (!nicPlugSucceeded) {
                notRepluggedNics.add(parameter.getNic());
            }
        }
        if (!plugOfAllMacsSucceeded) {
            Set<String> vfsToUnregister = notRepluggedNics.stream().map(VmNic::getId).map(vnicToVfMap::get).collect(Collectors.toSet());
            networkDeviceHelper.setVmIdOnVfs(getDestinationVdsId(), null, vfsToUnregister);
            addCustomValue("NamesOfNotRepluggedNics", notRepluggedNics.stream().map(VmNic::getName).collect(Collectors.joining(",")));
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NOT_ALL_VM_NICS_WERE_PLUGGED_BACK);
        }
    } catch (Exception e) {
        auditLogDirector.log(this, AuditLogType.VM_MIGRATION_PLUGGING_VM_NICS_FAILED);
        log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
        log.debug("Exception: ", e);
    }
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
        try {
            plugPassthroughNics();
        } catch (Exception e) {
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_PLUGGING_VM_NICS_FAILED);
            log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
            log.debug("Exception: ", e);
        }
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
        plugPassthroughNics(allVmPassthroughNics);
    } finally {
        super.runningSucceded();
    }
}
#end_block

#method_before
@Override
public void rerun() {
    // make Vm property to null in order to refresh it from db
    setVm(null);
    determineMigrationFailureForAuditLog();
    // if vm is up and rerun is called then it got up on the source, try to rerun
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        super.rerun();
    } else {
        // vm went down on the destination and source, migration failed.
        runningFailed();
        // signal the caller that a rerun was made so that it won't log
        // the failure message again
        _isRerun = true;
    }
}
#method_after
@Override
public void rerun() {
    // make Vm property to null in order to refresh it from db
    setVm(null);
    determineMigrationFailureForAuditLog();
    // if vm is up and rerun is called then it got up on the source, try to rerun
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        // this will clean all VF reservations made in {@link #initVdss}.
        cleanupPassthroughVnics(getDestinationVdsId());
        super.rerun();
    } else {
        // vm went down on the destination and source, migration failed.
        runningFailed();
        // signal the caller that a rerun was made so that it won't log
        // the failure message again
        _isRerun = true;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    resourceManager.getVmManager(getVmId()).getStatistics().setMigrationProgressPercent(0);
    try {
        setSucceeded(initVdss() && perform());
    } catch (Exception e) {
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        cleanupPassthroughVnics(getDestinationVdsId());
    }
}
#method_after
@Override
protected void executeVmCommand() {
    getVmManager().getStatistics().setMigrationProgressPercent(0);
    try {
        setSucceeded(initVdss() && perform());
    } catch (Exception e) {
        setSucceeded(false);
    }
    if (!getSucceeded()) {
        cleanupPassthroughVnics(getDestinationVdsId());
    }
}
#end_block

#method_before
private boolean perform() {
    getParameters().setStartTime(new Date());
    try {
        if (unplugPassthroughNics() && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
    } catch (EngineException e) {
        // this will clean all VF reservations made in {@link #initVdss}.
        cleanupPassthroughVnics(getDestinationVdsId());
    }
    runningFailed();
    return false;
}
#method_after
private boolean perform() {
    try {
        getParameters().setStartTime(new Date());
        allVmPassthroughNics = getAllVmPassthroughNics();
        log.debug("Performing migration with following passthrough nics: {}", allVmPassthroughNics);
        if (unplugPassthroughNics(allVmPassthroughNics) && connectLunDisks(getDestinationVdsId()) && migrateVm()) {
            ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            return true;
        }
        // otherwise
        runningFailed();
        return false;
    } catch (Exception e) {
        // this will clean all VF reservations made in {@link #initVdss}.
        cleanupPassthroughVnics(getDestinationVdsId());
        runningFailed();
        throw e;
    }
}
#end_block

#method_before
private boolean unplugPassthroughNics() {
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getVmPassthroughNics(), PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    return true;
}
#method_after
private boolean unplugPassthroughNics(List<VmNetworkInterface> vmNics) {
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(vmNics, PlugAction.UNPLUG);
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        if (!returnValue.getSucceeded()) {
            returnValue.getValidationMessages().forEach(this::addValidationMessage);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean plugPassthroughNics() {
    List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(getVmPassthroughNics(), PlugAction.PLUG);
    boolean plugOfAllMacsSucceeded = true;
    log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
    Map<Guid, String> vnicToVfMap = getVnicToVfMap(getDestinationVdsId());
    List<VmNic> notRepluggedNics = new ArrayList<>();
    for (ActivateDeactivateVmNicParameters parameter : parametersList) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
        boolean nicPlugSucceeded = returnValue.getSucceeded();
        plugOfAllMacsSucceeded &= nicPlugSucceeded;
        if (!nicPlugSucceeded) {
            notRepluggedNics.add(parameter.getNic());
        }
    }
    if (!plugOfAllMacsSucceeded) {
        Set<String> vfsToUnregister = notRepluggedNics.stream().map(VmNic::getId).map(vnicToVfMap::get).collect(Collectors.toSet());
        networkDeviceHelper.setVmIdOnVfs(getDestinationVdsId(), null, vfsToUnregister);
        addCustomValue("NamesOfNotRepluggedNics", notRepluggedNics.stream().map(VmNic::getName).collect(Collectors.joining(",")));
        auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NOT_ALL_VM_NICS_WERE_PLUGGED_BACK);
    }
    return plugOfAllMacsSucceeded;
}
#method_after
private void plugPassthroughNics(List<VmNetworkInterface> vmNics) {
    try {
        List<ActivateDeactivateVmNicParameters> parametersList = createActivateDeactivateVmNicParameters(vmNics, PlugAction.PLUG);
        boolean plugOfAllMacsSucceeded = true;
        log.debug("About to call {} with parameters: {}", VdcActionType.ActivateDeactivateVmNic, Arrays.toString(parametersList.toArray()));
        Map<Guid, String> vnicToVfMap = getVnicToVfMap(getDestinationVdsId());
        List<VmNic> notRepluggedNics = new ArrayList<>();
        for (ActivateDeactivateVmNicParameters parameter : parametersList) {
            VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameter);
            boolean nicPlugSucceeded = returnValue.getSucceeded();
            plugOfAllMacsSucceeded &= nicPlugSucceeded;
            if (!nicPlugSucceeded) {
                notRepluggedNics.add(parameter.getNic());
            }
        }
        if (!plugOfAllMacsSucceeded) {
            Set<String> vfsToUnregister = notRepluggedNics.stream().map(VmNic::getId).map(vnicToVfMap::get).collect(Collectors.toSet());
            networkDeviceHelper.setVmIdOnVfs(getDestinationVdsId(), null, vfsToUnregister);
            addCustomValue("NamesOfNotRepluggedNics", notRepluggedNics.stream().map(VmNic::getName).collect(Collectors.joining(",")));
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_NOT_ALL_VM_NICS_WERE_PLUGGED_BACK);
        }
    } catch (Exception e) {
        auditLogDirector.log(this, AuditLogType.VM_MIGRATION_PLUGGING_VM_NICS_FAILED);
        log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
        log.debug("Exception: ", e);
    }
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
        try {
            plugPassthroughNics();
        } catch (Exception e) {
            auditLogDirector.log(this, AuditLogType.VM_MIGRATION_PLUGGING_VM_NICS_FAILED);
            log.error("Failed to plug nics back after migration of vm {}: {}", getVmName(), e.getMessage());
            log.debug("Exception: ", e);
        }
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        getDowntime();
        vmDynamicDao.clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
        plugPassthroughNics(allVmPassthroughNics);
    } finally {
        super.runningSucceded();
    }
}
#end_block

#method_before
@Override
public void rerun() {
    // make Vm property to null in order to refresh it from db
    setVm(null);
    determineMigrationFailureForAuditLog();
    // if vm is up and rerun is called then it got up on the source, try to rerun
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        super.rerun();
    } else {
        // vm went down on the destination and source, migration failed.
        runningFailed();
        // signal the caller that a rerun was made so that it won't log
        // the failure message again
        _isRerun = true;
    }
}
#method_after
@Override
public void rerun() {
    // make Vm property to null in order to refresh it from db
    setVm(null);
    determineMigrationFailureForAuditLog();
    // if vm is up and rerun is called then it got up on the source, try to rerun
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        // this will clean all VF reservations made in {@link #initVdss}.
        cleanupPassthroughVnics(getDestinationVdsId());
        super.rerun();
    } else {
        // vm went down on the destination and source, migration failed.
        runningFailed();
        // signal the caller that a rerun was made so that it won't log
        // the failure message again
        _isRerun = true;
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!checkStorageDomain()) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal()) {
        if (getStorageDomain().isHostedEngineStorage()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && !validateMasterDeactivationAllowed()) {
            return false;
        }
    }
    if (!getParameters().getIsInternal() && !isNoRunningVmsWithLeasesExist()) {
        return false;
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !vmDao.getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (asyncTaskDao.getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || commandEntityDao.getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!checkStorageDomain()) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal()) {
        if (getStorageDomain().isHostedEngineStorage()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && !validateMasterDeactivationAllowed()) {
            return false;
        }
        if (!isNoRunningVmsWithLeasesExist()) {
            return false;
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !vmDao.getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (asyncTaskDao.getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || commandEntityDao.getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isNoRunningVmsWithLeasesExist() {
    List<VM> runningVmsWithLeases = vmDao.getAllActiveWithLeaseOnForStorageDomain(getStorageDomain().getId());
    if (!runningVmsWithLeases.isEmpty()) {
        String vmNames = runningVmsWithLeases.stream().map(v -> v.getName()).collect(Collectors.joining(", "));
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_RUNNING_VMS_WITH_LEASES, String.format("$vmNames %s", vmNames));
    }
    return true;
}
#method_after
private boolean isNoRunningVmsWithLeasesExist() {
    List<VmStatic> runningVmsWithLeases = vmStaticDao.getAllRunningWithLeaseOnStorageDomain(getStorageDomain().getId());
    if (!runningVmsWithLeases.isEmpty()) {
        String vmNames = runningVmsWithLeases.stream().map(VmStatic::getName).collect(Collectors.joining(", "));
        return failValidation(EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_RUNNING_VMS_WITH_LEASES, String.format("$vmNames %s", vmNames));
    }
    return true;
}
#end_block

#method_before
@Test
public void testDeactivateStorageDomainWithRunningVmWithLeaseFails() {
    VM vm = new VM();
    vm.setName("myRunningVmWithLease");
    mockDomain();
    when(vmDao.getAllActiveWithLeaseOnForStorageDomain(domain.getId())).thenReturn(Collections.singletonList(vm));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_RUNNING_VMS_WITH_LEASES);
    assertTrue(cmd.getReturnValue().getValidationMessages().contains(String.format("$vmNames %s", vm.getName())));
}
#method_after
@Test
public void testDeactivateStorageDomainWithRunningVmWithLeaseFails() {
    VmStatic vm = new VmStatic();
    vm.setName("myRunningVmWithLease");
    mockDomain();
    when(vmStaticDao.getAllRunningWithLeaseOnStorageDomain(domain.getId())).thenReturn(Collections.singletonList(vm));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_RUNNING_VMS_WITH_LEASES);
    assertTrue(cmd.getReturnValue().getValidationMessages().contains(String.format("$vmNames %s", vm.getName())));
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!checkStoragePool() || !initializeVds() || !checkStorageDomain()) {
        return false;
    }
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    if (!validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool())) {
        return false;
    }
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        return failValidation(EngineMessage.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Uninitialized) {
        return checkMasterDomainIsUp();
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!checkStoragePool() || !initializeVds() || !checkStorageDomain()) {
        return false;
    }
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    if (!validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool())) {
        return false;
    }
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        return failValidation(EngineMessage.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Uninitialized) {
        return checkMasterDomainIsUp();
    }
    return true;
}
#end_block

#method_before
public void analyzeSource(File sourceFile) throws IOException {
    // Create the QDox project:
    JavaProjectBuilder project = new JavaProjectBuilder();
    // we need to iterate the contents file by file, as QDox doesn't directly support loading .jar files:
    if (sourceFile.isDirectory()) {
        project.addSourceTree(sourceFile);
        Collection<File> documentFiles = FileUtils.listFiles(sourceFile, new String[] { "adoc" }, true);
        for (File documentFile : documentFiles) {
            try (InputStream documentIn = new FileInputStream(documentFile)) {
                analyzeDocument(documentFile.getName(), documentIn);
            }
        }
    } else if (sourceFile.isFile() && sourceFile.getName().endsWith(".jar")) {
        try (ZipFile zipFile = new ZipFile(sourceFile)) {
            Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
            while (zipEntries.hasMoreElements()) {
                ZipEntry zipEntry = zipEntries.nextElement();
                String zipEntryName = zipEntry.getName();
                if (zipEntryName.endsWith(".java")) {
                    try (InputStream sourceIn = zipFile.getInputStream(zipEntry)) {
                        try (Reader sourceReader = new InputStreamReader(sourceIn, Charset.forName("UTF-8"))) {
                            project.addSource(sourceReader);
                        }
                    }
                } else if (zipEntryName.endsWith(".adoc")) {
                    try (InputStream documentIn = zipFile.getInputStream(zipEntry)) {
                        analyzeDocument(zipEntryName, documentIn);
                    }
                }
            }
        }
    } else {
        throw new IOException("Don't know how to parse source file \"" + sourceFile.getAbsolutePath() + "\", should be a " + "directory or a .jar file.");
    }
    // Process the classes, discarding inner classes als they will be processed as part of the processing of the
    // class containing them:
    project.getClasses().stream().filter(x -> !x.isInner()).forEach(this::analyzeClass);
    // Fix the places where undefined types and services have been used, replacing them with the corresponding
    // completely defined ones:
    fixUndefinedTypeUsages();
    fixUndefinedServiceUsages();
    // Analyze constraints:
    parseConstraints();
}
#method_after
public void analyzeSource(File sourceFile) throws IOException {
    // Create the QDox project:
    JavaProjectBuilder project = new JavaProjectBuilder();
    // we need to iterate the contents file by file, as QDox doesn't directly support loading .jar files:
    if (sourceFile.isDirectory()) {
        project.addSourceTree(sourceFile);
        Collection<File> documentFiles = FileUtils.listFiles(sourceFile, new String[] { "adoc" }, true);
        for (File documentFile : documentFiles) {
            try (InputStream documentIn = new FileInputStream(documentFile)) {
                analyzeDocument(documentFile.getName(), documentIn);
            }
        }
    } else if (sourceFile.isFile() && sourceFile.getName().endsWith(".jar")) {
        try (ZipFile zipFile = new ZipFile(sourceFile)) {
            Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
            while (zipEntries.hasMoreElements()) {
                ZipEntry zipEntry = zipEntries.nextElement();
                String zipEntryName = zipEntry.getName();
                if (zipEntryName.endsWith(".java")) {
                    try (InputStream sourceIn = zipFile.getInputStream(zipEntry)) {
                        try (Reader sourceReader = new InputStreamReader(sourceIn, Charset.forName("UTF-8"))) {
                            project.addSource(sourceReader);
                        }
                    }
                } else if (zipEntryName.endsWith(".adoc")) {
                    try (InputStream documentIn = zipFile.getInputStream(zipEntry)) {
                        analyzeDocument(zipEntryName, documentIn);
                    }
                }
            }
        }
    } else {
        throw new IOException("Don't know how to parse source file \"" + sourceFile.getAbsolutePath() + "\", should be a " + "directory or a .jar file.");
    }
    // Separate classes into 'types' (Vm, Disk..) and 'services' (HostService, DisksService...)
    // Types are processed before services, because they are referenced during the processing of services.
    List<JavaClass> types = new ArrayList<>();
    List<JavaClass> services = new ArrayList<>();
    separateClasses(project, types, services);
    // Process the types.
    analyzeTypes(types);
    // Process the services
    analyzeServices(services);
    // Analyze constraints:
    parseConstraints();
}
#end_block

#method_before
private void analyzeService(JavaClass javaClass) {
    // Create the service:
    Service service = new Service();
    analyzeModule(javaClass, service);
    analyzeName(javaClass, service);
    analyzeAnnotations(javaClass, service);
    analyzeDocumentation(javaClass, service);
    // Analyze the base service:
    JavaClass javaSuperClass = null;
    if (javaClass.isInterface()) {
        List<JavaClass> javaSuperInterfaces = javaClass.getInterfaces();
        if (javaSuperInterfaces != null && javaSuperInterfaces.size() > 0) {
            javaSuperClass = javaSuperInterfaces.get(0);
        }
    } else {
        javaSuperClass = javaClass.getSuperJavaClass();
    }
    if (javaSuperClass != null) {
        String javaSuperClassName = removeSuffix(javaSuperClass.getName(), SERVICE_SUFFIX);
        Name baseTypeName = parseJavaName(javaSuperClassName);
        assignService(baseTypeName, service::setBase);
    }
    // Analyze the members:
    javaClass.getNestedClasses().forEach(x -> analyzeServiceMember(x, service));
    javaClass.getMethods().forEach(x -> analyzeServiceMember(x, service));
    // Add the type to the model:
    model.addService(service);
    // Check if this should be the root of the tree of services of the model:
    if (isAnnotatedWith(javaClass, ModelAnnotations.ROOT)) {
        Service root = model.getRoot();
        if (root != null) {
            System.err.println("The current root \"" + root.getName() + "\" will be replaced with \"" + service.getName() + "\".");
        }
        model.setRoot(service);
    }
}
#method_after
private void analyzeService(JavaClass javaClass) {
    // Create the service:
    Service service = new Service();
    analyzeModule(javaClass, service);
    analyzeName(javaClass, service);
    analyzeAnnotations(javaClass, service);
    analyzeDocumentation(javaClass, service);
    // Analyze the base service:
    JavaClass javaSuperClass = null;
    if (javaClass.isInterface()) {
        List<JavaClass> javaSuperInterfaces = javaClass.getInterfaces();
        if (javaSuperInterfaces != null && javaSuperInterfaces.size() > 0) {
            javaSuperClass = javaSuperInterfaces.get(0);
        }
    } else {
        javaSuperClass = javaClass.getSuperJavaClass();
    }
    if (javaSuperClass != null) {
        String javaSuperClassName = removeSuffix(javaSuperClass.getName(), SERVICE_SUFFIX);
        Name baseTypeName = parseJavaName(javaSuperClassName);
        assignService(baseTypeName, service::setBase);
    }
    // Analyze the members:
    javaClass.getNestedClasses().forEach(x -> analyzeNestedClass(x, service));
    javaClass.getMethods().forEach(x -> analyzeServiceMember(x, service));
    // Add the type to the model:
    model.addService(service);
    // Check if this should be the root of the tree of services of the model:
    if (isAnnotatedWith(javaClass, ModelAnnotations.ROOT)) {
        Service root = model.getRoot();
        if (root != null) {
            System.err.println("The current root \"" + root.getName() + "\" will be replaced with \"" + service.getName() + "\".");
        }
        model.setRoot(service);
    }
}
#end_block

#method_before
private void analyzeDocumentation(JavaAnnotatedElement javaElement, Concept concept) {
    String javaComment = javaElement.getComment();
    if (javaComment != null && !javaComment.isEmpty()) {
        concept.setDoc(javaComment);
    }
}
#method_after
private void analyzeDocumentation(JavaAnnotatedElement javaElement, Concept concept) {
    // Copy the text of the documentation (without the doclet tags):
    String javaComment = javaElement.getComment();
    if (javaComment != null) {
        javaComment = javaComment.trim();
        if (!javaComment.isEmpty()) {
            concept.setDoc(javaComment);
        }
    }
    // Make annotations for the javadoc tags:
    javaElement.getTags().stream().forEach(docTag -> {
        this.analyzeDocletTag(docTag, concept);
    });
}
#end_block

#method_before
private void analyzeDocument(String file, InputStream in) throws IOException {
    // Create the document:
    Document document = new Document();
    // Compute the name of the document from the name of the file, without the extension:
    Name name = NameParser.parseUsingCase(FilenameUtils.getBaseName(file));
    document.setName(name);
    // Read the source of the document:
    String source = IOUtils.toString(in, StandardCharsets.UTF_8);
    document.setSource(source);
    // Add the document to the model:
    model.addDocument(document);
}
#method_after
private void analyzeDocument(String file, InputStream in) throws IOException {
    // Create the document:
    Document document = new Document();
    // Remove the extension from the file name:
    file = FilenameUtils.getBaseName(file);
    // The name of the document can contain a prefix to explicitly indicate the order of the document relative to
    // the other documents of the model. This prefix should be separated from the rest of the name using a dash, and
    // that dash should be ignored.
    String prefix = null;
    int index = file.indexOf('-');
    if (index > 0) {
        prefix = file.substring(0, index);
        file = file.substring(index + 1);
    }
    Name name = NameParser.parseUsingCase(file);
    if (prefix != null && !prefix.isEmpty()) {
        List<String> words = name.getWords();
        words.add(0, prefix);
        name.setWords(words);
        if (Character.isAlphabetic(prefix.charAt(0))) {
            document.setAppendix(true);
        }
    }
    document.setName(name);
    // Read the source of the document:
    String source = IOUtils.toString(in, StandardCharsets.UTF_8);
    document.setSource(source);
    // Add the document to the model:
    model.addDocument(document);
}
#end_block

#method_before
@Test
public void testDeactivateHostedDomainStorageFails() {
    mockDomain();
    doReturn(domain.getId()).when(hostedEngineHelper).getStorageDomainId();
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
}
#method_after
@Test
public void testDeactivateHostedDomainStorageFails() {
    mockDomain();
    domain.setHostedEngineStorage(true);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_HOSTED_ENGINE_STORAGE);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(getSnapshot());
    boolean succeeded = true;
    List<CinderDisk> cinderDisksToRestore = new ArrayList<>();
    for (DiskImage image : imagesToRestore) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisksToRestore.add((CinderDisk) image);
                continue;
            }
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), getSnapshot(), removedSnapshot.getId());
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    List<CinderDisk> cinderVolumesToRemove = new ArrayList<>();
    List<CinderDisk> cinderDisksToRemove = new ArrayList<>();
    removeUnusedImages(cinderVolumesToRemove);
    removeSnapshotsFromDB();
    setNewerVmConfigurationsAsBroken();
    if (!getTaskIdList().isEmpty() || !cinderDisksToRestore.isEmpty() || !cinderVolumesToRemove.isEmpty()) {
        deleteOrphanedImages(cinderDisksToRemove);
        if (!restoreCinderDisks(removedSnapshot.getId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove)) {
            log.error("Error to restore Cinder volumes snapshots");
        }
    } else {
        vmStaticDao.incrementDbGeneration(getVm().getId());
        snapshotDao.updateStatus(getSnapshot().getId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(getSnapshot());
    boolean succeeded = true;
    List<CinderDisk> cinderDisksToRestore = new ArrayList<>();
    for (DiskImage image : imagesToRestore) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                cinderDisksToRestore.add((CinderDisk) image);
                continue;
            }
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), getSnapshot(), removedSnapshot.getId());
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    List<CinderDisk> cinderVolumesToRemove = new ArrayList<>();
    List<CinderDisk> cinderDisksToRemove = new ArrayList<>();
    removeUnusedImages(cinderVolumesToRemove);
    if (getSnapshot().getType() == SnapshotType.REGULAR) {
        snapshotsToRemove.addAll(findSnapshotsWithOnlyIllegalDisks());
        setNewerVmConfigurationsAsBroken();
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty() || !cinderDisksToRestore.isEmpty() || !cinderVolumesToRemove.isEmpty()) {
        deleteOrphanedImages(cinderDisksToRemove);
        if (!restoreCinderDisks(removedSnapshot.getId(), cinderDisksToRestore, cinderDisksToRemove, cinderVolumesToRemove)) {
            log.error("Error to restore Cinder volumes snapshots");
        }
    } else {
        vmStaticDao.incrementDbGeneration(getVm().getId());
        snapshotDao.updateStatus(getSnapshot().getId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
protected void removeSnapshotsFromDB() {
    snapshotsToRemove.addAll(findSnapshotsWithOnlyIllegalDisks());
    for (Guid snapshotId : snapshotsToRemove) {
        Snapshot snap = snapshotDao.get(snapshotId);
        // Cinder volumes might not have correlated snapshot.
        if (snap != null) {
            String memoryVolume = snapshotDao.get(snapshotId).getMemoryVolume();
            if (!memoryVolume.isEmpty() && snapshotDao.getNumOfSnapshotsByMemory(memoryVolume) == 1) {
                boolean succeed = removeMemoryDisks(memoryVolume);
                if (!succeed) {
                    log.error("Failed to remove memory '{}' of snapshot '{}'", memoryVolume, snapshotId);
                }
            }
            snapshotDao.remove(snapshotId);
        }
    }
}
#method_after
protected void removeSnapshotsFromDB() {
    for (Guid snapshotId : snapshotsToRemove) {
        Snapshot snap = snapshotDao.get(snapshotId);
        // Cinder volumes might not have correlated snapshot.
        if (snap != null) {
            String memoryVolume = snapshotDao.get(snapshotId).getMemoryVolume();
            if (!memoryVolume.isEmpty() && snapshotDao.getNumOfSnapshotsByMemory(memoryVolume) == 1) {
                boolean succeed = removeMemoryDisks(memoryVolume);
                if (!succeed) {
                    log.error("Failed to remove memory '{}' of snapshot '{}'", memoryVolume, snapshotId);
                }
            }
            snapshotDao.remove(snapshotId);
        }
    }
}
#end_block

#method_before
protected void prepareToDeletePreviewBranch(List<DiskImage> imagesFromActiveSnapshot) {
    removedSnapshot = snapshotDao.get(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = snapshotDao.getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshot.getId());
    List<DiskImage> images = diskImageDao.getAllSnapshotsForVmSnapshot(removedSnapshot.getId());
    for (DiskImage image : images) {
        if (image.getDiskStorageType() == DiskStorageType.IMAGE) {
            DiskImage parentImage = diskImageDao.getSnapshotById(image.getParentId());
            Guid snapshotToRemove = (parentImage == null) ? null : parentImage.getVmSnapshotId();
            Snapshot candidateSnapToRemove = snapshotDao.get(snapshotToRemove);
            while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId) && isSnapshotEligibleToBeDeleted(candidateSnapToRemove)) {
                snapshotsToRemove.add(snapshotToRemove);
                parentImage = diskImageDao.getSnapshotById(parentImage.getParentId());
                snapshotToRemove = (parentImage == null) ? null : parentImage.getVmSnapshotId();
            }
        }
    }
    addRedundantCinderSnapshots(previewedSnapshotId, imagesFromActiveSnapshot);
}
#method_after
protected void prepareToDeletePreviewBranch(List<DiskImage> imagesFromActiveSnapshot) {
    removedSnapshot = snapshotDao.get(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = snapshotDao.getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshot.getId());
    addRedundantCinderSnapshots(previewedSnapshotId, imagesFromActiveSnapshot);
}
#end_block

#method_before
private Set<Guid> findSnapshotsWithOnlyIllegalDisks() {
    List<Snapshot> newerSnapshots = getNewerSnapshots(snapshot);
    Set<Guid> snapshotsToRemove = new HashSet<>();
    newerSnapshots.forEach(snapshot -> {
        VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
        if (vm != null) {
            boolean shouldRemove = !vm.getImages().isEmpty() && vm.getImages().stream().allMatch(diskImage -> diskImage.getImageStatus() == ImageStatus.ILLEGAL);
            if (shouldRemove) {
                snapshotsToRemove.add(snapshot.getId());
            }
        }
    });
    return snapshotsToRemove;
}
#method_after
private Set<Guid> findSnapshotsWithOnlyIllegalDisks() {
    List<Snapshot> newerSnapshots = getNewerSnapshots(snapshot);
    Set<Guid> snapshotsToRemove = new HashSet<>();
    newerSnapshots.forEach(snapshot -> {
        VM vm = snapshotVmConfigurationHelper.getVmFromConfiguration(snapshot.getVmConfiguration(), snapshot.getVmId(), snapshot.getId());
        if (vm != null) {
            boolean shouldRemove = vm.getImages().isEmpty() || vm.getImages().stream().allMatch(diskImage -> diskImage.getImageStatus() == ImageStatus.ILLEGAL);
            if (shouldRemove) {
                snapshotsToRemove.add(snapshot.getId());
            }
        }
    });
    return snapshotsToRemove;
}
#end_block

#method_before
public void updateModel(String format, int actualSize, int virtualSize, String qcowCompat, boolean backingFile) {
    setFormat(VolumeFormat.valueOf(format));
    setActualSize(actualSize);
    setVirtualSize(virtualSize);
    setQcowCompat(QemuCompat.forValue(qcowCompat));
    setBackingFile(backingFile);
    getEntityChangedEvent().raise(this, EventArgs.EMPTY);
}
#method_after
public void updateModel(String format, int actualSize, int virtualSize, String qcowCompat, boolean backingFile, boolean fileLoaded) {
    setFormat(VolumeFormat.valueOf(format));
    setActualSize(actualSize);
    setVirtualSize(virtualSize);
    setQcowCompat(QemuCompat.forValue(qcowCompat));
    setBackingFile(backingFile);
    setFileLoaded(fileLoaded);
    getEntityChangedEvent().raise(this, EventArgs.EMPTY);
}
#end_block

#method_before
public boolean validate() {
    if (backingFile == null) {
        getInvalidityReasons().add(constants.uploadImageFileNotExist());
        return false;
    }
    if (backingFile) {
        getInvalidityReasons().add(constants.uploadImageBackingFileUnsupported());
        return false;
    }
    return true;
}
#method_after
public boolean validate() {
    if (!fileLoaded) {
        getInvalidityReasons().add(constants.uploadImageCannotBeOpened());
        return false;
    }
    if (backingFile) {
        getInvalidityReasons().add(constants.uploadImageBackingFileUnsupported());
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean validateDiscardAfterDeleteLegal(StorageDomainValidator storageDomainValidator) {
    if (getStoragePoolId() != null && validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    return validate(storageDomainValidator.isDiscardAfterDeleteLegalForExistingStorageDomain());
}
#method_after
private boolean validateDiscardAfterDeleteLegal(StorageDomainValidator storageDomainValidator) {
    if (getStoragePoolId() != null && !validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    return validate(storageDomainValidator.isDiscardAfterDeleteLegalForExistingStorageDomain());
}
#end_block

#method_before
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    Map<Guid, Integer> hostViolations = getHostsViolations(true, hosts, vm, messages);
    return hosts.stream().filter(host -> !hostViolations.containsKey(host.getId())).collect(Collectors.toList());
}
#method_after
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    Map<Guid, Integer> hostViolations = getHostViolationCount(true, hosts, vm, messages);
    return hosts.stream().filter(host -> !hostViolations.containsKey(host.getId())).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostViolations = getHostsViolations(false, hosts, vm, new PerHostMessages());
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    int score;
    for (VDS host : hosts) {
        score = hostViolations.containsKey(host.getId()) ? hostViolations.get(host.getId()) : DEFAULT_SCORE;
        retList.add(new Pair<>(host.getId(), score));
    }
    return retList;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostViolations = getHostViolationCount(false, hosts, vm, new PerHostMessages());
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    int score;
    for (VDS host : hosts) {
        score = hostViolations.containsKey(host.getId()) ? hostViolations.get(host.getId()) : DEFAULT_SCORE;
        retList.add(new Pair<>(host.getId(), score));
    }
    return retList;
}
#end_block

#method_before
private void getDefaultConfigurationVersion(final LoginModel loginModel) {
    AsyncQuery callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = returnValue.getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(final LoginModel loginModel) {
    AsyncQuery callback = new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public void initCache(final LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery<>(new AsyncCallback<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public void onSuccess(Map<KeyValuePairCompat<ConfigurationValues, String>, Object> returnValue) {
            getDefaultConfigurationVersion(loginModel);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#method_after
public void initCache(final LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery<>(new AsyncCallback<Map<KeyValuePairCompat<ConfigurationValues, String>, Object>>() {

        @Override
        public void onSuccess(Map<KeyValuePairCompat<ConfigurationValues, String>, Object> returnValue) {
            getDefaultConfigurationVersion(loginModel);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initGet64BitOss();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initMemoryHotUnplugSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
    initMigrationPolicies();
    initCpuMap();
}
#end_block

#method_before
private void initMigrationPolicies() {
    AsyncQuery<List<MigrationPolicy>> aQuery = new AsyncQuery<>(new AsyncCallback<List<MigrationPolicy>>() {

        @Override
        public void onSuccess(List<MigrationPolicy> returnValue) {
            migrationPolicies = returnValue;
        }
    });
    aQuery.converterCallback = new Converter<List<MigrationPolicy>>() {

        @Override
        public List<MigrationPolicy> convert(Object returnValue) {
            if (returnValue == null) {
                return new ArrayList<>();
            }
            List<MigrationPolicy> policies = (List<MigrationPolicy>) returnValue;
            Collections.sort(policies, new Comparator<MigrationPolicy>() {

                @Override
                public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                    // the empty one is always the first
                    if (NoMigrationPolicy.ID.equals(m1.getId())) {
                        return -1;
                    }
                    return m1.getName().compareTo(m2.getName());
                }
            });
            return policies;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void initMigrationPolicies() {
    AsyncQuery<Map<Version, List<MigrationPolicy>>> aQuery = new AsyncQuery<>(new AsyncCallback<Map<Version, List<MigrationPolicy>>>() {

        @Override
        public void onSuccess(Map<Version, List<MigrationPolicy>> returnValue) {
            migrationPoliciesByVersion = returnValue;
        }
    });
    aQuery.converterCallback = new Converter<Map<Version, List<MigrationPolicy>>>() {

        @Override
        public Map<Version, List<MigrationPolicy>> convert(Object returnValue) {
            if (returnValue == null) {
                return new HashMap<>();
            }
            Map<Version, List<MigrationPolicy>> policiesByVersion = (Map<Version, List<MigrationPolicy>>) returnValue;
            for (List<MigrationPolicy> policies : policiesByVersion.values()) {
                Collections.sort(policies, new Comparator<MigrationPolicy>() {

                    @Override
                    public int compare(MigrationPolicy m1, MigrationPolicy m2) {
                        // the empty one is always the first
                        if (NoMigrationPolicy.ID.equals(m1.getId())) {
                            return -1;
                        }
                        return m1.getName().compareTo(m2.getName());
                    }
                });
            }
            return policiesByVersion;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllMigrationPolicies, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public List<MigrationPolicy> getMigrationPolicies() {
    return migrationPolicies;
}
#method_after
public List<MigrationPolicy> getMigrationPolicies(Version compatibilityVersion) {
    List<MigrationPolicy> migrationPolicies = migrationPoliciesByVersion.get(compatibilityVersion);
    return migrationPolicies != null ? migrationPolicies : Collections.singletonList((MigrationPolicy) new NoMigrationPolicy());
}
#end_block

#method_before
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
}
#method_after
private void saveDefaultedStorageProperties(StorageModel model, StorageDomainStatic storageDomainStatic) {
    storageDomainStatic.setWipeAfterDelete(model.getWipeAfterDelete().getEntity());
    storageDomainStatic.setDiscardAfterDelete(model.getDiscardAfterDelete().getEntity());
    storageDomainStatic.setWarningLowSpaceIndicator(model.getWarningLowSpaceIndicator().getEntity());
    storageDomainStatic.setCriticalSpaceActionBlocker(model.getCriticalSpaceActionBlocker().getEntity());
}
#end_block

#method_before
protected boolean isValidConnection(StorageServerConnections conn) {
    StorageType storageType = conn.getStorageType();
    if (storageType == StorageType.NFS && !new NfsMountPointConstraint().isValid(conn.getConnection(), null)) {
        return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (storageType == StorageType.POSIXFS && StringUtils.isEmpty(conn.getVfsType())) {
        return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if ((storageType == StorageType.POSIXFS || storageType == StorageType.NFS) && !validate(validateMountOptions())) {
        return false;
    }
    if (storageType == StorageType.ISCSI) {
        if (StringUtils.isEmpty(conn.getIqn())) {
            return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
        }
        if (!isValidStorageConnectionPort(conn.getPort())) {
            return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
        }
    }
    if (storageType == StorageType.GLUSTERFS) {
        StorageConnectionValidator validator = new StorageConnectionValidator(conn);
        if (!validate(updatePathFromGlusterVolume(conn)) && !validate(validator.canVDSConnectToGlusterfs(getVds()))) {
            return false;
        }
    }
    if (checkIsConnectionFieldEmpty(conn)) {
        return false;
    }
    return true;
}
#method_after
protected boolean isValidConnection(StorageServerConnections conn) {
    StorageType storageType = conn.getStorageType();
    if (storageType == StorageType.NFS && !new NfsMountPointConstraint().isValid(conn.getConnection(), null)) {
        return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_INVALID);
    }
    if (storageType == StorageType.POSIXFS && StringUtils.isEmpty(conn.getVfsType())) {
        return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_EMPTY_VFSTYPE);
    }
    if ((storageType == StorageType.POSIXFS || storageType == StorageType.NFS) && !validate(validateMountOptions())) {
        return false;
    }
    if (storageType == StorageType.ISCSI) {
        if (StringUtils.isEmpty(conn.getIqn())) {
            return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_EMPTY_IQN);
        }
        if (!isValidStorageConnectionPort(conn.getPort())) {
            return failValidation(EngineMessage.VALIDATION_STORAGE_CONNECTION_INVALID_PORT);
        }
    }
    if (storageType == StorageType.GLUSTERFS) {
        StorageConnectionValidator validator = new StorageConnectionValidator(conn);
        if (!validate(validateVolumeIdAndUpdatePath(conn)) || !validate(validator.canVDSConnectToGlusterfs(getVds()))) {
            return false;
        }
    }
    if (checkIsConnectionFieldEmpty(conn)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getStorageType() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = XmlRpcStringUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new HashSet<>();
    for (String option : optionsMap.keySet()) {
        optionsKeys.add(option.toLowerCase());
    }
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addValidationMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(EngineMessage.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getStorageType() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = StringMapUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new HashSet<>();
    for (String option : optionsMap.keySet()) {
        optionsKeys.add(option.toLowerCase());
    }
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addValidationMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(EngineMessage.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(name, clusterId, volumeType, status, replicaCount, stripeCount, disperseCount, redundancyCount, options, accessProtocols, transportTypes, bricks, asyncTask, advancedDetails, snapshotsCount, snapMaxLimit, snapshotScheduled);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(name, clusterId, volumeType, status, replicaCount, stripeCount, disperseCount, redundancyCount, isArbiter, options, accessProtocols, transportTypes, bricks, asyncTask, advancedDetails, snapshotsCount, snapMaxLimit, snapshotScheduled);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity other = (GlusterVolumeEntity) obj;
    return Objects.equals(name, other.getName()) && Objects.equals(clusterId, other.clusterId) && volumeType == other.volumeType && status == other.status && Objects.equals(replicaCount, other.replicaCount) && Objects.equals(stripeCount, other.stripeCount) && Objects.equals(disperseCount, other.disperseCount) && Objects.equals(redundancyCount, other.redundancyCount) && ObjectUtils.haveSameElements(getOptions(), other.getOptions()) && ObjectUtils.haveSameElements(accessProtocols, other.accessProtocols) && ObjectUtils.haveSameElements(transportTypes, other.transportTypes) && ObjectUtils.haveSameElements(bricks, other.bricks) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(advancedDetails, other.advancedDetails) && Objects.equals(snapshotsCount, other.snapshotsCount) && Objects.equals(snapMaxLimit, other.snapMaxLimit) && Objects.equals(snapshotScheduled, other.snapshotScheduled);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity other = (GlusterVolumeEntity) obj;
    return Objects.equals(name, other.getName()) && Objects.equals(clusterId, other.clusterId) && volumeType == other.volumeType && status == other.status && Objects.equals(replicaCount, other.replicaCount) && Objects.equals(stripeCount, other.stripeCount) && Objects.equals(disperseCount, other.disperseCount) && Objects.equals(redundancyCount, other.redundancyCount) && Objects.equals(isArbiter, other.isArbiter) && ObjectUtils.haveSameElements(getOptions(), other.getOptions()) && ObjectUtils.haveSameElements(accessProtocols, other.accessProtocols) && ObjectUtils.haveSameElements(transportTypes, other.transportTypes) && ObjectUtils.haveSameElements(bricks, other.bricks) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(advancedDetails, other.advancedDetails) && Objects.equals(snapshotsCount, other.snapshotsCount) && Objects.equals(snapMaxLimit, other.snapMaxLimit) && Objects.equals(snapshotScheduled, other.snapshotScheduled);
}
#end_block

#method_before
@Override
public List<GlusterVolumeEntity> getVolumesSupportedAsStorageDomain() {
    List<GlusterVolumeEntity> volumes = getCallsHandler().executeReadList("GetGlusterVolumesSupportedAsStorageDomain", volumeRowMapper, getCustomMapSqlParameterSource().addValue("replica_count", 3));
    fetchRelatedEntities(volumes);
    return volumes;
}
#method_after
@Override
public List<GlusterVolumeEntity> getVolumesSupportedAsStorageDomain() {
    List<GlusterVolumeEntity> volumes = getCallsHandler().executeReadList("GetGlusterVolumesSupportedAsStorageDomain", volumeRowMapper, null);
    fetchRelatedEntities(volumes);
    return volumes;
}
#end_block

#method_before
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()));
}
#method_after
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()).addValue("is_arbiter", volume.getIsArbiter()));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(GlusterVolumeEntity volume) {
    return getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(GlusterVolumeEntity volume) {
    return getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()).addValue("is_arbiter", volume.getIsArbiter());
}
#end_block

#method_before
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
                logChangeStatusToConnecting(timeoutToFence);
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                setStatus(VDSStatus.NonResponsive, cachedVds);
                List<VmDynamic> vmsRunningOnVds = vmDynamicDao.getAllRunningForVds(getVdsId());
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    moveVmsToUnknown(vmsRunningOnVds);
                    // we want to try to restart VMs with lease right after they switch to unknown
                    autoRestartUnknownVmsIteration = -1;
                    long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
                    logHostFailToRespond(ex, timeoutToFence);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                }
                restartVmsWithLeaseIfNeeded(vmsRunningOnVds);
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#method_after
public void handleNetworkException(VDSNetworkException ex) {
    boolean saveToDb = true;
    if (cachedVds.getStatus() != VDSStatus.Down) {
        if (isHostInGracePeriod(false)) {
            if (cachedVds.getStatus() != VDSStatus.Connecting && cachedVds.getStatus() != VDSStatus.PreparingForMaintenance && cachedVds.getStatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, cachedVds);
                logChangeStatusToConnecting();
            } else {
                saveToDb = false;
            }
            unrespondedAttempts.incrementAndGet();
        } else {
            if (cachedVds.getStatus() == VDSStatus.Maintenance) {
                saveToDb = false;
            } else {
                List<VmDynamic> vmsRunningOnVds = vmDynamicDao.getAllRunningForVds(getVdsId());
                if (cachedVds.getStatus() != VDSStatus.NonResponsive) {
                    setStatus(VDSStatus.NonResponsive, cachedVds);
                    moveVmsToUnknown(vmsRunningOnVds);
                    // we want to try to restart VMs with lease right after they switch to unknown
                    autoRestartUnknownVmsIteration = -1;
                    logHostFailToRespond(ex);
                    resourceManager.getEventListener().vdsNotResponding(cachedVds);
                } else {
                    saveToDb = false;
                }
                restartVmsWithLeaseIfNeeded(vmsRunningOnVds);
            }
        }
    }
    if (saveToDb) {
        updateDynamicData(cachedVds.getDynamicData());
        updateStatisticsData(cachedVds.getStatisticsData());
    }
}
#end_block

#method_before
private void restartVmsWithLeaseIfNeeded(List<VmDynamic> vms) {
    if (vms.isEmpty()) {
        return;
    }
    int skippedIterations = Config.<Integer>getValue(ConfigValues.NumberVdsRefreshesBeforeRetryToStartUnkownVms);
    autoRestartUnknownVmsIteration = (autoRestartUnknownVmsIteration + 1) % (skippedIterations + 1);
    if (autoRestartUnknownVmsIteration != 0) {
        // we don't want to restart VMs with lease too frequently
        return;
    }
    resourceManager.getEventListener().restartVmsWithLease(vms.stream().map(VmDynamic::getId).filter(vmId -> resourceManager.getVmManager(vmId).getLeaseStorageDomainId() != null).collect(Collectors.toList()));
}
#method_after
private void restartVmsWithLeaseIfNeeded(List<VmDynamic> vms) {
    if (vms.isEmpty() || !autoStartVmsWithLeasesLock.tryLock()) {
        return;
    }
    try {
        int skippedIterations = Config.<Integer>getValue(ConfigValues.NumberVdsRefreshesBeforeRetryToStartUnknownVms);
        autoRestartUnknownVmsIteration++;
        // we don't want to restart VMs with lease too frequently
        if (autoRestartUnknownVmsIteration % (skippedIterations + 1) == 0) {
            resourceManager.getEventListener().restartVmsWithLease(vms.stream().map(VmDynamic::getId).filter(vmId -> resourceManager.getVmManager(vmId).getLeaseStorageDomainId() != null).collect(Collectors.toList()));
        }
    } finally {
        autoStartVmsWithLeasesLock.unlock();
    }
}
#end_block

#method_before
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = Injector.injectMembers(new AuditLogableBase(cachedVds.getId()));
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#method_after
private void logHostFailToRespond(VDSNetworkException ex) {
    long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = Injector.injectMembers(new AuditLogableBase(cachedVds.getId()));
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#end_block

#method_before
private void logChangeStatusToConnecting(long timeoutToFence) {
    String msg;
    AuditLogType auditLogType;
    if (cachedVds.isPmEnabled()) {
        msg = "Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING;
        log.warn(msg, cachedVds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
    } else {
        msg = "Host '{}' is not responding.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING;
        log.warn(msg, cachedVds.getName());
    }
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    logable.setVdsId(cachedVds.getId());
    logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
    auditLogDirector.log(logable, auditLogType);
}
#method_after
private void logChangeStatusToConnecting() {
    long timeoutToFence = calcTimeoutToFence(cachedVds.getVmCount(), cachedVds.getSpmStatus());
    String msg;
    AuditLogType auditLogType;
    if (cachedVds.isPmEnabled()) {
        msg = "Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING;
        log.warn(msg, cachedVds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
    } else {
        msg = "Host '{}' is not responding.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING;
        log.warn(msg, cachedVds.getName());
    }
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    logable.setVdsId(cachedVds.getId());
    logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
    auditLogDirector.log(logable, auditLogType);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStorageDomain().getStorageType().isCinderDomain()) {
        detachCinderStorageDomain();
        return;
    }
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Detaching);
    log.info(" Detach storage domain: before connect");
    connectHostsInUpToDomainStorageServer();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getMasterDomainVersion()));
    log.info(" Detach storage domain: after disconnect storage");
    TransactionSupport.executeInNewTransaction(() -> {
        resetStorageDomainMacPool();
        detachStorageDomainWithEntities(getStorageDomain());
        StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
        getCompensationContext().snapshotEntity(mapToRemove);
        storagePoolIsoMapDao.remove(new StoragePoolIsoMapId(mapToRemove.getStorageId(), mapToRemove.getStoragePoolId()));
        // when detaching SD for data center, we should remove any attachment to qos, which is part of the old
        // data center
        diskProfileDao.nullifyQosForStorageDomain(getStorageDomain().getId());
        getCompensationContext().stateChanged();
        return null;
    });
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#method_after
@Override
protected void executeCommand() {
    if (getStorageDomain().getStorageType().isCinderDomain()) {
        detachCinderStorageDomain();
        return;
    }
    log.info("Start detach storage domain");
    changeStorageDomainStatusInTransaction(getStorageDomain().getStoragePoolIsoMapData(), StorageDomainStatus.Detaching);
    log.info(" Detach storage domain: before connect");
    connectHostsInUpToDomainStorageServer();
    log.info(" Detach storage domain: after connect");
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, new DetachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), Guid.Empty, getStoragePool().getMasterDomainVersion()));
    log.info(" Detach storage domain: after disconnect storage");
    TransactionSupport.executeInNewTransaction(() -> {
        releaseStorageDomainMacPool(getVmsOnlyOnStorageDomain());
        detachStorageDomainWithEntities(getStorageDomain());
        StoragePoolIsoMap mapToRemove = getStorageDomain().getStoragePoolIsoMapData();
        getCompensationContext().snapshotEntity(mapToRemove);
        storagePoolIsoMapDao.remove(new StoragePoolIsoMapId(mapToRemove.getStorageId(), mapToRemove.getStoragePoolId()));
        // when detaching SD for data center, we should remove any attachment to qos, which is part of the old
        // data center
        diskProfileDao.nullifyQosForStorageDomain(getStorageDomain().getId());
        getCompensationContext().stateChanged();
        return null;
    });
    log.info(" Detach storage domain: after detach in vds");
    disconnectAllHostsInPool();
    if (returnValue.getSucceeded() && getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        // reset iso for this pool in vdsBroker cache
        runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getParameters().getStoragePoolId()));
    }
    log.info("End detach storage domain");
    setSucceeded(returnValue.getSucceeded());
}
#end_block

#method_before
private void handleMasterDomain(StorageDomain masterDomain) {
    TransactionSupport.executeInNewTransaction(() -> {
        resetStorageDomainMacPool();
        detachStorageDomainWithEntities(masterDomain);
        getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
        masterDomain.setStorageDomainType(StorageDomainType.Data);
        storageDomainStaticDao.update(masterDomain.getStorageStaticData());
        getCompensationContext().stateChanged();
        return null;
    });
}
#method_after
private void handleMasterDomain(StorageDomain masterDomain) {
    TransactionSupport.executeInNewTransaction(() -> {
        releaseStorageDomainMacPool(vmDao.getAllForStoragePool(getStoragePoolId()));
        detachStorageDomainWithEntities(masterDomain);
        getCompensationContext().snapshotEntity(masterDomain.getStorageStaticData());
        masterDomain.setStorageDomainType(StorageDomainType.Data);
        storageDomainStaticDao.update(masterDomain.getStorageStaticData());
        getCompensationContext().stateChanged();
        return null;
    });
}
#end_block

#method_before
public void setOldClusterVersionOfSnapshotWithMemory(VM vm) {
    if (!isVMWithMemoryCompatible(vm)) {
        // message regarding old cluster snapshot will be shown
        Version originalClusterVersion = vm.getClusterCompatibilityVersionOrigin();
        originalClusterVersion = (originalClusterVersion == null) ? Version.v3_6 : originalClusterVersion;
        this.oldClusterVersionOfSnapshotWithMemory = originalClusterVersion;
    } else {
        this.oldClusterVersionOfSnapshotWithMemory = null;
    }
}
#method_after
public void setOldClusterVersionOfSnapshotWithMemory(VM vm) {
    if (!isVMWithMemoryCompatible(vm)) {
        // message regarding old cluster snapshot will be shown
        Version originalClusterVersion = vm.getClusterCompatibilityVersionOrigin();
        originalClusterVersion = (originalClusterVersion == null) ? Version.v3_6 : originalClusterVersion;
        oldClusterVersionOfSnapshotWithMemory = originalClusterVersion;
    } else {
        oldClusterVersionOfSnapshotWithMemory = null;
    }
}
#end_block

#method_before
private ValidationResult hostStatusLegalForSetupNetworks() {
    boolean hostStatusLegalForSetupNetworks = LEGAL_STATUSES.contains(host.getStatus()) || host.getStatus() == VDSStatus.Installing && internalExecution;
    if (!hostStatusLegalForSetupNetworks) {
        logger.error("Unable to setup network: operation can only be done when Host status is one of: {};" + " current status is {}", LEGAL_STATUSES_STR, host.getStatus());
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, ReplacementUtils.replaceWith(VAR_HOST_STATUS, LEGAL_STATUSES, ",", LEGAL_STATUSES.size()));
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult hostStatusLegalForSetupNetworks() {
    VDSStatus hostStatus = host.getStatus();
    boolean hostStatusLegalForSetupNetworks = LEGAL_STATUSES.contains(hostStatus) || hostStatus == VDSStatus.Installing && internalExecution;
    if (!hostStatusLegalForSetupNetworks) {
        logger.error("Unable to setup network: operation can only be done when Host status is one of: {};" + " current status is {}", LEGAL_STATUSES_STR, hostStatus);
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL, ReplacementUtils.replaceWith(VAR_HOST_STATUS, LEGAL_STATUSES, ",", LEGAL_STATUSES.size()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void cleanupLunsFromDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    for (LUNs lunFromDb : lunsFromDb) {
        if (!isDummyLun(lunFromDb) && !containsLun(lunsFromVgInfo, lunFromDb)) {
            lunDao.remove(lunFromDb.getLUNId());
            log.info("Removed LUN ID '{}'", lunFromDb.getLUNId());
        }
    }
}
#method_after
private void cleanupLunsFromDb(List<LUNs> lunsFromVgInfo, List<LUNs> lunsFromDb) {
    lunsFromDb.stream().map(LUNs::getLUNId).filter(lunId -> !lunId.startsWith(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX)).filter(lunId -> lunsFromVgInfo.stream().noneMatch(lun -> lun.getLUNId().equals(lunId))).forEach(lunId -> {
        lunDao.remove(lunId);
        log.info("Removed LUN ID '{}'", lunId);
    });
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    // disable usb in case of headless vm and no serial console is set
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !parameters.isConsoleEnabled()) {
        parameters.getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !parameters.isConsoleEnabled()) {
        parameters.getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void copyVmDevices() {
    getVmDeviceUtils().copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#method_after
protected void copyVmDevices() {
    getVmDeviceUtils().copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled(), isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false, getEffectiveCompatibilityVersion());
    if (getInstanceTypeId() != null) {
        copyDiskDevicesFromTemplate();
    }
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    // disable usb in case of headless vm and no serial console is set
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getCluster() != null) {
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    vmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(vmNumaNodeDao.getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() == DisplayType.none && !getParameters().isConsoleEnabled()) {
        getParameters().getVmStaticData().setUsbPolicy(UsbPolicy.DISABLED);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        vmTemplateHandler.updateDisksFromDb(oldTemplate);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (VmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getValidationMessages()) && checkDomain()) {
        returnValue = vmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        vmTemplateHandler.updateDisksFromDb(oldTemplate);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (VmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getValidationMessages()) && checkDomain()) {
        returnValue = vmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmTemplateData(), CompatibilityVersionUtils.getEffective(getParameters().getVmTemplateData(), this::getCluster)))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
public void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskMap().values(), ONLY_ACTIVE);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    @SuppressWarnings("unchecked")
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#method_after
public void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = DisksFilter.filterImageDisks(vm.getDiskMap().values(), ONLY_ACTIVE);
    List<CinderDisk> filteredCinderDisks = DisksFilter.filterCinderDisks(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    @SuppressWarnings("unchecked")
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#end_block

#method_before
public void updateVmGuestAgentVersion(final VM vm) {
    if (vm.getAppList() != null) {
        final String[] parts = vm.getAppList().split("[,]", -1);
        if (parts != null && parts.length != 0) {
            final List<String> possibleAgentAppNames = Config.getValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.getValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(osRepository.getOsFamily(vm.getOs()).toLowerCase());
            for (final String part : parts) {
                for (String agentName : possibleAgentAppNames) {
                    if (StringUtils.containsIgnoreCase(part, agentName)) {
                        vm.setGuestAgentVersion(getApplicationVersion(part, agentName));
                    }
                    if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                        vm.setSpiceDriverVersion(getApplicationVersion(part, spiceDriverInGuest));
                    }
                }
            }
        }
    }
}
#method_after
public void updateVmGuestAgentVersion(final VM vm) {
    if (vm.getAppList() != null) {
        final String[] parts = vm.getAppList().split("[,]", -1);
        if (parts.length != 0) {
            final List<String> possibleAgentAppNames = Config.getValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.getValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(osRepository.getOsFamily(vm.getOs()).toLowerCase());
            for (final String part : parts) {
                for (String agentName : possibleAgentAppNames) {
                    if (StringUtils.containsIgnoreCase(part, agentName)) {
                        vm.setGuestAgentVersion(getApplicationVersion(part, agentName));
                    }
                    if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                        vm.setSpiceDriverVersion(getApplicationVersion(part, spiceDriverInGuest));
                    }
                }
            }
        }
    }
}
#end_block

#method_before
public void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    vdsBrokerFrontend.runVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vmDynamic));
}
#method_after
public void updateCurrentCd(VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    vdsBrokerFrontend.runVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vmDynamic));
}
#end_block

#method_before
public void updateDefaultTimeZone(VmBase vmBase) {
    if (vmBase.getTimeZone() == null) {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
}
#method_after
public void updateDefaultTimeZone(VmBase vmBase) {
    if (vmBase.getTimeZone() == null) {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
}
#end_block

#method_before
public boolean isCpuSupported(int osId, Version version, String cpuName, ArrayList<String> validationMessages) {
    String cpuId = cpuFlagsManagerHandler.getCpuId(cpuName, version);
    if (cpuId == null) {
        validationMessages.add(EngineMessage.CPU_TYPE_UNKNOWN.name());
        return false;
    }
    if (!osRepository.isCpuSupported(osId, version, cpuId)) {
        String unsupportedCpus = osRepository.getUnsupportedCpus(osId, version).toString();
        validationMessages.add(EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS.name());
        validationMessages.add("$unsupportedCpus " + StringUtils.strip(unsupportedCpus.toString(), "[]"));
        return false;
    }
    return true;
}
#method_after
public boolean isCpuSupported(int osId, Version version, String cpuName, ArrayList<String> validationMessages) {
    String cpuId = cpuFlagsManagerHandler.getCpuId(cpuName, version);
    if (cpuId == null) {
        validationMessages.add(EngineMessage.CPU_TYPE_UNKNOWN.name());
        return false;
    }
    if (!osRepository.isCpuSupported(osId, version, cpuId)) {
        String unsupportedCpus = osRepository.getUnsupportedCpus(osId, version).toString();
        validationMessages.add(EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS.name());
        validationMessages.add("$unsupportedCpus " + StringUtils.strip(unsupportedCpus, "[]"));
        return false;
    }
    return true;
}
#end_block

#method_before
public void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, Cluster cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS) {
        return;
    }
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), CompatibilityVersionUtils.getEffective(parametersStaticData, cluster));
    if (parametersStaticData.getDefaultDisplayType() != null && isDisplayTypeSupported(parametersStaticData.getDefaultDisplayType(), graphicsAndDisplays)) {
        return;
    }
    DisplayType defaultDisplayType = null;
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new LinkedHashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        final List<GraphicsType> graphicsTypes = vmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId);
        final Set<GraphicsType> resultingVmGraphics = getResultingVmGraphics(graphicsTypes, graphicsDevices);
        if (entry.getValue().containsAll(resultingVmGraphics)) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    if (defaultDisplayType == null) {
        if (!displayGraphicsSupport.isEmpty()) {
            // when not found otherwise, let's take osinfo's record as the default
            Map.Entry<DisplayType, Set<GraphicsType>> entry = displayGraphicsSupport.entrySet().iterator().next();
            defaultDisplayType = entry.getKey();
        } else {
            // no osinfo record
            defaultDisplayType = DisplayType.qxl;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#method_after
public void autoSelectDefaultDisplayType(Guid srcEntityId, VmBase parametersStaticData, Cluster cluster, Map<GraphicsType, GraphicsDevice> graphicsDevices) {
    if (parametersStaticData.getOsId() == OsRepository.AUTO_SELECT_OS) {
        return;
    }
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = osRepository.getGraphicsAndDisplays(parametersStaticData.getOsId(), CompatibilityVersionUtils.getEffective(parametersStaticData, cluster));
    if (parametersStaticData.getDefaultDisplayType() != null && (parametersStaticData.getDefaultDisplayType() == DisplayType.none || isDisplayTypeSupported(parametersStaticData.getDefaultDisplayType(), graphicsAndDisplays))) {
        return;
    }
    DisplayType defaultDisplayType = null;
    // map holding display type -> set of supported graphics types for this display type
    Map<DisplayType, Set<GraphicsType>> displayGraphicsSupport = new LinkedHashMap<>();
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        DisplayType display = graphicsAndDisplay.getSecond();
        if (!displayGraphicsSupport.containsKey(display)) {
            displayGraphicsSupport.put(display, new HashSet<>());
        }
        displayGraphicsSupport.get(display).add(graphicsAndDisplay.getFirst());
    }
    for (Map.Entry<DisplayType, Set<GraphicsType>> entry : displayGraphicsSupport.entrySet()) {
        final List<GraphicsType> graphicsTypes = vmDeviceUtils.getGraphicsTypesOfEntity(srcEntityId);
        final Set<GraphicsType> resultingVmGraphics = getResultingVmGraphics(graphicsTypes, graphicsDevices);
        if (entry.getValue().containsAll(resultingVmGraphics)) {
            defaultDisplayType = entry.getKey();
            break;
        }
    }
    if (defaultDisplayType == null) {
        if (!displayGraphicsSupport.isEmpty()) {
            // when not found otherwise, let's take osinfo's record as the default
            Map.Entry<DisplayType, Set<GraphicsType>> entry = displayGraphicsSupport.entrySet().iterator().next();
            defaultDisplayType = entry.getKey();
        } else {
            // no osinfo record
            defaultDisplayType = DisplayType.qxl;
        }
    }
    parametersStaticData.setDefaultDisplayType(defaultDisplayType);
}
#end_block

#method_before
private static boolean isDisplayTypeSupported(DisplayType displayType, List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays) {
    // For Headless VM
    if (displayType == DisplayType.none) {
        return true;
    }
    for (Pair<GraphicsType, DisplayType> pair : graphicsAndDisplays) {
        if (displayType.equals(pair.getSecond())) {
            return true;
        }
    }
    return false;
}
#method_after
private static boolean isDisplayTypeSupported(DisplayType displayType, List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays) {
    for (Pair<GraphicsType, DisplayType> pair : graphicsAndDisplays) {
        if (displayType.equals(pair.getSecond())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getIsHeadlessModeEnabled().setIsChangeable(false);
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getOverrideMigrationPolicy().setIsChangeable(false);
        getMigrationPolicies().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceUrandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getMaxMemorySize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getThreadsPerCore().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getIsHeadlessModeEnabled().setIsChangeable(false);
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getConsoleDisconnectAction().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        getOverrideMigrationPolicy().setIsChangeable(false);
        getMigrationPolicies().setIsChangeable(false);
        getCustomCompatibilityVersion().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceUrandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsHeadlessModeEnabled().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceUrandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    initConsoleDisconnectAction();
    updateLabelList();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getMaxMemorySize().setEntity(256 * DEFAULT_MAX_MEMORY_RATIO);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsHeadlessModeEnabled().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceUrandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    initConsoleDisconnectAction();
    updateLabelList();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    refreshMigrationPolicies();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
private void memSize_EntityChanged(Object sender, EventArgs args) {
    behavior.updateMinAllocatedMemory();
}
#method_after
private void memSize_EntityChanged(Object sender, EventArgs args) {
    behavior.updateMinAllocatedMemory();
    if (getMemSize().getEntity() != null) {
        maxMemorySize.setEntity(getMemSize().getEntity() * DEFAULT_MAX_MEMORY_RATIO);
    }
}
#end_block

#method_before
public boolean validateHwPart() {
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    validateMemoryAlignment(getMemSize());
    if (getIoThreadsEnabled().getEntity()) {
        getNumOfIoThreads().validateEntity(new IValidation[] { new NotNullIntegerValidation(1, AsyncDataProvider.getInstance().getMaxIoThreadsPerVm()) });
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid() && getNumOfIoThreads().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    /*
         * This should be run at very end of the validation process otherwise general validation can override more
         * strict checks in behaviors
         */
    boolean behaviorValid = behavior.validate();
    boolean isValid = behaviorValid && allTabsValid();
    return isValid;
}
#method_after
public boolean validateHwPart() {
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    validateMaxMemorySize();
    validateMemoryAlignment(getMemSize());
    if (getIoThreadsEnabled().getEntity()) {
        getNumOfIoThreads().validateEntity(new IValidation[] { new NotNullIntegerValidation(1, AsyncDataProvider.getInstance().getMaxIoThreadsPerVm()) });
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid() && getNumOfIoThreads().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    /*
         * This should be run at very end of the validation process otherwise general validation can override more
         * strict checks in behaviors
         */
    boolean behaviorValid = behavior.validate();
    boolean isValid = behaviorValid && allTabsValid();
    return isValid;
}
#end_block

#method_before
protected void initDisplayTypes(DisplayType selected, UnitVmModel.GraphicsTypes selectedGrahicsTypes) {
    getModel().getDisplayType().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            enableSinglePCI(getModel().getDisplayType().getSelectedItem() == DisplayType.qxl);
        }
    });
    List<Pair<GraphicsType, DisplayType>> allGraphicsAndDisplays = new ArrayList<>();
    for (GraphicsType graphicsType : GraphicsType.values()) {
        for (DisplayType displayType : DisplayType.values()) {
            if (displayType != DisplayType.none) {
                allGraphicsAndDisplays.add(new Pair<>(graphicsType, displayType));
            }
        }
    }
    getModel().initDisplayModels(allGraphicsAndDisplays);
    initGraphicsModel(selectedGrahicsTypes);
    if (getModel().getDisplayType().getItems().contains(selected)) {
        getModel().getDisplayType().setSelectedItem(selected);
    }
}
#method_after
protected void initDisplayTypes(DisplayType selected, UnitVmModel.GraphicsTypes selectedGrahicsTypes) {
    getModel().getDisplayType().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            enableSinglePCI(getModel().getDisplayType().getSelectedItem() == DisplayType.qxl);
        }
    });
    List<Pair<GraphicsType, DisplayType>> allGraphicsAndDisplays = new ArrayList<>();
    for (GraphicsType graphicsType : GraphicsType.values()) {
        for (DisplayType displayType : DisplayType.values()) {
            if (displayType != DisplayType.none) {
                allGraphicsAndDisplays.add(new Pair<>(graphicsType, displayType));
            }
        }
    }
    getModel().initDisplayModels(allGraphicsAndDisplays);
    initGraphicsModel(selectedGrahicsTypes);
    if (getModel().getDisplayType().getItems().contains(selected)) {
        getModel().getDisplayType().setSelectedItem(selected);
    }
    if (selected == DisplayType.none) {
        getModel().getDisplayType().setSelectedItem(DisplayType.qxl);
        getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.SPICE);
        getModel().getIsHeadlessModeEnabled().setEntity(true);
    }
}
#end_block

#method_before
private void initDetachableFields() {
    detachableInstanceTypesEditor = new EntityModelDetachableWidgetWithLabel(instanceTypesEditor);
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.IGNORE);
    detachablePriorityEditor = new EntityModelDetachableWidgetWithLabel(priorityEditor);
    isMemoryBalloonDeviceEnabledDetachable = new EntityModelDetachableWidget(isMemoryBalloonDeviceEnabled);
    isIoThreadsEnabledDetachable = new EntityModelDetachableWidget(isIoThreadsEnabled);
    detachableMinAllocatedMemoryEditor = new EntityModelDetachableWidgetWithLabel(minAllocatedMemoryEditor);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationPolicyEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationPolicyEditor, Align.IGNORE);
    overrideMigrationPolicyEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
}
#method_after
private void initDetachableFields() {
    detachableInstanceTypesEditor = new EntityModelDetachableWidgetWithLabel(instanceTypesEditor);
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    final EnableableFormLabel maxMemoryLabel = new EnableableFormLabel(constants.maxMemorySizePopup());
    maxMemorySizeEditor = new MemorySizeEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    detachableMaxMemorySizeEditor = new EntityModelDetachableWidgetWithInfo(maxMemoryLabel, maxMemorySizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.IGNORE);
    detachablePriorityEditor = new EntityModelDetachableWidgetWithLabel(priorityEditor);
    isMemoryBalloonDeviceEnabledDetachable = new EntityModelDetachableWidget(isMemoryBalloonDeviceEnabled);
    isIoThreadsEnabledDetachable = new EntityModelDetachableWidget(isIoThreadsEnabled);
    detachableMinAllocatedMemoryEditor = new EntityModelDetachableWidgetWithLabel(minAllocatedMemoryEditor);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationPolicyEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationPolicyEditor, Align.IGNORE);
    overrideMigrationPolicyEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    labelEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    isHeadlessModeEnabledEditor.setTabIndex(nextTabIndex++);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceUrandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    labelEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    increaseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    maxMemorySizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    threadsPerCoreEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    poolStatefulEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    isHeadlessModeEnabledEditor.setTabIndex(nextTabIndex++);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    consoleDisconnectActionEditor.setTabIndexes(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationPolicyEditor.setTabIndex(nextTabIndex++);
    migrationPolicyEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    customCompatibilityVersionEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceUrandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    // ==Foreman Tab==
    nextTabIndex = foremanTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
protected List<Widget> advancedFieldsFromGeneralTab() {
    return Arrays.<Widget>asList(memSizeEditor, totalvCPUsEditor, vcpusAdvancedParameterExpander, copyTemplatePermissionsEditor, vmIdEditor);
}
#method_after
protected List<Widget> advancedFieldsFromGeneralTab() {
    return Arrays.<Widget>asList(memSizeEditor, maxMemorySizeEditor, totalvCPUsEditor, vcpusAdvancedParameterExpander, copyTemplatePermissionsEditor, vmIdEditor);
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, threadsPerCoreEditorWithInfoIcon, isHighlyAvailableEditorWithDetachable, isMemoryBalloonDeviceEnabledDetachable, isIoThreadsEnabledDetachable, detachablePriorityEditor, migrationModeEditorWithDetachable, detachableMinAllocatedMemoryEditor, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable, overrideMigrationPolicyEditorWithDetachable);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, threadsPerCoreEditorWithInfoIcon, isHighlyAvailableEditorWithDetachable, isMemoryBalloonDeviceEnabledDetachable, isIoThreadsEnabledDetachable, detachablePriorityEditor, migrationModeEditorWithDetachable, detachableMinAllocatedMemoryEditor, detachableMemSizeEditor, detachableMaxMemorySizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable, overrideMigrationPolicyEditorWithDetachable);
}
#end_block

#method_before
protected List<Widget> adminOnlyWidgets() {
    return Arrays.asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, monitors, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#method_after
protected List<Widget> adminOnlyWidgets() {
    return Arrays.asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, detachableMaxMemorySizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, consoleDisconnectActionEditor, monitors, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#end_block

#method_before
public void addVideoDevices(VmBase vmBase, int numberOfVideoDevices) {
    for (int i = 0; i < numberOfVideoDevices; i++) {
        if (vmBase.getDefaultDisplayType() != DisplayType.none) {
            addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.VIDEO, vmBase.getDefaultDisplayType().getDefaultVmDeviceType(), getVideoDeviceSpecParams(vmBase), true, false);
        }
    }
}
#method_after
public void addVideoDevices(VmBase vmBase, int numberOfVideoDevices) {
    if (vmBase.getDefaultDisplayType() != DisplayType.none) {
        for (int i = 0; i < numberOfVideoDevices; i++) {
            addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.VIDEO, vmBase.getDefaultDisplayType().getDefaultVmDeviceType(), getVideoDeviceSpecParams(vmBase), true, false);
        }
    }
}
#end_block

#method_before
/*
     * USB slot
     */
private void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int currentNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        currentNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    }
    final int usbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    // We add USB slots if they are disabled in oldVm configuration, but enabled in newVm
    if (!oldUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE) && newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (usbSlots > 0) {
            removeUsbControllers(newVm.getId());
            addUsbControllers(newVm.getId(), getNeededNumberOfUsbControllers(usbSlots));
            addUsbSlots(newVm.getId(), usbSlots);
        }
    // Remove USB slots and controllers if the policy is to disable
    } else if (newUsbPolicy.equals(UsbPolicy.DISABLED)) {
        removeUsbControllers(newVm.getId());
        removeUsbSlots(newVm.getId());
    // If the USB policy is to enable (and was enabled before), we need to update the number of slots
    } else if (newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (currentNumberOfSlots < usbSlots) {
            // Add slots and controllers
            if (currentNumberOfSlots == 0) {
                addUsbControllers(newVm.getId(), getNeededNumberOfUsbControllers(usbSlots));
            }
            addUsbSlots(newVm.getId(), usbSlots - currentNumberOfSlots);
        } else if (currentNumberOfSlots > usbSlots) {
            // Remove slots and controllers
            removeUsbSlots(newVm.getId(), currentNumberOfSlots - usbSlots);
            if (usbSlots == 0) {
                removeUsbControllers(newVm.getId());
            }
        }
    }
}
#method_after
/*
     * USB slot
     */
private void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int oldNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        oldNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    }
    final int newNumberOfUsbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        disableNormalUsb(newVm.getId());
        enableSpiceUsb(newVm.getId(), newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.ENABLED_NATIVE == newUsbPolicy) {
        updateSpiceUsb(newVm.getId(), oldNumberOfSlots, newNumberOfUsbSlots);
        return;
    }
    if (UsbPolicy.ENABLED_NATIVE == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        disableSpiceUsb(newVm.getId());
        enableNormalUsb(newVm);
        return;
    }
    if (UsbPolicy.DISABLED == oldUsbPolicy && UsbPolicy.DISABLED == newUsbPolicy) {
        updateNormalUsb(newVm);
        return;
    }
    throw new RuntimeException(format("Unexpected state: oldUsbPolicy=%s, newUsbPolicy=%s", oldUsbPolicy, newUsbPolicy));
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VmBase srcVmBase = getVmBase(srcId);
    VmBase dstVmBase = getVmBase(dstId);
    List<VmDevice> srcDevices = vmDeviceDao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, dstVmBase, srcDevices, srcDeviceIdToDstDeviceIdMapping, isSoundEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices, canCopyHostDevices(srcVmBase, dstVmBase));
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices, Version versionToUpdateRngDeviceWith) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device), dstVmBase.getCustomCompatibilityVersion()).isValid()) {
                    continue;
                }
                final VmRngDevice rngDevice = new VmRngDevice(device);
                if (versionToUpdateRngDeviceWith != null) {
                    rngDevice.updateSourceByVersion(versionToUpdateRngDeviceWith);
                }
                specParams.putAll(rngDevice.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstVmBase, getVmCompatibilityVersion(dstVmBase));
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = vmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    // For Headless VM - remove the Display device
    VmDevice device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, VmDeviceGeneralType.VIDEO);
    if (device != null) {
        vmManagedDeviceMap.remove(device.getDeviceId());
    }
    return vmManagedDeviceMap;
}
#method_after
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = vmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    // @TODO - this was added to handle the headless VM since the VIDEO devices were added anyway with the DB value instead of the
    // new configuration value. Should be handled correctly while the task of removing the static.displaytype and handling the VIDEO device
    // as all other devices
    VmDevice device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, VmDeviceGeneralType.VIDEO);
    if (device != null) {
        vmManagedDeviceMap.remove(device.getDeviceId());
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#method_after
@Override
protected void updateActionsAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    boolean singleVmSelected = items.size() == 1;
    boolean vmsSelected = items.size() > 0;
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.getInstance().isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecutePartially(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(vmsSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(singleVmSelected && !getSelectedItem().isStateless() && !getSelectedItem().isPreviewSnapshot() && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(singleVmSelected && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(vmsSelected);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || singleVmSelected);
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(singleVmSelected && isConsoleEditEnabled());
    getCancelConvertCommand().setIsExecutionAllowed(isSelectedVmBeingConverted());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
    } else if ("PreSavePhase3".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase3();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (command == getCancelConvertCommand()) {
        cancelConversion();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        if (!model.validate()) {
            return;
        }
        updateExistingVm(model.getApplyLater().getEntity());
        cancelConfirmation();
    } else if ("ClearCpuPinning".equals(command.getName())) {
        // $NON-NLS-1$
        clearCpuPinning();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
    } else if ("PreSavePhase3".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase3();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (command == getCancelConvertCommand()) {
        cancelConversion();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        if (!model.validate()) {
            return;
        }
        updateExistingVm(model.getApplyLater().getEntity());
        cancelConfirmation();
    } else if ("ClearCpuPinning".equals(command.getName())) {
        // $NON-NLS-1$
        clearCpuPinning();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
protected void doUpdateManagedFieldsFrom(final VmBase vmBase) {
    if (vmBase == null) {
        model.stopProgress();
        return;
    }
    deactivate();
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getIoThreadsEnabled(), vmBase.getNumOfIoThreads() != 0);
    maybeSetEntity(model.getNumOfIoThreads(), vmBase.getNumOfIoThreads());
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getTotalCPUCores(), Integer.toString(vmBase.getNumOfCpus()));
    model.setBootSequence(vmBase.getDefaultBootSequence());
    List<MigrationSupport> supportedModes = (List<MigrationSupport>) getModel().getMigrationMode().getItems();
    if (supportedModes.contains(vmBase.getMigrationSupport())) {
        maybeSetSelectedItem(getModel().getMigrationMode(), vmBase.getMigrationSupport());
    }
    maybeSetEntity(model.getIsHighlyAvailable(), vmBase.isAutoStartup());
    maybeSetSelectedItem(model.getNumOfSockets(), vmBase.getNumOfSockets());
    maybeSetSelectedItem(model.getCoresPerSocket(), vmBase.getCpuPerSocket());
    maybeSetSelectedItem(model.getThreadsPerCore(), vmBase.getThreadsPerCpu());
    maybeSetSelectedItem(model.getEmulatedMachine(), vmBase.getCustomEmulatedMachine());
    maybeSetSelectedItem(model.getCustomCpu(), vmBase.getCustomCpuName());
    model.setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
    model.selectMigrationPolicy(vmBase.getMigrationPolicyId());
    // SL!
    priorityUtil.initPriority(vmBase.getPriority(), new PriorityUtil.PriorityUpdatingCallbacks() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
        }
    });
    updateDefaultDisplayRelatedFields(vmBase);
    if (vmBase.getMinAllocatedMem() != 0) {
        model.getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
    }
    activate();
    AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean returnValue) {
            deactivate();
            getModel().getIsSoundcardEnabled().setEntity(returnValue);
            activate();
            Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    deactivate();
                    List<String> consoleDevices = returnValue.getReturnValue();
                    getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
                    activate();
                    postDoUpdateManagedFieldsFrom(vmBase);
                }
            }));
        }
    }), vmBase.getId());
}
#method_after
protected void doUpdateManagedFieldsFrom(final VmBase vmBase) {
    if (vmBase == null) {
        model.stopProgress();
        return;
    }
    deactivate();
    maybeSetEntity(model.getMemSize(), vmBase.getMemSizeMb());
    maybeSetEntity(model.getMaxMemorySize(), vmBase.getMaxMemorySizeMb());
    maybeSetEntity(model.getIoThreadsEnabled(), vmBase.getNumOfIoThreads() != 0);
    maybeSetEntity(model.getNumOfIoThreads(), vmBase.getNumOfIoThreads());
    maybeSetEntity(model.getTotalCPUCores(), Integer.toString(vmBase.getNumOfCpus()));
    model.setBootSequence(vmBase.getDefaultBootSequence());
    List<MigrationSupport> supportedModes = (List<MigrationSupport>) getModel().getMigrationMode().getItems();
    if (supportedModes.contains(vmBase.getMigrationSupport())) {
        maybeSetSelectedItem(getModel().getMigrationMode(), vmBase.getMigrationSupport());
    }
    maybeSetEntity(model.getIsHighlyAvailable(), vmBase.isAutoStartup());
    maybeSetSelectedItem(model.getNumOfSockets(), vmBase.getNumOfSockets());
    maybeSetSelectedItem(model.getCoresPerSocket(), vmBase.getCpuPerSocket());
    maybeSetSelectedItem(model.getThreadsPerCore(), vmBase.getThreadsPerCpu());
    maybeSetSelectedItem(model.getEmulatedMachine(), vmBase.getCustomEmulatedMachine());
    maybeSetSelectedItem(model.getCustomCpu(), vmBase.getCustomCpuName());
    model.setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
    model.selectMigrationPolicy(vmBase.getMigrationPolicyId());
    priorityUtil.initPriority(vmBase.getPriority(), new PriorityUtil.PriorityUpdatingCallbacks() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
        }
    });
    updateDefaultDisplayRelatedFields(vmBase);
    if (vmBase.getMinAllocatedMem() != 0) {
        model.getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
    }
    activate();
    AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery<>(new AsyncCallback<Boolean>() {

        @Override
        public void onSuccess(Boolean returnValue) {
            deactivate();
            getModel().getIsSoundcardEnabled().setEntity(returnValue);
            activate();
            Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDevices, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    deactivate();
                    List<String> consoleDevices = returnValue.getReturnValue();
                    getModel().getIsConsoleDeviceEnabled().setEntity(!consoleDevices.isEmpty());
                    activate();
                    postDoUpdateManagedFieldsFrom(vmBase);
                }
            }));
        }
    }), vmBase.getId());
}
#end_block

#method_before
public void authCheck(String name, Map<String, Object> vars) throws Exception {
    log.debug("authCheck Entry name='{}'", name);
    final String PREFIX_AUTH_CHECK = "auth-check";
    MapProperties authCheckProps = Util.expandMap(new MapProperties(props.get(PREFIX_AUTH_CHECK, "default"), props.get(PREFIX_AUTH_CHECK, name)), "seq", vars);
    String pool = authCheckProps.getMandatoryString("pool");
    String user = authCheckProps.getMandatoryString("user");
    if (user == null || user.isEmpty()) {
        throw new IllegalArgumentException("User required for authentication check");
    }
    ConnectionPoolEntry connectionPoolEntry = getConnectionPoolEntry(pool, null, vars);
    LDAPConnection connection = null;
    try {
        connection = connectionPoolEntry.connectionPool.getConnection();
        log.debug("Creating BindRequest");
        BindRequest bindRequest = createBindRequest(authCheckProps, user, authCheckProps.getString(null, "password"));
        log.debug("BindRequest: {}", bindRequest);
        log.debug("bind");
        BindResult bindResult = connection.bind(bindRequest);
        log.debug("BindResult: {}", bindResult);
        PasswordExpiringControl expiringControl = PasswordExpiringControl.get(bindResult);
        if (expiringControl != null) {
            log.debug("Password about to expire");
            int secondsToExpiration = expiringControl.getSecondsUntilExpiration();
            vars.put(VARS_MESSAGE, String.format("Password will be expired in %s days", expiringControl.getSecondsUntilExpiration() / 60 / 60 / 24));
        }
        if (connectionPoolEntry.supportWhoAmI && authCheckProps.getBoolean(Boolean.TRUE, "whoami", "enable")) {
            log.debug("Trying WhoAmI");
            WhoAmIExtendedResult whoAmIExtendedResult = (WhoAmIExtendedResult) connection.processExtendedOperation(new WhoAmIExtendedRequest());
            if (whoAmIExtendedResult.getResultCode() == ResultCode.SUCCESS) {
                String authzID = whoAmIExtendedResult.getAuthorizationID();
                log.debug("Got WhoAmI: {}", authzID);
                if (!Arrays.asList("", "u:", "dn:").contains(authzID)) {
                    vars.put(VARS_AUTH_WHO_AM_I, authzID);
                }
            }
        }
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(ResultCode.SUCCESS));
    } catch (LDAPException e) {
        log.debug("Authentication exception", e);
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(e.getResultCode()));
        vars.put(VARS_MESSAGE, e.getMessage());
        if (ResultCode.LOCAL_ERROR.equals(e.getResultCode())) {
            vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getCause().getClass().getName(), e.getCause().getMessage()));
        } else {
            if (e.getDiagnosticMessage() != null) {
                vars.put(VARS_DIAGNOSTIC_MESSAGE, e.getDiagnosticMessage());
            }
        }
        try {
            if (PasswordExpiredControl.get(e) != null) {
                log.debug("Password is expired");
                vars.put(VARS_RESULT_CODE, "PASSWORD_EXPIRED");
                vars.put(VARS_MESSAGE, "Password expired");
            }
        } catch (LDAPException e1) {
            log.debug("Ignoring exception during get of expired control", e1);
        }
    } catch (Exception e) {
        log.debug("Authentication exception", e);
        vars.put(VARS_MESSAGE, e.getMessage());
        vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getClass().getName(), e.getMessage()));
    } finally {
        if (connection != null) {
            if (authCheckProps.getBoolean(Boolean.FALSE, "reuse-connections")) {
                connectionPoolEntry.connectionPool.releaseAndReAuthenticateConnection(connection);
            } else {
                connectionPoolEntry.connectionPool.discardConnection(connection);
            }
        }
    }
    vars.put(VARS_AUTH_TRANSLATED_MESSAGE, translateDiagnosticMessage(authCheckProps.get("diagnostic"), vars));
    log.debug("authCheck Return");
}
#method_after
public void authCheck(String name, Map<String, Object> vars) throws Exception {
    log.debug("authCheck Entry name='{}'", name);
    final String PREFIX_AUTH_CHECK = "auth-check";
    MapProperties authCheckProps = Util.expandMap(new MapProperties(props.get(PREFIX_AUTH_CHECK, "default"), props.get(PREFIX_AUTH_CHECK, name)), "seq", vars);
    String pool = authCheckProps.getMandatoryString("pool");
    String user = authCheckProps.getMandatoryString("user");
    if (user == null || user.isEmpty()) {
        throw new IllegalArgumentException("User required for authentication check");
    }
    ConnectionPoolEntry connectionPoolEntry = getConnectionPoolEntry(pool, null, vars);
    LDAPConnection connection = null;
    try {
        connection = connectionPoolEntry.connectionPool.getConnection();
        log.debug("Creating BindRequest");
        BindRequest bindRequest = createBindRequest(authCheckProps, user, authCheckProps.getString(null, "password"));
        log.debug("BindRequest: {}", bindRequest);
        log.debug("User '{}' is performing bind request to: {}", user, connection.getConnectedAddress());
        BindResult bindResult = connection.bind(bindRequest);
        log.debug("BindResult: {}", bindResult);
        PasswordExpiringControl expiringControl = PasswordExpiringControl.get(bindResult);
        if (expiringControl != null) {
            log.debug("Password about to expire");
            int secondsToExpiration = expiringControl.getSecondsUntilExpiration();
            vars.put(VARS_MESSAGE, String.format("Password will be expired in %s days", expiringControl.getSecondsUntilExpiration() / 60 / 60 / 24));
        }
        if (connectionPoolEntry.supportWhoAmI && authCheckProps.getBoolean(Boolean.TRUE, "whoami", "enable")) {
            log.debug("Trying WhoAmI");
            WhoAmIExtendedResult whoAmIExtendedResult = (WhoAmIExtendedResult) connection.processExtendedOperation(new WhoAmIExtendedRequest());
            if (whoAmIExtendedResult.getResultCode() == ResultCode.SUCCESS) {
                String authzID = whoAmIExtendedResult.getAuthorizationID();
                log.debug("Got WhoAmI: {}", authzID);
                if (!Arrays.asList("", "u:", "dn:").contains(authzID)) {
                    vars.put(VARS_AUTH_WHO_AM_I, authzID);
                }
            }
        }
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(ResultCode.SUCCESS));
    } catch (LDAPException e) {
        log.debug("Authentication exception", e);
        vars.put(VARS_RESULT_CODE, resultCodeNameMap.get(e.getResultCode()));
        vars.put(VARS_MESSAGE, e.getMessage());
        if (ResultCode.LOCAL_ERROR.equals(e.getResultCode())) {
            vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getCause().getClass().getName(), e.getCause().getMessage()));
        } else {
            if (e.getDiagnosticMessage() != null) {
                vars.put(VARS_DIAGNOSTIC_MESSAGE, e.getDiagnosticMessage());
            }
        }
        try {
            if (PasswordExpiredControl.get(e) != null) {
                log.debug("Password is expired");
                vars.put(VARS_RESULT_CODE, "PASSWORD_EXPIRED");
                vars.put(VARS_MESSAGE, "Password expired");
            }
        } catch (LDAPException e1) {
            log.debug("Ignoring exception during get of expired control", e1);
        }
    } catch (Exception e) {
        log.debug("Authentication exception", e);
        vars.put(VARS_MESSAGE, e.getMessage());
        vars.put(VARS_DIAGNOSTIC_MESSAGE, String.format("%s:%s", e.getClass().getName(), e.getMessage()));
    } finally {
        if (connection != null) {
            if (authCheckProps.getBoolean(Boolean.FALSE, "reuse-connections")) {
                connectionPoolEntry.connectionPool.releaseAndReAuthenticateConnection(connection);
            } else {
                connectionPoolEntry.connectionPool.discardConnection(connection);
            }
        }
    }
    vars.put(VARS_AUTH_TRANSLATED_MESSAGE, translateDiagnosticMessage(authCheckProps.get("diagnostic"), vars));
    log.debug("authCheck Return");
}
#end_block

#method_before
public List<Map<String, List<String>>> searchExecute(SearchInstance instance, int pageSize) throws LDAPException {
    log.trace("searchExecute Entry");
    List<Map<String, List<String>>> ret = null;
    if (!instance.done) {
        if (instance.connection == null) {
            log.debug("Getting connection out of pool '{}'", instance.connectionPoolEntry.name);
            instance.connection = instance.connectionPoolEntry.connectionPool.getConnection();
        }
        if (instance.doPaging) {
            instance.searchRequest.setControls(new SimplePagedResultsControl(pageSize != 0 ? pageSize : instance.pageSize, instance.resumeCookie));
        }
        log.debug("SearchRequest: {}", instance.searchRequest);
        instance.resumeCookie = null;
        SearchResult searchResult;
        try {
            searchResult = instance.connection.search(instance.searchRequest);
        } catch (LDAPSearchException e) {
            log.debug("SearchRequest: Exception {}", (Object) e);
            log.trace("SearchRequest: Exception", e);
            log.trace("SearchRequest: Exception SearchReferences: {}", e.getSearchReferences());
            searchResult = e.getSearchResult();
        }
        log.debug("SearchResult: {}", searchResult);
        log.trace("SearchReferences: {}", searchResult.getSearchReferences());
        log.trace("SearchReferences: {}", searchResult.getSearchReferences());
        if (searchResult.getReferralURLs() != null && searchResult.getReferralURLs().length > 0) {
            if (log.isTraceEnabled()) {
                log.trace("Search Referral URLs: {}", Arrays.asList(searchResult.getReferralURLs()));
            }
            String host = searchResult.getReferralURLs()[0];
            try {
                LDAPConnection connection = instance.connection.getReferralConnector().getReferralConnection(new LDAPURL(host), instance.connection);
                instance.connection.close();
                instance.connection = connection;
                ret = new ArrayList<>();
            } catch (LDAPException e) {
                log.warn("{} Cannot connect referral '{}': {}", logPrefix, host, e.getMessage());
                log.debug("Exception", e);
            }
        } else {
            if (searchResult.getEntryCount() > 0) {
                ret = searchMapEntries(searchResult.getSearchEntries(), instance.attrMap);
            }
            if (searchResult.hasResponseControl(SimplePagedResultsControl.PAGED_RESULTS_OID)) {
                SimplePagedResultsControl responseControl = SimplePagedResultsControl.get(searchResult);
                if (responseControl.moreResultsToReturn()) {
                    instance.resumeCookie = responseControl.getCookie();
                }
            }
            instance.limitLeft -= searchResult.getEntryCount();
            if (instance.resumeCookie == null || instance.limitLeft <= 0) {
                instance.done = true;
            }
        }
    }
    log.trace("searchExecute Return: {}", ret);
    return ret;
}
#method_after
public List<Map<String, List<String>>> searchExecute(SearchInstance instance, int pageSize) throws LDAPException {
    log.trace("searchExecute Entry");
    List<Map<String, List<String>>> ret = null;
    if (!instance.done) {
        if (instance.connection == null) {
            log.debug("Getting connection out of pool '{}'", instance.connectionPoolEntry.name);
            instance.connection = instance.connectionPoolEntry.connectionPool.getConnection();
        }
        if (instance.doPaging) {
            instance.searchRequest.setControls(new SimplePagedResultsControl(pageSize != 0 ? pageSize : instance.pageSize, instance.resumeCookie));
        }
        instance.resumeCookie = null;
        SearchResult searchResult;
        try {
            log.debug("Performing SearchRequest '{}' request on server '{}'", instance.searchRequest, instance.connection.getConnectedAddress());
            searchResult = instance.connection.search(instance.searchRequest);
        } catch (LDAPSearchException e) {
            log.debug("SearchRequest: Exception {}", (Object) e);
            log.trace("SearchRequest: Exception", e);
            log.trace("SearchRequest: Exception SearchReferences: {}", e.getSearchReferences());
            searchResult = e.getSearchResult();
        }
        log.debug("SearchResult: {}", searchResult);
        log.trace("SearchReferences: {}", searchResult.getSearchReferences());
        log.trace("SearchReferences: {}", searchResult.getSearchReferences());
        if (searchResult.getReferralURLs() != null && searchResult.getReferralURLs().length > 0) {
            if (log.isTraceEnabled()) {
                log.trace("Search Referral URLs: {}", Arrays.asList(searchResult.getReferralURLs()));
            }
            String host = searchResult.getReferralURLs()[0];
            try {
                LDAPConnection connection = instance.connection.getReferralConnector().getReferralConnection(new LDAPURL(host), instance.connection);
                instance.connection.close();
                instance.connection = connection;
                ret = new ArrayList<>();
            } catch (LDAPException e) {
                log.warn("{} Cannot connect referral '{}': {}", logPrefix, host, e.getMessage());
                log.debug("Exception", e);
            }
        } else {
            if (searchResult.getEntryCount() > 0) {
                ret = searchMapEntries(searchResult.getSearchEntries(), instance.attrMap);
            }
            if (searchResult.hasResponseControl(SimplePagedResultsControl.PAGED_RESULTS_OID)) {
                SimplePagedResultsControl responseControl = SimplePagedResultsControl.get(searchResult);
                if (responseControl.moreResultsToReturn()) {
                    instance.resumeCookie = responseControl.getCookie();
                }
            }
            instance.limitLeft -= searchResult.getEntryCount();
            if (instance.resumeCookie == null || instance.limitLeft <= 0) {
                instance.done = true;
            }
        }
    }
    log.trace("searchExecute Return: {}", ret);
    return ret;
}
#end_block

#method_before
private List<Map<String, List<String>>> executeVarQuery(Map<String, Object> vars, String varName) throws LDAPException {
    List<Map<String, List<String>>> ret = new ArrayList<>();
    List<String> queryVars = new ArrayList<>();
    for (String var : vars.keySet()) {
        if (var.startsWith(varName)) {
            queryVars.add(var);
        }
    }
    if (queryVars.size() > 0) {
        try {
            ExecutorService executor = Executors.newFixedThreadPool(queryVars.size());
            List<Future<List<Map<String, List<String>>>>> list = new ArrayList<>();
            for (String var : queryVars) {
                log.debug("Resolving query var '{}'", var);
                Framework.SearchInstance instance = (Framework.SearchInstance) vars.get(var);
                if (instance != null) {
                    Callable<List<Map<String, List<String>>>> searchExecute = framework.new SearchExecute(instance, 0);
                    Future<List<Map<String, List<String>>>> submit = executor.submit(searchExecute);
                    list.add(submit);
                }
            }
            for (Future<List<Map<String, List<String>>>> future : list) {
                try {
                    ret.addAll(future.get());
                } catch (InterruptedException | ExecutionException e) {
                    log.error("Failed to execute search: {}", e.getMessage());
                    log.debug("Exception", e);
                }
            }
            executor.shutdown();
        } finally {
            for (String var : queryVars) {
                Framework.SearchInstance instance = (Framework.SearchInstance) vars.get(var);
                if (instance != null) {
                    vars.remove(var);
                    try {
                        framework.searchClose(instance);
                    } catch (Exception e) {
                        log.error("Cannot close search of var '{}'", var);
                        log.debug("Cannot close search of var '{}', search: {}", var, instance);
                        log.debug("Exception", e);
                    }
                }
            }
        }
    }
    return ret;
}
#method_after
private List<Map<String, List<String>>> executeVarQuery(Map<String, Object> vars, String varName) throws LDAPException {
    List<Map<String, List<String>>> ret = new ArrayList<>();
    List<String> queryVars = new ArrayList<>();
    for (String var : vars.keySet()) {
        if (var.startsWith(varName)) {
            queryVars.add(var);
        }
    }
    if (queryVars.size() > 0) {
        try {
            ExecutorService executor = Executors.newFixedThreadPool(queryVars.size());
            List<Future<List<Map<String, List<String>>>>> list = new ArrayList<>();
            for (String var : queryVars) {
                log.debug("Resolving query var '{}'", var);
                Framework.SearchInstance instance = (Framework.SearchInstance) vars.get(var);
                if (instance != null) {
                    Callable<List<Map<String, List<String>>>> searchExecute = framework.new SearchExecute(instance, 0);
                    Future<List<Map<String, List<String>>>> submit = executor.submit(searchExecute);
                    list.add(submit);
                }
            }
            for (Future<List<Map<String, List<String>>>> future : list) {
                try {
                    ret.addAll(future.get());
                } catch (InterruptedException | ExecutionException e) {
                    throw new RuntimeException(e);
                }
            }
            executor.shutdown();
        } finally {
            for (String var : queryVars) {
                Framework.SearchInstance instance = (Framework.SearchInstance) vars.get(var);
                if (instance != null) {
                    vars.remove(var);
                    try {
                        framework.searchClose(instance);
                    } catch (Exception e) {
                        log.error("Cannot close search of var '{}': {}", var, e.getMessage());
                        log.debug("Search: {}", instance);
                        log.debug("Exception", e);
                    }
                }
            }
        }
    }
    return ret;
}
#end_block

#method_before
private void addNumaSetting() {
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#method_after
private void addNumaSetting() {
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.ALLOW_CONSOLE_RECONNECT);
    if (node != null) {
        vmBase.setAllowConsoleReconnect(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_POLICY_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationPolicyId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MAX_MEMORY_SIZE_MB);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMaxMemorySizeMb(Integer.parseInt(node.innerText));
        } else {
            vmBase.setMaxMemorySizeMb(VmCommonUtils.maxMemorySizeWithHotplugInMb(vmBase.getOsId(), null));
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = selectSingleNode(_document, "//*/Content");
    XmlNode node;
    vmBase.setVmInit(new VmInit());
    // set ovf version to the ovf object
    vmBase.setOvfVersion(getVersion());
    node = selectSingleNode(content, OvfProperties.DESCRIPTION);
    if (node != null) {
        vmBase.setDescription(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.COMMENT);
    if (node != null) {
        vmBase.setComment(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.DOMAIN);
    if (node != null) {
        vmBase.getVmInit().setDomain(node.innerText);
    }
    node = selectSingleNode(content, OvfProperties.CREATION_DATE);
    if (node != null) {
        Date creationDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (creationDate != null) {
            vmBase.setCreationDate(creationDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.EXPORT_DATE);
    if (node != null) {
        Date exportDate = OvfParser.utcDateStringToLocaDate(node.innerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = selectSingleNode(content, OvfProperties.DEFAULT_BOOT_SEQUENCE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultBootSequence(BootSequence.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.INITRD_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setInitrdUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_URL);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelUrl(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.KERNEL_PARAMS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setKernelParams(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.GENERATION);
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.innerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
    if (node != null) {
        vmBase.setCustomCompatibilityVersion(new Version(node.innerText));
    }
    // the originating ENGINE version
    Version originVersion = new Version(getVersion());
    node = selectSingleNode(content, OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    if (node != null) {
        originVersion = new Version(node.innerText);
    }
    vmBase.setClusterCompatibilityVersionOrigin(originVersion);
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = selectSingleNode(content, getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDefaultDisplayType(DisplayType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    XmlNodeList list = selectNodes(content, "Section");
    if (list != null) {
        // The Os need to be read before the hardware
        node = getNode(list, "xsi:type", "ovf:OperatingSystemSection_Type");
        if (node != null) {
            readOsSection(node);
            if (!osRepository.isLinux(vmBase.getOsId()) || vmBase.getDefaultDisplayType() != DisplayType.qxl) {
                vmBase.setSingleQxlPci(false);
            }
        }
        node = getNode(list, "xsi:type", "ovf:VirtualHardwareSection_Type");
        if (node != null) {
            readHardwareSection(node);
        }
        node = getNode(list, "xsi:type", "ovf:SnapshotsSection_Type");
        if (node != null) {
            readSnapshotsSection(node);
        }
    }
    // after reading the hardware section, if graphics device is still absent, add a default one
    addDefaultGraphicsDevice();
    // if boot order is not set, figure out some default based on the set of bootable disks
    setDefaultBootDevice();
    // due to dependency on vmBase.getOsId() must be read AFTER readOsSection
    node = selectSingleNode(content, OvfProperties.TIMEZONE);
    if (node != null && StringUtils.isNotEmpty(node.innerText)) {
        vmBase.setTimeZone(node.innerText);
    } else {
        if (osRepository.isWindows(vmBase.getOsId())) {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone));
        } else {
            vmBase.setTimeZone(Config.<String>getValue(ConfigValues.DefaultGeneralTimeZone));
        }
    }
    node = selectSingleNode(content, OvfProperties.ORIGIN);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setOrigin(OriginType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.VM_TYPE);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVmType(VmType.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_SMARTCARD_ENABLED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.NUM_OF_IOTHREADS);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setNumOfIoThreads(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.DELETE_PROTECTED);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.SSO_METHOD);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setSsoMethod(SsoMethod.fromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.TUNNEL_MIGRATION);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setTunnelMigration(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.VNC_KEYBOARD_LAYOUT);
    if (node != null) {
        if (!StringUtils.isEmpty(node.innerText)) {
            vmBase.setVncKeyboardLayout(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MIN_ALLOCATED_MEMORY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMinAllocatedMem(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_STATELESS);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setStateless(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_RUN_AND_PAUSE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setRunAndPause(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CREATED_BY_USER_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCreatedByUserId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_DOWNTIME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationDowntime(Integer.parseInt(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_SUPPORT);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            MigrationSupport migrationSupport = MigrationSupport.forValue(Integer.parseInt(node.innerText));
            vmBase.setMigrationSupport(migrationSupport);
        }
    }
    // TODO dedicated to multiple hosts
    readDedicatedHostsList();
    node = selectSingleNode(content, OvfProperties.SERIAL_NUMBER_POLICY);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setSerialNumberPolicy(SerialNumberPolicy.forValue(Integer.parseInt(node.innerText)));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_SERIAL_NUMBER);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomSerialNumber(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.AUTO_STARTUP);
    if (node != null) {
        vmBase.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.PRIORITY);
    if (node != null) {
        vmBase.setPriority(Integer.parseInt(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_BOOT_MENU_ENABLED);
    if (node != null) {
        vmBase.setBootMenuEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    if (node != null) {
        vmBase.setSpiceFileTransferEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    if (node != null) {
        vmBase.setSpiceCopyPasteEnabled(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.ALLOW_CONSOLE_RECONNECT);
    if (node != null) {
        vmBase.setAllowConsoleReconnect(Boolean.parseBoolean(node.innerText));
    }
    node = selectSingleNode(content, OvfProperties.IS_AUTO_CONVERGE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setAutoConverge(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.IS_MIGRATE_COMPRESSED);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrateCompressed(Boolean.parseBoolean(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.MIGRATION_POLICY_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMigrationPolicyId(Guid.createGuidFromString(node.innerText));
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_EMULATED_MACHINE);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomEmulatedMachine(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.CUSTOM_CPU_NAME);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setCustomCpuName(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.PREDEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setPredefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.USER_DEFINED_PROPERTIES);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setUserDefinedProperties(node.innerText);
        }
    }
    node = selectSingleNode(content, OvfProperties.MAX_MEMORY_SIZE_MB);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            vmBase.setMaxMemorySizeMb(Integer.parseInt(node.innerText));
        }
    }
    vmBase.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(vmBase.getPredefinedProperties(), vmBase.getUserDefinedProperties()));
    readGeneralData(content);
    readVmInit(content);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(VmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) && !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk))) {
        return false;
    }
    setStoragePoolId(getDiskImage().getStoragePoolId());
    if (!FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion().toString()));
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (getDiskImage().getVmEntityType().isTemplateType()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_TEMPLATE_DISK);
    }
    StorageDomain sd = storageDomainDao.get(getDiskImage().getStorageIds().get(0));
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(sd);
    if (!validate(storageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#method_after
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) && !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk))) {
        return false;
    }
    setStoragePoolId(getDiskImage().getStoragePoolId());
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (!FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_AMEND_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion().toString()));
    }
    if (getDiskImage().getVmEntityType().isTemplateType()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_AMEND_TEMPLATE_DISK);
    }
    setStorageDomainId(getDiskImage().getStorageIds().get(0));
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!validate(storageDomainValidator.isDomainExistAndActive())) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    // Allow runAction to succeed
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void handleFailure() {
    log.error("Command id: '{} failed child command status for step '{}'", getCommandId(), getParameters().getCommandStep());
}
#method_after
@Override
public void handleFailure() {
    log.error("Command '{}' id '{}' failed executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Cold Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.ColdMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.FINALIZE_MERGE);
            break;
        case FINALIZE_MERGE:
            nextCommand = new Pair<>(VdcActionType.FinalizeMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters(getActiveDiskImage().getId(), Collections.singletonList(getDestinationImageId()), VdcActionType.ColdMergeSnapshotSingleDisk));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters(getActiveDiskImage().getId(), Collections.singletonList(getDestinationImageId()), VdcActionType.ColdMergeSnapshotSingleDisk));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.ColdMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.FINALIZE_MERGE);
            break;
        case FINALIZE_MERGE:
            nextCommand = new Pair<>(VdcActionType.FinalizeMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            nextCommand = buildDestroyCommand(VdcActionType.DestroyImage, getActionType(), Collections.singletonList(getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = buildDestroyCommand(VdcActionType.DestroyImageCheck, getActionType(), Collections.singletonList(getDestinationImageId()));
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommandIfNeeded();
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new ColdMergeSnapshotSingleDiskCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(VdcActionType.ColdMergeSnapshotSingleDisk);
    parameters.setParentParameters(getParameters());
    return parameters;
}
#method_after
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    return parameters;
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters(getActiveDiskImage().getId(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()), VdcActionType.RemoveSnapshotSingleDiskLive));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters(getActiveDiskImage().getId(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()), VdcActionType.RemoveSnapshotSingleDiskLive));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = buildDestroyCommand(VdcActionType.DestroyImage, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = buildDestroyCommand(VdcActionType.DestroyImageCheck, getActionType(), new ArrayList<>(getParameters().getMergeStatusReturnValue().getImagesToRemove()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
protected void syncChildCommandList(RemoveSnapshotSingleDiskStep commandStep, Map<RemoveSnapshotSingleDiskStep, Guid> childCommands) {
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != childCommands.size()) {
        for (Guid id : childCommandIds) {
            if (!childCommands.containsValue(id)) {
                childCommands.put(commandStep, id);
                break;
            }
        }
    }
}
#method_after
protected void syncChildCommandList(RemoveSnapshotSingleDiskParameters parameters) {
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != parameters.getChildCommands().size()) {
        for (Guid id : childCommandIds) {
            if (!parameters.getChildCommands().containsValue(id)) {
                parameters.getChildCommands().put(parameters.getCommandStep(), id);
                break;
            }
        }
    }
}
#end_block

#method_before
protected Guid getCurrentChildId(RemoveSnapshotSingleDiskStep commandStep, Map<RemoveSnapshotSingleDiskStep, Guid> childCommands) {
    return childCommands.get(commandStep);
}
#method_after
protected Guid getCurrentChildId(RemoveSnapshotSingleDiskParameters parameters) {
    return parameters.getChildCommands().get(parameters.getCommandStep());
}
#end_block

#method_before
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#method_after
@Override
public void close() {
    HttpUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneVmReturnForXmlRpc create(Map createInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.create").withParameter("vmID", getVmId(createInfo)).withParameter("vmParams", createInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneVmReturn create(Map createInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.create").withParameter("vmID", getVmId(createInfo)).withParameter("vmParams", createInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc allocateVolume(String spUUID, String sdUUID, String imgGUID, String volUUID, String size) {
    JsonRpcRequest request = new RequestBuilder("Volume.allocate").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn allocateVolume(String spUUID, String sdUUID, String imgGUID, String volUUID, String size) {
    JsonRpcRequest request = new RequestBuilder("Volume.allocate").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
@SuppressWarnings("rawtypes")
public StatusOnlyReturn copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc destroy(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.destroy").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn destroy(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.destroy").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn shutdown(String vmId, String timeout, String message) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message, boolean reboot) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).withParameter("reboot", reboot).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn shutdown(String vmId, String timeout, String message, boolean reboot) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).withParameter("reboot", reboot).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc pause(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.pause").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn pause(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.pause").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hibernate(String vmId, String hiberVolHandle) {
    JsonRpcRequest request = new RequestBuilder("VM.hibernate").withParameter("vmID", vmId).withParameter("hibernationVolHandle", hiberVolHandle).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn hibernate(String vmId, String hiberVolHandle) {
    JsonRpcRequest request = new RequestBuilder("VM.hibernate").withParameter("vmID", vmId).withParameter("hibernationVolHandle", hiberVolHandle).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc resume(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.cont").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn resume(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.cont").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc fullList(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn fullList(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setMOMPolicyParameters(Map<String, Object> values) {
    JsonRpcRequest request = new RequestBuilder("Host.setMOMPolicyParameters").withParameter("key_value_store", values).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setMOMPolicyParameters(Map<String, Object> values) {
    JsonRpcRequest request = new RequestBuilder("Host.setMOMPolicyParameters").withParameter("key_value_store", values).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc desktopLogin(String vmId, String domain, String user, String password) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogin").withParameter("vmID", vmId).withParameter("domain", domain).withParameter("username", user).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn desktopLogin(String vmId, String domain, String user, String password) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogin").withParameter("vmID", vmId).withParameter("domain", domain).withParameter("username", user).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc desktopLogoff(String vmId, String force) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogoff").withParameter("vmID", vmId).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn desktopLogoff(String vmId, String force) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogoff").withParameter("vmID", vmId).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public VMInfoListReturnForXmlRpc getVmStats(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getStats").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList");
    return new VMInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public VMInfoListReturn getVmStats(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getStats").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList");
    return new VMInfoListReturn(response);
}
#end_block

#method_before
@Override
public VMInfoListReturnForXmlRpc getAllVmStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllVmStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList").withResponseType(Object[].class);
    return new VMInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public VMInfoListReturn getAllVmStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllVmStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList").withResponseType(Object[].class);
    return new VMInfoListReturn(response);
}
#end_block

#method_before
@Override
public HostDevListReturnForXmlRpc hostDevListByCaps() {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevListByCaps").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("deviceList");
    return new HostDevListReturnForXmlRpc(response);
}
#method_after
@Override
public HostDevListReturn hostDevListByCaps() {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevListByCaps").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("deviceList");
    return new HostDevListReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturnForXmlRpc(response);
}
#method_after
@Override
public MigrateStatusReturn migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateCancel(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.migrateCancel").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn migrateCancel(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.migrateCancel").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, Map<String, Object> driveSpec) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", driveSpec).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeDisk(String vmId, Map<String, Object> driveSpec) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", driveSpec).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setSafeNetworkConfig() {
    JsonRpcRequest request = new RequestBuilder("Host.setSafeNetworkConfig").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setSafeNetworkConfig() {
    JsonRpcRequest request = new RequestBuilder("Host.setSafeNetworkConfig").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturn fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturn(response);
}
#end_block

#method_before
@Override
public ServerConnectionStatusReturnForXmlRpc connectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturnForXmlRpc(response);
}
#method_after
@Override
public ServerConnectionStatusReturn connectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturn(response);
}
#end_block

#method_before
@Override
public ServerConnectionStatusReturnForXmlRpc disconnectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturnForXmlRpc(response);
}
#method_after
@Override
public ServerConnectionStatusReturn disconnectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc formatStorageDomain(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.format").withParameter("storagedomainID", sdUUID).withParameter("autoDetach", false).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn formatStorageDomain(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.format").withParameter("storagedomainID", sdUUID).withParameter("autoDetach", false).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc disconnectStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn disconnectStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    // no lockPolicy and hostSpmId not needed can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.reconstructMaster").withParameter("storagepoolID", spUUID).withParameter("hostId", hostSpmId).withParameter("name", poolName).withParameter("masterSdUUID", masterDom).withParameter("masterVersion", masterVersion).withParameter("domainDict", domDict).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    // no lockPolicy and hostSpmId not needed can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.reconstructMaster").withParameter("storagepoolID", spUUID).withParameter("hostId", hostSpmId).withParameter("name", poolName).withParameter("masterSdUUID", masterDom).withParameter("masterVersion", masterVersion).withParameter("domainDict", domDict).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDomainStatsReturnForXmlRpc getStorageDomainStats(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getStats").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new OneStorageDomainStatsReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDomainStatsReturn getStorageDomainStats(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getStats").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new OneStorageDomainStatsReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDomainInfoReturnForXmlRpc getStorageDomainInfo(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getInfo").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneStorageDomainInfoReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDomainInfoReturn getStorageDomainInfo(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getInfo").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneStorageDomainInfoReturn(response);
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDomainListReturn getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneVGReturnForXmlRpc getVGInfo(String vgUUID) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.getInfo").withParameter("lvmvolumegroupID", vgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneVGReturnForXmlRpc(response);
}
#method_after
@Override
public OneVGReturn getVGInfo(String vgUUID) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.getInfo").withParameter("lvmvolumegroupID", vgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneVGReturn(response);
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturn getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturn(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturn getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturn(response);
}
#end_block

#method_before
@Override
public IQNListReturnForXmlRpc discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturnForXmlRpc(response);
}
#method_after
@Override
public IQNListReturn discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc spmStop(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStop").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn spmStop(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStop").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public SpmStatusReturnForXmlRpc spmStatus(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getSpmStatus").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("spm_st");
    return new SpmStatusReturnForXmlRpc(response);
}
#method_after
@Override
public SpmStatusReturn spmStatus(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getSpmStatus").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("spm_st");
    return new SpmStatusReturn(response);
}
#end_block

#method_before
@Override
public HostJobsReturnForXmlRpc getHostJobs(String jobType, List<String> jobIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getJobs").withOptionalParameter("job_type", jobType).withOptionalParameterAsList("job_ids", jobIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("jobs");
    return new HostJobsReturnForXmlRpc(response);
}
#method_after
@Override
public HostJobsReturn getHostJobs(String jobType, List<String> jobIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getJobs").withOptionalParameter("job_type", jobType).withOptionalParameterAsList("job_ids", jobIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("jobs");
    return new HostJobsReturn(response);
}
#end_block

#method_before
@Override
public TaskStatusReturnForXmlRpc getTaskStatus(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.getStatus").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("taskStatus");
    return new TaskStatusReturnForXmlRpc(response);
}
#method_after
@Override
public TaskStatusReturn getTaskStatus(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.getStatus").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("taskStatus");
    return new TaskStatusReturn(response);
}
#end_block

#method_before
@Override
public TaskStatusListReturnForXmlRpc getAllTasksStatuses() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksStatuses").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksStatus");
    return new TaskStatusListReturnForXmlRpc(response);
}
#method_after
@Override
public TaskStatusListReturn getAllTasksStatuses() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksStatuses").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksStatus");
    return new TaskStatusListReturn(response);
}
#end_block

#method_before
@Override
public TaskInfoListReturnForXmlRpc getAllTasksInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksInfo");
    return new TaskInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public TaskInfoListReturn getAllTasksInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksInfo");
    return new TaskInfoListReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc stopTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.stop").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn stopTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.stop").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc clearTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.clear").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn clearTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.clear").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc revertTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.revert").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn revertTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.revert").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotunplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotPlugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotUnplugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, Map device) {
    JsonRpcRequest request = new RequestBuilder("VM.updateDevice").withParameter("vmID", vmId).withParameter("params", device).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn vmUpdateDevice(String vmId, Map device) {
    JsonRpcRequest request = new RequestBuilder("VM.updateDevice").withParameter("vmID", vmId).withParameter("params", device).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public AlignmentScanReturnForXmlRpc getDiskAlignment(String vmId, Map<String, String> driveSpecs) {
    JsonRpcRequest request = new RequestBuilder("VM.getDiskAlignment").withParameter("vmID", vmId).withParameter("disk", driveSpecs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("alignment");
    return new AlignmentScanReturnForXmlRpc(response);
}
#method_after
@Override
public AlignmentScanReturn getDiskAlignment(String vmId, Map<String, String> driveSpecs) {
    JsonRpcRequest request = new RequestBuilder("VM.getDiskAlignment").withParameter("vmID", vmId).withParameter("disk", driveSpecs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("alignment");
    return new AlignmentScanReturn(response);
}
#end_block

#method_before
@Override
public ImageSizeReturnForXmlRpc diskSizeExtend(String vmId, Map<String, String> diskParams, String newSize) {
    JsonRpcRequest request = new RequestBuilder("VM.diskSizeExtend").withParameter("vmID", vmId).withParameter("driveSpecs", diskParams).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ImageSizeReturnForXmlRpc(response);
}
#method_after
@Override
public ImageSizeReturn diskSizeExtend(String vmId, Map<String, String> diskParams, String newSize) {
    JsonRpcRequest request = new RequestBuilder("VM.diskSizeExtend").withParameter("vmID", vmId).withParameter("driveSpecs", diskParams).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ImageSizeReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc merge(String vmId, Map<String, String> drive, String baseVolUUID, String topVolUUID, String bandwidth, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("VM.merge").withParameter("vmID", vmId).withParameter("drive", drive).withParameter("baseVolUUID", baseVolUUID).withParameter("topVolUUID", topVolUUID).withParameter("bandwidth", bandwidth).withParameter("jobUUID", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn merge(String vmId, Map<String, String> drive, String baseVolUUID, String topVolUUID, String bandwidth, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("VM.merge").withParameter("vmID", vmId).withParameter("drive", drive).withParameter("baseVolUUID", baseVolUUID).withParameter("topVolUUID", topVolUUID).withParameter("bandwidth", bandwidth).withParameter("jobUUID", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withParameter("arbiter", isArbiter).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSet(String volumeName, String key, String value) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.set").withParameter("volumeName", volumeName).withParameter("option", key).withParameter("value", value).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSet(String volumeName, String key, String value) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.set").withParameter("volumeName", volumeName).withParameter("option", key).withParameter("value", value).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.start").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeStart(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.start").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStop(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.stop").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeStop(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.stop").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.delete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.delete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeReset(String volumeName, String volumeOption, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.reset").withParameter("volumeName", volumeName).withParameter("option", volumeOption).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeReset(String volumeName, String volumeOption, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.reset").withParameter("volumeName", volumeName).withParameter("option", volumeOption).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeOptionsInfoReturnForXmlRpc glusterVolumeSetOptionsList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.setOptionsList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeOptionsInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeOptionsInfoReturn glusterVolumeSetOptionsList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.setOptionsList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeOptionsInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturn glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStart").withParameter("volumeName", volumeName).withParameter("rebalanceType", fixLayoutOnly).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturn glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStart").withParameter("volumeName", volumeName).withParameter("rebalanceType", fixLayoutOnly).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturn(response);
}
#end_block

#method_before
@Override
public BooleanReturnForXmlRpc glusterVolumeEmptyCheck(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.volumeEmptyCheck").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new BooleanReturnForXmlRpc(response, "volumeEmptyCheck");
}
#method_after
@Override
public BooleanReturn glusterVolumeEmptyCheck(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.volumeEmptyCheck").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new BooleanReturn(response, "volumeEmptyCheck");
}
#end_block

#method_before
@Override
public GlusterHostsPubKeyReturnForXmlRpc glusterGeoRepKeysGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysGet").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterHostsPubKeyReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHostsPubKeyReturn glusterGeoRepKeysGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysGet").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterHostsPubKeyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRebalanceStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeReplaceBrickCommitForce(String volumeName, String existingBrickDir, String newBrickDir) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.replaceBrickCommitForce").withParameter("volumeName", volumeName).withParameter("existingBrick", existingBrickDir).withParameter("newBrick", newBrickDir).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeReplaceBrickCommitForce(String volumeName, String existingBrickDir, String newBrickDir) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.replaceBrickCommitForce").withParameter("volumeName", volumeName).withParameter("existingBrick", existingBrickDir).withParameter("newBrick", newBrickDir).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHostRemove(String hostName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.remove").withParameter("hostName", hostName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHostRemove(String hostName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.remove").withParameter("hostName", hostName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHostAdd(String hostName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.add").withParameter("hostName", hostName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHostAdd(String hostName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.add").withParameter("hostName", hostName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterServersListReturnForXmlRpc glusterServersList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServersListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterServersListReturn glusterServersList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServersListReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateStart").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateStart").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateFinish").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateFinish").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeProfileStart(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStart").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeProfileStart(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStart").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeProfileStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeProfileStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigList glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigList(response);
}
#end_block

#method_before
@Override
public GlusterVolumeStatusReturnForXmlRpc glusterVolumeStatus(Guid clusterId, String volumeName, String brickName, String volumeStatusOption) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.status").withParameter("volumeName", volumeName).withParameter("brick", brickName).withParameter("statusOption", volumeStatusOption).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeStatusReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeStatusReturn glusterVolumeStatus(Guid clusterId, String volumeName, String brickName, String volumeStatusOption) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.status").withParameter("volumeName", volumeName).withParameter("brick", brickName).withParameter("statusOption", volumeStatusOption).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeStatusReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesListReturnForXmlRpc glusterVolumesList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumesListReturn glusterVolumesList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesListReturnForXmlRpc glusterVolumeInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumesListReturn glusterVolumeInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesHealInfoReturnForXmlRpc glusterVolumeHealInfo(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.healInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesHealInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumesHealInfoReturn glusterVolumeHealInfo(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.healInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesHealInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeProfileInfoReturn glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturn(clusterId, response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookEnable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.enable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookEnable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.enable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookDisable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.disable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookDisable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.disable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterHooksListReturnForXmlRpc glusterHooksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHooksListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHooksListReturn glusterHooksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHooksListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterHostUUIDGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.uuid").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn glusterHostUUIDGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.uuid").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturn glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturn(serverId, response);
}
#end_block

#method_before
@Override
public GlusterHookContentInfoReturnForXmlRpc glusterHookRead(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.read").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHookContentInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHookContentInfoReturn glusterHookRead(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.read").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHookContentInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookUpdate(String glusterCommand, String stage, String hookName, String content, String checksum) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.update").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookUpdate(String glusterCommand, String stage, String hookName, String content, String checksum) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.update").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookAdd(String glusterCommand, String stage, String hookName, String content, String checksum, Boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.add").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).withParameter("enable", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookAdd(String glusterCommand, String stage, String hookName, String content, String checksum, Boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.add").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).withParameter("enable", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookRemove(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.remove").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookRemove(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.remove").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturn glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturn(serverId, response);
}
#end_block

#method_before
@Override
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfoReturnForXmlRpc(response);
}
#method_after
@Override
public StoragePoolInfo getStoragePoolInfo(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfo(response);
}
#end_block

#method_before
@Override
public GlusterTasksListReturnForXmlRpc glusterTasksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterTask.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTasksListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTasksListReturn glusterTasksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterTask.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTasksListReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStatus(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStatus").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRebalanceStatus(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStatus").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetail glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetail(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setNumberOfCpus(String vmId, String numberOfCpus) {
    JsonRpcRequest request = new RequestBuilder("VM.setNumberOfCpus").withParameter("vmID", vmId).withParameter("numberOfCpus", numberOfCpus).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setNumberOfCpus(String vmId, String numberOfCpus) {
    JsonRpcRequest request = new RequestBuilder("VM.setNumberOfCpus").withParameter("vmID", vmId).withParameter("numberOfCpus", numberOfCpus).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotplugMemory(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugMemory").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
@SuppressWarnings("rawtypes")
public StatusOnlyReturn hotplugMemory(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugMemory").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setHaMaintenanceMode(String mode, boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("Host.setHaMaintenanceMode").withParameter("mode", mode).withParameter("enabled", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setHaMaintenanceMode(String mode, boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("Host.setHaMaintenanceMode").withParameter("mode", mode).withParameter("enabled", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc remove_image_ticket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.remove_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn remove_image_ticket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.remove_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extend_image_ticket(String ticketId, long timeout) {
    JsonRpcRequest request = new RequestBuilder("Host.extend_image_ticket").withParameter("uuid", ticketId).withParameter("timeout", timeout).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn extend_image_ticket(String ticketId, long timeout) {
    JsonRpcRequest request = new RequestBuilder("Host.extend_image_ticket").withParameter("uuid", ticketId).withParameter("timeout", timeout).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneMapReturnForXmlRpc get_image_transfer_session_stats(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_transfer_session_stats").withParameter("ticketUUID", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsMap");
    return new OneMapReturnForXmlRpc(response);
}
#method_after
@Override
public OneMapReturn get_image_transfer_session_stats(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_transfer_session_stats").withParameter("ticketUUID", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsMap");
    return new OneMapReturn(response);
}
#end_block

#method_before
@Override
public PrepareImageReturnForXmlRpc prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturnForXmlRpc(response);
}
#method_after
@Override
public PrepareImageReturn prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc teardownImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.teardown").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("leafVolID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn teardownImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.teardown").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("leafVolID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc verifyUntrustedVolume(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Volume.verify_untrusted").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn verifyUntrustedVolume(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Volume.verify_untrusted").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VMNamesListReturnForXmlRpc getExternalVmNamesList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMNames").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmNames").withResponseType(Object[].class);
    return new VMNamesListReturnForXmlRpc(response);
}
#method_after
@Override
public VMNamesListReturn getExternalVmNamesList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMNames").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmNames").withResponseType(Object[].class);
    return new VMNamesListReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotInfoReturnForXmlRpc glusterVolumeSnapshotList(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotList").withOptionalParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeSnapshotInfoReturn glusterVolumeSnapshotList(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotList").withOptionalParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotInfoReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotConfigReturnForXmlRpc glusterSnapshotConfigList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotConfigReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeSnapshotConfigReturn glusterSnapshotConfigList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotConfigReturn(clusterId, response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotDelete(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.delete").withOptionalParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotDelete(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.delete").withOptionalParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotDeleteAll(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSnapshotDeleteAll(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotActivate(String snapshotName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.activate").withParameter("snapName", snapshotName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotActivate(String snapshotName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.activate").withParameter("snapName", snapshotName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotDeactivate(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.deactivate").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotDeactivate(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.deactivate").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotRestore(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.restore").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotRestore(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.restore").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotCreateReturnForXmlRpc glusterVolumeSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeSnapshotCreateReturn glusterVolumeSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StorageDeviceListReturnForXmlRpc glusterStorageDeviceList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.storageDevicesList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StorageDeviceListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDeviceListReturn glusterStorageDeviceList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.storageDevicesList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StorageDeviceListReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDeviceReturn glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hostdevChangeNumvfs(String deviceName, int numOfVfs) {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevChangeNumvfs").withParameter("deviceName", deviceName).withParameter("numvfs", numOfVfs).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn hostdevChangeNumvfs(String deviceName, int numOfVfs) {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevChangeNumvfs").withParameter("deviceName", deviceName).withParameter("numvfs", numOfVfs).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc convertVmFromOva(String ovaPath, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVmFromOva").withParameter("ova_path", ovaPath).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn convertVmFromOva(String ovaPath, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVmFromOva").withParameter("ova_path", ovaPath).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.getConvertedVm").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ovf").withResponseType(String.class);
    return new OvfReturnForXmlRpc(response);
}
#method_after
@Override
public OvfReturn getConvertedVm(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.getConvertedVm").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ovf").withResponseType(String.class);
    return new OvfReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc deleteV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.deleteV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn deleteV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.deleteV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc abortV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.abortV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn abortV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.abortV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotScheduleOverride(boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleOverride").withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotScheduleOverride(boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleOverride").withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotScheduleReset() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleReset").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotScheduleReset() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleReset").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturn registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc unregisterSecrets(String[] libvirtSecretsUuids) {
    JsonRpcRequest request = new RequestBuilder("Host.unregisterSecrets").withParameter("uuids", libvirtSecretsUuids).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn unregisterSecrets(String[] libvirtSecretsUuids) {
    JsonRpcRequest request = new RequestBuilder("Host.unregisterSecrets").withParameter("uuids", libvirtSecretsUuids).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc freeze(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.freeze").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn freeze(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.freeze").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc thaw(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.thaw").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn thaw(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.thaw").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc isolateVolume(String sdUUID, String srcImageID, String dstImageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("SDM.isolateVolume").withParameter("storagedomainID", sdUUID).withParameter("srcImageID", srcImageID).withParameter("dstImageID", dstImageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn isolateVolume(String sdUUID, String srcImageID, String dstImageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("SDM.isolateVolume").withParameter("storagedomainID", sdUUID).withParameter("srcImageID", srcImageID).withParameter("dstImageID", dstImageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc wipeVolume(String sdUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.wipeVolume").withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn wipeVolume(String sdUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.wipeVolume").withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc getExternalVmFromOva(String ovaPath) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVmFromOva").withParameter("ova_path", ovaPath).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn getExternalVmFromOva(String ovaPath) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVmFromOva").withParameter("ova_path", ovaPath).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc refreshVolume(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.refresh").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn refreshVolume(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.refresh").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public VolumeInfoReturnForXmlRpc getVolumeInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new VolumeInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VolumeInfoReturn getVolumeInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new VolumeInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc sparsifyVolume(String jobId, Map<String, Object> volumeAddress) {
    JsonRpcRequest request = new RequestBuilder("SDM.sparsify_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeAddress).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn sparsifyVolume(String jobId, Map<String, Object> volumeAddress) {
    JsonRpcRequest request = new RequestBuilder("SDM.sparsify_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeAddress).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    // Allow runAction to succeed
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void handleFailure() {
    log.error("Command id: '{} failed child command status for step '{}'", getCommandId(), getParameters().getCommandStep());
}
#method_after
@Override
public void handleFailure() {
    log.error("Command '{}' id '{}' failed executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.EXTEND);
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.ColdMergeExtend, buildMergeParameters(VdcActionType.ColdMergeSnapshotSingleDisk));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.ColdMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            break;
        case SYNC_VOLUME_CHAIN:
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.ColdMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.FINALIZE_MERGE);
            break;
        case FINALIZE_MERGE:
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
    }
    persistCommandIfNeeded();
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new RemoveSnapshotSingleDiskLiveCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return null;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return Collections.emptyList();
}
#end_block

#method_before
private ColdMergeCommandParameters buildColdMergeParameters(Guid topImageGuid, Guid baseImageGuid) {
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getParameters().getJobId(), baseImageGuid, topImageGuid);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(VdcActionType.ColdMergeSnapshotSingleDisk);
    parameters.setParentParameters(getParameters());
    return parameters;
}
#method_after
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    return parameters;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.ColdMerge, new ColdMergeVDSCommandParameters(getParameters().getStorageJobId(), getParameters().getBaseVolumeGuid(), getParameters().getTopVolumeGuid()), getParameters().getStoragePoolId(), this);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.ColdMerge, new ColdMergeVDSCommandParameters(getParameters().getStorageJobId(), getParameters().getSubchainInfo()), getParameters().getStoragePoolId(), this);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected StepEnum getCommandStep() {
    return StepEnum.COLD_MERGE;
}
#method_after
@Override
protected StepEnum getCommandStep() {
    return StepEnum.MERGE_SNAPSHOTS;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    log.info("-- executeVdsBrokerCommand: calling 'merge'");
    Map<String, String> mergeInfo = new HashMap<>(2);
    mergeInfo.put("top_vol_id", getParameters().getTopVolumeGuid().toString());
    mergeInfo.put("base_vol_id", getParameters().getBaseVolumeGuid().toString());
    status = getBroker().mergeSnapshots(getParameters().getStorageJobId().toString(), mergeInfo);
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    log.info("-- executeVdsBrokerCommand: calling 'mergeSubchain'");
    status = getBroker().mergeSubchain(getParameters().getJobId().toString(), SubchainInfoHelper.prepareSubchainInfoForVdsCommand(getParameters().getSubchainInfo()));
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVolume(String sdUUID, String spUUID, String imgGUID, String size, int volFormat, int volType, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID, String initialSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.create").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).withParameter("volFormat", volFormat).withParameter("preallocate", volType).withParameter("diskType", diskType).withParameter("desc", descr).withParameter("srcImgUUID", srcImgGUID).withParameter("srcVolUUID", srcVolUUID).withOptionalParameter("initialSize", initialSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn createVolume(String sdUUID, String spUUID, String imgGUID, String size, int volFormat, int volType, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID, String initialSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.create").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).withParameter("volFormat", volFormat).withParameter("preallocate", volType).withParameter("diskType", diskType).withParameter("desc", descr).withParameter("srcImgUUID", srcImgGUID).withParameter("srcVolUUID", srcVolUUID).withOptionalParameter("initialSize", initialSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    return copyImage(sdUUID, spUUID, vmGUID, srcImgGUID, srcVolUUID, dstImgGUID, dstVolUUID, descr, dstSdUUID, volType, volFormat, preallocate, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, Boolean discard, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturnForXmlRpc downloadImage(Map methodInfo, String spUUID, String sdUUID, String dstImgGUID, String dstVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.download").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", dstImgGUID).withParameter("volumeID", dstVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturn downloadImage(Map methodInfo, String spUUID, String sdUUID, String dstImgGUID, String dstVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.download").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", dstImgGUID).withParameter("volumeID", dstVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturnForXmlRpc uploadImage(Map methodInfo, String spUUID, String sdUUID, String srcImgGUID, String srcVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.upload").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("volumeID", srcVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturn uploadImage(Map methodInfo, String spUUID, String sdUUID, String srcImgGUID, String srcVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.upload").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("volumeID", srcVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    return mergeSnapshots(sdUUID, spUUID, vmGUID, imgGUID, ancestorUUID, successorUUID, postZero, null);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero, Boolean discard) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).withOptionalParameter("discard", discard).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public VolumeListReturnForXmlRpc reconcileVolumeChain(String spUUID, String sdUUID, String imgGUID, String leafVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.reconcileVolumeChain").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("leafVolID", leafVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("volumes").withResponseType(Object[].class);
    return new VolumeListReturnForXmlRpc(response);
}
#method_after
@Override
public VolumeListReturn reconcileVolumeChain(String spUUID, String sdUUID, String imgGUID, String leafVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.reconcileVolumeChain").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("leafVolID", leafVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("volumes").withResponseType(Object[].class);
    return new VolumeListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    return deleteVolume(sdUUID, spUUID, imgGUID, volUUID, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("discard", discard).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public IrsStatsAndStatusXmlRpc getIrsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageRepoStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new IrsStatsAndStatusXmlRpc(response);
}
#method_after
@Override
public IrsStatsAndStatus getIrsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageRepoStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new IrsStatsAndStatus(response);
}
#end_block

#method_before
@Override
public FileStatsReturnForXmlRpc getFileStats(String sdUUID, String pattern, boolean caseSensitive) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getFileStats").withParameter("storagedomainID", sdUUID).withParameter("pattern", pattern).withParameter("caseSensitive", caseSensitive).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fileStats");
    return new FileStatsReturnForXmlRpc(response);
}
#method_after
@Override
public FileStatsReturn getFileStats(String sdUUID, String pattern, boolean caseSensitive) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getFileStats").withParameter("storagedomainID", sdUUID).withParameter("pattern", pattern).withParameter("caseSensitive", caseSensitive).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fileStats");
    return new FileStatsReturn(response);
}
#end_block

#method_before
@Override
public StorageStatusReturnForXmlRpc activateStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.activate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("storageStatus").withResponseType(String.class);
    return new StorageStatusReturnForXmlRpc(response);
}
#method_after
@Override
public StorageStatusReturn activateStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.activate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("storageStatus").withResponseType(String.class);
    return new StorageStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc deactivateStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.deactivate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn deactivateStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.deactivate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc detachStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn detachStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc forcedDetachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("force", true).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn forcedDetachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("force", true).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc attachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.attach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn attachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.attach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setStorageDomainDescription(String sdUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.setDescription").withParameter("storagedomainID", sdUUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setStorageDomainDescription(String sdUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.setDescription").withParameter("storagedomainID", sdUUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extendStorageDomain(String sdUUID, String spUUID, String[] devlist, boolean force) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.extend").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(devlist))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn extendStorageDomain(String sdUUID, String spUUID, String[] devlist, boolean force) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.extend").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(devlist))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public ResizeStorageDomainPVMapReturnForXmlRpc resizeStorageDomainPV(String sdUUID, String spUUID, String device) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.resizePV").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("guid", device).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ResizeStorageDomainPVMapReturnForXmlRpc(response);
}
#method_after
@Override
public ResizeStorageDomainPVMapReturn resizeStorageDomainPV(String sdUUID, String spUUID, String device) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.resizePV").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("guid", device).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ResizeStorageDomainPVMapReturn(response);
}
#end_block

#method_before
@Override
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    // duplicated in IVdsServer#getStoragePoolInfo
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfoReturnForXmlRpc(response);
}
#method_after
@Override
public StoragePoolInfo getStoragePoolInfo(String spUUID) {
    // duplicated in IVdsServer#getStoragePoolInfo
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfo(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc destroyStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.destroy").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn destroyStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.destroy").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    return deleteImage(sdUUID, spUUID, imgGUID, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    return moveImage(spUUID, srcDomUUID, dstDomUUID, imgGUID, vmGUID, op, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc cloneImageStructure(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.cloneStructure").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn cloneImageStructure(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.cloneStructure").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc syncImageData(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID, String syncType) {
    JsonRpcRequest request = new RequestBuilder("Image.syncData").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("syncType", syncType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn syncImageData(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID, String syncType) {
    JsonRpcRequest request = new RequestBuilder("Image.syncData").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("syncType", syncType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVM(String spUUID, Map[] vms) {
    return updateVMInImportExport(spUUID, vms, null);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVM(String spUUID, Map[] vms) {
    return updateVMInImportExport(spUUID, vms, null);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID) {
    return removeVM(spUUID, vmGUID, null);
}
#method_after
@Override
public StatusOnlyReturn removeVM(String spUUID, String vmGUID) {
    return removeVM(spUUID, vmGUID, null);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVMInImportExport(String spUUID, Map[] vms, String StorageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.updateVMs").withParameter("storagepoolID", spUUID).withParameter("vmList", new ArrayList<>(Arrays.asList(vms))).withOptionalParameter("storagedomainID", StorageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVMInImportExport(String spUUID, Map[] vms, String StorageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.updateVMs").withParameter("storagepoolID", spUUID).withParameter("vmList", new ArrayList<>(Arrays.asList(vms))).withOptionalParameter("storagedomainID", StorageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID, String storageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.removeVM").withParameter("storagepoolID", spUUID).withParameter("vmUUID", vmGUID).withOptionalParameter("storagedomainID", storageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn removeVM(String spUUID, String vmGUID, String storageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.removeVM").withParameter("storagepoolID", spUUID).withParameter("vmUUID", vmGUID).withOptionalParameter("storagedomainID", storageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GetVmsInfoReturnForXmlRpc getVmsInfo(String storagePoolId, String storageDomainId, String[] VMIDList) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getBackedUpVmsInfo").withParameter("storagepoolID", storagePoolId).withParameter("storagedomainID", storageDomainId).withParameter("vmList", new ArrayList<>(Arrays.asList(VMIDList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmlist");
    return new GetVmsInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GetVmsInfoReturn getVmsInfo(String storagePoolId, String storageDomainId, String[] VMIDList) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getBackedUpVmsInfo").withParameter("storagepoolID", storagePoolId).withParameter("storagedomainID", storageDomainId).withParameter("vmList", new ArrayList<>(Arrays.asList(VMIDList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmlist");
    return new GetVmsInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc upgradeStoragePool(String storagePoolId, String targetVersion) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.upgrade").withParameter("storagepoolID", storagePoolId).withParameter("targetDomVersion", targetVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn upgradeStoragePool(String storagePoolId, String targetVersion) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.upgrade").withParameter("storagepoolID", storagePoolId).withParameter("targetDomVersion", targetVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public ImagesListReturnForXmlRpc getImagesList(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getImages").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("imageslist").withResponseType(Object[].class);
    return new ImagesListReturnForXmlRpc(response);
}
#method_after
@Override
public ImagesListReturn getImagesList(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getImages").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("imageslist").withResponseType(Object[].class);
    return new ImagesListReturn(response);
}
#end_block

#method_before
@Override
public UUIDListReturnForXmlRpc getVolumesList(String sdUUID, String spUUID, String imgUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getVolumes").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("imageID", imgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuidlist").withResponseType(Object[].class);
    return new UUIDListReturnForXmlRpc(response);
}
#method_after
@Override
public UUIDListReturn getVolumesList(String sdUUID, String spUUID, String imgUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getVolumes").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("imageID", imgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuidlist").withResponseType(Object[].class);
    return new UUIDListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc extendVolumeSize(String spUUID, String sdUUID, String imageUUID, String volumeUUID, String newSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.extendSize").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imageUUID).withParameter("volumeID", volumeUUID).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn extendVolumeSize(String spUUID, String sdUUID, String imageUUID, String volumeUUID, String newSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.extendSize").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imageUUID).withParameter("volumeID", volumeUUID).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setVolumeDescription(String sdUUID, String spUUID, String imgGUID, String volUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("Volume.setDescription").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setVolumeDescription(String sdUUID, String spUUID, String imgGUID, String volUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("Volume.setDescription").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc setVolumeLegality(String spID, String sdID, String imageID, String volumeID, String legality) {
    JsonRpcRequest request = new RequestBuilder("Volume.setLegality").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("legality", legality).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn setVolumeLegality(String spID, String sdID, String imageID, String volumeID, String legality) {
    JsonRpcRequest request = new RequestBuilder("Volume.setLegality").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("legality", legality).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc prepareMerge(String spUUID, Map<String, String> subchainInfo) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.prepareMerge").withParameter("storagepoolID", spUUID).withParameter("subchainInfo", subchainInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn prepareMerge(String spUUID, Map<String, String> subchainInfo) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.prepareMerge").withParameter("storagepoolID", spUUID).withParameter("subchainInfo", subchainInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc finalizeMerge(String spUUID, Map<String, String> subchainInfo) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.finalizeMerge").withParameter("storagepoolID", spUUID).withParameter("subchainInfo", subchainInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn finalizeMerge(String spUUID, Map<String, String> subchainInfo) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.finalizeMerge").withParameter("storagepoolID", spUUID).withParameter("subchainInfo", subchainInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    uuidReturn = getIrsProxy().finalizeMerge(getParameters().getStoragePoolId().toString(), getParameters().getSubchainInfo().convertToVdsmMergeSnapshotsInfo());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.finalizeMerge, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    uuidReturn = getIrsProxy().finalizeMerge(getParameters().getStoragePoolId().toString(), SubchainInfoHelper.prepareSubchainInfoForVdsCommand(getParameters().getSubchainInfo()));
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.finalizeMerge, getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    // Allow runAction to succeed
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void handleFailure() {
    log.error("Command id: '{} failed child command status for step '{}'", getCommandId(), getParameters().getCommandStep());
}
#method_after
@Override
public void handleFailure() {
    log.error("Command '{}' id '{}' failed executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Cold Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.ColdMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.FINALIZE_MERGE);
            break;
        case FINALIZE_MERGE:
            nextCommand = new Pair<>(VdcActionType.FinalizeMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.ColdMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.FINALIZE_MERGE);
            break;
        case FINALIZE_MERGE:
            nextCommand = new Pair<>(VdcActionType.FinalizeMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
    }
    persistCommandIfNeeded();
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new ColdMergeSnapshotSingleDiskCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(VdcActionType.ColdMergeSnapshotSingleDisk);
    parameters.setParentParameters(getParameters());
    return parameters;
}
#method_after
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    return parameters;
}
#end_block

#method_before
@Override
public String toString() {
    return "SubchainInfo [" + "storageDomainId=" + storageDomainId + ", imageGroupId=" + imageGroupId + ", baseImageId=" + baseImageId + ", topImageId=" + topImageId + ']';
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("storageDomainId", storageDomainId).append("imageGroupId", imageGroupId).append("baseImageId", baseImageId).append("topImageId", topImageId).build();
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVolume(String sdUUID, String spUUID, String imgGUID, String size, int volFormat, int volType, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID, String initialSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.create").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).withParameter("volFormat", volFormat).withParameter("preallocate", volType).withParameter("diskType", diskType).withParameter("desc", descr).withParameter("srcImgUUID", srcImgGUID).withParameter("srcVolUUID", srcVolUUID).withOptionalParameter("initialSize", initialSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn createVolume(String sdUUID, String spUUID, String imgGUID, String size, int volFormat, int volType, int diskType, String volUUID, String descr, String srcImgGUID, String srcVolUUID, String initialSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.create").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).withParameter("volFormat", volFormat).withParameter("preallocate", volType).withParameter("diskType", diskType).withParameter("desc", descr).withParameter("srcImgUUID", srcImgGUID).withParameter("srcVolUUID", srcVolUUID).withOptionalParameter("initialSize", initialSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    return copyImage(sdUUID, spUUID, vmGUID, srcImgGUID, srcVolUUID, dstImgGUID, dstVolUUID, descr, dstSdUUID, volType, volFormat, preallocate, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, Boolean discard, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturnForXmlRpc downloadImage(Map methodInfo, String spUUID, String sdUUID, String dstImgGUID, String dstVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.download").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", dstImgGUID).withParameter("volumeID", dstVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturn downloadImage(Map methodInfo, String spUUID, String sdUUID, String dstImgGUID, String dstVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.download").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", dstImgGUID).withParameter("volumeID", dstVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturnForXmlRpc uploadImage(Map methodInfo, String spUUID, String sdUUID, String srcImgGUID, String srcVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.upload").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("volumeID", srcVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneUuidReturn uploadImage(Map methodInfo, String spUUID, String sdUUID, String srcImgGUID, String srcVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.upload").withParameter("methodArgs", methodInfo).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("volumeID", srcVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    return mergeSnapshots(sdUUID, spUUID, vmGUID, imgGUID, ancestorUUID, successorUUID, postZero, null);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero, Boolean discard) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).withOptionalParameter("discard", discard).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public VolumeListReturnForXmlRpc reconcileVolumeChain(String spUUID, String sdUUID, String imgGUID, String leafVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.reconcileVolumeChain").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("leafVolID", leafVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("volumes").withResponseType(Object[].class);
    return new VolumeListReturnForXmlRpc(response);
}
#method_after
@Override
public VolumeListReturn reconcileVolumeChain(String spUUID, String sdUUID, String imgGUID, String leafVolUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.reconcileVolumeChain").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("leafVolID", leafVolUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("volumes").withResponseType(Object[].class);
    return new VolumeListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    return deleteVolume(sdUUID, spUUID, imgGUID, volUUID, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("discard", discard).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public IrsStatsAndStatusXmlRpc getIrsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageRepoStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new IrsStatsAndStatusXmlRpc(response);
}
#method_after
@Override
public IrsStatsAndStatus getIrsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageRepoStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new IrsStatsAndStatus(response);
}
#end_block

#method_before
@Override
public FileStatsReturnForXmlRpc getFileStats(String sdUUID, String pattern, boolean caseSensitive) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getFileStats").withParameter("storagedomainID", sdUUID).withParameter("pattern", pattern).withParameter("caseSensitive", caseSensitive).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fileStats");
    return new FileStatsReturnForXmlRpc(response);
}
#method_after
@Override
public FileStatsReturn getFileStats(String sdUUID, String pattern, boolean caseSensitive) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getFileStats").withParameter("storagedomainID", sdUUID).withParameter("pattern", pattern).withParameter("caseSensitive", caseSensitive).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fileStats");
    return new FileStatsReturn(response);
}
#end_block

#method_before
@Override
public StorageStatusReturnForXmlRpc activateStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.activate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("storageStatus").withResponseType(String.class);
    return new StorageStatusReturnForXmlRpc(response);
}
#method_after
@Override
public StorageStatusReturn activateStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.activate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("storageStatus").withResponseType(String.class);
    return new StorageStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc deactivateStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.deactivate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn deactivateStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.deactivate").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc detachStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn detachStorageDomain(String sdUUID, String spUUID, String msdUUID, int masterVersion) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc forcedDetachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("force", true).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn forcedDetachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.detach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("force", true).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc attachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.attach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn attachStorageDomain(String sdUUID, String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.attach").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setStorageDomainDescription(String sdUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.setDescription").withParameter("storagedomainID", sdUUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setStorageDomainDescription(String sdUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.setDescription").withParameter("storagedomainID", sdUUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extendStorageDomain(String sdUUID, String spUUID, String[] devlist, boolean force) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.extend").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(devlist))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn extendStorageDomain(String sdUUID, String spUUID, String[] devlist, boolean force) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.extend").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(devlist))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public ResizeStorageDomainPVMapReturnForXmlRpc resizeStorageDomainPV(String sdUUID, String spUUID, String device) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.resizePV").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("guid", device).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ResizeStorageDomainPVMapReturnForXmlRpc(response);
}
#method_after
@Override
public ResizeStorageDomainPVMapReturn resizeStorageDomainPV(String sdUUID, String spUUID, String device) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.resizePV").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("guid", device).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ResizeStorageDomainPVMapReturn(response);
}
#end_block

#method_before
@Override
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    // duplicated in IVdsServer#getStoragePoolInfo
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfoReturnForXmlRpc(response);
}
#method_after
@Override
public StoragePoolInfo getStoragePoolInfo(String spUUID) {
    // duplicated in IVdsServer#getStoragePoolInfo
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfo(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc destroyStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.destroy").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn destroyStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.destroy").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    return deleteImage(sdUUID, spUUID, imgGUID, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    return moveImage(spUUID, srcDomUUID, dstDomUUID, imgGUID, vmGUID, op, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc cloneImageStructure(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.cloneStructure").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn cloneImageStructure(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID) {
    JsonRpcRequest request = new RequestBuilder("Image.cloneStructure").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc syncImageData(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID, String syncType) {
    JsonRpcRequest request = new RequestBuilder("Image.syncData").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("syncType", syncType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn syncImageData(String spUUID, String srcDomUUID, String imgGUID, String dstDomUUID, String syncType) {
    JsonRpcRequest request = new RequestBuilder("Image.syncData").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("syncType", syncType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVM(String spUUID, Map[] vms) {
    return updateVMInImportExport(spUUID, vms, null);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVM(String spUUID, Map[] vms) {
    return updateVMInImportExport(spUUID, vms, null);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID) {
    return removeVM(spUUID, vmGUID, null);
}
#method_after
@Override
public StatusOnlyReturn removeVM(String spUUID, String vmGUID) {
    return removeVM(spUUID, vmGUID, null);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVMInImportExport(String spUUID, Map[] vms, String StorageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.updateVMs").withParameter("storagepoolID", spUUID).withParameter("vmList", new ArrayList<>(Arrays.asList(vms))).withOptionalParameter("storagedomainID", StorageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVMInImportExport(String spUUID, Map[] vms, String StorageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.updateVMs").withParameter("storagepoolID", spUUID).withParameter("vmList", new ArrayList<>(Arrays.asList(vms))).withOptionalParameter("storagedomainID", StorageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc removeVM(String spUUID, String vmGUID, String storageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.removeVM").withParameter("storagepoolID", spUUID).withParameter("vmUUID", vmGUID).withOptionalParameter("storagedomainID", storageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn removeVM(String spUUID, String vmGUID, String storageDomainId) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.removeVM").withParameter("storagepoolID", spUUID).withParameter("vmUUID", vmGUID).withOptionalParameter("storagedomainID", storageDomainId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GetVmsInfoReturnForXmlRpc getVmsInfo(String storagePoolId, String storageDomainId, String[] VMIDList) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getBackedUpVmsInfo").withParameter("storagepoolID", storagePoolId).withParameter("storagedomainID", storageDomainId).withParameter("vmList", new ArrayList<>(Arrays.asList(VMIDList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmlist");
    return new GetVmsInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GetVmsInfoReturn getVmsInfo(String storagePoolId, String storageDomainId, String[] VMIDList) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getBackedUpVmsInfo").withParameter("storagepoolID", storagePoolId).withParameter("storagedomainID", storageDomainId).withParameter("vmList", new ArrayList<>(Arrays.asList(VMIDList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmlist");
    return new GetVmsInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc upgradeStoragePool(String storagePoolId, String targetVersion) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.upgrade").withParameter("storagepoolID", storagePoolId).withParameter("targetDomVersion", targetVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn upgradeStoragePool(String storagePoolId, String targetVersion) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.upgrade").withParameter("storagepoolID", storagePoolId).withParameter("targetDomVersion", targetVersion).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public ImagesListReturnForXmlRpc getImagesList(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getImages").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("imageslist").withResponseType(Object[].class);
    return new ImagesListReturnForXmlRpc(response);
}
#method_after
@Override
public ImagesListReturn getImagesList(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getImages").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("imageslist").withResponseType(Object[].class);
    return new ImagesListReturn(response);
}
#end_block

#method_before
@Override
public UUIDListReturnForXmlRpc getVolumesList(String sdUUID, String spUUID, String imgUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getVolumes").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("imageID", imgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuidlist").withResponseType(Object[].class);
    return new UUIDListReturnForXmlRpc(response);
}
#method_after
@Override
public UUIDListReturn getVolumesList(String sdUUID, String spUUID, String imgUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getVolumes").withParameter("storagedomainID", sdUUID).withParameter("storagepoolID", spUUID).withParameter("imageID", imgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuidlist").withResponseType(Object[].class);
    return new UUIDListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc extendVolumeSize(String spUUID, String sdUUID, String imageUUID, String volumeUUID, String newSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.extendSize").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imageUUID).withParameter("volumeID", volumeUUID).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn extendVolumeSize(String spUUID, String sdUUID, String imageUUID, String volumeUUID, String newSize) {
    JsonRpcRequest request = new RequestBuilder("Volume.extendSize").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imageUUID).withParameter("volumeID", volumeUUID).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setVolumeDescription(String sdUUID, String spUUID, String imgGUID, String volUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("Volume.setDescription").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setVolumeDescription(String sdUUID, String spUUID, String imgGUID, String volUUID, String description) {
    JsonRpcRequest request = new RequestBuilder("Volume.setDescription").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("description", description).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc setVolumeLegality(String spID, String sdID, String imageID, String volumeID, String legality) {
    JsonRpcRequest request = new RequestBuilder("Volume.setLegality").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("legality", legality).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn setVolumeLegality(String spID, String sdID, String imageID, String volumeID, String legality) {
    JsonRpcRequest request = new RequestBuilder("Volume.setLegality").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("legality", legality).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc prepareMerge(String spUUID, Map<String, String> subchainInfo) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.prepareMerge").withParameter("storagepoolID", spUUID).withParameter("subchainInfo", subchainInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn prepareMerge(String spUUID, Map<String, String> subchainInfo) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.prepareMerge").withParameter("storagepoolID", spUUID).withParameter("subchainInfo", subchainInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    uuidReturn = getIrsProxy().prepareMerge(getParameters().getStoragePoolId().toString(), getParameters().getSubchainInfo().convertToVdsmMergeSnapshotsInfo());
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.prepareMerge, getParameters().getStoragePoolId()));
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    uuidReturn = getIrsProxy().prepareMerge(getParameters().getStoragePoolId().toString(), SubchainInfoHelper.prepareSubchainInfoForVdsCommand(getParameters().getSubchainInfo()));
    proceedProxyReturnValue();
    Guid taskID = new Guid(uuidReturn.uuid);
    getVDSReturnValue().setCreationInfo(new AsyncTaskCreationInfo(taskID, AsyncTaskType.prepareMerge, getParameters().getStoragePoolId()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    // Allow runAction to succeed
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void handleFailure() {
    log.error("Command id: '{} failed child command status for step '{}'", getCommandId(), getParameters().getCommandStep());
}
#method_after
@Override
public void handleFailure() {
    log.error("Command '{}' id '{}' failed executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Cold Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            break;
        case FINALIZE_MERGE:
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            nextCommand = new Pair<>(VdcActionType.PrepareMerge, buildColdMergeParameters(getImageId(), getDestinationImageId()));
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            break;
        case FINALIZE_MERGE:
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
    }
    persistCommandIfNeeded();
    if (nextCommand != null) {
        runInternalActionWithTasksContext(nextCommand.getFirst(), nextCommand.getSecond());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new ColdMergeSnapshotSingleDiskCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(VdcActionType.ColdMergeSnapshotSingleDisk);
    parameters.setParentParameters(getParameters());
    return parameters;
}
#method_after
private ColdMergeCommandParameters buildColdMergeParameters(Guid baseVolumeId, Guid topVolumeId) {
    SubchainInfo subchainInfo = new SubchainInfo(getDiskImage().getStorageIds().get(0), getImageGroupId(), baseVolumeId, topVolumeId);
    ColdMergeCommandParameters parameters = new ColdMergeCommandParameters(getDiskImage().getStoragePoolId(), subchainInfo);
    parameters.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    return parameters;
}
#end_block

#method_before
protected void syncChildCommandList(RemoveSnapshotSingleDiskStep commandStep, Map<RemoveSnapshotSingleDiskStep, Guid> childCommands) {
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != childCommands.size()) {
        for (Guid id : childCommandIds) {
            if (!childCommands.containsValue(id)) {
                childCommands.put(commandStep, id);
                break;
            }
        }
    }
}
#method_after
protected void syncChildCommandList(RemoveSnapshotSingleDiskParameters parameters) {
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != parameters.getChildCommands().size()) {
        for (Guid id : childCommandIds) {
            if (!parameters.getChildCommands().containsValue(id)) {
                parameters.getChildCommands().put(parameters.getCommandStep(), id);
                break;
            }
        }
    }
}
#end_block

#method_before
protected Guid getCurrentChildId(RemoveSnapshotSingleDiskStep commandStep, Map<RemoveSnapshotSingleDiskStep, Guid> childCommands) {
    return childCommands.get(commandStep);
}
#method_after
protected Guid getCurrentChildId(RemoveSnapshotSingleDiskParameters parameters) {
    return parameters.getChildCommands().get(parameters.getCommandStep());
}
#end_block

#method_before
private void initializeObjectState() {
    if (StringUtils.isEmpty(getSnapshotName())) {
        Snapshot snapshot = snapshotDao.get(getParameters().getSnapshotId());
        if (snapshot != null) {
            setSnapshotName(snapshot.getDescription());
            getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getSourceImages()).isEmpty());
        }
    }
    setStoragePoolId(getVm().getStoragePoolId());
}
#method_after
private void initializeObjectState() {
    if (StringUtils.isEmpty(getSnapshotName())) {
        Snapshot snapshot = snapshotDao.get(getParameters().getSnapshotId());
        if (snapshot != null) {
            setSnapshotName(snapshot.getDescription());
            getParameters().setUseCinderCommandCallback(!DisksFilter.filterCinderDisks(getSourceImages()).isEmpty());
        }
    }
    setStoragePoolId(getVm().getStoragePoolId());
}
#end_block

#method_before
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDisk) {
            if (FeatureSupported.isQemuingCommitSupported(Version.v4_1)) {
                RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, VdcActionType.ColdMergeSnapshotSingleDisk, EndProcedure.COMMAND_MANAGED);
                CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.ColdMergeSnapshotSingleDisk, parameters, cloneContextAndDetachFromParent());
            } else {
                VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType(), EndProcedure.COMMAND_MANAGED));
                if (vdcReturnValue != null && vdcReturnValue.getInternalVdsmTaskIdList() != null) {
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                }
            }
        } else {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType(), EndProcedure.COMMAND_MANAGED), cloneContextAndDetachFromParent());
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#method_after
private void removeImages() {
    List<CinderDisk> cinderDisks = new ArrayList<>();
    for (final DiskImage source : getSourceImages()) {
        if (source.getDiskStorageType() == DiskStorageType.CINDER) {
            cinderDisks.add((CinderDisk) source);
            continue;
        }
        // The following is ok because we have tested in the validate that the vm
        // is not a template and the vm is not in preview mode and that
        // this is not the active snapshot.
        List<DiskImage> images = diskImageDao.getAllSnapshotsForParent(source.getImageId());
        DiskImage dest = null;
        if (!images.isEmpty()) {
            dest = images.get(0);
        }
        if (getSnapshotActionType() == VdcActionType.RemoveSnapshotSingleDiskLive) {
            CommandCoordinatorUtil.executeAsyncCommand(getSnapshotActionType(), buildRemoveSnapshotSingleDiskParameters(source, dest, getSnapshotActionType()), cloneContextAndDetachFromParent());
        } else {
            RemoveSnapshotSingleDiskParameters parameters = buildRemoveSnapshotSingleDiskParameters(source, dest, VdcActionType.ColdMergeSnapshotSingleDisk);
            runInternalActionWithTasksContext(getSnapshotActionType(), parameters);
        }
        List<Guid> quotasToRemoveFromCache = new ArrayList<>();
        quotasToRemoveFromCache.add(source.getQuotaId());
        if (dest != null) {
            quotasToRemoveFromCache.add(dest.getQuotaId());
        }
        getQuotaManager().removeQuotaFromCache(getStoragePoolId(), quotasToRemoveFromCache);
    }
    if (!cinderDisks.isEmpty()) {
        handleCinderSnapshotDisks(cinderDisks);
    }
}
#end_block

#method_before
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest, VdcActionType snapshotActionType, EndProcedure endProcedure) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setStorageDomainId(source.getStorageIds().get(0));
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(snapshotActionType);
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setEndProcedure(endProcedure);
    return parameters;
}
#method_after
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest, VdcActionType snapshotActionType) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setStorageDomainId(source.getStorageIds().get(0));
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(snapshotActionType);
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return parameters;
}
#end_block

#method_before
private List<DiskImage> getDiskImagesToValidate() {
    List<Disk> disks = diskDao.getAllForVm(getVmId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#method_after
private List<DiskImage> getDiskImagesToValidate() {
    List<Disk> disks = diskDao.getAllForVm(getVmId());
    List<DiskImage> allDisks = DisksFilter.filterImageDisks(disks, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(disks);
    allDisks.addAll(cinderDisks);
    return allDisks;
}
#end_block

#method_before
private VdcActionType getSnapshotActionType() {
    return getVm().isQualifiedForLiveSnapshotMerge() ? VdcActionType.RemoveSnapshotSingleDiskLive : VdcActionType.RemoveSnapshotSingleDisk;
}
#method_after
private VdcActionType getSnapshotActionType() {
    if (getVm().isQualifiedForLiveSnapshotMerge()) {
        return VdcActionType.RemoveSnapshotSingleDiskLive;
    }
    if (isQemuimgCommitSupported()) {
        return VdcActionType.ColdMergeSnapshotSingleDisk;
    }
    return VdcActionType.RemoveSnapshotSingleDisk;
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    if (FeatureSupported.isQemuingCommitSupported(Version.v4_1)) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    if (getVm().isQualifiedForLiveSnapshotMerge() || getParameters().isUseCinderCommandCallback()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#method_after
@Override
public CommandCallback getCallback() {
    if (getVm().isQualifiedForLiveSnapshotMerge() || getParameters().isUseCinderCommandCallback() || isQemuimgCommitSupported()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    // Allow runAction to succeed
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Let doPolling() drive the execution; we don't have any guarantee that
    // executeCommand() will finish before doPolling() is called, and we don't
    // want to possibly run the first command twice.
    getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.PREPARE_MERGE);
    getParameters().setChildCommands(new HashMap<>());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void handleFailure() {
    log.error("Command id: '{} failed child command status for step '{}'", getCommandId(), getParameters().getCommandStep());
}
#method_after
@Override
public void handleFailure() {
    log.error("Command '{}' id '{}' failed executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(RemoveSnapshotSingleDiskStep.EXTEND);
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            break;
        case MERGE:
            break;
        case MERGE_STATUS:
            break;
        case SYNC_VOLUME_CHAIN:
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    if (currentChildId != null) {
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Command '{}' id '{}' executing step '{}'", getActionType(), getCommandId(), getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case PREPARE_MERGE:
            break;
        case MERGE:
            break;
        case FINALIZE_MERGE:
            break;
        case DESTROY_IMAGE:
            break;
        case DESTROY_IMAGE_CHECK:
            break;
    }
    persistCommandIfNeeded();
    return false;
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return new RemoveSnapshotSingleDiskLiveCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new SerialChildCommandsExecutionCallback();
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return null;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters().getCommandStep(), getParameters().getChildCommands());
    Guid currentChildId = getCurrentChildId(getParameters().getCommandStep(), getParameters().getChildCommands());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList(getParameters());
    Guid currentChildId = getCurrentChildId(getParameters());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
        getParameters().setCommandStep(getParameters().getNextCommandStep());
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case EXTEND:
            nextCommand = new Pair<>(VdcActionType.MergeExtend, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE);
            break;
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue(vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.DESTROY_IMAGE_CHECK);
            break;
        case DESTROY_IMAGE_CHECK:
            nextCommand = new Pair<>(VdcActionType.DestroyImageCheck, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
        // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private Optional<VM> chooseNextVmToMigrateFromVMsToHostsAffinity(Cluster cluster, List<AffinityGroup> allAffinityGroups) {
    VM vm = null;
    List<AffinityGroup> allVMtoHostsAffinityGroups = getAllAffinityGroupsForVMsToHostsAffinity(allAffinityGroups);
    if (allVMtoHostsAffinityGroups.isEmpty()) {
        return Optional.ofNullable(vm);
    }
    Map<Guid, VM> vmsMap = getVMsMap(allVMtoHostsAffinityGroups);
    List<Guid> candidateVMsPositiveEnforcingAffinitiy = getCanidatesFromVMtoHostsAffinity(allVMtoHostsAffinityGroups, vmsMap, true, true);
    List<Guid> candidateVMsNegativeEnforcingAffinitiy = getCanidatesFromVMtoHostsAffinity(allVMtoHostsAffinityGroups, vmsMap, false, true);
    List<Guid> candidateVMsPositiveNonEnforcingAffinitiy = getCanidatesFromVMtoHostsAffinity(allVMtoHostsAffinityGroups, vmsMap, true, false);
    List<Guid> candidateVMsNegativeNonEnforcingAffinitiy = getCanidatesFromVMtoHostsAffinity(allVMtoHostsAffinityGroups, vmsMap, false, false);
    // TODO check intersections between candidate groups and warn user if needed.
    List<Guid> canidatesVMs = new ArrayList<>();
    canidatesVMs.addAll(candidateVMsPositiveEnforcingAffinitiy);
    canidatesVMs.addAll(candidateVMsNegativeEnforcingAffinitiy);
    canidatesVMs.addAll(candidateVMsPositiveNonEnforcingAffinitiy);
    canidatesVMs.addAll(candidateVMsNegativeNonEnforcingAffinitiy);
    if (!canidatesVMs.isEmpty()) {
        log.info("vm to hosts affinity group violation detected");
    }
    for (Guid id : canidatesVMs) {
        VM canidateVM = vmsMap.get(id);
        if (isVMmigrationValid(cluster, canidateVM)) {
            return Optional.of(canidateVM);
        }
    }
    return Optional.ofNullable(vm);
}
#method_after
private Optional<VM> chooseNextVmToMigrateFromVMsToHostsAffinity(Cluster cluster, List<AffinityGroup> allAffinityGroups) {
    List<AffinityGroup> allVmToHostsAffinityGroups = getAllAffinityGroupsForVMsToHostsAffinity(allAffinityGroups);
    if (allVmToHostsAffinityGroups.isEmpty()) {
        return Optional.empty();
    }
    Map<Guid, VM> vmsMap = getVMsMap(allVmToHostsAffinityGroups);
    List<Guid> candidateVMsPositiveEnforcingAffinity = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, true, true);
    List<Guid> candidateVMsNegativeEnforcingAffinity = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, false, true);
    List<Guid> candidateVMsPositiveNonEnforcingAffinity = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, true, false);
    List<Guid> candidateVMsNegativeNonEnforcingAffinity = getVmToHostsAffinityGroupCandidates(allVmToHostsAffinityGroups, vmsMap, false, false);
    // TODO check intersections between candidate groups and warn user if needed.
    List<Guid> candidateVMs = new ArrayList<>();
    candidateVMs.addAll(candidateVMsPositiveEnforcingAffinity);
    candidateVMs.addAll(candidateVMsNegativeEnforcingAffinity);
    candidateVMs.addAll(candidateVMsPositiveNonEnforcingAffinity);
    candidateVMs.addAll(candidateVMsNegativeNonEnforcingAffinity);
    if (!candidateVMs.isEmpty()) {
        log.info("vm to hosts affinity group violation detected");
    }
    for (Guid id : candidateVMs) {
        VM candidateVM = vmsMap.get(id);
        if (isVmMigrationValid(cluster, candidateVM)) {
            return Optional.of(candidateVM);
        }
    }
    return Optional.empty();
}
#end_block

#method_before
private List<Guid> getSortedVmsViolatingVmToHostsAffinity(Map<Guid, Set<Guid>> vmToHosts, Map<Guid, VM> vmsMap, boolean isVdsAffinityPositive) {
    List<Guid> nonViolatingVms = vmToHosts.keySet().stream().filter(vm_id -> {
        Set<Guid> hosts = vmToHosts.get(vm_id);
        boolean vmRunsOnAffinityHost = hosts.contains(vmsMap.get(vm_id).getRunOnVds());
        if ((isVdsAffinityPositive && vmRunsOnAffinityHost) || (!isVdsAffinityPositive && !vmRunsOnAffinityHost)) {
            return true;
        }
        return false;
    }).collect(Collectors.toList());
    vmToHosts.keySet().removeAll(nonViolatingVms);
    List<Guid> candidateVMids = new ArrayList<>();
    // for negative affinity groups sort the candidates from the smallest hosts group first
    vmToHosts.entrySet().stream().sorted(comparingInt(e -> e.getValue().size())).forEachOrdered(x -> candidateVMids.add(x.getKey()));
    // for positive affinity groups sort the candidates from the largest hosts group first
    if (isVdsAffinityPositive) {
        Collections.reverse(candidateVMids);
    }
    return candidateVMids;
}
#method_after
private List<Guid> getSortedVmsViolatingVmToHostsAffinity(Map<Guid, Set<Guid>> vmToHostsAffinityMap, Map<Guid, VM> vmsMap, boolean isVdsAffinityPositive) {
    List<Guid> nonViolatingVms = vmToHostsAffinityMap.keySet().stream().filter(vm_id -> {
        Set<Guid> hosts = vmToHostsAffinityMap.get(vm_id);
        boolean vmRunsOnAffinityHost = hosts.contains(vmsMap.get(vm_id).getRunOnVds());
        if ((isVdsAffinityPositive && vmRunsOnAffinityHost) || (!isVdsAffinityPositive && !vmRunsOnAffinityHost)) {
            return true;
        }
        return false;
    }).collect(Collectors.toList());
    vmToHostsAffinityMap.keySet().removeAll(nonViolatingVms);
    List<Guid> candidateVMids = new ArrayList<>();
    // for negative affinity groups sort the candidates from the smallest hosts group first
    vmToHostsAffinityMap.entrySet().stream().sorted(comparingInt(e -> e.getValue().size())).forEachOrdered(x -> candidateVMids.add(x.getKey()));
    // for positive affinity groups sort the candidates from the largest hosts group first
    if (isVdsAffinityPositive) {
        Collections.reverse(candidateVMids);
    }
    return candidateVMids;
}
#end_block

#method_before
private VM chooseNextVmToMigrateFromVMsAffinity(Cluster cluster, List<AffinityGroup> allAffinityGroups) {
    List<AffinityGroup> allHardAffinityGroups = getAllHardAffinityGroupsForVMsAffinity(allAffinityGroups);
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(allHardAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allHardAffinityGroups) {
        if (ag.isVmNegative()) {
            unifiedAffinityGroups.add(ag);
        }
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getVmIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForVMAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", cluster.getId());
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with bigger Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, Collections.reverseOrder(new AffinityGroupComparator()));
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        final List<VM> candidateVms;
        if (affinityGroup.isVmPositive()) {
            candidateVms = vmDao.getVmsByIds(findVmViolatingPositiveAg(affinityGroup, vmToHost));
            log.info("Positive affinity group violation detected");
        } else if (affinityGroup.isVmNegative()) {
            candidateVms = vmDao.getVmsByIds(findVmViolatingNegativeAg(affinityGroup, vmToHost));
            log.info("Negative affinity group violation detected");
        } else {
            continue;
        }
        while (!candidateVms.isEmpty()) {
            final int index = random.nextInt(candidateVms.size());
            final VM candidateVm = candidateVms.get(index);
            if (isVMmigrationValid(cluster, candidateVm)) {
                return candidateVm;
            }
            candidateVms.remove(index);
        }
    }
    // No possible migration..
    return null;
}
#method_after
private VM chooseNextVmToMigrateFromVMsAffinity(Cluster cluster, List<AffinityGroup> allAffinityGroups) {
    List<AffinityGroup> allHardAffinityGroups = getAllHardAffinityGroupsForVMsAffinity(allAffinityGroups);
    Set<Set<Guid>> unifiedPositiveAffinityGroups = AffinityRulesUtils.getUnifiedPositiveAffinityGroups(allHardAffinityGroups);
    List<AffinityGroup> unifiedAffinityGroups = AffinityRulesUtils.setsToAffinityGroups(unifiedPositiveAffinityGroups);
    // Add negative affinity groups
    for (AffinityGroup ag : allHardAffinityGroups) {
        if (ag.isVmNegative()) {
            unifiedAffinityGroups.add(ag);
        }
    }
    // Create a set of all VMs in affinity groups
    Set<Guid> allVms = new HashSet<>();
    for (AffinityGroup group : unifiedAffinityGroups) {
        allVms.addAll(group.getVmIds());
    }
    Map<Guid, Guid> vmToHost = createMapOfVmToHost(allVms);
    // There is no need to migrate when no collision was detected
    Set<AffinityGroup> violatedAffinityGroups = checkForVMAffinityGroupViolations(unifiedAffinityGroups, vmToHost, FailMode.GET_ALL);
    if (violatedAffinityGroups.isEmpty()) {
        log.debug("No affinity group collision detected for cluster {}. Standing by.", cluster.getId());
        return null;
    }
    // Find a VM that is breaking the affinityGroup and can be theoretically migrated
    // - start with bigger Affinity Groups
    List<AffinityGroup> affGroupsBySize = new ArrayList<>(violatedAffinityGroups);
    Collections.sort(affGroupsBySize, Collections.reverseOrder(new AffinityGroupComparator()));
    for (AffinityGroup affinityGroup : affGroupsBySize) {
        final List<VM> candidateVms;
        if (affinityGroup.isVmPositive()) {
            candidateVms = vmDao.getVmsByIds(findVmViolatingPositiveAg(affinityGroup, vmToHost));
            log.info("Positive affinity group violation detected");
        } else if (affinityGroup.isVmNegative()) {
            candidateVms = vmDao.getVmsByIds(findVmViolatingNegativeAg(affinityGroup, vmToHost));
            log.info("Negative affinity group violation detected");
        } else {
            continue;
        }
        while (!candidateVms.isEmpty()) {
            final int index = random.nextInt(candidateVms.size());
            final VM candidateVm = candidateVms.get(index);
            if (isVmMigrationValid(cluster, candidateVm)) {
                return candidateVm;
            }
            candidateVms.remove(index);
        }
    }
    // No possible migration..
    return null;
}
#end_block

#method_before
private boolean validateDiscardAfterDeleteLegal(StorageDomainValidator storageDomainValidator) {
    if (getStorageDomain().isDiscardAfterDelete() && !FeatureSupported.discardAfterDeleteSupported(getStoragePool().getCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISCARD_AFTER_DELETE_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", getStoragePool().getCompatibilityVersion().toString()));
    }
    return validate(storageDomainValidator.isDiscardAfterDeleteLegalForExistingStorageDomain());
}
#method_after
private boolean validateDiscardAfterDeleteLegal(StorageDomainValidator storageDomainValidator) {
    if (!validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(getStoragePool().getCompatibilityVersion()))) {
        return false;
    }
    return validate(storageDomainValidator.isDiscardAfterDeleteLegalForExistingStorageDomain());
}
#end_block

#method_before
@Test
public void validateFailsUnSupportedVersionForDiscardAfterDelete() {
    sd.setDiscardAfterDelete(true);
    cmd.getStoragePool().setCompatibilityVersion(Version.v4_0);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISCARD_AFTER_DELETE_NOT_SUPPORTED_BY_DC_VERSION);
}
#method_after
@Test
public void validateFailsUnSupportedVersionForDiscardAfterDelete() {
    EngineMessage message = EngineMessage.ACTION_TYPE_FAILED_DISCARD_AFTER_DELETE_NOT_SUPPORTED_BY_DC_VERSION;
    when(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(any(Version.class))).thenReturn(new ValidationResult(message));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, message);
}
#end_block

#method_before
private void mockStorageDomainValidator() {
    doReturn(storageDomainValidator).when(cmd).getStorageDomainValidator();
    when(storageDomainValidator.isDiscardAfterDeleteLegalForExistingStorageDomain()).thenReturn(ValidationResult.VALID);
}
#method_after
private void mockStorageDomainValidator() {
    doReturn(storageDomainValidator).when(cmd).getStorageDomainValidator();
    when(storageDomainValidator.isDiscardAfterDeleteLegalForExistingStorageDomain()).thenReturn(ValidationResult.VALID);
    when(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(any(Version.class))).thenReturn(ValidationResult.VALID);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = (getStorageDomain().getStorage() != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && addStorageDomainInIrs()) {
        storageDomainStaticDao.update(getStorageDomain().getStorageStaticData());
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = (getStorageDomain().getStorage() != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && addStorageDomainInIrs()) {
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        blockStorageDomainHelper.fillMetadataDevicesInfo(getStorageDomain().getStorageStaticData(), getVds().getId());
        storageDomainStaticDao.update(getStorageDomain().getStorageStaticData());
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
protected boolean validateDiscardAfterDeleteLegal(StorageDomainValidator storageDomainValidator, Version compatibilityVersion) {
    if (getStorageDomain().isDiscardAfterDelete() && !FeatureSupported.discardAfterDeleteSupported(compatibilityVersion)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISCARD_AFTER_DELETE_NOT_SUPPORTED_BY_DC_VERSION, String.format("$dataCenterVersion %s", compatibilityVersion.toString()));
    }
    ArrayList<LUNs> luns = (ArrayList<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, new GetDeviceListVDSCommandParameters(getVds().getId(), getStorageDomain().getStorageType(), false, getParameters().getLunIds())).getReturnValue();
    return validate(storageDomainValidator.isDiscardAfterDeleteLegalForNewBlockStorageDomain(luns));
}
#method_after
@Override
@SuppressWarnings("unchecked")
protected boolean validateDiscardAfterDeleteLegal(StorageDomainValidator storageDomainValidator, Version compatibilityVersion) {
    if (!validate(storageDomainValidator.isDiscardAfterDeleteSupportedByDcVersion(compatibilityVersion))) {
        return false;
    }
    ArrayList<LUNs> luns = (ArrayList<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, new GetDeviceListVDSCommandParameters(getVds().getId(), getStorageDomain().getStorageType(), false, getParameters().getLunIds())).getReturnValue();
    return validate(storageDomainValidator.isDiscardAfterDeleteLegalForNewBlockStorageDomain(luns));
}
#end_block

#method_before
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, String force) {
    // vmGUID is not needed and can be removed from the interface
    return copyImage(sdUUID, spUUID, vmGUID, srcImgGUID, srcVolUUID, dstImgGUID, dstVolUUID, descr, dstSdUUID, volType, volFormat, preallocate, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, boolean discard, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn copyImage(String sdUUID, String spUUID, String vmGUID, String srcImgGUID, String srcVolUUID, String dstImgGUID, String dstVolUUID, String descr, String dstSdUUID, int volType, int volFormat, int preallocate, String postZero, Boolean discard, String force) {
    // vmGUID is not needed and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Volume.copy").withParameter("volumeID", srcVolUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", srcImgGUID).withParameter("dstSdUUID", dstSdUUID).withParameter("dstImgUUID", dstImgGUID).withParameter("dstVolUUID", dstVolUUID).withParameter("desc", descr).withParameter("volType", volType).withParameter("volFormat", volFormat).withParameter("preallocate", preallocate).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero) {
    // vmGUID not used and can be removed from the interface
    return mergeSnapshots(sdUUID, spUUID, vmGUID, imgGUID, ancestorUUID, successorUUID, postZero, null);
}
#end_block

#method_before
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero, boolean discard) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).withParameter("discard", discard).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn mergeSnapshots(String sdUUID, String spUUID, String vmGUID, String imgGUID, String ancestorUUID, String successorUUID, String postZero, Boolean discard) {
    // vmGUID not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("Image.mergeSnapshots").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("ancestor", ancestorUUID).withParameter("successor", successorUUID).withParameter("postZero", postZero).withOptionalParameter("discard", discard).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, String force) {
    return deleteVolume(sdUUID, spUUID, imgGUID, volUUID, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("discard", discard).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn deleteVolume(String sdUUID, String spUUID, String imgGUID, String[] volUUID, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.deleteVolumes").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("volumeList", new ArrayList<>(Arrays.asList(volUUID))).withOptionalParameter("postZero", postZero).withOptionalParameter("discard", discard).withOptionalParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    return deleteImage(sdUUID, spUUID, imgGUID, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.delete").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, String force) {
    return moveImage(spUUID, srcDomUUID, dstDomUUID, imgGUID, vmGUID, op, postZero, null, force);
}
#end_block

#method_before
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#method_after
@Override
public OneUuidReturn moveImage(String spUUID, String srcDomUUID, String dstDomUUID, String imgGUID, String vmGUID, int op, String postZero, Boolean discard, String force) {
    JsonRpcRequest request = new RequestBuilder("Image.move").withParameter("imageID", imgGUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", srcDomUUID).withParameter("dstSdUUID", dstDomUUID).withParameter("operation", op).withParameter("postZero", postZero).withOptionalParameter("discard", discard).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
private void removeImageMapping() {
    TransactionSupport.executeInNewTransaction(() -> {
        imageStorageDomainMapDao.remove(new ImageStorageDomainMapId(getParameters().getImageId(), getParameters().getStorageDomainId()));
        ImagesHandler.updateAllDiskImageSnapshotsStatus(getRelevantDiskImage().getId(), getRelevantDiskImage().getImageStatus());
        return null;
    });
}
#method_after
private void removeImageMapping() {
    TransactionSupport.executeInNewTransaction(() -> {
        imageStorageDomainMapDao.remove(new ImageStorageDomainMapId(getParameters().getImageId(), getParameters().getStorageDomainId()));
        imageDao.updateStatusOfImagesByImageGroupId(getRelevantDiskImage().getId(), getRelevantDiskImage().getImageStatus());
        return null;
    });
}
#end_block

#method_before
private void updateDiscardAfterDelete() {
    if (getDataCenter().getSelectedItem() != null && getAvailableStorageTypeItems().getSelectedItem() != null) {
        boolean discardAfterDeleteSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DiscardAfterDeleteSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
        boolean isBlockDomain = getAvailableStorageTypeItems().getSelectedItem().isBlockDomain();
        getDiscardAfterDelete().setIsAvailable(discardAfterDeleteSupported && isBlockDomain);
        if (getDiscardAfterDelete().getIsAvailable()) {
            if (isNewStorage()) {
                getDiscardAfterDelete().setEntity(false);
            } else {
                getDiscardAfterDelete().setEntity(getStorage().isDiscardAfterDelete());
            }
        }
    }
}
#method_after
private void updateDiscardAfterDelete() {
    if (getDataCenter().getSelectedItem() != null && getAvailableStorageTypeItems().getSelectedItem() != null) {
        boolean isBlockDomain = getAvailableStorageTypeItems().getSelectedItem().isBlockDomain();
        if (!isBlockDomain) {
            getDiscardAfterDelete().setIsAvailable(false);
            getDiscardAfterDelete().setEntity(false);
            return;
        }
        boolean discardAfterDeleteSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DiscardAfterDeleteSupported, getDataCenter().getSelectedItem().getCompatibilityVersion().toString());
        getDiscardAfterDelete().setIsAvailable(discardAfterDeleteSupported);
        if (getDiscardAfterDelete().getIsAvailable()) {
            if (isNewStorage()) {
                getDiscardAfterDelete().setEntity(false);
            } else {
                getDiscardAfterDelete().setEntity(getStorage().isDiscardAfterDelete());
            }
        }
    }
}
#end_block

#method_before
@Mapping(from = Step.class, to = org.ovirt.engine.core.common.job.Step.class)
public static org.ovirt.engine.core.common.job.Step map(Step step, org.ovirt.engine.core.common.job.Step entity) {
    org.ovirt.engine.core.common.job.Step target = entity != null ? entity : new org.ovirt.engine.core.common.job.Step();
    target.setId(GuidUtils.asGuid(step.getId()));
    if (step.isSetParentStep()) {
        target.setParentStepId(GuidUtils.asGuid(step.getParentStep().getId()));
    }
    target.setJobId(GuidUtils.asGuid(step.getJob().getId()));
    if (step.isSetType()) {
        target.setStepType(map(step.getType()));
    }
    if (step.isSetDescription()) {
        target.setDescription(step.getDescription());
    }
    if (step.isSetNumber()) {
        target.setStepNumber(step.getNumber());
    }
    if (step.isSetStatus()) {
        target.setStatus(mapStepStatus(step.getStatus()));
    }
    target.setProgress(step.getProgress());
    target.setStartTime(step.isSetStartTime() ? step.getStartTime().toGregorianCalendar().getTime() : new Date(Calendar.getInstance().getTimeInMillis()));
    target.setEndTime(step.isSetEndTime() ? step.getEndTime().toGregorianCalendar().getTime() : new Date(Calendar.getInstance().getTimeInMillis()));
    target.setExternal(step.isSetExternal() ? step.isExternal() : true);
    return target;
}
#method_after
@Mapping(from = Step.class, to = org.ovirt.engine.core.common.job.Step.class)
public static org.ovirt.engine.core.common.job.Step map(Step step, org.ovirt.engine.core.common.job.Step entity) {
    org.ovirt.engine.core.common.job.Step target = entity != null ? entity : new org.ovirt.engine.core.common.job.Step();
    target.setId(GuidUtils.asGuid(step.getId()));
    if (step.isSetParentStep()) {
        target.setParentStepId(GuidUtils.asGuid(step.getParentStep().getId()));
    }
    target.setJobId(GuidUtils.asGuid(step.getJob().getId()));
    if (step.isSetType()) {
        target.setStepType(map(step.getType()));
    }
    if (step.isSetDescription()) {
        target.setDescription(step.getDescription());
    }
    if (step.isSetNumber()) {
        target.setStepNumber(step.getNumber());
    }
    if (step.isSetStatus()) {
        target.setStatus(mapStepStatus(step.getStatus()));
    }
    if (step.isSetProgress()) {
        target.setProgress(step.getProgress());
    }
    target.setStartTime(step.isSetStartTime() ? step.getStartTime().toGregorianCalendar().getTime() : new Date(Calendar.getInstance().getTimeInMillis()));
    target.setEndTime(step.isSetEndTime() ? step.getEndTime().toGregorianCalendar().getTime() : new Date(Calendar.getInstance().getTimeInMillis()));
    target.setExternal(step.isSetExternal() ? step.isExternal() : true);
    return target;
}
#end_block

#method_before
protected HostJobStatus pollImage(Guid storagePoolId, Guid storageDomainId, Guid imageGroupId, Guid imageId, int executionGeneration, Guid cmdId, VdcActionType actionType) {
    Image imageInfo = ((DiskImage) VdsCommandsHelper.runVdsCommandWithoutFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageId), storagePoolId, null).getReturnValue()).getImage();
    if (!imageInfo.getLeaseInfo().isFree()) {
        log.info("Command {} id: '{}': the volume lease is not FREE - the job is running", actionType, cmdId);
        return HostJobStatus.running;
    }
    if (imageInfo.getStatus() == ImageStatus.ILLEGAL) {
        log.info("Command {} id: '{}': the volume is in ILLEGAL status - the job has failed", actionType, cmdId);
        return HostJobStatus.failed;
    }
    if (imageInfo.getStatus() == ImageStatus.OK && imageInfo.getGeneration() == executionGeneration + 1) {
        log.info("Command {} id: '{}': the volume is in OK status and the generation was incremented - the " + "job execution has completed successfully", actionType, cmdId);
        return HostJobStatus.done;
    }
    log.info("Command {} id: '{}': couldn't determine the status of the job by entity polling", actionType, cmdId);
    return null;
}
#method_after
protected HostJobStatus pollImage(Guid storagePoolId, Guid storageDomainId, Guid imageGroupId, Guid imageId, int executionGeneration, Guid cmdId, VdcActionType actionType) {
    Image imageInfo = ((DiskImage) VdsCommandsHelper.runVdsCommandWithoutFailover(VDSCommandType.GetVolumeInfo, new GetVolumeInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageId), storagePoolId, null).getReturnValue()).getImage();
    if (imageInfo.getLeaseStatus() != null && !imageInfo.getLeaseStatus().isFree()) {
        log.info("Command {} id: '{}': the volume lease is not FREE - the job is running", actionType, cmdId);
        return HostJobStatus.running;
    }
    if (imageInfo.getStatus() == ImageStatus.ILLEGAL) {
        log.info("Command {} id: '{}': the volume is in ILLEGAL status - the job has failed", actionType, cmdId);
        return HostJobStatus.failed;
    }
    if (imageInfo.getStatus() == ImageStatus.OK && imageInfo.getGeneration() == executionGeneration + 1) {
        log.info("Command {} id: '{}': the volume is in OK status and the generation was incremented - the " + "job execution has completed successfully", actionType, cmdId);
        return HostJobStatus.done;
    }
    log.info("Command {} id: '{}': couldn't determine the status of the job by entity polling", actionType, cmdId);
    return null;
}
#end_block

#method_before
public DiskImage buildImageEntity(Map<String, Object> struct) {
    DiskImage newImage = new DiskImage();
    try {
        newImage.setImageId(new Guid((String) struct.get(IrsProperties.uuid)));
        newImage.setParentId(new Guid((String) struct.get(IrsProperties.parent)));
        newImage.setDescription((String) struct.get(IrsProperties.description));
        newImage.setImageStatus(EnumUtils.valueOf(ImageStatus.class, (String) struct.get(IrsProperties.ImageStatus), true));
        if (struct.containsKey(IrsProperties.size)) {
            newImage.setSize(Long.parseLong(struct.get(IrsProperties.size).toString()) * 512);
        }
        if (struct.containsKey("capacity")) {
            newImage.setSize(Long.parseLong(struct.get("capacity").toString()));
        }
        if (struct.containsKey("truesize")) {
            newImage.setActualSizeInBytes(Long.parseLong(struct.get("truesize").toString()));
        }
        if (struct.containsKey("ctime")) {
            long secsSinceEpoch = Long.parseLong(struct.get("ctime").toString());
            newImage.setCreationDate(makeDTFromCTime(secsSinceEpoch));
        }
        if (struct.containsKey("mtime")) {
            long secsSinceEpoch = Long.parseLong(struct.get("mtime").toString());
            newImage.setLastModifiedDate(makeDTFromCTime(secsSinceEpoch));
        }
        if (struct.containsKey("domain")) {
            newImage.setStorageIds(new ArrayList<>(Arrays.asList(new Guid(struct.get("domain").toString()))));
        }
        if (struct.containsKey("image")) {
            newImage.setId(new Guid(struct.get("image").toString()));
        }
        if (struct.containsKey("type")) {
            newImage.setVolumeType(EnumUtils.valueOf(VolumeType.class, struct.get("type").toString(), true));
        }
        if (struct.containsKey("format")) {
            newImage.setVolumeFormat(EnumUtils.valueOf(VolumeFormat.class, struct.get("format").toString(), true));
        }
        if (struct.containsKey("lease")) {
            Map<String, Object> leaseInfo = (Map<String, Object>) struct.get("lease");
            Object[] owners = (Object[]) leaseInfo.get("owners");
            newImage.getImage().setLeaseInfo(new LeaseInfo(owners.length > 0));
        }
        if (struct.containsKey("generation")) {
            newImage.getImage().setGeneration(Integer.valueOf(struct.get("generation").toString()));
        }
    } catch (RuntimeException ex) {
        log.error("Failed building DiskImage: {}", ex.getMessage());
        printReturnValue();
        log.debug("Exception", ex);
        newImage = null;
    }
    return newImage;
}
#method_after
public DiskImage buildImageEntity(Map<String, Object> struct) {
    DiskImage newImage = new DiskImage();
    try {
        newImage.setImageId(new Guid((String) struct.get(IrsProperties.uuid)));
        newImage.setParentId(new Guid((String) struct.get(IrsProperties.parent)));
        newImage.setDescription((String) struct.get(IrsProperties.description));
        newImage.setImageStatus(EnumUtils.valueOf(ImageStatus.class, (String) struct.get(IrsProperties.ImageStatus), true));
        if (struct.containsKey(IrsProperties.size)) {
            newImage.setSize(Long.parseLong(struct.get(IrsProperties.size).toString()) * 512);
        }
        if (struct.containsKey("capacity")) {
            newImage.setSize(Long.parseLong(struct.get("capacity").toString()));
        }
        if (struct.containsKey("truesize")) {
            newImage.setActualSizeInBytes(Long.parseLong(struct.get("truesize").toString()));
        }
        if (struct.containsKey("ctime")) {
            long secsSinceEpoch = Long.parseLong(struct.get("ctime").toString());
            newImage.setCreationDate(makeDTFromCTime(secsSinceEpoch));
        }
        if (struct.containsKey("mtime")) {
            long secsSinceEpoch = Long.parseLong(struct.get("mtime").toString());
            newImage.setLastModifiedDate(makeDTFromCTime(secsSinceEpoch));
        }
        if (struct.containsKey("domain")) {
            newImage.setStorageIds(new ArrayList<>(Arrays.asList(new Guid(struct.get("domain").toString()))));
        }
        if (struct.containsKey("image")) {
            newImage.setId(new Guid(struct.get("image").toString()));
        }
        if (struct.containsKey("type")) {
            newImage.setVolumeType(EnumUtils.valueOf(VolumeType.class, struct.get("type").toString(), true));
        }
        if (struct.containsKey("format")) {
            newImage.setVolumeFormat(EnumUtils.valueOf(VolumeFormat.class, struct.get("format").toString(), true));
        }
        if (struct.containsKey("lease")) {
            Map<String, Object> leaseStatus = (Map<String, Object>) struct.get("lease");
            newImage.getImage().setLeaseStatus(VdsBrokerObjectsBuilder.buildLeaseStatus(leaseStatus));
        }
        if (struct.containsKey("generation")) {
            newImage.getImage().setGeneration(Integer.valueOf(struct.get("generation").toString()));
        }
    } catch (RuntimeException ex) {
        log.error("Failed building DiskImage: {}", ex.getMessage());
        printReturnValue();
        log.debug("Exception", ex);
        newImage = null;
    }
    return newImage;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.scheduling.AffinityGroup.class, to = AffinityGroup.class)
public static AffinityGroup map(org.ovirt.engine.core.common.scheduling.AffinityGroup entity, AffinityGroup template) {
    AffinityGroup model = template != null ? template : new AffinityGroup();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setPositive(entity.isVmAffinityEnabled() ? entity.getVmPolarityBooleanObject() : null);
    model.setEnforcing(entity.isVmEnforcing());
    AffinityRule hostsRule = new AffinityRule();
    hostsRule.setEnabled(true);
    hostsRule.setEnforcing(entity.isVdsEnforcing());
    hostsRule.setPositive(entity.isVdsPositive());
    model.setHostsRule(hostsRule);
    AffinityRule vmsRule = new AffinityRule();
    vmsRule.setEnabled(entity.isVmAffinityEnabled());
    vmsRule.setEnforcing(entity.isVmEnforcing());
    vmsRule.setPositive(entity.isVmPositive());
    model.setVmsRule(vmsRule);
    Cluster cluster = new Cluster();
    cluster.setId(entity.getClusterId().toString());
    model.setCluster(cluster);
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.scheduling.AffinityGroup.class, to = AffinityGroup.class)
public static AffinityGroup map(org.ovirt.engine.core.common.scheduling.AffinityGroup entity, AffinityGroup template) {
    AffinityGroup model = template != null ? template : new AffinityGroup();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    // These two fields are maintained to keep the backwards compatibility
    // with version 4 of the API and will be removed in future.
    model.setPositive(entity.isVmAffinityEnabled() ? entity.getVmPolarityBooleanObject() : null);
    model.setEnforcing(entity.isVmEnforcing());
    AffinityRule hostsRule = model.getHostsRule();
    if (hostsRule == null) {
        hostsRule = new AffinityRule();
        model.setHostsRule(hostsRule);
    }
    hostsRule.setEnabled(true);
    hostsRule.setEnforcing(entity.isVdsEnforcing());
    hostsRule.setPositive(entity.isVdsPositive());
    AffinityRule vmsRule = model.getVmsRule();
    if (vmsRule == null) {
        vmsRule = new AffinityRule();
        model.setVmsRule(vmsRule);
    }
    vmsRule.setEnabled(entity.isVmAffinityEnabled());
    vmsRule.setEnforcing(entity.isVmEnforcing());
    vmsRule.setPositive(entity.isVmPositive());
    Cluster cluster = new Cluster();
    cluster.setId(entity.getClusterId().toString());
    model.setCluster(cluster);
    Hosts hosts = model.getHosts();
    if (hosts == null) {
        hosts = new Hosts();
        model.setHosts(hosts);
    }
    entity.getVdsIds().stream().map(id -> {
        Host host = new Host();
        host.setId(id.toString());
        return host;
    }).forEach(model.getHosts().getHosts()::add);
    Vms vms = model.getVms();
    if (vms == null) {
        vms = new Vms();
        model.setVms(vms);
    }
    entity.getVmIds().stream().map(id -> {
        Vm vm = new Vm();
        vm.setId(id.toString());
        return vm;
    }).forEach(model.getVms().getVms()::add);
    return model;
}
#end_block

#method_before
@Mapping(from = AffinityGroup.class, to = org.ovirt.engine.core.common.scheduling.AffinityGroup.class)
public static org.ovirt.engine.core.common.scheduling.AffinityGroup map(AffinityGroup model, org.ovirt.engine.core.common.scheduling.AffinityGroup template) {
    org.ovirt.engine.core.common.scheduling.AffinityGroup entity = template != null ? template : new org.ovirt.engine.core.common.scheduling.AffinityGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHostsRule()) {
        AffinityRule hostsRule = model.getHostsRule();
        if (hostsRule.isSetEnforcing()) {
            entity.setVdsEnforcing(hostsRule.isEnforcing());
        }
        if (hostsRule.isSetPositive()) {
            entity.setVdsAffinityRule(hostsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        }
    }
    if (model.isSetVmsRule()) {
        AffinityRule vmsRule = model.getVmsRule();
        if (vmsRule.isSetEnabled()) {
            if (!vmsRule.isEnabled()) {
                entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
            } else if (vmsRule.isSetPositive()) {
                entity.setVmAffinityRule(vmsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
            }
        }
        if (vmsRule.isSetEnforcing()) {
            entity.setVmEnforcing(vmsRule.isEnforcing());
        }
    } else {
        if (model.isSetPositive()) {
            entity.setVmAffinityRule(model.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        } else {
            entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
        }
        if (model.isSetEnforcing()) {
            entity.setVmEnforcing(model.isEnforcing());
        }
    }
    return entity;
}
#method_after
@Mapping(from = AffinityGroup.class, to = org.ovirt.engine.core.common.scheduling.AffinityGroup.class)
public static org.ovirt.engine.core.common.scheduling.AffinityGroup map(AffinityGroup model, org.ovirt.engine.core.common.scheduling.AffinityGroup template) {
    org.ovirt.engine.core.common.scheduling.AffinityGroup entity = template != null ? template : new org.ovirt.engine.core.common.scheduling.AffinityGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setClusterId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    AffinityRule hostsRule = model.getHostsRule();
    if (hostsRule != null) {
        if (hostsRule.isSetEnforcing()) {
            entity.setVdsEnforcing(hostsRule.isEnforcing());
        }
        if (hostsRule.isSetPositive()) {
            entity.setVdsAffinityRule(hostsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        }
    }
    AffinityRule vmsRule = model.getVmsRule();
    if (vmsRule != null) {
        if (vmsRule.isSetEnabled()) {
            if (!vmsRule.isEnabled()) {
                entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
            } else if (vmsRule.isSetPositive()) {
                entity.setVmAffinityRule(vmsRule.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
            }
        }
        if (vmsRule.isSetEnforcing()) {
            entity.setVmEnforcing(vmsRule.isEnforcing());
        }
    } else {
        if (model.isSetPositive()) {
            entity.setVmAffinityRule(model.isPositive() ? EntityAffinityRule.POSITIVE : EntityAffinityRule.NEGATIVE);
        } else {
            entity.setVmAffinityRule(EntityAffinityRule.DISABLED);
        }
        if (model.isSetEnforcing()) {
            entity.setVmEnforcing(model.isEnforcing());
        }
    }
    if (model.isSetHosts()) {
        List<Guid> hostIds = entity.getVdsIds();
        if (hostIds == null) {
            hostIds = new ArrayList<>();
            entity.setVdsIds(hostIds);
        }
        // Replace the existing list with the provided one
        hostIds.clear();
        model.getHosts().getHosts().stream().filter(Host::isSetId).map(Host::getId).map(Guid::createGuidFromString).forEach(hostIds::add);
    }
    if (model.isSetVms()) {
        List<Guid> vmIds = entity.getVmIds();
        if (vmIds == null) {
            vmIds = new ArrayList<>();
            entity.setVmIds(vmIds);
        }
        // Replace the existing list with the provided one
        vmIds.clear();
        model.getVms().getVms().stream().filter(Vm::isSetId).map(Vm::getId).map(Guid::createGuidFromString).forEach(vmIds::add);
    }
    return entity;
}
#end_block

